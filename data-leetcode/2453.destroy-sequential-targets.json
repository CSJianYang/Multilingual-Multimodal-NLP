[
    {
        "title": "Destroy Sequential Targets",
        "question_content": "You are given a 0-indexed array nums consisting of positive integers, representing targets on a number line. You are also given an integer space.\nYou have a machine which can destroy targets. Seeding the machine with some nums[i] allows it to destroy all targets with values that can be represented as nums[i] + c * space, where c is any non-negative integer. You want to destroy the maximum number of targets in nums.\nReturn the minimum value of nums[i] you can seed the machine with to destroy the maximum number of targets.\n&nbsp;\nExample 1:\n\nInput: nums = [3,7,8,1,1,5], space = 2\nOutput: 1\nExplanation: If we seed the machine with nums[3], then we destroy all targets equal to 1,3,5,7,9,... \nIn this case, we would destroy 5 total targets (all except for nums[2]). \nIt is impossible to destroy more than 5 targets, so we return nums[3].\n\nExample 2:\n\nInput: nums = [1,3,5,2,4,6], space = 2\nOutput: 1\nExplanation: Seeding the machine with nums[0], or nums[3] destroys 3 targets. \nIt is not possible to destroy more than 3 targets.\nSince nums[0] is the minimal integer that can destroy 3 targets, we return 1.\n\nExample 3:\n\nInput: nums = [6,2,5], space = 100\nOutput: 2\nExplanation: Whatever initial seed we select, we can only destroy 1 target. The minimal seed is nums[1].\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 105\n\t1 <= nums[i] <= 109\n\t1 <= space <=&nbsp;109",
        "solutions": [
            {
                "id": 2756382,
                "title": "c-solution-with-explanation-using-modulo-map",
                "content": "<b>Up Vote if you like the solution\\n```\\n/* \\nVery simple approach is to just take the reminder of eanch element when divided by space.\\nThen take the smallest element with having reminder same as that of maximum elements with same reminder.\\n\\n1. Count number of elements with same reminder, this can be achived by simple adding reminder to map & increamenting it.\\n2. Also keep track of the max count of reminder with same reminder value.\\n3. Scan the array again and find the smallest element with the max count reminder value, that we found in above step.\\n\\nIf you wonder why modulus/reminder:\\n- When adding c*space to a fix number, all of the number generated from this will be having same reminder. \\n*/\\n\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = INT_MAX, mx = INT_MIN;\\n        unordered_map<int, int> mp;\\n        for(auto n: nums){\\n            int r = n % space;                  //evaluate reminder\\n            mp[r]++;                               // add reminder to map\\n            if(mx < mp[r])  mx = mp[r];   //keep track of the max count, with same reminder\\n        }\\n        for(auto n: nums){  //scan smalest element with same riminder as of mx\\n            if(mx == mp[n%space])  ans = min(ans, n);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n<b>Here is an article of my recent interview experience - A Journey to FAANG Company, I recomand you to go through this to know which all resources I have used & how I cracked interview at Amazon:\\nhttps://leetcode.com/discuss/interview-experience/3171859/Journey-to-a-FAANG-Company-Amazon-or-SDE2-(L5)-or-Bangalore-or-Oct-2022-Accepted",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/* \\nVery simple approach is to just take the reminder of eanch element when divided by space.\\nThen take the smallest element with having reminder same as that of maximum elements with same reminder.\\n\\n1. Count number of elements with same reminder, this can be achived by simple adding reminder to map & increamenting it.\\n2. Also keep track of the max count of reminder with same reminder value.\\n3. Scan the array again and find the smallest element with the max count reminder value, that we found in above step.\\n\\nIf you wonder why modulus/reminder:\\n- When adding c*space to a fix number, all of the number generated from this will be having same reminder. \\n*/\\n\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = INT_MAX, mx = INT_MIN;\\n        unordered_map<int, int> mp;\\n        for(auto n: nums){\\n            int r = n % space;                  //evaluate reminder\\n            mp[r]++;                               // add reminder to map\\n            if(mx < mp[r])  mx = mp[r];   //keep track of the max count, with same reminder\\n        }\\n        for(auto n: nums){  //scan smalest element with same riminder as of mx\\n            if(mx == mp[n%space])  ans = min(ans, n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756795,
                "title": "java-c-python-count-a-i-space",
                "content": "# **Intuition**\\nThe elements with same remainder module by `space`,\\ncan be destroied together.\\n<br>\\n\\n# **Explanation**\\n1. Count the frequency of `A[i] % space`.\\n2. The maximum frequency `maxc` is the the maximum number of targets we can destroy.\\n3. Find the minimum element A[i] that `A[i] % space = maxc`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int destroyTargets(int[] A, int space) {\\n        int res = (int)1e9;\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a % space, count.getOrDefault(a % space, 0) + 1);\\n        int maxc = Collections.max(count.values());\\n        for (int a : A)\\n            if (count.get(a % space) == maxc)\\n                res = Math.min(res, a);\\n        return res;\\n    }\\n```\\n**C++**\\n```cpp\\n    int destroyTargets(vector<int>& A, int space) {\\n        int res = 1e9, maxc = 0;\\n        unordered_map<int, int> count;\\n        for (int a : A)\\n            maxc = max(maxc, ++count[a % space]);\\n        for (int a : A)\\n            if (count[a % space] == maxc)\\n                res = min(res, a);\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def destroyTargets(self, A: List[int], space: int) -> int:\\n        count = Counter(a % space for a in A)\\n        maxc = max(count.values())\\n        return min(a for a in A if count[a % space] == maxc)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int destroyTargets(int[] A, int space) {\\n        int res = (int)1e9;\\n        HashMap<Integer, Integer> count = new HashMap<>();\\n        for (int a : A)\\n            count.put(a % space, count.getOrDefault(a % space, 0) + 1);\\n        int maxc = Collections.max(count.values());\\n        for (int a : A)\\n            if (count.get(a % space) == maxc)\\n                res = Math.min(res, a);\\n        return res;\\n    }\\n```\n```cpp\\n    int destroyTargets(vector<int>& A, int space) {\\n        int res = 1e9, maxc = 0;\\n        unordered_map<int, int> count;\\n        for (int a : A)\\n            maxc = max(maxc, ++count[a % space]);\\n        for (int a : A)\\n            if (count[a % space] == maxc)\\n                res = min(res, a);\\n        return res;\\n    }\\n```\n```py\\n    def destroyTargets(self, A: List[int], space: int) -> int:\\n        count = Counter(a % space for a in A)\\n        maxc = max(count.values())\\n        return min(a for a in A if count[a % space] == maxc)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2756401,
                "title": "python-o-n-solution-with-comments-easy-understanding",
                "content": "```\\nclass Solution:\\n    #easy idea solution\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dct = dict() \\n        mx = 0 # maximum of destroyed targets\\n        \\n        for num in nums:\\n            x = num % space # if the numbers have the same remainder after division by space, \\n                            # then they can be presented in the form : nums[i] + c * space\\n            if x not in dct:\\n                dct[x] = (1, num)\\n            else:\\n                dct[x] = (dct[x][0] + 1, min(dct[x][1], num)) # we always keep the minimum nums[i] for all remainders \\n                \\n            mx = max(mx, dct[x][0])\\n            \\n        res = float(\"inf\")\\n        for val in dct.values(): #we just go through all the values and find the result\\n            if val[0] == mx:\\n                res = min(res, val[1])\\n        \\n        return res\\n\\t\\t\\n\\t\\t# N = nums.length\\n\\t\\n        #O(N) - space\\n        #O(N) - time\\n\\n\\t\\t\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    #easy idea solution\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dct = dict() \\n        mx = 0 # maximum of destroyed targets\\n        \\n        for num in nums:\\n            x = num % space # if the numbers have the same remainder after division by space, \\n                            # then they can be presented in the form : nums[i] + c * space\\n            if x not in dct:\\n                dct[x] = (1, num)\\n            else:\\n                dct[x] = (dct[x][0] + 1, min(dct[x][1], num)) # we always keep the minimum nums[i] for all remainders \\n                \\n            mx = max(mx, dct[x][0])\\n            \\n        res = float(\"inf\")\\n        for val in dct.values(): #we just go through all the values and find the result\\n            if val[0] == mx:\\n                res = min(res, val[1])\\n        \\n        return res\\n\\t\\t\\n\\t\\t# N = nums.length\\n\\t\\n        #O(N) - space\\n        #O(N) - time\\n\\n\\t\\t\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756840,
                "title": "explained-approach-basic-maths-with-map",
                "content": "# Intuition\\nSo say you are destryoing j th index and you started from i th index\\nthen *** nums[j] = nums[i] +  c * space*** which can also be written as \\n***nums[j]-nums[i] = c * space*** ?? right ??\\nthis means the difference nums[j]-nums[i] will be divisible by space i.e, ***nums[j]-nums[i] % space = 0*** is TRUE !!\\nnow this can only happen if both nums[i] and nums[j] give same remainder upon division with space i.e, ***nums[i]% space == nums[j] % space***\\n\\nfrom here one can conclude that elements with same remainder will be destroyed together !! so just need to find the max occuring remainder for the array !!\\n\\nonce you find that max occuring remainder (using map) then you need to find the minimum value in the array that gives that remainder (you can sort or simply traverse array)..\\nThat\\'s it !! SIMPLE ain\\'it it ?? some basic maths !! I feel stupid not being able to solve this in contest ! I solved it later with some hint xd !!\\n\\nPS: UPVOTE IF YOU LIKE :D\\n \\n\\n# Approach\\nUse map to find max frequency remainder\\nfind the smallest element with same remainder\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        unordered_map<int, int>map; // key will be remainder // value will be it\\'s frequency !!\\n        int ans = INT_MAX;\\n        int max_freq = 0;\\n        for(int i=0;i<nums.size();i++)\\n            {\\n                int r = nums[i]%space;\\n                map[r]++;\\n                max_freq=max(max_freq,map[r]);\\n            }\\n\\n        // now we have max occ remainder frequency and it\\'s frequency as well !!\\n\\n        // just need to find the first value with that remainder \\n\\n        // sort(nums.begin(),nums.end());\\n\\n        // for(int i=0;i<nums.size();i++)\\n        //     {\\n        //         int r = nums[i]%space;\\n        //         if(map[r]==max_freq)\\n        //             {\\n        //                 ans=nums[i];\\n        //                 break;\\n        //             }\\n        //     }\\n\\n        for(int i=0;i<nums.size();i++)\\n            {\\n                int r = nums[i]%space;\\n                if(map[r]==max_freq)\\n                    {\\n                        ans=min(ans,nums[i]);\\n                    }\\n            }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Ordered Map",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        unordered_map<int, int>map; // key will be remainder // value will be it\\'s frequency !!\\n        int ans = INT_MAX;\\n        int max_freq = 0;\\n        for(int i=0;i<nums.size();i++)\\n            {\\n                int r = nums[i]%space;\\n                map[r]++;\\n                max_freq=max(max_freq,map[r]);\\n            }\\n\\n        // now we have max occ remainder frequency and it\\'s frequency as well !!\\n\\n        // just need to find the first value with that remainder \\n\\n        // sort(nums.begin(),nums.end());\\n\\n        // for(int i=0;i<nums.size();i++)\\n        //     {\\n        //         int r = nums[i]%space;\\n        //         if(map[r]==max_freq)\\n        //             {\\n        //                 ans=nums[i];\\n        //                 break;\\n        //             }\\n        //     }\\n\\n        for(int i=0;i<nums.size();i++)\\n            {\\n                int r = nums[i]%space;\\n                if(map[r]==max_freq)\\n                    {\\n                        ans=min(ans,nums[i]);\\n                    }\\n            }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756360,
                "title": "java-python-3-count-the-frequency-of-the-remainder-of-modulo",
                "content": "**Q & A**\\n\\nQ1: What does `freqs.merge(n, 1, Integer::sum)` mean in Java code?\\nA1: `freqs.merge(n, 1, Integer::sum)` is simiar to `freqs.put(n, freqs.getOrDefault(n, 0) + 1)`, which increase the frequency (occurrence) of `n` by `1`; The difference between them is that `merge` return the increased frequency but `put` returns old value: the frequency before being increased (or `null`).\\n\\n**End of Q & A**\\n\\n----\\n\\n1. Count the frequencies of `remainder = nums[i] % space`;\\n2. Traverse the input array `nums` again and locate the minimum.\\n\\n```java\\n    public int destroyTargets(int[] nums, int space) {\\n        Map<Integer, Integer> freqs = new HashMap<>();\\n        int maxFreq = 0;\\n        for (int n : nums) {\\n            n %= space;\\n            maxFreq = Math.max(maxFreq, freqs.merge(n, 1, Integer::sum));\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int n : nums) {\\n            if (freqs.get(n % space) == maxFreq && min > n) {\\n                min = n;\\n            }\\n        }\\n        return min;\\n    }\\n```\\n```python\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        freqs, mi = Counter(), inf\\n        for num in nums:\\n            freqs[num % space] += 1\\n        max_freq = max(freqs.values())\\n        for num in nums:\\n            if freqs[num % space] == max_freq and num < mi:\\n                mi = num\\n        return mi\\n```\\n\\n**Analysis:**\\n\\nTime & space: `O(n)`, where `n = nums.length`.\\n\\n----\\n\\nPlease let me know if you have any questions, and **upvote** if the post is helpful.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public int destroyTargets(int[] nums, int space) {\\n        Map<Integer, Integer> freqs = new HashMap<>();\\n        int maxFreq = 0;\\n        for (int n : nums) {\\n            n %= space;\\n            maxFreq = Math.max(maxFreq, freqs.merge(n, 1, Integer::sum));\\n        }\\n        int min = Integer.MAX_VALUE;\\n        for (int n : nums) {\\n            if (freqs.get(n % space) == maxFreq && min > n) {\\n                min = n;\\n            }\\n        }\\n        return min;\\n    }\\n```\n```python\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        freqs, mi = Counter(), inf\\n        for num in nums:\\n            freqs[num % space] += 1\\n        max_freq = max(freqs.values())\\n        for num in nums:\\n            if freqs[num % space] == max_freq and num < mi:\\n                mi = num\\n        return mi\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2756739,
                "title": "explaining-why-modulo-solution-works",
                "content": "**Given**\\nnums[i] can destroy all targets with values that can be represented as nums[i] + c * space\\nc - Non-Negative integer.\\nSpace - Constant.\\n**Explanation**\\nGiven any number it will belong only to one series. \\nFor example, \\n```\\nLets take space as 2. \\nWhen space is 2, there can be two series. (space = Number of series)\\n1, 3, 5, 7, 9 ...(Series A)\\n2, 4, 6, 8, 10...(Series B)\\n1)Given any number it will belong to either series A or series B.\\n2)Any number in series can generate all numbers greater than or equal to that in the series.\\n3)Number % space gives the starting number of its respective series. \\nSo using that we find the series each num belongs to.\\n4)After finding count of elements in each series, series which has max count(max destroy) should contain our answer. \\nOnce max count series is found, we find the min element in our array which belongs to this series\\n(Because from point (2) we know that min element can generate(destroy) all numbers greater than or equal to that in the series).\\n```\\n\\nJava Solution\\n```java\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Map<Integer, Integer> dCount = new HashMap<>();\\n        for(int num : nums)\\n            dCount.put(num%space, dCount.getOrDefault(num%space, 0) + 1);\\n        int destroy = 1, answer = Integer.MAX_VALUE;\\n        for(int num: nums){\\n            int curDestroy = dCount.get(num % space);\\n            if(curDestroy > destroy || (curDestroy == destroy && num < answer)){\\n               destroy = curDestroy;\\n               answer = num;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nLets take space as 2. \\nWhen space is 2, there can be two series. (space = Number of series)\\n1, 3, 5, 7, 9 ...(Series A)\\n2, 4, 6, 8, 10...(Series B)\\n1)Given any number it will belong to either series A or series B.\\n2)Any number in series can generate all numbers greater than or equal to that in the series.\\n3)Number % space gives the starting number of its respective series. \\nSo using that we find the series each num belongs to.\\n4)After finding count of elements in each series, series which has max count(max destroy) should contain our answer. \\nOnce max count series is found, we find the min element in our array which belongs to this series\\n(Because from point (2) we know that min element can generate(destroy) all numbers greater than or equal to that in the series).\\n```\n```java\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Map<Integer, Integer> dCount = new HashMap<>();\\n        for(int num : nums)\\n            dCount.put(num%space, dCount.getOrDefault(num%space, 0) + 1);\\n        int destroy = 1, answer = Integer.MAX_VALUE;\\n        for(int num: nums){\\n            int curDestroy = dCount.get(num % space);\\n            if(curDestroy > destroy || (curDestroy == destroy && num < answer)){\\n               destroy = curDestroy;\\n               answer = num;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756351,
                "title": "python-c-java-rust-remainder-equivalence-classes-with-detailed-comments",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs calculation of remainders to group numbers into equivalence classes. Time complexity is logarithmic: **O(N\\\\*logN)**. Space complexity is linear: **O(N)**. \\n\\n**Comment**. Targets are numbers of the form `nums[i] + c * space`, namely, the numbers that have the same remainder when divided by `space`. We call them *equivalence classes modulo `space`*. The strategy here is to\\n1. Establish equivalence classes modulo `space`.\\n2. Find (probably, several) largest of them using sorting.\\n3. Among the largest classes of equal size, get the minimal value.\\n\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: list[int], space: int) -> int:\\n        \\n        # [1] group all digits into equivalence classes\\n        #     according to their remainder modulo \\'space\\'\\n        rem = defaultdict(list)\\n        for n in nums: rem[n%space].append(n)\\n        \\n        # [2] sort by size of each equivalence class (larger classes come first)\\n        srt = sorted(list(rem.items()), key=lambda x: len(x[1]), reverse=True)\\n        \\n        # [3] get size of the larget equivalence class\\n        max_size = len(srt[0][1])\\n        \\n        # [4] well, there might be many equivalence classes with\\n        #     the same size; let\\'s iterate over them...\\n        min_num = 10**9+1\\n        for _, eq in srt:\\n            if len(eq) != max_size: break\\n            #[5] ...and take minimal value from each class\\n            min_num = min(min_num, min(eq))\\n        \\n        return min_num\\n```\\nSolutions in other languages are coming",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: list[int], space: int) -> int:\\n        \\n        # [1] group all digits into equivalence classes\\n        #     according to their remainder modulo \\'space\\'\\n        rem = defaultdict(list)\\n        for n in nums: rem[n%space].append(n)\\n        \\n        # [2] sort by size of each equivalence class (larger classes come first)\\n        srt = sorted(list(rem.items()), key=lambda x: len(x[1]), reverse=True)\\n        \\n        # [3] get size of the larget equivalence class\\n        max_size = len(srt[0][1])\\n        \\n        # [4] well, there might be many equivalence classes with\\n        #     the same size; let\\'s iterate over them...\\n        min_num = 10**9+1\\n        for _, eq in srt:\\n            if len(eq) != max_size: break\\n            #[5] ...and take minimal value from each class\\n            min_num = min(min_num, min(eq))\\n        \\n        return min_num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756350,
                "title": "count-modulo",
                "content": "All elements in the sequence have the same mod `space`.\\n\\nCount elements with the same modulo, and return the smallest element with the highest frequency modulo.\\n\\n**C++**\\n```cpp\\nint destroyTargets(vector<int>& nums, int space) {\\n    unordered_map<int, int> cnt;\\n    for (int n : nums)\\n        ++cnt[n % space];\\n    return *max_element(begin(nums), end(nums), [&](int a, int b){\\n        int cnt1 = cnt[a % space], cnt2 = cnt[b % space];\\n        return cnt1 == cnt2 ? a > b : cnt1 < cnt2;\\n    });\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint destroyTargets(vector<int>& nums, int space) {\\n    unordered_map<int, int> cnt;\\n    for (int n : nums)\\n        ++cnt[n % space];\\n    return *max_element(begin(nums), end(nums), [&](int a, int b){\\n        int cnt1 = cnt[a % space], cnt2 = cnt[b % space];\\n        return cnt1 == cnt2 ? a > b : cnt1 < cnt2;\\n    });\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756349,
                "title": "hashmap",
                "content": "```\\nclass Solution\\n{\\n    public int destroyTargets(int[] nums, int space)\\n    {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int num : nums)\\n        {\\n            num = num % space;\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n        int maxi = Collections.max(map.values());\\n        Arrays.sort(nums);\\n        for(int i = 0 ; i < n;i++)\\n        {\\n            if(map.get(nums[i] % space) == maxi) return nums[i];\\n        }\\n       \\n        return 0;\\n    }\\n}\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int destroyTargets(int[] nums, int space)\\n    {\\n        int n = nums.length;\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int num : nums)\\n        {\\n            num = num % space;\\n            map.put(num,map.getOrDefault(num,0)+1);\\n        }\\n        int maxi = Collections.max(map.values());\\n        Arrays.sort(nums);\\n        for(int i = 0 ; i < n;i++)\\n        {\\n            if(map.get(nums[i] % space) == maxi) return nums[i];\\n        }\\n       \\n        return 0;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756347,
                "title": "c-very-easy-self-explanatory-code",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(),nums.end());\\n       unordered_map<int,int>mp; //for storing min arr element with particular reminder\\n       unordered_map<int,int>freq; // for calculating freq of particular reminder\\n        \\n        int maxV=-1e9;\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int val=nums[i]%space;\\n            if(!mp.count(val))\\n            {\\n               mp[val]=nums[i];  //once found this will be smallest value with this reminder because array is sorted\\n            }\\n            \\n            freq[val]++;\\n            \\n            if(freq[val]>maxV)\\n            {\\n                maxV=freq[val];\\n                ans=mp[val];\\n            }\\n            \\n            else if(freq[val]==maxV)\\n            {\\n                if(mp[val]<ans)\\n                    ans=mp[val];\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(),nums.end());\\n       unordered_map<int,int>mp; //for storing min arr element with particular reminder\\n       unordered_map<int,int>freq; // for calculating freq of particular reminder\\n        \\n        int maxV=-1e9;\\n        int ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int val=nums[i]%space;\\n            if(!mp.count(val))\\n            {\\n               mp[val]=nums[i];  //once found this will be smallest value with this reminder because array is sorted\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2760111,
                "title": "c-2-different-approaches-single-pass-two-passes-o-n",
                "content": "### Approach 1: single pass\\n\\nWe scan all of ```nums``` and while we do so we keep track for each rest class mod ```space``` how many numbers fall into and what\\'s the smallest one we have seen so far.\\n\\n```cpp\\n    static int destroyTargets(const vector<int>& nums, int space) {\\n        unordered_map<int, pair<int, int>> m;\\n        int ans = numeric_limits<int>::max();\\n        int mc = 0;\\n        for (int num : nums) {\\n            auto& p = m[num % space];\\n            p.second = !p.first++ ? num : min(p.second, num);\\n            if (p.first >= mc) {\\n                ans = p.first > mc ? p.second : min(ans, p.second);\\n                mc = p.first;\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analsysis**\\nLet $$n$$ be the size of ```nums``` then the\\n  * Time complexity is $$O(n)$$ as we look at each element once, and the\\n  * Space complexity is $$O(n)$$ as in the worst case each number has a different remainder modulo ```space``` and we keep track of the count and the smallest such number.\\n\\n### Approach 2: two passes\\n\\nIf we take two passes over ```nums``` the code becomes simpler and we need less extra memory.\\n\\n```\\n    static int destroyTargets(const vector<int>& nums, int space) {\\n        unordered_map<int, int> m;\\n        int target = 0;\\n        for (int num : nums) target = max(target, ++m[num % space]);\\n        int ans = numeric_limits<int>::max();\\n        for (int num : nums)\\n            if (m[num % space] == target)\\n                ans = min(ans, num);\\n        return ans;\\n    }\\n```\\n\\n**Complexity Analysis**\\n\"Modulo\" the constant factors the complexity analysis is the same as for the first approache, we scan the input twice, but we need less memory.\\n\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```nums```\n```space```\n```cpp\\n    static int destroyTargets(const vector<int>& nums, int space) {\\n        unordered_map<int, pair<int, int>> m;\\n        int ans = numeric_limits<int>::max();\\n        int mc = 0;\\n        for (int num : nums) {\\n            auto& p = m[num % space];\\n            p.second = !p.first++ ? num : min(p.second, num);\\n            if (p.first >= mc) {\\n                ans = p.first > mc ? p.second : min(ans, p.second);\\n                mc = p.first;\\n            }\\n        }\\n        return ans;\\n    }\\n```\n```nums```\n```space```\n```nums```\n```\\n    static int destroyTargets(const vector<int>& nums, int space) {\\n        unordered_map<int, int> m;\\n        int target = 0;\\n        for (int num : nums) target = max(target, ++m[num % space]);\\n        int ans = numeric_limits<int>::max();\\n        for (int num : nums)\\n            if (m[num % space] == target)\\n                ans = min(ans, num);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757217,
                "title": "short-simple-clean",
                "content": "![image](https://assets.leetcode.com/users/images/e8396de9-5341-40f9-ade0-fc4f51acdb6c_1667069978.8880672.jpeg)\\n\\n1) store every remainder k%space in a map\\n2) So choosing key of the map with max value (key\\'s value will represent the number of element which could be destroyed together if we choose this key)\\n\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        mp=defaultdict(int)\\n        \\n        for k in nums:\\n            mp[k%space]+=1\\n            \\n        mx=max(mp.values())\\n        ans=10000000000\\n        \\n        for k in nums:\\n            if mp[k%space]==mx:\\n                ans=min(ans,k)\\n                \\n        return ans\\n```\\nUpvote if u like it!",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        mp=defaultdict(int)\\n        \\n        for k in nums:\\n            mp[k%space]+=1\\n            \\n        mx=max(mp.values())\\n        ans=10000000000\\n        \\n        for k in nums:\\n            if mp[k%space]==mx:\\n                ans=min(ans,k)\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756442,
                "title": "java-simple-solution-easy-understanding",
                "content": "Approach: used remainder theorem   (Dividend = Divisor * Quotient + Remainder)\\nBecause only that target will be destroyed whose remainder is same with respect to `space`\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        \\n        Arrays.sort(nums);    // purpost for sorting the array just for getting first element of number which woud be distroyed\\n        HashMap<Integer, Integer> hm = new HashMap<>();   // counting the frequency of number whose remainders are same\\n        for(int i = 0; i < nums.length; i++){\\n            int r = nums[i] % space;\\n            hm.put(r, hm.getOrDefault(r, 0) + 1);    \\n        }\\n        int max = 0;\\n        ArrayList<Integer> sans = new ArrayList<>();\\n        for(int key : hm.keySet()){\\n            if(hm.get(key) > max){\\n                max = hm.get(key);           // here we calculated the remainder whose frequency is maximum\\n            }\\n        }\\n        HashSet<Integer> hs = new HashSet<>();  // there can be many remainder whose frequency are equal to maximum (means equal to \\'max\\')\\n        for(int key : hm.keySet()){\\n            if(hm.get(key) == max){      \\n                hs.add(key);\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            int r = nums[i] % space;         \\n            if(hs.contains(r)){            // in hashset we have only those remainder whose frequency is maximum and array is already sorted so if we found remainder in hashset then return element because it will be minimum value.\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        \\n        Arrays.sort(nums);    // purpost for sorting the array just for getting first element of number which woud be distroyed\\n        HashMap<Integer, Integer> hm = new HashMap<>();   // counting the frequency of number whose remainders are same\\n        for(int i = 0; i < nums.length; i++){\\n            int r = nums[i] % space;\\n            hm.put(r, hm.getOrDefault(r, 0) + 1);    \\n        }\\n        int max = 0;\\n        ArrayList<Integer> sans = new ArrayList<>();\\n        for(int key : hm.keySet()){\\n            if(hm.get(key) > max){\\n                max = hm.get(key);           // here we calculated the remainder whose frequency is maximum\\n            }\\n        }\\n        HashSet<Integer> hs = new HashSet<>();  // there can be many remainder whose frequency are equal to maximum (means equal to \\'max\\')\\n        for(int key : hm.keySet()){\\n            if(hm.get(key) == max){      \\n                hs.add(key);\\n            }\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            int r = nums[i] % space;         \\n            if(hs.contains(r)){            // in hashset we have only those remainder whose frequency is maximum and array is already sorted so if we found remainder in hashset then return element because it will be minimum value.\\n                return nums[i];\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756405,
                "title": "easy-c-commented-solution-with-intuition",
                "content": "Read question carefully, it formulates to (nums[j] - selected value) % space = 0 for max possible elements, so we count frequency of each remainder when divided by space and find answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> umap; //map to store frequencies\\n        int target=0; // max frequency\\n        for(int i=0; i<nums.size(); i++){\\n            target=max(target, ++umap[nums[i]%space]); \\n        }\\n        int ret=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            if(umap[nums[i]%space]==target)\\n                ret=min(ret, nums[i]); // min value having max frequency\\n        }\\n        return ret;\\n    }\\n};\\n```\\n\\nedit: more readable code built on same intuition given by @am011iitjmu",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> umap; //map to store frequencies\\n        int target=0; // max frequency\\n        for(int i=0; i<nums.size(); i++){\\n            target=max(target, ++umap[nums[i]%space]); \\n        }\\n        int ret=INT_MAX;\\n        for(int i=0; i<nums.size(); i++){\\n            if(umap[nums[i]%space]==target)\\n                ret=min(ret, nums[i]); // min value having max frequency\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673308,
                "title": "c-3-approaches",
                "content": "# Solution 1: gives TLE\\nTime Complexity: O(N^2)\\nSpace Complexity: O(1)\\n\\nbrute force approach\\ncheck nums[j]-nums[i]%space==0 for every jth index\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(begin(nums),end(nums));\\n        int n=nums.size();\\n        int maxcnt=1;\\n        int ans=nums[0];\\n        for(int i=0;i<n;i++){\\n            int cnt=1;\\n            for(int j=i+1;j<n;j++){\\n                if((nums[j]-nums[i])%space==0) cnt++;\\n            }\\n            if(cnt >maxcnt){\\n                maxcnt=cnt;\\n                ans=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# Solution 2: Accepted\\nTime Complexity: O(NlogN)\\nSpace Complexity: O(N)\\n--> my solution beat 44.25% time and 63.94% memory\\n\\nthis is one pass approach\\nsort the vector and iterate in reverse to find min element\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(begin(nums),end(nums));\\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        int maxcnt=0;\\n        unordered_map<int,int> mp;\\n        for(int i=n-1;i>=0;i--){\\n            int rem=nums[i]%space;\\n            mp[rem]++;\\n            if(mp[rem]>=maxcnt){\\n                maxcnt=mp[rem];\\n                ans=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\\n# Solution 3: Accepted\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n\\n--> my solution beat 41.13% time and 63.94% memory\\n\\nINTUITION\\n-to destroy jth index it should satisfy nums[j]-nums[i]=c*space\\n-this means that nums[j]-nums[i] will be divisible by space\\n-that means both nums[i] and num[j] should be separately divisible by space\\n-now iterate over the vector and store the remainder of each element in a map and store the number of times a certain remainder is occuring(that is frequency of remainder)\\n-now you only have to find the minimum element corresponding to max occuring remainder\\n\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(begin(nums),end(nums));\\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        int maxcnt=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            mp[rem]++;\\n            maxcnt=max(maxcnt, mp[rem]);\\n        }\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            if(mp[rem]==maxcnt) ans=min(ans,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Sort",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(begin(nums),end(nums));\\n        int n=nums.size();\\n        int maxcnt=1;\\n        int ans=nums[0];\\n        for(int i=0;i<n;i++){\\n            int cnt=1;\\n            for(int j=i+1;j<n;j++){\\n                if((nums[j]-nums[i])%space==0) cnt++;\\n            }\\n            if(cnt >maxcnt){\\n                maxcnt=cnt;\\n                ans=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(begin(nums),end(nums));\\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        int maxcnt=0;\\n        unordered_map<int,int> mp;\\n        for(int i=n-1;i>=0;i--){\\n            int rem=nums[i]%space;\\n            mp[rem]++;\\n            if(mp[rem]>=maxcnt){\\n                maxcnt=mp[rem];\\n                ans=nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(begin(nums),end(nums));\\n        int n=nums.size();\\n        int ans=INT_MAX;\\n        int maxcnt=0;\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            mp[rem]++;\\n            maxcnt=max(maxcnt, mp[rem]);\\n        }\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            if(mp[rem]==maxcnt) ans=min(ans,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3621628,
                "title": "python-3-hash-table-counting-greedy-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        c = collections.Counter()\\n        max_target = 0\\n        for num in nums:\\n            val = num % space\\n            c[val] += 1\\n            max_target = max(max_target, c[val])\\n        \\n        res = max(nums)\\n        for num in nums:\\n            val = num % space\\n            if c[val] == max_target:\\n                res = min(res, num)\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        c = collections.Counter()\\n        max_target = 0\\n        for num in nums:\\n            val = num % space\\n            c[val] += 1\\n            max_target = max(max_target, c[val])\\n        \\n        res = max(nums)\\n        for num in nums:\\n            val = num % space\\n            if c[val] == max_target:\\n                res = min(res, num)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555296,
                "title": "using-map-c",
                "content": "SPACE COMPLEXITY IS O(SPACE)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,vector<int>> mp;\\n        int mx = 0, ans = 0;\\n        for(auto &i: nums){\\n            if(mp.count(i%space)==0){\\n                mp[i%space] = {1,i};\\n            }else{\\n                mp[i%space][0]++;\\n                mp[i%space][1] = min(i,mp[i%space][1]);\\n            }\\n            if(mp[i%space][0]>mx){\\n                mx = mp[i%space][0];\\n                ans = mp[i%space][1];\\n            }if(mp[i%space][0]==mx){\\n                ans = min(ans,mp[i%space][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,vector<int>> mp;\\n        int mx = 0, ans = 0;\\n        for(auto &i: nums){\\n            if(mp.count(i%space)==0){\\n                mp[i%space] = {1,i};\\n            }else{\\n                mp[i%space][0]++;\\n                mp[i%space][1] = min(i,mp[i%space][1]);\\n            }\\n            if(mp[i%space][0]>mx){\\n                mx = mp[i%space][0];\\n                ans = mp[i%space][1];\\n            }if(mp[i%space][0]==mx){\\n                ans = min(ans,mp[i%space][1]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811863,
                "title": "mod-map-solution",
                "content": "# Intuition\\n\\nnums[i]= all the elements that can be destroyed using ans as the seeding\\n\\nans + c * space = nums[i]\\nnums[i] - ans = c * space\\n\\nsince c is a non negative integer so (nums[i] - ans) is divisible by space\\n\\n(nums[i] - ans) % space == 0\\n\\ntherefore, \\nnums[i] % space - ans % space = 0\\nnums[i] % space = ans % space\\n\\ntherefore we need to hunt down the remainder/remainders with the highest occurences(no of times they appear) using a hash map \\n\\nwe then get the minimum element whose remainder occurs maxx no of times\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        \\n        Map<Integer, Integer> m= new HashMap<>();\\n\\n        \\n        //hunting down the remainder/remainders with the highest occurences(no of times they appear)\\n        //maxx= highest no of occurences of remainders\\n        int maxx= 0;\\n        for( int i: nums){\\n            m.put(i%space,m.getOrDefault(i%space,0)+1);\\n            maxx= Math.max( maxx,m.get(i%space));\\n        }\\n\\n\\n\\n        // hunting the minimum element whose remainder occurs maxx no of times\\n        int ans=Integer.MAX_VALUE;\\n        for( int i: nums){\\n            if( m.get(i%space)==maxx){\\n                ans= Math.min(i, ans);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        \\n        Map<Integer, Integer> m= new HashMap<>();\\n\\n        \\n        //hunting down the remainder/remainders with the highest occurences(no of times they appear)\\n        //maxx= highest no of occurences of remainders\\n        int maxx= 0;\\n        for( int i: nums){\\n            m.put(i%space,m.getOrDefault(i%space,0)+1);\\n            maxx= Math.max( maxx,m.get(i%space));\\n        }\\n\\n\\n\\n        // hunting the minimum element whose remainder occurs maxx no of times\\n        int ans=Integer.MAX_VALUE;\\n        for( int i: nums){\\n            if( m.get(i%space)==maxx){\\n                ans= Math.min(i, ans);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756746,
                "title": "video-explanation-with-intuition-of-every-step",
                "content": "https://www.youtube.com/watch?v=CFuCarnHoNM",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=CFuCarnHoNM",
                "codeTag": "Unknown"
            },
            {
                "id": 2756514,
                "title": "c-cleanest-code-count-modulo",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<long long int,vector<long long int>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            long long int diff=nums[i]%space;\\n            mp[diff].push_back(nums[i]);\\n        }\\n        long long int mx=-1e18;\\n        for(auto it:mp){\\n           \\n            if((long long int)it.second.size()>mx){\\n                mx=(long long int)it.second.size();\\n            }\\n           \\n        }\\n       \\n        long long int res;\\n        for(auto it:mp){\\n            vector<long long int> v=it.second;\\n            sort(v.begin(),v.end());\\n            if(v.size()==mx){\\n               \\n                res=min(res,v[0]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<long long int,vector<long long int>> mp;\\n        for(int i=0;i<nums.size();i++){\\n            long long int diff=nums[i]%space;\\n            mp[diff].push_back(nums[i]);\\n        }\\n        long long int mx=-1e18;\\n        for(auto it:mp){\\n           \\n            if((long long int)it.second.size()>mx){\\n                mx=(long long int)it.second.size();\\n            }\\n           \\n        }\\n       \\n        long long int res;\\n        for(auto it:mp){\\n            vector<long long int> v=it.second;\\n            sort(v.begin(),v.end());\\n            if(v.size()==mx){\\n               \\n                res=min(res,v[0]);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756374,
                "title": "python-greedy-group-example",
                "content": "\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n\\t\\t# example:  nums = [3,7,8,1,1,5], space = 2\\n        groups = defaultdict(list)\\n        for num in nums:\\n            groups[num % space].append(num)\\n        \\n        # print(groups) # defaultdict(<class \\'list\\'>, {1: [3, 7, 1, 1, 5], 0: [8]}) groups is [3, 7, 1, 1, 5] and [8] \\n        \"\"\" min of [3, 7, 1, 1, 5] can destroy all others (greedy approach) => 1 can destory 1,3,5,7 ... \"\"\"\\n        performance = defaultdict(list)\\n        for group in groups.values():\\n            performance[len(group)].append(min(group))\\n        \\n        # print(performance) # defaultdict(<class \\'list\\'>, {5: [1], 1: [8]})\\n\\t\\t# nums that can destory 5 targets are [1], nums that can destory 1 target are [8] \\n        return min(performance[max(performance)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n\\t\\t# example:  nums = [3,7,8,1,1,5], space = 2\\n        groups = defaultdict(list)\\n        for num in nums:\\n            groups[num % space].append(num)\\n        \\n        # print(groups) # defaultdict(<class \\'list\\'>, {1: [3, 7, 1, 1, 5], 0: [8]}) groups is [3, 7, 1, 1, 5] and [8] \\n        \"\"\" min of [3, 7, 1, 1, 5] can destroy all others (greedy approach) => 1 can destory 1,3,5,7 ... \"\"\"\\n        performance = defaultdict(list)\\n        for group in groups.values():\\n            performance[len(group)].append(min(group))\\n        \\n        # print(performance) # defaultdict(<class \\'list\\'>, {5: [1], 1: [8]})\\n\\t\\t# nums that can destory 5 targets are [1], nums that can destory 1 target are [8] \\n        return min(performance[max(performance)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766029,
                "title": "beginner-friendly-o-n-python-c-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe Most important line in the question is:\\n\\n`Seeding the machine with some nums[i] allows it to destroy all targets with values that can be represented as nums[i] + c * space, where c is any non-negative integer.`\\n\\nSo let us assume that it can distroy a target that is having a value of X. \\n\\n`X =  nums[i] + c*space`\\nif i rearrange the equation by then equation will look like \\n`c = (X - nums[i])/space`\\nit is given that \\n`c is any non-negative integer`\\nthis indicate that `(X-nums[i])` is a multiple of `space`\\nthis indicate `(X - nums[i])%space = 0` or `X%space = nums[i]%space` \\nwhere % is remainder operator in C++ you can learn more about  %  -> [click here](https://stackoverflow.com/questions/13683563/whats-the-difference-between-mod-and-remainder)\\n\\nSo this implies that all those targets that seeding machine can destroy with $$nums[i]$$ will wil give remainder that is equal to `nums[i]%space`\\n\\n- This means that the seeding machine can only destroy the targets that have the same remainder as the seed when divided by the space. For example, if the seed is 3 and the space is 5, the seeding machine can only destroy the targets that have a remainder of 3 when divided by 5, such as 8, 13, 18, 23, and so on.\\n- To find the best seed, we need to count how many targets have each possible remainder. For example, if we have targets like 8, 9, 13, 14, 18, 19, 23, and 24, we can count how many of them have a remainder of 0, 1, 2, 3, or 4 when divided by 5. We can use a table to show this:\\n![Screenshot 2023-07-15 015608.png](https://assets.leetcode.com/users/images/26e85dfe-8ba6-4129-8eac-17be71679e08_1689366400.9808855.png)\\n- We can see that the remainders with the highest count are 3 and 4. This means that the seeds that can destroy the most targets are the ones that have a remainder of 3 or 4 when divided by 5. For example, we can use seeds like 3, 8, or 13 for a remainder of 3, or seeds like 4, 9, or 14 for a remainder of 4.\\n- To find the best seed among these options, we need to choose the smallest one. This is because we want to use the smallest seed possible to destroy the most targets possible. For example, if we use a seed of 3 instead of a seed of 8 or 13, we can save some space and energy for the seeding machine. Therefore, the best seeds are either 3 or 4, depending on which remainder has more targets.\\n\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLook for the smallest target that appears most often in the same group of remainders and give it as the answer\\n> First for loop is for finding maximum frquency.\\nSecond for loop is for finding the minimum elemnt that is having maximum frequency.\\n\\n---\\n\\n\\n# Complexity\\n- **Time complexity**:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n> Time complexity of this code is $$O(N)$$\\n- **Space complexity**:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n> Space complexity of this code in worst case would be $$O(N)$$\\n\\n---\\n\\n# Code\\n```cpp []\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& targets, int space) {\\n        int size = targets.size();\\n        int maximum = 0;\\n        unordered_map<int, int> targetCount;\\n\\n        // Count the occurrences of each target modulo space\\n        for (int i = 0; i < size; i++) {\\n            targetCount[targets[i] % space]++;\\n            // Update the maximum frequency if needed\\n            maximum = max(maximum, targetCount[targets[i] % space]);\\n        }\\n\\n        int answer = INT_MAX;\\n        // Find the target with maximum occurrences modulo space\\n        for (int i = 0; i < size; i++) {\\n            // Check if the current target has the maximum frequency\\n            if (targetCount[targets[i] % space] == maximum) {\\n                // Update the answer if the current target is smaller\\n                answer = min(targets[i], answer);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        size = len(nums)\\n        maximum = 0\\n        targetCount = defaultdict(int)\\n\\n        # Count the occurrences of each target modulo space\\n        for i in range(size):\\n            targetCount[nums[i] % space] += 1\\n            # Update the maximum frequency if needed\\n            maximum = max(maximum, targetCount[nums[i] % space])\\n\\n        answer = float(\\'inf\\')\\n        # Find the target with maximum occurrences modulo space\\n        for i in range(size):\\n            # Check if the current target has the maximum frequency\\n            if targetCount[nums[i] % space] == maximum:\\n                # Update the answer if the current target is smaller\\n                answer = min(nums[i], answer)\\n\\n        return answer\\n```\\n```Java []\\nclass Solution {\\n    public int destroyTargets(int[] targets, int space) {\\n        int size = targets.length;\\n        int maximum = 0;\\n        Map<Integer, Integer> targetCount = new HashMap<>();\\n\\n        // Count the occurrences of each target modulo space\\n        for (int i = 0; i < size; i++) {\\n            targetCount.put(targets[i] % space, targetCount.getOrDefault(targets[i] % space, 0) + 1);\\n            // Update the maximum frequency if needed\\n            maximum = Math.max(maximum, targetCount.get(targets[i] % space));\\n        }\\n\\n        int answer = Integer.MAX_VALUE;\\n        // Find the target with maximum occurrences modulo space\\n        for (int i = 0; i < size; i++) {\\n            // Check if the current target has the maximum frequency\\n            if (targetCount.get(targets[i] % space) == maximum) {\\n                // Update the answer if the current target is smaller\\n                answer = Math.min(targets[i], answer);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```\\n\\n\\n\\n# \\uD83D\\uDE4F I appreciate your feedback and support for my explanation and solution. \\uD83D\\uDC4D Please consider upvoting it if you find it helpful and valuable. \\uD83D\\uDE4C This will encourage me to continue sharing my insights  with you. \\uD83D\\uDE4F Thank you. \\uD83D\\uDE0A\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```cpp []\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& targets, int space) {\\n        int size = targets.size();\\n        int maximum = 0;\\n        unordered_map<int, int> targetCount;\\n\\n        // Count the occurrences of each target modulo space\\n        for (int i = 0; i < size; i++) {\\n            targetCount[targets[i] % space]++;\\n            // Update the maximum frequency if needed\\n            maximum = max(maximum, targetCount[targets[i] % space]);\\n        }\\n\\n        int answer = INT_MAX;\\n        // Find the target with maximum occurrences modulo space\\n        for (int i = 0; i < size; i++) {\\n            // Check if the current target has the maximum frequency\\n            if (targetCount[targets[i] % space] == maximum) {\\n                // Update the answer if the current target is smaller\\n                answer = min(targets[i], answer);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        size = len(nums)\\n        maximum = 0\\n        targetCount = defaultdict(int)\\n\\n        # Count the occurrences of each target modulo space\\n        for i in range(size):\\n            targetCount[nums[i] % space] += 1\\n            # Update the maximum frequency if needed\\n            maximum = max(maximum, targetCount[nums[i] % space])\\n\\n        answer = float(\\'inf\\')\\n        # Find the target with maximum occurrences modulo space\\n        for i in range(size):\\n            # Check if the current target has the maximum frequency\\n            if targetCount[nums[i] % space] == maximum:\\n                # Update the answer if the current target is smaller\\n                answer = min(nums[i], answer)\\n\\n        return answer\\n```\n```Java []\\nclass Solution {\\n    public int destroyTargets(int[] targets, int space) {\\n        int size = targets.length;\\n        int maximum = 0;\\n        Map<Integer, Integer> targetCount = new HashMap<>();\\n\\n        // Count the occurrences of each target modulo space\\n        for (int i = 0; i < size; i++) {\\n            targetCount.put(targets[i] % space, targetCount.getOrDefault(targets[i] % space, 0) + 1);\\n            // Update the maximum frequency if needed\\n            maximum = Math.max(maximum, targetCount.get(targets[i] % space));\\n        }\\n\\n        int answer = Integer.MAX_VALUE;\\n        // Find the target with maximum occurrences modulo space\\n        for (int i = 0; i < size; i++) {\\n            // Check if the current target has the maximum frequency\\n            if (targetCount.get(targets[i] % space) == maximum) {\\n                // Update the answer if the current target is smaller\\n                answer = Math.min(targets[i], answer);\\n            }\\n        }\\n\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333737,
                "title": "simple-using-map-memory-limit-error-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nA target can be destroyed if it is of type nums[i] + f*k. so,we classify the numbers based on the remainder they give when divided by k. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe keep track of the numbers giving same remainder by storing their count in a map.So,we traverse thru nums, updating the count of remainder in the map.And also while traversing we keep track of the remainder which has maximum count.\\n**WE USE MAP BECAUSE IF WE USE VECTOR FOR MAX SIZE,WHICH IS K,IT GIVES MEMORY LIMIT ERROR AS SOME OF THE ELEMENTS IN VECTOR WLL BE EMPTY WHICH TAKES EXTRA NON USEFUL SPACE**\\n\\nNow,we traverse thru nums to find the minimum element having the remainder which we found out to be having max count.\\n\\n**NOTE**: When we have multiple remainders giving same count,we will return the minimum element of both remainders,which is taken care by the process we follow.\\n# Complexity\\n- Time complexity:     O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k) at max,when we encounter remainders from 0 to k-1 in nums.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int k) {\\n        unordered_map<int,int>v;\\n        int ind=INT_MIN;\\n//ind stores the remainder which has maximum count of it\\'s type\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[nums[i]%k]++;\\n            ind=max(ind,v[nums[i]%k]);\\n        }\\n        int ret=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(v[nums[i]%k] == ind)\\n            {\\n                ret=min(ret,nums[i]);\\n//we find minimum element having ind as remainder.\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int k) {\\n        unordered_map<int,int>v;\\n        int ind=INT_MIN;\\n//ind stores the remainder which has maximum count of it\\'s type\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v[nums[i]%k]++;\\n            ind=max(ind,v[nums[i]%k]);\\n        }\\n        int ret=INT_MAX;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(v[nums[i]%k] == ind)\\n            {\\n                ret=min(ret,nums[i]);\\n//we find minimum element having ind as remainder.\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2811134,
                "title": "easy-c-solution-with-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> m;\\n        int res = INT_MAX;\\n        int maxcount = 0;\\n        \\n        // count the numbers with same reminder and find max count\\n        for (int n: nums) {\\n            maxcount = max(maxcount, ++m[n % space]);\\n        }\\n        // find the smallest number with max count\\n        for (int n: nums) {\\n            if (m[n % space] == maxcount) {\\n                res = min(res, n);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> m;\\n        int res = INT_MAX;\\n        int maxcount = 0;\\n        \\n        // count the numbers with same reminder and find max count\\n        for (int n: nums) {\\n            maxcount = max(maxcount, ++m[n % space]);\\n        }\\n        // find the smallest number with max count\\n        for (int n: nums) {\\n            if (m[n % space] == maxcount) {\\n                res = min(res, n);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2799376,
                "title": "hash-by-remainder",
                "content": "# Intuition\\nTo find such a number we group all numbers by their remainder and then we find the remainder with max frequency and afterwords we can find the minimum number with remainder and max frequency.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe add all numbers to `rems` factoring them by their remainder when divided by `space`.\\n`rems` store the feq and the min number with that remainder and return it.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(n)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n#define has(m, k) (m.find(k) != m.end())\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, pair<int, int>> rems;\\n        int r;\\n        for(int num: nums) {\\n            r = num % space;\\n            if(has(rems, r))\\n                rems[r] = make_pair(rems[r].first + 1, min(rems[r].second, num));\\n            else\\n                rems[r] = make_pair(1, num);\\n        }\\n        \\n        int ans, count = 0;\\n        for(auto& it: rems) {\\n            if(it.second.first > count) {\\n                count = it.second.first;\\n                ans = it.second.second;\\n            }\\n            else if(it.second.first == count && it.second.second < ans)\\n                ans = it.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Math"
                ],
                "code": "```\\n#define has(m, k) (m.find(k) != m.end())\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, pair<int, int>> rems;\\n        int r;\\n        for(int num: nums) {\\n            r = num % space;\\n            if(has(rems, r))\\n                rems[r] = make_pair(rems[r].first + 1, min(rems[r].second, num));\\n            else\\n                rems[r] = make_pair(1, num);\\n        }\\n        \\n        int ans, count = 0;\\n        for(auto& it: rems) {\\n            if(it.second.first > count) {\\n                count = it.second.first;\\n                ans = it.second.second;\\n            }\\n            else if(it.second.first == count && it.second.second < ans)\\n                ans = it.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760924,
                "title": "best-solution-in-c-hashmap",
                "content": "# Code\\n**Please Upvote if u liked my Solution**\\uD83D\\uDE42\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        vector<int> vec;\\n        unordered_map<int,int> mp;\\n        int maxi=INT_MIN,count=0,ans=0;\\n        for(auto it:nums)\\n            vec.push_back(it%space);\\n        for(auto it:vec)\\n            mp[it]++;\\n        for(int i=0;i<vec.size();i++){\\n            count=mp[vec[i]];\\n            if(count>maxi){\\n                maxi=count;\\n                ans=nums[i];\\n            }\\n            if(count==maxi)\\n                ans=min(ans,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        vector<int> vec;\\n        unordered_map<int,int> mp;\\n        int maxi=INT_MIN,count=0,ans=0;\\n        for(auto it:nums)\\n            vec.push_back(it%space);\\n        for(auto it:vec)\\n            mp[it]++;\\n        for(int i=0;i<vec.size();i++){\\n            count=mp[vec[i]];\\n            if(count>maxi){\\n                maxi=count;\\n                ans=nums[i];\\n            }\\n            if(count==maxi)\\n                ans=min(ans,nums[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757428,
                "title": "java-solution-using-map",
                "content": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums){\\n            int mod = num % space;\\n            map.put(mod, map.getOrDefault(mod, 0) + 1);\\n        }\\n        int maxTargets = Collections.max(map.values());\\n        int ans = Integer.MAX_VALUE;\\n        for (int num : nums){\\n            int mod = num % space;\\n            if (map.get(mod) == maxTargets){\\n                 ans = Math.min(ans, num);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums){\\n            int mod = num % space;\\n            map.put(mod, map.getOrDefault(mod, 0) + 1);\\n        }\\n        int maxTargets = Collections.max(map.values());\\n        int ans = Integer.MAX_VALUE;\\n        for (int num : nums){\\n            int mod = num % space;\\n            if (map.get(mod) == maxTargets){\\n                 ans = Math.min(ans, num);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756880,
                "title": "js-easy-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} space\\n * @return {number}\\n */\\nvar destroyTargets = function (nums, space) {\\n  nums.sort((a, b) => a - b);\\n  const count = {};\\n  for (let num of nums) {\\n    const remainder = num % space;\\n    if (!count[remainder]) {\\n      count[remainder] = 0;\\n    }\\n    count[remainder]++;\\n  }\\n  let max = 0;\\n  let answer;\\n  for (let num of nums) {\\n    const remainder = num % space;\\n    if (count[remainder] > max) {\\n      max = count[remainder];\\n      answer = num;\\n    }\\n  }\\n  return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} space\\n * @return {number}\\n */\\nvar destroyTargets = function (nums, space) {\\n  nums.sort((a, b) => a - b);\\n  const count = {};\\n  for (let num of nums) {\\n    const remainder = num % space;\\n    if (!count[remainder]) {\\n      count[remainder] = 0;\\n    }\\n    count[remainder]++;\\n  }\\n  let max = 0;\\n  let answer;\\n  for (let num of nums) {\\n    const remainder = num % space;\\n    if (count[remainder] > max) {\\n      max = count[remainder];\\n      answer = num;\\n    }\\n  }\\n  return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2756689,
                "title": "c-with-notes-and-detailed-explanation",
                "content": "# First Intuition\\nMy first intuition was find all targets for each `nums`. As we know `targets = nums[i] + c * space` which can be written as `nums[j] == (nums[j] - nums[i]) % space` to check if a `nums[j]` is a target `nums[i]` (remember that `c` can\\'t be negative which means that `nums[j]` must be greater than `nums[i]` and their difference must divisible (with no rest) by `space`).\\nHowever, this cause **LTE** because `1 <= nums.length <= 10^5` (this is an hint that the time complexity of our function must $$O(n)$$).\\n\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //save the maximum number of targets       \\n        int max_n_target = 0;\\n        \\n    //amont target, min num to get that amount of targets\\n        map<int,int> mp;\\n        \\n        //sort nums (so that we do the first number first)\\n        sort(begin(nums), end(nums));\\n        \\n        //check each number\\n        for (int i = 0; i < nums.size(); i++){\\n            //get the number of target with this number\\n            int n_target = 0;\\n            //since we want to check only numbers that are greater then nums[i] we start from i\\n            for (int j = i; j < nums.size(); j++)\\n                //if nums[j] is a target, increase n_target\\n                if ((nums[j] - nums[i]) % space == 0)\\n                    n_target++;\\n            \\n            //if mp doesn\\'t contain n_target\\n            //we need to assign nums[i] to n_target only once because we started from the smallest number to the greatest, so the first number we found with n_target is the smallest number\\n            if (mp.count(n_target) == 0)\\n                mp[n_target] = nums[i];\\n                   \\n            //save the maximum number of targets       \\n            max_n_target = max(max_n_target, n_target);\\n        }\\n                    \\n        return mp[max_n_target];\\n    }\\n};\\n```\\n\\n\\n# Second Intuition\\nAfter some while, I realized that I don\\'t need to care about `nums[i]` because `nums[i] % space` is equal to `nums[j] % space` (where `nums[j]` is the target of `nums[i]` and `nums[j]` is greater than `nums[i]`), so we just need to mod all numbers and find the numbers that appeear the most. Then find the smallest number in that frequence.\\n\\n## Example with an example\\n1. `nums = [5, 4, 3, 2, 1] space = 2`\\n2. we mod each number of `nums`,\\n3. we get `nums_modded = [1, 0, 1, 0, 1]`\\n4. The number that appears the most is `1`\\n5. which correspondes to `nums[0], nums[2], nums[3]`\\n6. `nums[3]` is the smallest number, so it\\'s the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //sort it in descending order, so that the last number we check is the smallest number\\n        sort(begin(nums), end(nums),greater());\\n        \\n        //mod numbers by space and save into nums_modded\\n        vector<int> nums_modded;\\n        //save how many times appear nums[i] % space\\n        unordered_map<int,int> freq; \\n        //save the nums[i](it will be the smallest one because we sort it in reverse order) that appears the most\\n        pair<int,int> highest_freq = {0,0};\\n        \\n        //mod each number\\n        for (int n : nums){\\n            nums_modded.push_back(n % space);\\n            freq[n % space]++;    \\n            \\n            //save the number with the highest frequence (that appear most)\\n            if (highest_freq.second <= freq[n % space])\\n                highest_freq = {n, freq[n % space]};\\n        }\\n\\n        \\n        return highest_freq.first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //save the maximum number of targets       \\n        int max_n_target = 0;\\n        \\n    //amont target, min num to get that amount of targets\\n        map<int,int> mp;\\n        \\n        //sort nums (so that we do the first number first)\\n        sort(begin(nums), end(nums));\\n        \\n        //check each number\\n        for (int i = 0; i < nums.size(); i++){\\n            //get the number of target with this number\\n            int n_target = 0;\\n            //since we want to check only numbers that are greater then nums[i] we start from i\\n            for (int j = i; j < nums.size(); j++)\\n                //if nums[j] is a target, increase n_target\\n                if ((nums[j] - nums[i]) % space == 0)\\n                    n_target++;\\n            \\n            //if mp doesn\\'t contain n_target\\n            //we need to assign nums[i] to n_target only once because we started from the smallest number to the greatest, so the first number we found with n_target is the smallest number\\n            if (mp.count(n_target) == 0)\\n                mp[n_target] = nums[i];\\n                   \\n            //save the maximum number of targets       \\n            max_n_target = max(max_n_target, n_target);\\n        }\\n                    \\n        return mp[max_n_target];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //sort it in descending order, so that the last number we check is the smallest number\\n        sort(begin(nums), end(nums),greater());\\n        \\n        //mod numbers by space and save into nums_modded\\n        vector<int> nums_modded;\\n        //save how many times appear nums[i] % space\\n        unordered_map<int,int> freq; \\n        //save the nums[i](it will be the smallest one because we sort it in reverse order) that appears the most\\n        pair<int,int> highest_freq = {0,0};\\n        \\n        //mod each number\\n        for (int n : nums){\\n            nums_modded.push_back(n % space);\\n            freq[n % space]++;    \\n            \\n            //save the number with the highest frequence (that appear most)\\n            if (highest_freq.second <= freq[n % space])\\n                highest_freq = {n, freq[n % space]};\\n        }\\n\\n        \\n        return highest_freq.first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756487,
                "title": "c-map-easy-understanding",
                "content": "We can mod all elements by space and the smallest element of the most occuring remainder will be the answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,pair<int,int>> mp;\\n        \\n        for(auto it : nums)\\n        {\\n            mp[it%space].first++;\\n            mp[it%space].second = mp[it%space].first == 1 ? it : min(mp[it%space].second , it); \\n        }\\n        \\n        int ans , freq = -1;\\n        \\n        for(auto it : mp)\\n        {\\n            if(freq == it.second.first)\\n                ans = min(ans,it.second.second);\\n            else if(freq < it.second.first)\\n             freq = it.second.first , ans = it.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,pair<int,int>> mp;\\n        \\n        for(auto it : nums)\\n        {\\n            mp[it%space].first++;\\n            mp[it%space].second = mp[it%space].first == 1 ? it : min(mp[it%space].second , it); \\n        }\\n        \\n        int ans , freq = -1;\\n        \\n        for(auto it : mp)\\n        {\\n            if(freq == it.second.first)\\n                ans = min(ans,it.second.second);\\n            else if(freq < it.second.first)\\n             freq = it.second.first , ans = it.second.second;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756464,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(), nums.end());\\n        map<int, vector<int> > mp;\\n        for(int i = 0; i<nums.size(); i++){\\n            mp[(nums[i]%space)].push_back(nums[i]);\\n        }\\n        int mx = 0, mxval = -1;\\n        for(auto it: mp){\\n            if(it.second.size() > mx){\\n                mx = it.second.size();\\n                mxval = it.second[0];\\n            }else if(it.second.size() == mx){\\n                mx = it.second.size();\\n                if(mxval > it.second[0]){\\n                    mxval = it.second[0];\\n                }\\n            }\\n        }\\n        return mxval;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(), nums.end());\\n        map<int, vector<int> > mp;\\n        for(int i = 0; i<nums.size(); i++){\\n            mp[(nums[i]%space)].push_back(nums[i]);\\n        }\\n        int mx = 0, mxval = -1;\\n        for(auto it: mp){\\n            if(it.second.size() > mx){\\n                mx = it.second.size();\\n                mxval = it.second[0];\\n            }else if(it.second.size() == mx){\\n                mx = it.second.size();\\n                if(mxval > it.second[0]){\\n                    mxval = it.second[0];\\n                }\\n            }\\n        }\\n        return mxval;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756334,
                "title": "c-hash-map-solution-with-comments-7-lines-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> freq;\\n        vector<int> cnt = nums;\\n        int best = INT_MAX, mx = 0;\\n        for(auto &i : cnt) i %= space; // we would have to seed i%space in order to access this element\\n        for(auto i : cnt) freq[i]++; // count how many of each we have after mod\\n        for(auto i : freq) mx = max(i.second, mx); // find the most targets we can destroy\\n        for(int i = 0; i < nums.size(); i++) if(freq[cnt[i]] == mx) best = min(best, nums[i]); // if seeding this results in max destruction\\n        return best;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> freq;\\n        vector<int> cnt = nums;\\n        int best = INT_MAX, mx = 0;\\n        for(auto &i : cnt) i %= space; // we would have to seed i%space in order to access this element\\n        for(auto i : cnt) freq[i]++; // count how many of each we have after mod\\n        for(auto i : freq) mx = max(i.second, mx); // find the most targets we can destroy\\n        for(int i = 0; i < nums.size(); i++) if(freq[cnt[i]] == mx) best = min(best, nums[i]); // if seeding this results in max destruction\\n        return best;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3574936,
                "title": "using-hash-map-to-store-all-modulos",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\no(N)\\n\\n- Space complexity:\\n- o(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n      unordered_map<int,int>m;\\n    \\n      for(auto e:nums)\\n        {\\n            m[e%space]++;\\n            \\n        }\\n        int ans=INT_MAX;\\n        int r=0;\\n        for(auto e:nums )\\n     {\\n         int n=m[e%space];\\n         if(n>r)\\n         {\\n             r=n;\\n             ans=e;\\n         }\\n         else if(r==n)\\n         {\\n             ans=min(ans,e);\\n         }\\n     }\\n     return(ans);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n      unordered_map<int,int>m;\\n    \\n      for(auto e:nums)\\n        {\\n            m[e%space]++;\\n            \\n        }\\n        int ans=INT_MAX;\\n        int r=0;\\n        for(auto e:nums )\\n     {\\n         int n=m[e%space];\\n         if(n>r)\\n         {\\n             r=n;\\n             ans=e;\\n         }\\n         else if(r==n)\\n         {\\n             ans=min(ans,e);\\n         }\\n     }\\n     return(ans);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2852782,
                "title": "kotlin-sort-map",
                "content": "# Code\\n```\\nclass Solution {\\n    fun destroyTargets(a: IntArray, s: Int): Int {\\n        a.sort()\\n        var m = mutableMapOf<Int, Int>()\\n        for (i in 0..a.size - 1) {\\n            var mod = a[i] % s\\n            m[mod] = (m[mod] ?: 0) + 1\\n        }\\n        var k = 0\\n        var maxValue = 0\\n        for (key in m.keys) {\\n            if (m[key]!! > maxValue) {\\n                maxValue = m[key]!!\\n                k = key\\n            }\\n        }\\n\\n        for (i in 0..a.size - 1) {\\n            if (a[i] % s == k) return a[i]\\n        }\\n\\n        return 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Hash Table",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    fun destroyTargets(a: IntArray, s: Int): Int {\\n        a.sort()\\n        var m = mutableMapOf<Int, Int>()\\n        for (i in 0..a.size - 1) {\\n            var mod = a[i] % s\\n            m[mod] = (m[mod] ?: 0) + 1\\n        }\\n        var k = 0\\n        var maxValue = 0\\n        for (key in m.keys) {\\n            if (m[key]!! > maxValue) {\\n                maxValue = m[key]!!\\n                k = key\\n            }\\n        }\\n\\n        for (i in 0..a.size - 1) {\\n            if (a[i] % s == k) return a[i]\\n        }\\n\\n        return 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794087,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums, space):\\n        dict1 = defaultdict(int)\\n\\n        for i in nums:\\n            dict1[i%space] += 1\\n\\n        max_val = max(dict1.values())\\n\\n        return min([i for i in nums if dict1[i%space] == max_val])\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums, space):\\n        dict1 = defaultdict(int)\\n\\n        for i in nums:\\n            dict1[i%space] += 1\\n\\n        max_val = max(dict1.values())\\n\\n        return min([i for i in nums if dict1[i%space] == max_val])\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760145,
                "title": "python-three-lines-mod-counter-w-explanation",
                "content": "# Intuition\\nConsider two integers *m* and *n*. If *m* and *n* are in the same congruence class mod *k* (i.e., ```m % k == n % k```), they must have the forms $$m = ak + r$$ and $$n = bk + r$$. Their difference is therefore $$m - n = ak - bk = (a-b)k$$, a multiple of the modulus *k*.\\n\\nSince our machine destroys targets that are a multiple of ```space``` apart, we can exploit the above property. We simply find the most-frequently occurring congruence class modulo ```space``` and select the smallest number in this class from the array (n.b.: different congruence classes may occur equally often).\\n\\n\\n# Approach\\nUse a Counter object to count how often each congruence class appears in the array. Find the maximum frequency of occurrence of any congruence class. Then select the minimum element of the array that occurs this often. The algorithm also handles the case that multiple congruence classes occur with the same frequency.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, xs: List[int], space: int) -> int:\\n        class_freqs = Counter(x % space for x in xs)\\n        max_count = max (class_freqs.values())\\n        return min(x for x in xs if class_freqs [x % space] == max_count)\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```m % k == n % k```\n```space```\n```space```\n```\\nclass Solution:\\n    def destroyTargets(self, xs: List[int], space: int) -> int:\\n        class_freqs = Counter(x % space for x in xs)\\n        max_count = max (class_freqs.values())\\n        return min(x for x in xs if class_freqs [x % space] == max_count)\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2759864,
                "title": "java-solution",
                "content": "```\\npublic int destroyTargets(int[] nums, int space) {\\n        int val = Integer.MIN_VALUE;\\n        int num = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n      for(int a : nums){\\n          hm.put(a%space,hm.getOrDefault(a%space,0)+1);\\n      }\\n      for(int a : nums){\\n          if(val<=hm.get(a%space)){\\n              val = hm.get(a%space) ; \\n          }\\n      }\\n      for(int a : nums){\\n          if(hm.get(a%space)==val){\\n              if(a<num) num = a ; \\n          }\\n      }\\n        return num ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int destroyTargets(int[] nums, int space) {\\n        int val = Integer.MIN_VALUE;\\n        int num = Integer.MAX_VALUE;\\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n      for(int a : nums){\\n          hm.put(a%space,hm.getOrDefault(a%space,0)+1);\\n      }\\n      for(int a : nums){\\n          if(val<=hm.get(a%space)){\\n              val = hm.get(a%space) ; \\n          }\\n      }\\n      for(int a : nums){\\n          if(hm.get(a%space)==val){\\n              if(a<num) num = a ; \\n          }\\n      }\\n        return num ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2757648,
                "title": "python-solution-using-hashmap-and-modulo-with-explanation",
                "content": "# **Problem:**\\nWe need to find an element in the given list nums[i] where maximum number of elements in the array could be represented as nums[i]+c * space .\\n\\n# **Intuition and Solution Explanation :** \\n\\n* The modulo of (nums[i] + c * space ) with space i.e., (nums[i] + c * space )%space will be equal to module of nums[i] with space i.e., nums[i]%space.\\n\\t\\t\\t\\t\\t\\t\\t\\t(nums[i] + c * space )%space = nums[i]%space\\n* An element k can be represend by (nums[i] + c * space ) when (nums[i] + c * space )%space and k % space is equal.\\n* Hence we will find modulo of space for all elements in input list and store it in HashMap with the count for each unique remainder.\\n                       \\n```\\n for i in nums:            \\n\\t\\tHashMap[(i % space)] += 1\\n```\\n\\n* For input list [3,7,8,1,1,5] we will get HashMap {1: 5, 0: 1} ,because 5 elements (1,1,3,5,7) has remainder 1 by dividing with space(2) and 1 element(8) has remainder 0.\\n* This means elements 1,1,3,5,7 can be represend by (k+c* space).\\n* Now we take the maximum count index from our HashMap i.e., 1 which corresponds to 5.\\n* So all the elements in the input array that gives 1 as remainder on dividing with space are the answer but just not final anwer.\\n* We only want minimum value from these according to problem statement.\\n* Hence we will sort the list and find the first element that gives above remainder and return that.\\n\\n**`Code:`**\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        \\n        HashMap = defaultdict(int)\\n        \\n        for i in nums:            \\n            HashMap[(i % space)] += 1\\n        res = max(HashMap.values())\\n    \\n        for i in sorted(nums):\\n            if HashMap[i % space] == res:\\n                return i\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n for i in nums:            \\n\\t\\tHashMap[(i % space)] += 1\\n```\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        \\n        HashMap = defaultdict(int)\\n        \\n        for i in nums:            \\n            HashMap[(i % space)] += 1\\n        res = max(HashMap.values())\\n    \\n        for i in sorted(nums):\\n            if HashMap[i % space] == res:\\n                return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757220,
                "title": "java-hashmap-clean-and-simple",
                "content": "### **Please Upvote** :D\\nI don\\'t know why but I this problem kinda sucks to me.\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i : nums) {\\n            int rem = i % space;\\n            map.put(rem, map.getOrDefault(rem, 0) + 1);\\n        }\\n\\n        int max = Collections.max(map.values());\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i : nums) {\\n            int rem = i % space;\\n            if (map.get(rem) == max) {\\n                ans = Math.min(ans, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i : nums) {\\n            int rem = i % space;\\n            map.put(rem, map.getOrDefault(rem, 0) + 1);\\n        }\\n\\n        int max = Collections.max(map.values());\\n        int ans = Integer.MAX_VALUE;\\n\\n        for (int i : nums) {\\n            int rem = i % space;\\n            if (map.get(rem) == max) {\\n                ans = Math.min(ans, i);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757007,
                "title": "c-using-unordered-map-modulo",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        unordered_map<int,int>mp,mp1;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for(int x : nums){\\n            if(mp.find(x%space)==mp.end()){\\n                mp1[x%space] = x;\\n            }\\n            mp[x%space]++;\\n        }\\n        \\n        pair<int,int>maxi = {-1,-1};\\n        \\n        for(auto pr : mp){\\n            \\n            if(pr.second>maxi.second){\\n                maxi = pr;\\n            }\\n            else if(pr.second==maxi.second){\\n                if(mp1[pr.first] < mp1[maxi.first]){\\n                    maxi = pr;\\n                }\\n            }\\n        }\\n        return mp1[maxi.first];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        unordered_map<int,int>mp,mp1;\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        for(int x : nums){\\n            if(mp.find(x%space)==mp.end()){\\n                mp1[x%space] = x;\\n            }\\n            mp[x%space]++;\\n        }\\n        \\n        pair<int,int>maxi = {-1,-1};\\n        \\n        for(auto pr : mp){\\n            \\n            if(pr.second>maxi.second){\\n                maxi = pr;\\n            }\\n            else if(pr.second==maxi.second){\\n                if(mp1[pr.first] < mp1[maxi.first]){\\n                    maxi = pr;\\n                }\\n            }\\n        }\\n        return mp1[maxi.first];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756825,
                "title": "detailed-explanation-c-solution",
                "content": "Since we can jump from a nmber a to a number b only by satisfying b=a + c * space, it can be concluded that both b and a have the same remainder when divided by space. It is first very intuitive to create a vector of size space in order to have all the remainders as indices in the vector, However, that can exceed memory limit as space can go upto 1e9.\\nHence, we use a map to store only the remainders that are obtained on dividing nums[i] by space. The map is of type <int,vector int>. The next step is to count the maximum size of the vector of a certain remainder vector and store it in a variable.\\nThen we shall return the smallest element in such a vector that has the maximum size. For that we sort whichever vector has maximum size in the map and compare the smallest elemnt each time.\\nNote that we can sort the elements at the start itself to avoid sorting afterwards whenever we find a vector of maximum size as the smallest integer will be first pushed in the vector.\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,vector<int>> m;\\n        for(auto i:nums){\\n            int r=i%space;\\n            m[r].push_back(i);\\n        }\\n       \\n        int maxm=INT_MIN;\\n        for(auto it:m){\\n            int x=it.second.size();\\n            if(x>maxm){\\n                maxm=it.second.size();\\n            }\\n        }\\n    \\n        int ans=INT_MAX;\\n        for(auto it:m){\\n            if(it.second.size()==maxm){\\n                vector<int> temp=it.second;\\n                sort(temp.begin(),temp.end());\\n                ans=min(ans,temp[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote if found helpful. Thanks.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,vector<int>> m;\\n        for(auto i:nums){\\n            int r=i%space;\\n            m[r].push_back(i);\\n        }\\n       \\n        int maxm=INT_MIN;\\n        for(auto it:m){\\n            int x=it.second.size();\\n            if(x>maxm){\\n                maxm=it.second.size();\\n            }\\n        }\\n    \\n        int ans=INT_MAX;\\n        for(auto it:m){\\n            if(it.second.size()==maxm){\\n                vector<int> temp=it.second;\\n                sort(temp.begin(),temp.end());\\n                ans=min(ans,temp[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756799,
                "title": "c-simple-code-with-explanation-hashing",
                "content": "Take two map and store the modular in first map with its frequency and after that check what is the frequency of the maximum modulo from the first map\\nusing the second map.Check the corresponding modulo with the minimum value and return the ans.\\n\\n**C++ code** :\\n\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        map<int,int>m1;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            m1[nums[i]%space]++;\\n        }\\n        \\n        \\n        \\n        int maxi{},res{};\\n        for(auto it : m1){\\n           // cout << it.first << \" \" <<it.second <<endl;\\n           maxi = max(maxi,it.second);\\n        }\\n        \\n        map<int,int>m2;\\n        for(auto it : m1){\\n            if(it.second==maxi){\\n                m2[it.first]++;\\n            }\\n        }\\n       \\n        \\n        int ans{};\\n        ans = 1e9+7;\\n        for(auto it : nums){\\n            long long int a = it%space;\\n            if(m2.find(a)!=m2.end()){\\n                ans = min(ans,it);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n\\nThank you.\\n\\t\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "Take two map and store the modular in first map with its frequency and after that check what is the frequency of the maximum modulo from the first map\\nusing the second map.Check the corresponding modulo with the minimum value and return the ans.\\n\\n**C++ code** :\\n\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        map<int,int>m1;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++){\\n            m1[nums[i]%space]++;\\n        }\\n        \\n        \\n        \\n        int maxi{},res{};\\n        for(auto it : m1){\\n           // cout << it.first << \" \" <<it.second <<endl;\\n           maxi = max(maxi,it.second);\\n        }\\n        \\n        map<int,int>m2;\\n        for(auto it : m1){\\n            if(it.second==maxi){\\n                m2[it.first]++;\\n            }\\n        }\\n       \\n        \\n        int ans{};\\n        ans = 1e9+7;\\n        for(auto it : nums){\\n            long long int a = it%space;\\n            if(m2.find(a)!=m2.end()){\\n                ans = min(ans,it);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n\\n\\nThank you.\\n\\t\\n",
                "codeTag": "C++"
            },
            {
                "id": 2756695,
                "title": "java-easy-to-understand-clean-code",
                "content": "```\\nclass Solution {\\n    \\n    // nums[i] + c * space = nums[j] ==> remainder + quotient * divisor = dividend,\\n\\t// you had to find the remainder \\n    // sort the array, so to find first minimum occurence\\n    public int destroyTargets(int[] nums, int space) {\\n        int n = nums.length;\\n        Arrays.sort( nums );\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for( int num : nums )\\n        {\\n            map.compute( num % space, ( k, v ) -> v == null ? 1 : v+1 );\\n        }\\n\\n        int max = 0;\\n        int max_count = 0;\\n\\n        for( int num : nums )\\n        {\\n            if( map.containsKey( num ) && max_count < map.get( num ) )\\n            {\\n                max = num;\\n                max_count = map.get( num );\\n            }\\n            \\n            // edge - cases.\\n            if( map.containsKey( num % space ) && max_count < map.get( num % space ) )\\n            {\\n                max = num;\\n                max_count = map.get( num % space );\\n            }\\n        }\\n\\n        return max == 0 ? nums[0] : max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // nums[i] + c * space = nums[j] ==> remainder + quotient * divisor = dividend,\\n\\t// you had to find the remainder \\n    // sort the array, so to find first minimum occurence\\n    public int destroyTargets(int[] nums, int space) {\\n        int n = nums.length;\\n        Arrays.sort( nums );\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n\\n        for( int num : nums )\\n        {\\n            map.compute( num % space, ( k, v ) -> v == null ? 1 : v+1 );\\n        }\\n\\n        int max = 0;\\n        int max_count = 0;\\n\\n        for( int num : nums )\\n        {\\n            if( map.containsKey( num ) && max_count < map.get( num ) )\\n            {\\n                max = num;\\n                max_count = map.get( num );\\n            }\\n            \\n            // edge - cases.\\n            if( map.containsKey( num % space ) && max_count < map.get( num % space ) )\\n            {\\n                max = num;\\n                max_count = map.get( num % space );\\n            }\\n        }\\n\\n        return max == 0 ? nums[0] : max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756652,
                "title": "c-a-p-o-nlogn-time-o-n-space",
                "content": "**Intuition**\\n* Notice that the term nums[i] + c * space represents a general term of an A.P(Arithmetic Progression) with first element as nums[i] and common difference as space\\n* Now, the problem just reduces to finding the first term of the longest A.P(not necessarily consecutive terms) which is present in the given input array.\\n* Since, we know that the the answer\\'s part of an A.P with common difference `space`,  we assume each element a[i] to be part of an A.P with such common difference and try to remove the largest multiple of `space` from a[i] (which is just taking modulo with `space`. Idk why I was complicating this in the contest).\\n* Now, every term a[i] has been reduced such that we can check if it belongs to an A.P starting with a[i] or not\\n* Then the length of the longest A.P is just the maximum frequency of any reduced a[i]\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& a, int space) {\\n      sort(a.begin(), a.end());\\n      vector<int> b = a;\\n      map<int, int> cnt;\\n\\t  \\n      int mx = 0;\\n      for (auto &bi: b) {\\n        bi -= bi / space * space;\\n        cnt[bi]++;\\n        mx = max(mx, cnt[bi]);\\n      }\\n\\t  \\n      int mn = 2e9;\\n      for (auto &ai: a) {\\n        int aii = ai - ai / space * space;\\n        if (cnt[aii] == mx)\\n          mn = min(mn, ai);\\n      }\\n      return mn;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& a, int space) {\\n      sort(a.begin(), a.end());\\n      vector<int> b = a;\\n      map<int, int> cnt;\\n\\t  \\n      int mx = 0;\\n      for (auto &bi: b) {\\n        bi -= bi / space * space;\\n        cnt[bi]++;\\n        mx = max(mx, cnt[bi]);\\n      }\\n\\t  \\n      int mn = 2e9;\\n      for (auto &ai: a) {\\n        int aii = ai - ai / space * space;\\n        if (cnt[aii] == mx)\\n          mn = min(mn, ai);\\n      }\\n      return mn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756555,
                "title": "short-concise-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> m;\\n        for(int i : nums) m[i % space]++;\\n        \\n        vector<pair<int, int>> v;\\n        for(auto i : m) v.push_back({i.second, i.first});\\n        \\n        sort(v.begin(), v.end(), greater<pair<int, int>>());\\n        int f = v[0].first, j = 0, ans = INT_MAX;\\n        \\n        while(j < v.size() && v[j].first == f) {\\n            int mn = INT_MAX;\\n            for(int i : nums) {\\n                if(i % space == v[j].second) mn = min(mn, i);\\n            }\\n            ans = min(ans, mn);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> m;\\n        for(int i : nums) m[i % space]++;\\n        \\n        vector<pair<int, int>> v;\\n        for(auto i : m) v.push_back({i.second, i.first});\\n        \\n        sort(v.begin(), v.end(), greater<pair<int, int>>());\\n        int f = v[0].first, j = 0, ans = INT_MAX;\\n        \\n        while(j < v.size() && v[j].first == f) {\\n            int mn = INT_MAX;\\n            for(int i : nums) {\\n                if(i % space == v[j].second) mn = min(mn, i);\\n            }\\n            ans = min(ans, mn);\\n            j++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756500,
                "title": "c-map-three-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& arr, int space,int mn = INT_MAX,int mx = -1,map<int,int>mp = {}) {\\n            for(auto ele:arr)mp[ele%space]++,mx = max(mx,mp[ele%space]);\\n            for(auto ele:arr)if(mp[ele%space] == mx)  mn = min(mn,ele);\\n            return(mn);            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& arr, int space,int mn = INT_MAX,int mx = -1,map<int,int>mp = {}) {\\n            for(auto ele:arr)mp[ele%space]++,mx = max(mx,mp[ele%space]);\\n            for(auto ele:arr)if(mp[ele%space] == mx)  mn = min(mn,ele);\\n            return(mn);            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756432,
                "title": "java-using-reminder",
                "content": "```\\nclass Solution {\\npublic int destroyTargets(int[] nums, int space) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int ans = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            map.putIfAbsent(num % space, new ArrayList<>());\\n            map.get(num % space).add(num);\\n        }\\n        int max = -1;\\n        for (int key : map.keySet()) {\\n            Collections.sort(map.get(key));\\n            max = Math.max(max, map.get(key).size());\\n        }\\n\\n        for (int key : map.keySet()) {\\n            if (map.get(key).size() == max) {\\n                ans = Math.min(ans, map.get(key).get(0));\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic int destroyTargets(int[] nums, int space) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        int ans = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            map.putIfAbsent(num % space, new ArrayList<>());\\n            map.get(num % space).add(num);\\n        }\\n        int max = -1;\\n        for (int key : map.keySet()) {\\n            Collections.sort(map.get(key));\\n            max = Math.max(max, map.get(key).size());\\n        }\\n\\n        for (int key : map.keySet()) {\\n            if (map.get(key).size() == max) {\\n                ans = Math.min(ans, map.get(key).get(0));\\n            }\\n        }\\n\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2756431,
                "title": "two-hashmaps",
                "content": "Sort the array in non decreasing order. Count the frequency of `(target MOD space)` using a hashmap. If the key is absent, map it to the target in another hashmap (This is the smallest seed value)\\n```\\nclass Solution\\n{\\n    public int destroyTargets(int[] nums, int space)\\n    {\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>(), ans = new HashMap<>();\\n        for(int i : nums)\\n        {\\n            int key = i % space;\\n            if(!map.containsKey(key))\\n                ans.put(key,i);\\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        int ret = -1;\\n        for(int i : map.keySet())\\n        {\\n            if(ret == -1)\\n                ret = i;\\n            if(map.get(ret) < map.get(i) || (map.get(ret) == map.get(i) && ans.get(ret) > ans.get(i)))\\n                ret = i;\\n        }\\n        return ans.get(ret);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int destroyTargets(int[] nums, int space)\\n    {\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>(), ans = new HashMap<>();\\n        for(int i : nums)\\n        {\\n            int key = i % space;\\n            if(!map.containsKey(key))\\n                ans.put(key,i);\\n            map.put(key, map.getOrDefault(key,0)+1);\\n        }\\n        int ret = -1;\\n        for(int i : map.keySet())\\n        {\\n            if(ret == -1)\\n                ret = i;\\n            if(map.get(ret) < map.get(i) || (map.get(ret) == map.get(i) && ans.get(ret) > ans.get(i)))\\n                ret = i;\\n        }\\n        return ans.get(ret);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4065920,
                "title": "brute-to-best-a-smooth-shift-towards-best-solution-explanation-with-full-intuition",
                "content": "# [2453. Destroy Sequential Targets](https://leetcode.com/problems/destroy-sequential-targets/description/)\\n\\n## Brute Force Approach :-\\n- So try to use every ele as seed and keep count of how many ele has been destroied with that seed and keep track of ur minimum seed which destroied maximum ele in nums[].\\n![image.png](https://assets.leetcode.com/users/images/92ad9d2e-2e4a-46ca-95d1-6aa08a00a215_1695150603.0014324.png)\\n```java\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        int n = nums.length;\\n        if(n==1) return nums[0];\\n\\n        int ans = Integer.MAX_VALUE;\\n        int td = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            int seed = nums[i];\\n            int targetDestroyed = 0;\\n            for(int j = 0; j<nums.length; j++){\\n                if((nums[j]-seed)%space == 0) targetDestroyed++;\\n            }\\n            if(targetDestroyed == td) ans = Math.min(ans,seed);\\n            else if(targetDestroyed > td){\\n                ans = seed;\\n                td = targetDestroyed;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n## Optimised Approach\\n![image.png](https://assets.leetcode.com/users/images/cc45553f-cb26-4a20-888f-ac193e92c90b_1695150638.385468.png)\\n```java\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer, Integer> hm=new HashMap<>();\\n        int mf = 0;\\n        for(int ele : nums){ \\n            hm.put(ele%space, hm.getOrDefault(ele%space,0)+1);\\n            mf = Math.max(mf, hm.get(ele%space));\\n        }\\n        \\n        int ans = (int)1e9+1;\\n        for(int ele :nums){\\n            if(hm.get(ele%space) == mf){\\n                ans = Math.min(ele,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        int n = nums.length;\\n        if(n==1) return nums[0];\\n\\n        int ans = Integer.MAX_VALUE;\\n        int td = 0;\\n        for(int i = 0; i<nums.length; i++){\\n            int seed = nums[i];\\n            int targetDestroyed = 0;\\n            for(int j = 0; j<nums.length; j++){\\n                if((nums[j]-seed)%space == 0) targetDestroyed++;\\n            }\\n            if(targetDestroyed == td) ans = Math.min(ans,seed);\\n            else if(targetDestroyed > td){\\n                ans = seed;\\n                td = targetDestroyed;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer, Integer> hm=new HashMap<>();\\n        int mf = 0;\\n        for(int ele : nums){ \\n            hm.put(ele%space, hm.getOrDefault(ele%space,0)+1);\\n            mf = Math.max(mf, hm.get(ele%space));\\n        }\\n        \\n        int ans = (int)1e9+1;\\n        for(int ele :nums){\\n            if(hm.get(ele%space) == mf){\\n                ans = Math.min(ele,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059193,
                "title": "python-beats-100-using-hashmap-and-modulos",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt all boils down to see what is the modulo of `space` that appears the most time.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each number, compute the modulo of it, and update the dictionary, then you know what is the most frequent. Then, you see which of the item with this modulo is the smaller\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        mods = {}\\n        for num in nums:\\n            mods[num%space] = mods.get(num%space, 0) + 1\\n        maxV = max(mods.values())\\n        res = float(\\'inf\\')\\n        for num in nums:\\n            if mods[num%space] == maxV:\\n                res = min(res, num)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        mods = {}\\n        for num in nums:\\n            mods[num%space] = mods.get(num%space, 0) + 1\\n        maxV = max(mods.values())\\n        res = float(\\'inf\\')\\n        for num in nums:\\n            if mods[num%space] == maxV:\\n                res = min(res, num)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010844,
                "title": "python-solution-using-modulo-in-o-n-and-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        d={}\\n        for item in nums:\\n            r=item%space\\n            if(r in d):\\n                d[r]+=1\\n            else:\\n                d[r]=1\\n        ans=nums[0]\\n        c=d[ans%space]\\n        for item in nums:\\n            if(c<d[item%space] or (c==d[item%space] and item<ans)):\\n                c=d[item%space]\\n                ans=item\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        d={}\\n        for item in nums:\\n            r=item%space\\n            if(r in d):\\n                d[r]+=1\\n            else:\\n                d[r]=1\\n        ans=nums[0]\\n        c=d[ans%space]\\n        for item in nums:\\n            if(c<d[item%space] or (c==d[item%space] and item<ans)):\\n                c=d[item%space]\\n                ans=item\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3995794,
                "title": "c-simple-solution-unordered-map-explanation-o-n",
                "content": "# EXPLANATION\\nAt first we created an unordered_map.\\nWe traverse in the given vector **nums**.\\nWe checked if the mod of that number with **space** is in map or not, then we insert in it, or if present then we update it with **increased count and min number, as a pair**.\\nSet **s=-1 and ans=INT_MAX.**\\nAfter this we traverse in the map **m**.\\nChecked if pair\\'s first is greater than **s**, if so then we update **s** and **ans**.\\nIf it is same as **s** then we update **ans** with minimum value.\\nFinally return **ans** as answer.\\n# SOLUTION\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,pair<int,int>> m;\\n        for(auto x:nums){\\n            int i=x%space;\\n            if(m.count(i)){\\n                int a=m[i].first,b=m[i].second;\\n                b=min(x,b);\\n                m[i]={++a,b};\\n            }\\n            else\\n                m[i]={1,x};\\n        }\\n        int s=-1,ans=INT_MAX;\\n        for(auto x:m){\\n            if(x.second.first==s)\\n                ans=min(ans,x.second.second);\\n            else if(x.second.first>s){\\n                s=x.second.first;\\n                ans=x.second.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,pair<int,int>> m;\\n        for(auto x:nums){\\n            int i=x%space;\\n            if(m.count(i)){\\n                int a=m[i].first,b=m[i].second;\\n                b=min(x,b);\\n                m[i]={++a,b};\\n            }\\n            else\\n                m[i]={1,x};\\n        }\\n        int s=-1,ans=INT_MAX;\\n        for(auto x:m){\\n            if(x.second.first==s)\\n                ans=min(ans,x.second.second);\\n            else if(x.second.first>s){\\n                s=x.second.first;\\n                ans=x.second.second;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985471,
                "title": "easy-based-on-remainder-intuition",
                "content": "# Intuition\\nstore the remainder of every number when divided by space.\\nThe highest number of same remainder will be our answer.\\nfor handelling the stiuations where there is more than one highest then store all those in a set.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,int>mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]%space]++;\\n        }\\n\\n        int maxi=INT_MIN;\\n        \\n        unordered_set<int>st;\\n        for(auto it:mp)\\n        {\\n            if(it.second>maxi)\\n            {\\n                maxi=it.second;\\n              \\n            }\\n        }\\n\\n        for(auto it:mp)\\n        {\\n            if(it.second==maxi)\\n            st.insert(it.first);\\n        }\\n        \\n        int ans=INT_MAX;\\n\\n        for(auto it:nums)\\n        {\\n            if(st.find(it%space)!=st.end())\\n            ans=min(ans,it);\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,int>mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mp[nums[i]%space]++;\\n        }\\n\\n        int maxi=INT_MIN;\\n        \\n        unordered_set<int>st;\\n        for(auto it:mp)\\n        {\\n            if(it.second>maxi)\\n            {\\n                maxi=it.second;\\n              \\n            }\\n        }\\n\\n        for(auto it:mp)\\n        {\\n            if(it.second==maxi)\\n            st.insert(it.first);\\n        }\\n        \\n        int ans=INT_MAX;\\n\\n        for(auto it:nums)\\n        {\\n            if(st.find(it%space)!=st.end())\\n            ans=min(ans,it);\\n        }\\n        return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3963934,
                "title": "easiest-cpp-code-best-from-rest",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //sort(nums.begin() , nums.end());\\n        unordered_map<int , int> ump;\\n        int min_val = 1e9;\\n        int max_count = 0;\\n        for(int num: nums)\\n        {\\n            ump[num%space]++;\\n            max_count = max(max_count , ump[num%space]);\\n        }\\n        for(const int num: nums)\\n        {\\n            if(ump[num%space]==max_count)\\n            {\\n                min_val = min(num , min_val);\\n            }\\n        }\\n        \\n        return min_val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //sort(nums.begin() , nums.end());\\n        unordered_map<int , int> ump;\\n        int min_val = 1e9;\\n        int max_count = 0;\\n        for(int num: nums)\\n        {\\n            ump[num%space]++;\\n            max_count = max(max_count , ump[num%space]);\\n        }\\n        for(const int num: nums)\\n        {\\n            if(ump[num%space]==max_count)\\n            {\\n                min_val = min(num , min_val);\\n            }\\n        }\\n        \\n        return min_val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3920277,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nYou can destroy all targets $x$ with seed $y$ with $x \\\\equiv y \\\\left(\\\\mod \\\\text{space}\\\\right)$ i.e. with the same modulus.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ - Two passes of the list (could be done in one pass too if needed)\\n\\n- Space complexity:\\n$$O(space)$$ - We store at most $space$ integers in the Counter\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        counts, best = Counter(), 0\\n        for x in nums:\\n            counts[x % space] += 1\\n            best = max(best, counts[x % space])\\n        return min(x for x in nums if counts[x % space] == best)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        counts, best = Counter(), 0\\n        for x in nums:\\n            counts[x % space] += 1\\n            best = max(best, counts[x % space])\\n        return min(x for x in nums if counts[x % space] == best)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892568,
                "title": "c-solution-using-sort-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,int> m;\\n        // sort nums to make sure the last number can destroy the maximunm number of target (number of % space) is minimum\\n        sort(nums.begin(), nums.end(),greater<int>());\\n        int ans;\\n        int max_count = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            m[nums[i] % space]++;\\n            if (m[nums[i] % space] >= max_count){ // as long as we have a equal or lager numbers of target with same modulo, change it to the smaller one\\n                max_count = m[nums[i] % space];\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,int> m;\\n        // sort nums to make sure the last number can destroy the maximunm number of target (number of % space) is minimum\\n        sort(nums.begin(), nums.end(),greater<int>());\\n        int ans;\\n        int max_count = 0;\\n        for(int i = 0; i < nums.size(); i++) {\\n            m[nums[i] % space]++;\\n            if (m[nums[i] % space] >= max_count){ // as long as we have a equal or lager numbers of target with same modulo, change it to the smaller one\\n                max_count = m[nums[i] % space];\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3854963,
                "title": "c-hashing-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> ourmap;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            ourmap[rem].push(nums[i]);\\n        }\\n        auto it=ourmap.begin();\\n        int maxi=-1e9;\\n        while(it!=ourmap.end()){\\n            int num=it->second.size();\\n            maxi=max(maxi,num);\\n            it++;\\n        }\\n        it=ourmap.begin();\\n        int ans=1e9;\\n        while(it!=ourmap.end()){\\n            if(it->second.size()==maxi){\\n                priority_queue<int,vector<int>,greater<int>> minheap=it->second;\\n                ans=min(ans,minheap.top());\\n            }\\n            it++;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        unordered_map<int,priority_queue<int,vector<int>,greater<int>>> ourmap;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            ourmap[rem].push(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3852046,
                "title": "kotlin-sorting-solution",
                "content": "```\\nclass Solution {\\n    fun destroyTargets(nums: IntArray, space: Int): Int {\\n        val modulo = HashMap<Int, Int>()\\n        var mod = 0\\n\\n        for (num in nums) {\\n            val m = num % space\\n            modulo.put(m, modulo.getOrDefault(m, 0) + 1)\\n        }\\n\\n        var max = modulo.values.max()!!\\n        var modList = mutableListOf<Int>()\\n\\n        for ((k, v) in modulo) {\\n            if (v == max) modList.add(k)\\n        }\\n\\n        Arrays.sort(nums)\\n        for (num in nums) {\\n            for (mod in modList) {\\n                if (num % space == mod) return num\\n            }\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun destroyTargets(nums: IntArray, space: Int): Int {\\n        val modulo = HashMap<Int, Int>()\\n        var mod = 0\\n\\n        for (num in nums) {\\n            val m = num % space\\n            modulo.put(m, modulo.getOrDefault(m, 0) + 1)\\n        }\\n\\n        var max = modulo.values.max()!!\\n        var modList = mutableListOf<Int>()\\n\\n        for ((k, v) in modulo) {\\n            if (v == max) modList.add(k)\\n        }\\n\\n        Arrays.sort(nums)\\n        for (num in nums) {\\n            for (mod in modList) {\\n                if (num % space == mod) return num\\n            }\\n        }\\n\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3843339,
                "title": "c-short-o-n-o-n-time-space",
                "content": "All numbers that can be destroyed with a seed share the common modulo. We just need to count them and keep the minimum value for them as well as the overall max count/min value.\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) \\n    {    \\n        int maxCnt{ 0 };\\n        int minVal{ 0 };\\n        unordered_map<int, pair<size_t, int>> moduloCnt;\\n\\n        for (size_t i{ 0 }; i < nums.size(); ++i)\\n        {\\n            auto& [cnt, val]{ moduloCnt[nums[i] % space] };\\n            if (!exchange(cnt, cnt + 1) || val > nums[i])\\n                val = nums[i];\\n\\n            if (maxCnt < cnt || (maxCnt == cnt && val < minVal))\\n                tie(maxCnt, minVal) = tie(cnt, val);\\n        }\\n\\n        return minVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) \\n    {    \\n        int maxCnt{ 0 };\\n        int minVal{ 0 };\\n        unordered_map<int, pair<size_t, int>> moduloCnt;\\n\\n        for (size_t i{ 0 }; i < nums.size(); ++i)\\n        {\\n            auto& [cnt, val]{ moduloCnt[nums[i] % space] };\\n            if (!exchange(cnt, cnt + 1) || val > nums[i])\\n                val = nums[i];\\n\\n            if (maxCnt < cnt || (maxCnt == cnt && val < minVal))\\n                tie(maxCnt, minVal) = tie(cnt, val);\\n        }\\n\\n        return minVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813806,
                "title": "c-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSince `num = seed + c * space`, numbers will be marked as destroied targets by the same seed if `num % space` is the same ( = seed ).\\n\\nWe will count those numbers and return the smallest one as the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nHave to build a hashmap of type `unordered_map<int, pair<int, int>>` which \\n- key is the seed (`num % space`)\\n- value is pair of `{how many number in nums has same seed, smallest number which accepts seed}`\\n\\nThen iterate through the hashmap and get the answer.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSince we iterate through the input to build hashmap, then iterate through hashmap to get the answer.\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nHashmap space.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, pair<int, int>> memo;\\n        int remainder, targets = INT_MIN;\\n        for (auto num: nums) {\\n            remainder = num % space;\\n            if (memo.find(remainder) == memo.end()) {\\n                memo[remainder] = make_pair(1, num);\\n            } else {\\n                memo[remainder] = make_pair(memo[remainder].first+1, min(memo[remainder].second, num));\\n            }\\n            targets = max(targets, memo[remainder].first);\\n        }\\n\\n        int ans = INT_MAX;\\n        for (auto [k, v]: memo) {\\n            if (v.first == targets) {\\n                ans = min(ans, v.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, pair<int, int>> memo;\\n        int remainder, targets = INT_MIN;\\n        for (auto num: nums) {\\n            remainder = num % space;\\n            if (memo.find(remainder) == memo.end()) {\\n                memo[remainder] = make_pair(1, num);\\n            } else {\\n                memo[remainder] = make_pair(memo[remainder].first+1, min(memo[remainder].second, num));\\n            }\\n            targets = max(targets, memo[remainder].first);\\n        }\\n\\n        int ans = INT_MAX;\\n        for (auto [k, v]: memo) {\\n            if (v.first == targets) {\\n                ans = min(ans, v.second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3796828,
                "title": "c-solution-using-hashmap-and-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCan approach the problem statement with a Mathematical equation and then try to hash the maxiumum frequency of the desired answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf any number x is representable in the form => y + factor*space \\nThen, (x - y)/space; so (x - y)%space == 0, so (x % space == y).\\n\\nFor each nums[i]; store (nums[i]%space) in a hashmap and then find the maximum frequency count amongst all hashed values. Now find the smallest nums[i] by traversing through the array; that has the count of (nums[i]%space) == Maximum Frequency of all possible (nums[i]%space).\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        // if any number x is representable in the form => y + factor*space\\n        //  (x - y)/space; so (x - y)%space == 0, so (x % space == y)\\n        map<int, int> mp;\\n        int mx_cnt = INT_MIN, rem;\\n        for(int i = 0; i < n; i++){\\n            mp[nums[i]%space]++;\\n            if(mx_cnt < mp[nums[i]%space]){\\n                mx_cnt = max(mx_cnt, mp[nums[i]%space]);\\n                rem = nums[i]%space;\\n            }\\n        }\\n        //cout<<mx_cnt<<\" \"<<rem<<endl;\\n        int ans = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            if(mp[nums[i]%space] == mx_cnt){\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        // if any number x is representable in the form => y + factor*space\\n        //  (x - y)/space; so (x - y)%space == 0, so (x % space == y)\\n        map<int, int> mp;\\n        int mx_cnt = INT_MIN, rem;\\n        for(int i = 0; i < n; i++){\\n            mp[nums[i]%space]++;\\n            if(mx_cnt < mp[nums[i]%space]){\\n                mx_cnt = max(mx_cnt, mp[nums[i]%space]);\\n                rem = nums[i]%space;\\n            }\\n        }\\n        //cout<<mx_cnt<<\" \"<<rem<<endl;\\n        int ans = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            if(mp[nums[i]%space] == mx_cnt){\\n                ans = nums[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3795602,
                "title": "destroy-sequential-targets-with-comments-easy-approach-simple-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) \\n    {\\n        int ans = INT_MAX;\\n        int mx = INT_MIN;\\n        unordered_map<int, int> mp;\\n\\n        for(auto n: nums)\\n        {\\n            int r = n % space;                  //evaluate reminder\\n            mp[r]++;                               // add reminder to map\\n            if(mx < mp[r])\\n            {\\n                 mx = mp[r];\\n            }   //keep track of the max count, with same reminder\\n        }\\n        for(auto n: nums)\\n        {  //scan smalest element with same riminder as of mx\\n            if(mx == mp[n%space])\\n            {\\n                 ans = min(ans, n);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) \\n    {\\n        int ans = INT_MAX;\\n        int mx = INT_MIN;\\n        unordered_map<int, int> mp;\\n\\n        for(auto n: nums)\\n        {\\n            int r = n % space;                  //evaluate reminder\\n            mp[r]++;                               // add reminder to map\\n            if(mx < mp[r])\\n            {\\n                 mx = mp[r];\\n            }   //keep track of the max count, with same reminder\\n        }\\n        for(auto n: nums)\\n        {  //scan smalest element with same riminder as of mx\\n            if(mx == mp[n%space])\\n            {\\n                 ans = min(ans, n);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3776887,
                "title": "javascript-easy-understaning-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} space\\n * @return {number}\\n */\\nvar destroyTargets = function(nums, space) {\\n    nums.sort((a, b) => a - b);\\n    let m = new Map(), res = 0, cnt = 0;\\n    for (let i = 0; i < nums.length; i++){\\n        if (m.get(nums[i] % space))\\n            m.set(nums[i] % space, m.get(nums[i] % space) + 1);\\n        else \\n            m.set(nums[i] % space, 1);\\n        if (cnt < m.get(nums[i] % space)){\\n            cnt = m.get(nums[i] % space);\\n        }        \\n    }\\n\\n    for (let i = 0; i < nums.length; i++){\\n        if (m.get(nums[i] % space) === cnt){\\n            res = nums[i];\\n            break;\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} space\\n * @return {number}\\n */\\nvar destroyTargets = function(nums, space) {\\n    nums.sort((a, b) => a - b);\\n    let m = new Map(), res = 0, cnt = 0;\\n    for (let i = 0; i < nums.length; i++){\\n        if (m.get(nums[i] % space))\\n            m.set(nums[i] % space, m.get(nums[i] % space) + 1);\\n        else \\n            m.set(nums[i] % space, 1);\\n        if (cnt < m.get(nums[i] % space)){\\n            cnt = m.get(nums[i] % space);\\n        }        \\n    }\\n\\n    for (let i = 0; i < nums.length; i++){\\n        if (m.get(nums[i] % space) === cnt){\\n            res = nums[i];\\n            break;\\n        }\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3771167,
                "title": "python-o-n-hashmap",
                "content": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dic = defaultdict(list)\\n        for i,v in enumerate(nums):\\n            dic[v%space].append(v)\\n        mx = 0\\n        for i in dic:\\n            mx = max(mx,len(dic[i]))\\n        res = float(\"inf\")\\n        \\n        for k,v in dic.items():\\n            if len(v) == mx:\\n                for j in v:\\n                    res = min(res,j)\\n        return res\\n\\t\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dic = defaultdict(list)\\n        for i,v in enumerate(nums):\\n            dic[v%space].append(v)\\n        mx = 0\\n        for i in dic:\\n            mx = max(mx,len(dic[i]))\\n        res = float(\"inf\")\\n        \\n        for k,v in dic.items():\\n            if len(v) == mx:\\n                for j in v:\\n                    res = min(res,j)\\n        return res\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 3770489,
                "title": "3-line-python3-solution-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        freq = Counter(x%space for x in nums)\\n        mfreq = max(freq.values())\\n        return min([x for x in nums if freq[x%space] == mfreq])\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        freq = Counter(x%space for x in nums)\\n        mfreq = max(freq.values())\\n        return min([x for x in nums if freq[x%space] == mfreq])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770488,
                "title": "3-line-python3-solution-counter",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        freq = Counter(x%space for x in nums)\\n        mfreq = max(freq.values())\\n        return min([x for x in nums if freq[x%space] == mfreq])\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        freq = Counter(x%space for x in nums)\\n        mfreq = max(freq.values())\\n        return min([x for x in nums if freq[x%space] == mfreq])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766518,
                "title": "simple-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int, pair<int, int> > mp;\\n        for( int i = 0; i<nums.size(); i++ ) {\\n            int r = nums[i]%space;\\n            if( mp.find(r) == mp.end() ) {\\n                mp[r] = { nums[i], 1 };\\n            }\\n            else {\\n                mp[r].second++;\\n                if( mp[r].first > nums[i] )\\n                    mp[r].first = nums[i];\\n            }\\n        }\\n        int res, cnt = 0;\\n        for( auto it : mp ) {\\n            int c = it.second.second, t = it.second.first;\\n            if( c > cnt ) {\\n                res = t;\\n                cnt = c;\\n            }\\n            if( c == cnt and res > t ) \\n                res = t;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int, pair<int, int> > mp;\\n        for( int i = 0; i<nums.size(); i++ ) {\\n            int r = nums[i]%space;\\n            if( mp.find(r) == mp.end() ) {\\n                mp[r] = { nums[i], 1 };\\n            }\\n            else {\\n                mp[r].second++;\\n                if( mp[r].first > nums[i] )\\n                    mp[r].first = nums[i];\\n            }\\n        }\\n        int res, cnt = 0;\\n        for( auto it : mp ) {\\n            int c = it.second.second, t = it.second.first;\\n            if( c > cnt ) {\\n                res = t;\\n                cnt = c;\\n            }\\n            if( c == cnt and res > t ) \\n                res = t;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766468,
                "title": "using-modulo-single-pass-very-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor example if  you are destryoing j th index and you started from i th index then nums[j] = nums[i] + c * space which can also be written as nums[j]-nums[i] = c * space ,\\nthis means the difference nums[j]-nums[i] will be divisible by space i.e, nums[j]-nums[i] % space = 0 ,\\nnow this can only happen if both nums[i] and nums[j] give same remainder upon division with space i.e, **nums[i]% space == nums[j] % space**\\n\\nfrom here you can conclude that elements with same remainder will be destroyed together so we just need to find the max occuring remainder for the array and smallest value that gives the same remainder.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse map to store frequency of remainder and smallest value which gives that remainder.\\n\\n![map.jpeg](https://assets.leetcode.com/users/images/93b067a0-9931-40ee-986c-4ff2cd0460c8_1689386094.0612724.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(N) for map\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int maxi=1,ans=nums[0];\\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i]%space)!=mp.end()){\\n                mp[nums[i]%space].first++;\\n\\n                if(mp[nums[i]%space].second>nums[i]) //if element smaller found for that frequency ,then update\\n                    mp[nums[i]%space].second=nums[i];\\n            }\\n            else{\\n                mp[nums[i]%space].first=1;\\n                mp[nums[i]%space].second=nums[i];\\n            }\\n\\n            int count=mp[nums[i]%space].first;\\n            int num=mp[nums[i]%space].second;\\n\\n            if(count>maxi){ // updating for maximum frequency remainder\\n                maxi=count;\\n                ans=num;\\n            }\\n            else if(count==maxi){ //updating for equal frequency remainder but minimum nums[i]\\n                ans=min(num,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Math",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int maxi=1,ans=nums[0];\\n        unordered_map<int,pair<int,int>>mp;\\n\\n        for(int i=0;i<nums.size();i++){\\n            if(mp.find(nums[i]%space)!=mp.end()){\\n                mp[nums[i]%space].first++;\\n\\n                if(mp[nums[i]%space].second>nums[i]) //if element smaller found for that frequency ,then update\\n                    mp[nums[i]%space].second=nums[i];\\n            }\\n            else{\\n                mp[nums[i]%space].first=1;\\n                mp[nums[i]%space].second=nums[i];\\n            }\\n\\n            int count=mp[nums[i]%space].first;\\n            int num=mp[nums[i]%space].second;\\n\\n            if(count>maxi){ // updating for maximum frequency remainder\\n                maxi=count;\\n                ans=num;\\n            }\\n            else if(count==maxi){ //updating for equal frequency remainder but minimum nums[i]\\n                ans=min(num,ans);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764906,
                "title": "linear-dp",
                "content": "# Intuition\\n\\n1. Hash numbers: take `num MOD space` to split numbers in list to groups\\n2. Choose groups with maximum count of numbers\\n3. Choose group with minimum number in it\\n\\n# Approach\\nLinear DP.\\n\\n# Complexity\\n- Time complexity: O(nums.length)\\n\\n- Space complexity: O(nums.length)\\n\\n# Code\\n```go\\nfunc destroyTargets(nums []int, space int) int {\\n    dp := map[int]struct{min int; max int}{}\\n    min := math.MaxInt;\\n    max := 0;\\n    for _,num := range nums {\\n        pos := num % space \\n        group := dp[pos]\\n        if group.max == 0 || num < group.min {\\n            // minimize num within group\\n            group.min = num\\n        }\\n        group.max ++\\n        dp[pos] = group\\n        if group.max > max || (group.max == max && group.min < min)  {\\n            // select record with higher count, lower number\\n            min = group.min\\n            max = group.max\\n        }\\n    }\\n    return min\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc destroyTargets(nums []int, space int) int {\\n    dp := map[int]struct{min int; max int}{}\\n    min := math.MaxInt;\\n    max := 0;\\n    for _,num := range nums {\\n        pos := num % space \\n        group := dp[pos]\\n        if group.max == 0 || num < group.min {\\n            // minimize num within group\\n            group.min = num\\n        }\\n        group.max ++\\n        dp[pos] = group\\n        if group.max > max || (group.max == max && group.min < min)  {\\n            // select record with higher count, lower number\\n            min = group.min\\n            max = group.max\\n        }\\n    }\\n    return min\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3764436,
                "title": "simple-java-solution-in-o-n",
                "content": "Trick here is to take $$num[i]$$% $$space$$ for every integer and keep count of that value.\\nEx: space =4;\\nThe num[i]%space could be possibly \\n0\\n1\\n2\\n3;\\nGet the maximum number of elements among these 4.\\nAmong Them get the least element .\\nTHat\\'s it--__/\\\\__ thank YYOOUU.  . .;)\\nO(N) solutionn..\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer,Integer> d= new HashMap<>();\\n        int max=0;\\n        for(int i:nums){\\n            d.put(i%space,d.getOrDefault(i%space,0)+1);\\n            if(d.get(i%space)>=max){\\n                max =d.get(i%space);\\n            }\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int i:nums){\\n            if(d.get(i%space)==max)\\n            ans = Math.min(ans,i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer,Integer> d= new HashMap<>();\\n        int max=0;\\n        for(int i:nums){\\n            d.put(i%space,d.getOrDefault(i%space,0)+1);\\n            if(d.get(i%space)>=max){\\n                max =d.get(i%space);\\n            }\\n        }\\n        int ans=Integer.MAX_VALUE;\\n        for(int i:nums){\\n            if(d.get(i%space)==max)\\n            ans = Math.min(ans,i);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3763540,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) \\n    {\\n        int ct,ans;\\n        ct=INT_MIN;\\n\\n        unordered_map<int,pair<int,int>> mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int k=nums[i]%space;\\n\\n            if(mp.find(k)==mp.end())\\n            {\\n                mp[k].second=nums[i];\\n            }\\n\\n            else if(nums[i]<mp[k].second)\\n            {\\n                mp[k].second=nums[i];\\n            }    \\n\\n            mp[k].first++;\\n\\n            if(mp[k].first>ct)\\n            {\\n                ct=mp[k].first;\\n                ans=mp[k].second;\\n            }\\n\\n            else if(mp[k].first==ct && mp[k].second<ans)\\n            {\\n                ans=mp[k].second;\\n            }\\n        }        \\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) \\n    {\\n        int ct,ans;\\n        ct=INT_MIN;\\n\\n        unordered_map<int,pair<int,int>> mp;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int k=nums[i]%space;\\n\\n            if(mp.find(k)==mp.end())\\n            {\\n                mp[k].second=nums[i];\\n            }\\n\\n            else if(nums[i]<mp[k].second)\\n            {\\n                mp[k].second=nums[i];\\n            }    \\n\\n            mp[k].first++;\\n\\n            if(mp[k].first>ct)\\n            {\\n                ct=mp[k].first;\\n                ans=mp[k].second;\\n            }\\n\\n            else if(mp[k].first==ct && mp[k].second<ans)\\n            {\\n                ans=mp[k].second;\\n            }\\n        }        \\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762790,
                "title": "1-line-scala-solution",
                "content": "\\n# Code\\n```\\nobject Solution {\\n  def destroyTargets(nums: Array[Int], space: Int): Int = {\\n    nums.groupMapReduce(_ % space)((-1, _)) { case ((a, x), (b, y)) => (a + b, x min y)}.values.min._2\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def destroyTargets(nums: Array[Int], space: Int): Int = {\\n    nums.groupMapReduce(_ % space)((-1, _)) { case ((a, x), (b, y)) => (a + b, x min y)}.values.min._2\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3762412,
                "title": "100-memory-efficient-clean-simple-code",
                "content": "# Intuition\\nSorted the arr, then iterated from back to store the sum of all ele in nums which are (c*space) distance apart from nums[i]\\n\\nThen, put the sum in nums[i], and also updated the map with (remainder, i), recent index at which remainder was found.\\n\\n\\n# Complexity\\n- Time complexity: $$O(nlog(n))$$\\n\\n- Space complexity:$$O(space)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums) ; \\n        int ans = nums[0] ;\\n        int max = -1 ;\\n        HashMap<Integer, Integer> map = new HashMap<>() ; \\n        for(int i=nums.length-1; i>=0 ; i--){\\n            int r1 = nums[i]%space ; \\n            int idx = map.getOrDefault(r1, -1) ; \\n            map.put(r1,i) ;\\n            int num = nums[i] ; \\n            if(idx==-1) nums[i] = 1 ; \\n            else nums[i] = 1+nums[idx] ; \\n                \\n            \\n            if(nums[i]>= max) {\\n                max = nums[i] ; \\n                ans = num ; \\n            }\\n\\n\\n        }\\n        return ans ; \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums) ; \\n        int ans = nums[0] ;\\n        int max = -1 ;\\n        HashMap<Integer, Integer> map = new HashMap<>() ; \\n        for(int i=nums.length-1; i>=0 ; i--){\\n            int r1 = nums[i]%space ; \\n            int idx = map.getOrDefault(r1, -1) ; \\n            map.put(r1,i) ;\\n            int num = nums[i] ; \\n            if(idx==-1) nums[i] = 1 ; \\n            else nums[i] = 1+nums[idx] ; \\n                \\n            \\n            if(nums[i]>= max) {\\n                max = nums[i] ; \\n                ans = num ; \\n            }\\n\\n\\n        }\\n        return ans ; \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3761970,
                "title": "python-simple-and-concise-solution-day-76",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n\\n        prefix = {}\\n        maxVal = 0\\n        res = 0\\n        nums.sort(reverse=True)\\n        for num in nums:\\n            cur = num % space\\n            prefix[cur] = 1 + prefix.get(cur, 0)\\n            if prefix[cur] >= maxVal:\\n                res = num\\n                maxVal = prefix[cur]\\n        return res\\n```\\n$$PLEASE UPVOTE$$\\n**$$THANK YOU$$**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n\\n        prefix = {}\\n        maxVal = 0\\n        res = 0\\n        nums.sort(reverse=True)\\n        for num in nums:\\n            cur = num % space\\n            prefix[cur] = 1 + prefix.get(cur, 0)\\n            if prefix[cur] >= maxVal:\\n                res = num\\n                maxVal = prefix[cur]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3750809,
                "title": "golang-hash-table-solution",
                "content": "# Code\\n```go\\nfunc destroyTargets(nums []int, space int) int {\\n\\tsort.Ints(nums)\\n\\tdestroyCounter := make(map[int]int)\\n\\tpositions:= make(map[int]int)\\n\\tmaxTargets, minPostion := 0, math.MaxInt64\\n\\tfor _, num := range nums {\\n\\t\\tdestroyCounter[num%space]++\\n\\t\\tif v, exists := positions[num%space]; exists == false {\\n\\t\\t\\tpositions[num%space] = num\\n\\t\\t} else if num < v {\\n            positions[num%space] = num\\n\\t\\t}\\n\\t\\tif destroyCounter[num%space] > maxTargets {\\n\\t\\t\\tmaxTargets = destroyCounter[num%space]\\n\\t\\t\\tminPostion = positions[num%space]\\n\\t\\t} else if destroyCounter[num%space] == maxTargets && positions[num%space] < minPostion {\\n\\t\\t\\tminPostion = positions[num%space]\\n\\t\\t}\\n\\t}\\n\\treturn minPostion\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table"
                ],
                "code": "```go\\nfunc destroyTargets(nums []int, space int) int {\\n\\tsort.Ints(nums)\\n\\tdestroyCounter := make(map[int]int)\\n\\tpositions:= make(map[int]int)\\n\\tmaxTargets, minPostion := 0, math.MaxInt64\\n\\tfor _, num := range nums {\\n\\t\\tdestroyCounter[num%space]++\\n\\t\\tif v, exists := positions[num%space]; exists == false {\\n\\t\\t\\tpositions[num%space] = num\\n\\t\\t} else if num < v {\\n            positions[num%space] = num\\n\\t\\t}\\n\\t\\tif destroyCounter[num%space] > maxTargets {\\n\\t\\t\\tmaxTargets = destroyCounter[num%space]\\n\\t\\t\\tminPostion = positions[num%space]\\n\\t\\t} else if destroyCounter[num%space] == maxTargets && positions[num%space] < minPostion {\\n\\t\\t\\tminPostion = positions[num%space]\\n\\t\\t}\\n\\t}\\n\\treturn minPostion\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3747024,
                "title": "python-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        buckets = defaultdict(lambda: [0, float(\\'-inf\\')])\\n        for num in nums:\\n            bucket = buckets[num % space]\\n            bucket[0] += 1\\n            bucket[1] = max(-num, bucket[1])\\n        return -max(buckets.values())[1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        buckets = defaultdict(lambda: [0, float(\\'-inf\\')])\\n        for num in nums:\\n            bucket = buckets[num % space]\\n            bucket[0] += 1\\n            bucket[1] = max(-num, bucket[1])\\n        return -max(buckets.values())[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684902,
                "title": "sorting-one-pass-use-modulus-operator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n\\n        sort(nums.begin(),nums.end());\\n        int n= nums.size();\\n        unordered_map<int,int>freq;\\n        int val=INT_MAX;\\n        int noTargets=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int x = nums[i]%space;\\n            freq[x]++;\\n            if(freq[x]>=noTargets)\\n            {\\n                noTargets= freq[x];\\n                val=nums[i];\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n\\n        sort(nums.begin(),nums.end());\\n        int n= nums.size();\\n        unordered_map<int,int>freq;\\n        int val=INT_MAX;\\n        int noTargets=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            int x = nums[i]%space;\\n            freq[x]++;\\n            if(freq[x]>=noTargets)\\n            {\\n                noTargets= freq[x];\\n                val=nums[i];\\n            }\\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683032,
                "title": "destroy-sequential-targets-c-explained-solution",
                "content": "**Do Upvote If Found Helpful !!!**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe problem here is quite simple and needs some simple observation from **number theory**. Lets say we have a number of the form : **K + c * space**. If we take modulus of this number with **space**, its basically equal to **K % space**. Thus the numbers which give same remainder when divided by **space** can be only destroyed by implanting gun at the least position. Thus we only have to count the frequency of the remainders and then we have to choose the one with least position having maximum frequency. Now a close observation can be seen that you cannot use an array for storing frequency of remainders as **space can go upto 10^9**. Thus we can use a map for this purpose. As even if we get all distinct remainders, then too we can have atmax **10^5** distinct remainders (constraint of the nums array). Rest implementation goes below :\\n\\n# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        ios_base::sync_with_stdio(0);\\n        map<int,pair<int,int>>mp;\\n        for(auto it : nums){\\n            if(mp.find(it % space) == mp.end()){\\n                mp[it % space] = {1,it};\\n            }\\n            else{\\n                mp[it % space].first++;\\n                mp[it % space].second = min(mp[it % space].second,it);\\n            }\\n        }\\n        int maxfreq = 0,place = INT_MAX;\\n        for(auto it : mp){\\n            if(it.second.first >= maxfreq){\\n                if(it.second.first == maxfreq){\\n                    place = min(place,it.second.second);\\n                }\\n                else{\\n                    place = it.second.second;\\n                }\\n                maxfreq = it.second.first;\\n            }\\n        }\\n        return place;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Number Theory"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        ios_base::sync_with_stdio(0);\\n        map<int,pair<int,int>>mp;\\n        for(auto it : nums){\\n            if(mp.find(it % space) == mp.end()){\\n                mp[it % space] = {1,it};\\n            }\\n            else{\\n                mp[it % space].first++;\\n                mp[it % space].second = min(mp[it % space].second,it);\\n            }\\n        }\\n        int maxfreq = 0,place = INT_MAX;\\n        for(auto it : mp){\\n            if(it.second.first >= maxfreq){\\n                if(it.second.first == maxfreq){\\n                    place = min(place,it.second.second);\\n                }\\n                else{\\n                    place = it.second.second;\\n                }\\n                maxfreq = it.second.first;\\n            }\\n        }\\n        return place;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3674828,
                "title": "simple-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        c=Counter( [x%space for x in nums])\\n        maxV=0\\n        for (k,v) in c.items():\\n            maxV=max(maxV,v)\\n        temp=inf \\n        for i,v in enumerate(nums):\\n            if c[v%space]==maxV:\\n                temp=min(temp,v)\\n        return temp\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        c=Counter( [x%space for x in nums])\\n        maxV=0\\n        for (k,v) in c.items():\\n            maxV=max(maxV,v)\\n        temp=inf \\n        for i,v in enumerate(nums):\\n            if c[v%space]==maxV:\\n                temp=min(temp,v)\\n        return temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3673369,
                "title": "rust-hashmap-solution",
                "content": "# Intuition\\nCount occurences of ***nums[i] % space*** elements, pick one ***nums[i]*** which  is lowest among nums belonging to largest set\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn destroy_targets(mut nums: Vec<i32>, space: i32) -> i32 {\\n        use std::collections::HashMap;\\n        let mut max = i32::MIN;\\n        let mut hm = HashMap::new();\\n        for i in 0..nums.len() {\\n            let k = nums[i] % space;\\n            *hm.entry(k).or_insert(0) += 1;\\n            if hm[&k] > max {\\n                max = hm[&k];\\n            }\\n        }\\n        let mut ans = i32::MAX;\\n        for i in 0..nums.len() {\\n            let k = nums[i] % space;\\n            if hm[&k] == max && ans > nums[i] {\\n                ans = nums[i];\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn destroy_targets(mut nums: Vec<i32>, space: i32) -> i32 {\\n        use std::collections::HashMap;\\n        let mut max = i32::MIN;\\n        let mut hm = HashMap::new();\\n        for i in 0..nums.len() {\\n            let k = nums[i] % space;\\n            *hm.entry(k).or_insert(0) += 1;\\n            if hm[&k] > max {\\n                max = hm[&k];\\n            }\\n        }\\n        let mut ans = i32::MAX;\\n        for i in 0..nums.len() {\\n            let k = nums[i] % space;\\n            if hm[&k] == max && ans > nums[i] {\\n                ans = nums[i];\\n            }\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3672693,
                "title": "simple-linear-solution-o-n-c",
                "content": "# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = 0,mxl = 0;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> m;\\n        for(int i: nums) m[i%space]++;\\n        for(int i: nums){\\n            if(m[i%space] > mxl){\\n                mxl = m[i%space];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = 0,mxl = 0;\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int> m;\\n        for(int i: nums) m[i%space]++;\\n        for(int i: nums){\\n            if(m[i%space] > mxl){\\n                mxl = m[i%space];\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672661,
                "title": "c-made-simple-single-loop-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int DestroyTargets(int[] nums, int space) {\\n        \\n        int highest = 0;\\n        int index = Int32.MaxValue;\\n\\n        var dict = new Dictionary<int, int>();\\n        var min = new Dictionary<int, int>();\\n\\n        for (int idx = 0; idx < nums.Length; idx++){\\n\\n            int val = nums[idx] % space;\\n\\n            dict[val] = (dict.ContainsKey(val) ? dict[val] + 1 : 2);\\n            min[val] = (min.ContainsKey(val) ? Math.Min(min[val], nums[idx]) : nums[idx]);\\n\\n            if (dict[val] > highest){\\n                highest = dict[val];\\n                index = val;\\n            }else if(dict[val] == highest){\\n                if (min[index] > min[val]){\\n                    index = val;\\n                }\\n            }\\n        }\\n\\n        return (index != Int32.MaxValue) ? min[index] : nums.Min();\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int DestroyTargets(int[] nums, int space) {\\n        \\n        int highest = 0;\\n        int index = Int32.MaxValue;\\n\\n        var dict = new Dictionary<int, int>();\\n        var min = new Dictionary<int, int>();\\n\\n        for (int idx = 0; idx < nums.Length; idx++){\\n\\n            int val = nums[idx] % space;\\n\\n            dict[val] = (dict.ContainsKey(val) ? dict[val] + 1 : 2);\\n            min[val] = (min.ContainsKey(val) ? Math.Min(min[val], nums[idx]) : nums[idx]);\\n\\n            if (dict[val] > highest){\\n                highest = dict[val];\\n                index = val;\\n            }else if(dict[val] == highest){\\n                if (min[index] > min[val]){\\n                    index = val;\\n                }\\n            }\\n        }\\n\\n        return (index != Int32.MaxValue) ? min[index] : nums.Min();\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3672594,
                "title": "java-easy-o-n-time",
                "content": "# Complexity\\n- Time complexity : O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer,Integer> map =new HashMap(); //remainder vs freq map\\n        for(int num:nums){\\n            int rem=num%space;\\n            map.put(rem,map.getOrDefault(rem,0)+1);\\n        }\\n\\n        //finding remainder whose frequency is max\\n        int maxFreq=0;\\n        HashSet<Integer> set = new HashSet();  //set to store values of reminders whose frequncy is max\\n        for(int rem:map.keySet()){\\n            int freq=map.get(rem);\\n            if(freq>maxFreq){\\n                maxFreq=freq;\\n                set = new HashSet();\\n                set.add(rem);\\n            }\\n            if(freq==maxFreq){\\n                set.add(rem);\\n            }\\n        }\\n\\n        //finding minValue having highest freq count\\n        int minValue=Integer.MAX_VALUE;\\n        for(int num:nums){\\n            int rem=num%space;\\n            if(set.contains(rem)){\\n                minValue=Math.min(num,minValue);\\n            }\\n        }\\n        return minValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer,Integer> map =new HashMap(); //remainder vs freq map\\n        for(int num:nums){\\n            int rem=num%space;\\n            map.put(rem,map.getOrDefault(rem,0)+1);\\n        }\\n\\n        //finding remainder whose frequency is max\\n        int maxFreq=0;\\n        HashSet<Integer> set = new HashSet();  //set to store values of reminders whose frequncy is max\\n        for(int rem:map.keySet()){\\n            int freq=map.get(rem);\\n            if(freq>maxFreq){\\n                maxFreq=freq;\\n                set = new HashSet();\\n                set.add(rem);\\n            }\\n            if(freq==maxFreq){\\n                set.add(rem);\\n            }\\n        }\\n\\n        //finding minValue having highest freq count\\n        int minValue=Integer.MAX_VALUE;\\n        for(int num:nums){\\n            int rem=num%space;\\n            if(set.contains(rem)){\\n                minValue=Math.min(num,minValue);\\n            }\\n        }\\n        return minValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671852,
                "title": "c-good-soln-upvote-if-it-helps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]%space]++;\\n\\n        }\\n        int temp=INT_MIN;\\n        int ans=-1;\\n        for(auto it=m.begin();it!=m.end();it++){\\n            if(it->second>temp){\\n                temp=it->second;\\n                ans=it->first;\\n            }\\n           \\n    }\\n    int ff;\\n    for(int i=0;i<nums.size();i++){\\n        if(m[nums[i]%space]==temp){\\n            ff=nums[i];\\n            break;\\n        }\\n    }\\n    return ff;\\n\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(),nums.end());\\n        unordered_map<int,int>m;\\n        for(int i=0;i<nums.size();i++){\\n            m[nums[i]%space]++;\\n\\n        }\\n        int temp=INT_MIN;\\n        int ans=-1;\\n        for(auto it=m.begin();it!=m.end();it++){\\n            if(it->second>temp){\\n                temp=it->second;\\n                ans=it->first;\\n            }\\n           \\n    }\\n    int ff;\\n    for(int i=0;i<nums.size();i++){\\n        if(m[nums[i]%space]==temp){\\n            ff=nums[i];\\n            break;\\n        }\\n    }\\n    return ff;\\n\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3671544,
                "title": "dictionary-to-track-space-mod-time-o-n-space-o-space",
                "content": "class Solution(object):\\n    def destroyTargets(self, nums, space):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type space: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        res = float(\"inf\")\\n        count = 0\\n        \\n        rem_dict = {}\\n        \\n        for n in nums:\\n            q = n%space\\n            if q not in rem_dict:\\n                rem_dict[q] = [1, n]\\n            else:\\n                rem_dict[q][0] += 1\\n                rem_dict[q][1] = min(rem_dict[q][1], n)\\n                \\n            if rem_dict[q][0] > count:\\n                count = rem_dict[q][0]\\n                res = rem_dict[q][1]\\n            elif rem_dict[q][0] == count:\\n                res = min(res, rem_dict[q][1])\\n        \\n        #print rem_dict\\n        #print res\\n        return res\\n                \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def destroyTargets(self, nums, space):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type space: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        res = float(\"inf\")\\n        count = 0\\n        \\n        rem_dict = {}",
                "codeTag": "Java"
            },
            {
                "id": 3634879,
                "title": "100-faster-hashing-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each `nums[i]`, we have to find the (count) number of `nums[j]`s\\nsuch that `nums[j] = nums[i] + c * space` and that `nums[i]` which gives the maximum count is the answer.\\n\\n`nums[j] = c*space + nums[i]` ==> `nums[i]` is the remainder when `nums[j]` is divided with `space`\\n\\nAs we know, \"larger the no.of `nums[j]`, larger will be the count of `nums[i]`\" we can say its equaivalent to larger the no.of times `nums[i]` appeared as a remainder when some element is divided with space. \\n\\nEg : [1,3,2,4,8], space = 2 --> 1 will be appeared as a remainder for 2 elements and 0 will be appeared as remainder for 3 elements. So while storing the remainders, even we get 0 remainder for 2,4,8 we have to store 2 only not 4 and 8 as 2 will be the minimum and have to be returned.\\n\\nWe should not return 0 rather we have to return 2. So we have to maintain one more HashMap to maintain remainders with its dividends (nums[i]) . So that when we get 0 as a remiander, this map.get(0) should give nums[i] and we return nums[i].\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each element in nums, find the remainder w.r.t space and increase the count of that remainder in `remainder_count` map. which ever key will have higher value will be the remainder with higher count.\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Map<Integer,Integer> remainder_count = new HashMap<>();\\n        for(int i : nums) remainder_count.put(i%space,0);\\n        for(int i : nums){\\n            int rem = i%space;\\n            remainder_count.put(rem,remainder_count.get(rem)+1);   \\n        }\\n        Map<Integer,Integer> getNumFromRem = new HashMap<>();\\n        for(int i : nums){\\n            int rem = i%space;\\n            if(getNumFromRem.containsKey(rem)){\\n                getNumFromRem.put(rem,Math.min(getNumFromRem.get(rem),i));\\n            }else{\\n                getNumFromRem.put(rem,i);\\n            }\\n        }\\n        \\n        int max = remainder_count.values().stream().mapToInt(Integer::intValue).max().orElse(0);\\n        int ans = -1;\\n        for(int i : remainder_count.keySet()){\\n            int rem = i%space;\\n            if(max==remainder_count.get(rem)){\\n                if(ans==-1) ans = getNumFromRem.get(rem);\\n                else if(ans>getNumFromRem.get(rem)) ans=getNumFromRem.get(rem);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Map<Integer,Integer> remainder_count = new HashMap<>();\\n        for(int i : nums) remainder_count.put(i%space,0);\\n        for(int i : nums){\\n            int rem = i%space;\\n            remainder_count.put(rem,remainder_count.get(rem)+1);   \\n        }\\n        Map<Integer,Integer> getNumFromRem = new HashMap<>();\\n        for(int i : nums){\\n            int rem = i%space;\\n            if(getNumFromRem.containsKey(rem)){\\n                getNumFromRem.put(rem,Math.min(getNumFromRem.get(rem),i));\\n            }else{\\n                getNumFromRem.put(rem,i);\\n            }\\n        }\\n        \\n        int max = remainder_count.values().stream().mapToInt(Integer::intValue).max().orElse(0);\\n        int ans = -1;\\n        for(int i : remainder_count.keySet()){\\n            int rem = i%space;\\n            if(max==remainder_count.get(rem)){\\n                if(ans==-1) ans = getNumFromRem.get(rem);\\n                else if(ans>getNumFromRem.get(rem)) ans=getNumFromRem.get(rem);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611830,
                "title": "c-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        unordered_map<int, int>map; \\n        int ans = INT_MAX;\\n        int mf= 0;\\n        for(int i=0;i<nums.size();i++)\\n            {\\n                int r = nums[i]%space;\\n                map[r]++;\\n                mf=max(mf,map[r]);\\n            }\\n        for(int i=0;i<nums.size();i++)\\n            {\\n             if(map[nums[i]%space]==mf){\\n                ans=min(ans,nums[i]);\\n            }\\n            }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        unordered_map<int, int>map; \\n        int ans = INT_MAX;\\n        int mf= 0;\\n        for(int i=0;i<nums.size();i++)\\n            {\\n                int r = nums[i]%space;\\n                map[r]++;\\n                mf=max(mf,map[r]);\\n            }\\n        for(int i=0;i<nums.size();i++)\\n            {\\n             if(map[nums[i]%space]==mf){\\n                ans=min(ans,nums[i]);\\n            }\\n            }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608634,
                "title": "c-hashmap-of-pair",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, pair<int,int>> m;\\n        for (auto& n : nums){\\n            int k = n % space;\\n            if (m.find(k) == m.end()) m[k] = {1, n};\\n            else {\\n                ++m[k].first;\\n                m[k].second = min(m[k].second, n);\\n            }\\n        }\\n        int ans = 0, l = 0;\\n        for (auto& [f,s] : m){\\n            auto [s1, s2] = s;\\n            if (s1 > l) ans = s2;\\n            else if (s1 == l) ans = min(ans, s2);\\n            l = max(l, s1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, pair<int,int>> m;\\n        for (auto& n : nums){\\n            int k = n % space;\\n            if (m.find(k) == m.end()) m[k] = {1, n};\\n            else {\\n                ++m[k].first;\\n                m[k].second = min(m[k].second, n);\\n            }\\n        }\\n        int ans = 0, l = 0;\\n        for (auto& [f,s] : m){\\n            auto [s1, s2] = s;\\n            if (s1 > l) ans = s2;\\n            else if (s1 == l) ans = min(ans, s2);\\n            l = max(l, s1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3523946,
                "title": "easy-solution-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(space)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int destroy = 0;\\n        int ans = 1e9;\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]%space]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            int no = mp[nums[i]%space];\\n            if(no>destroy){\\n                destroy = no;\\n                ans = nums[i];\\n            }\\n            else if(no==destroy && ans > nums[i]){\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int destroy = 0;\\n        int ans = 1e9;\\n        int n = nums.size();\\n        unordered_map<int,int> mp;\\n        for(int i=0; i<nums.size(); i++){\\n            mp[nums[i]%space]++;\\n        }\\n        for(int i=0; i<nums.size(); i++){\\n            int no = mp[nums[i]%space];\\n            if(no>destroy){\\n                destroy = no;\\n                ans = nums[i];\\n            }\\n            else if(no==destroy && ans > nums[i]){\\n                ans = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3483443,
                "title": "java-using-hashmap-remainder-count-with-comments",
                "content": "\\n// b <========2453. Destroy Sequential Targets ===============>\\n    // https://leetcode.com/problems/destroy-sequential-targets/description/\\n\\n    // # Humko multiples check karne the. To multiples ka remainder same hota hai.\\n    // # Bas yhi kiya hai. Simple.\\n\\n    // To hashmap mai remainder, count store kiya hai. Jiska sabse jyada hoga, hume\\n    // whi smallest element kake dena hai.\\n\\n    // Agar kisi 2 element ka reminder count same hai to hume smallest element\\n    // return karna hai, isiliye loop ko piche se run kiya.\\n\\n```\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums);\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        int maxLen = 0, minEle = -1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val = nums[i];\\n            int r = val % space;\\n\\n            map.put(r, map.getOrDefault(r, 0) + 1);\\n            if (map.get(r) >= maxLen) {\\n                maxLen = map.get(r);\\n                minEle = val;\\n            }\\n        }\\n        return minEle;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums);\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        int n = nums.length;\\n        int maxLen = 0, minEle = -1;\\n        for (int i = n - 1; i >= 0; i--) {\\n            int val = nums[i];\\n            int r = val % space;\\n\\n            map.put(r, map.getOrDefault(r, 0) + 1);\\n            if (map.get(r) >= maxLen) {\\n                maxLen = map.get(r);\\n                minEle = val;\\n            }\\n        }\\n        return minEle;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3420830,
                "title": "destroy-sequential-targets",
                "content": "----------------- C++ Easy Solution ----------------\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n    int ans = INT_MAX;\\n    int maxCount = 0;\\n    unordered_map<int, int> count;\\n\\n    for (const int num : nums)\\n      maxCount = max(maxCount, ++count[num % space]);\\n\\n    for (const int num : nums)\\n      if (count[num % space] == maxCount)\\n        ans = min(ans, num);\\n\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n    int ans = INT_MAX;\\n    int maxCount = 0;\\n    unordered_map<int, int> count;\\n\\n    for (const int num : nums)\\n      maxCount = max(maxCount, ++count[num % space]);\\n\\n    for (const int num : nums)\\n      if (count[num % space] == maxCount)\\n        ans = min(ans, num);\\n\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370334,
                "title": "python-o-n-solution-with-explanation",
                "content": "```python\\n\\'\\'\\'\\n1. calculate the frequency of n%space, also find the min n for each reminder\\n2. find the minimum n which has the max number of target\\ntc is O(n), sc is O(n) \\n\\'\\'\\'\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n\\t\\t# remainder -> [min n, frequency]\\n        remainderToMinKeyAndFreq = collections.defaultdict(lambda:[-1, 0])\\n        for n in nums:\\n            keyAndFreq = remainderToMinKeyAndFreq[n%space]\\n            keyAndFreq[0] = n if keyAndFreq[0] == -1 else min(keyAndFreq[0], n)\\n            keyAndFreq[1] += 1\\n        minK, maxF = -1, 0\\n        for k, f in remainderToMinKeyAndFreq.values():\\n            if f == maxF: minK = k if k < minK else minK\\n            elif f > maxF: minK, maxF = k, f \\n        return minK\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n\\'\\'\\'\\n1. calculate the frequency of n%space, also find the min n for each reminder\\n2. find the minimum n which has the max number of target\\ntc is O(n), sc is O(n) \\n\\'\\'\\'\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n\\t\\t# remainder -> [min n, frequency]\\n        remainderToMinKeyAndFreq = collections.defaultdict(lambda:[-1, 0])\\n        for n in nums:\\n            keyAndFreq = remainderToMinKeyAndFreq[n%space]\\n            keyAndFreq[0] = n if keyAndFreq[0] == -1 else min(keyAndFreq[0], n)\\n            keyAndFreq[1] += 1\\n        minK, maxF = -1, 0\\n        for k, f in remainderToMinKeyAndFreq.values():\\n            if f == maxF: minK = k if k < minK else minK\\n            elif f > maxF: minK, maxF = k, f \\n        return minK\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354798,
                "title": "pyhon3-solution-with-sorting-and-priority-heap",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimport bisect\\nimport heapq\\n\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dic = {}\\n        for idx, num in enumerate(nums):\\n            key = num % space\\n            if key not in dic:\\n                dic[key] = [num]\\n            else:\\n                bisect.insort_left(dic[key], num)\\n        max_len = -1\\n        for key in dic:\\n            if len(dic[key]) > max_len:\\n                max_len = len(dic[key])\\n        heap = []\\n        for key in dic:\\n            if len(dic[key]) == max_len:\\n                for val in dic[key]:\\n                    heapq.heappush(heap, val)\\n        return heapq.heappop(heap)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nimport bisect\\nimport heapq\\n\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        dic = {}\\n        for idx, num in enumerate(nums):\\n            key = num % space\\n            if key not in dic:\\n                dic[key] = [num]\\n            else:\\n                bisect.insort_left(dic[key], num)\\n        max_len = -1\\n        for key in dic:\\n            if len(dic[key]) > max_len:\\n                max_len = len(dic[key])\\n        heap = []\\n        for key in dic:\\n            if len(dic[key]) == max_len:\\n                for val in dic[key]:\\n                    heapq.heappush(heap, val)\\n        return heapq.heappop(heap)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345509,
                "title": "clean-and-easy-c",
                "content": "\\n\\'\\'\\'\\n\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int res=0, count=0;\\n        map<int, int> m;\\n        for (auto i : nums) {\\n            int mod = i%space;\\n            m[mod]++;\\n        }\\n        sort(nums.begin(), nums.end());\\n        for (auto i : nums) {\\n            int mod = i%space;\\n            if (m[mod] > count) {\\n                count = m[mod];\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\n\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int res=0, count=0;\\n        map<int, int> m;\\n        for (auto i : nums) {\\n            int mod = i%space;\\n            m[mod]++;\\n        }\\n        sort(nums.begin(), nums.end());\\n        for (auto i : nums) {\\n            int mod = i%space;\\n            if (m[mod] > count) {\\n                count = m[mod];\\n                res = i;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 3327530,
                "title": "c-count-modulo-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,pair<int,int>> m;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(auto i:nums)\\n        {\\n            int tmp = i%space;\\n            if(m.find(tmp)!=m.end())\\n            {\\n                int fre = m[tmp].second;\\n                fre++;\\n                int val = m[tmp].first;\\n                m[tmp] = {val,fre};\\n            }\\n            else\\n            {\\n                m[tmp] = {i,1};\\n            }\\n        }\\n        int maxF=0,ans=0;\\n        for(auto i:nums)\\n        {\\n            int fre = m[i%space].second;\\n            int val = m[i%space].first;\\n            if(fre>maxF)\\n            {\\n                maxF = fre;\\n                ans = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,pair<int,int>> m;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        for(auto i:nums)\\n        {\\n            int tmp = i%space;\\n            if(m.find(tmp)!=m.end())\\n            {\\n                int fre = m[tmp].second;\\n                fre++;\\n                int val = m[tmp].first;\\n                m[tmp] = {val,fre};\\n            }\\n            else\\n            {\\n                m[tmp] = {i,1};\\n            }\\n        }\\n        int maxF=0,ans=0;\\n        for(auto i:nums)\\n        {\\n            int fre = m[i%space].second;\\n            int val = m[i%space].first;\\n            if(fre>maxF)\\n            {\\n                maxF = fre;\\n                ans = val;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310933,
                "title": "java-simplest-of-possible-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer>map = new HashMap<Integer,Integer>();\\n        for(int i = 0 ;i<nums.length ;i++){\\n            int r = nums[i] % space ;\\n            map.put(r,map.getOrDefault(r,0)+1);\\n        }\\n        int max = 0 ; \\n        for(int r :map.keySet()){\\n         \\n        max = Math.max(map.get(r),max);\\n        }\\n        int min = nums[nums.length-1];\\n        int in = nums.length-1;\\n        for(int i = 0 ;i<nums.length ;i++){\\n            int r = nums[i] % space ;\\n            if(map.get(r)==max){\\n                min = Math.min(nums[i],min);\\n            }\\n           \\n\\n        }\\n        return min;\\n\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums);\\n        HashMap<Integer,Integer>map = new HashMap<Integer,Integer>();\\n        for(int i = 0 ;i<nums.length ;i++){\\n            int r = nums[i] % space ;\\n            map.put(r,map.getOrDefault(r,0)+1);\\n        }\\n        int max = 0 ; \\n        for(int r :map.keySet()){\\n         \\n        max = Math.max(map.get(r),max);\\n        }\\n        int min = nums[nums.length-1];\\n        int in = nums.length-1;\\n        for(int i = 0 ;i<nums.length ;i++){\\n            int r = nums[i] % space ;\\n            if(map.get(r)==max){\\n                min = Math.min(nums[i],min);\\n            }\\n           \\n\\n        }\\n        return min;\\n\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3289785,
                "title": "267-ms",
                "content": "```ruby\\ndef destroy_targets a, k\\n    v, c = {}, Hash.new(0)\\n    a.each do\\n        c[x = _1 % k] += 1\\n        v[x] = _1 if !(y = v[x]) || _1 < y\\n    end\\n    m = c.each_value.max\\n    c.filter_map { v[_1.first] if _1.last == m } .min\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\ndef destroy_targets a, k\\n    v, c = {}, Hash.new(0)\\n    a.each do\\n        c[x = _1 % k] += 1\\n        v[x] = _1 if !(y = v[x]) || _1 < y\\n    end\\n    m = c.each_value.max\\n    c.filter_map { v[_1.first] if _1.last == m } .min\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3278811,
                "title": "simple-c-solution",
                "content": "# Intuition\\nThe elements with same remainder module by space,\\ncan be destroied together.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Count the frequency of A[i] % space.\\n- The maximum frequency maxc is the the maximum number of targets we can destroy.\\n- Find the minimum element A[i] that A[i] % space = maxc.\\n\\n# Complexity\\n- Time complexity: O(N + N)\\n\\n- Space complexity:O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = INT_MAX;\\n        unordered_map<int, int> mpp;\\n        int mx = INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int r = nums[i] % space;\\n            mpp[r]++;\\n            mx = max(mx, mpp[nums[i] % space]);\\n        }\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mx == mpp[nums[i]%space]) ans = min(ans, nums[i]);\\n        }\\n\\n        // for(int &n : nums)\\n        // {\\n        //     if(mpp[n % space] == mx) ans = min(ans, n);\\n        // }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = INT_MAX;\\n        unordered_map<int, int> mpp;\\n        int mx = INT_MIN;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int r = nums[i] % space;\\n            mpp[r]++;\\n            mx = max(mx, mpp[nums[i] % space]);\\n        }\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(mx == mpp[nums[i]%space]) ans = min(ans, nums[i]);\\n        }\\n\\n        // for(int &n : nums)\\n        // {\\n        //     if(mpp[n % space] == mx) ans = min(ans, n);\\n        // }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3221732,
                "title": "prabal-kumar-pandey",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBy using frequency table.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(s), where s is the value of space\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> cnt;\\n        int mx = 0;\\n        for (const auto& x : nums) {\\n            mx = max(mx, ++cnt[x % space]);\\n        }\\n        int result = numeric_limits<int>::max();\\n        for (const auto& x : nums) {\\n            if (cnt[x % space] == mx) {\\n                result = min(result, x);\\n            }\\n        }\\n        return result;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> cnt;\\n        int mx = 0;\\n        for (const auto& x : nums) {\\n            mx = max(mx, ++cnt[x % space]);\\n        }\\n        int result = numeric_limits<int>::max();\\n        for (const auto& x : nums) {\\n            if (cnt[x % space] == mx) {\\n                result = min(result, x);\\n            }\\n        }\\n        return result;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3192784,
                "title": "c",
                "content": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint cmp1(const void* a, const void* b){\\n    int* A = *(int**)a ;\\n    int* B = *(int**)b ;\\n    if(A[1] == B[1])\\n        return A[0] - B[0] ;\\n    else\\n        return A[1]- B[1] ;\\n}\\n\\nint destroyTargets(int* nums, int numsSize, int space){\\n    int n = numsSize ;\\n    qsort(nums, n, sizeof(int), cmp) ;\\n    int** mod = malloc(n * sizeof(int*)) ;\\n    for(int i  = 0; i < n; i++){\\n        mod[i] = malloc(2 * sizeof(int)) ;\\n        mod[i][0] = i ;\\n        mod[i][1] = nums[i] % space ;\\n    }\\n    \\n    qsort(mod, n, sizeof(int*), cmp1) ;\\n\\n    int M = mod[0][1] ;\\n    int Midx = mod[0][0] ;\\n    int next = mod[0][0] ;\\n    int max_cn = 1 ;\\n    int cn = 1 ;\\n    for(int i =1; i < n; i++){\\n        if(mod[i][1] == mod[i-1][1])\\n            cn++ ;\\n        else{\\n            if(cn > max_cn){\\n                M = mod[i-1][1] ;\\n                Midx = next ;\\n                max_cn = cn ;\\n            }\\n            else if((cn == max_cn) && (next < Midx)){\\n                Midx = next ;\\n                M = mod[i-1][1] ;\\n            }\\n            next = mod[i][0] ;\\n            cn = 1 ;\\n        }\\n    }\\n    if(cn > max_cn){\\n            M = mod[n-1][1] ;\\n            Midx = next ;\\n            max_cn = cn ;\\n    }\\n    else if(cn == max_cn && next < Midx){\\n            Midx = next ;\\n            M = mod[n-1][1] ;\\n    }\\n    int ans = -1;\\n    for(int i = 0; i < n; i++){\\n        if(nums[i] % space == M){\\n            ans = nums[i] ;\\n            break ;\\n        }\\n    }\\n    \\n    for(int i = 0; i < n; i++)\\n        free(mod[i]) ;\\n    free(mod) ;\\n    return ans ;\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmp(const void* a, const void* b){\\n    return *(int*)a - *(int*)b;\\n}\\n\\nint cmp1(const void* a, const void* b){\\n    int* A = *(int**)a ;\\n    int* B = *(int**)b ;\\n    if(A[1] == B[1])\\n        return A[0] - B[0] ;\\n    else\\n        return A[1]- B[1] ;\\n}\\n\\nint destroyTargets(int* nums, int numsSize, int space){\\n    int n = numsSize ;\\n    qsort(nums, n, sizeof(int), cmp) ;\\n    int** mod = malloc(n * sizeof(int*)) ;\\n    for(int i  = 0; i < n; i++){\\n        mod[i] = malloc(2 * sizeof(int)) ;\\n        mod[i][0] = i ;\\n        mod[i][1] = nums[i] % space ;\\n    }\\n    \\n    qsort(mod, n, sizeof(int*), cmp1) ;\\n\\n    int M = mod[0][1] ;\\n    int Midx = mod[0][0] ;\\n    int next = mod[0][0] ;\\n    int max_cn = 1 ;\\n    int cn = 1 ;\\n    for(int i =1; i < n; i++){\\n        if(mod[i][1] == mod[i-1][1])\\n            cn++ ;\\n        else{\\n            if(cn > max_cn){\\n                M = mod[i-1][1] ;\\n                Midx = next ;\\n                max_cn = cn ;\\n            }\\n            else if((cn == max_cn) && (next < Midx)){\\n                Midx = next ;\\n                M = mod[i-1][1] ;\\n            }\\n            next = mod[i][0] ;\\n            cn = 1 ;\\n        }\\n    }\\n    if(cn > max_cn){\\n            M = mod[n-1][1] ;\\n            Midx = next ;\\n            max_cn = cn ;\\n    }\\n    else if(cn == max_cn && next < Midx){\\n            Midx = next ;\\n            M = mod[n-1][1] ;\\n    }\\n    int ans = -1;\\n    for(int i = 0; i < n; i++){\\n        if(nums[i] % space == M){\\n            ans = nums[i] ;\\n            break ;\\n        }\\n    }\\n    \\n    for(int i = 0; i < n; i++)\\n        free(mod[i]) ;\\n    free(mod) ;\\n    return ans ;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3157222,
                "title": "c-golang-map",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = 0, maximum = 0;\\n        unordered_map<int, pair<int, int>> Map;\\n        for(int num: nums) {\\n            int val = num % space;\\n            if(Map.find(val) == Map.end()) {\\n                Map[val] = {num, 1};\\n            } else {\\n                Map[val] = {min(Map[val].first, num), Map[val].second + 1};\\n            }\\n        }\\n        for( auto &[key, val]: Map) {\\n            if(val.second > maximum) {\\n                ans = val.first;\\n                maximum = val.second;\\n            } else if(val.second == maximum) {\\n                ans = min(ans, val.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\nfunc destroyTargets(nums []int, space int) int {\\n    var ans, maximum = 0, 0\\n    Map := make(map[int][]int)\\n    for _, num := range nums {\\n        key := num % space\\n        if val, ok := Map[key]; !ok {\\n            Map[key] = []int{num, 1}\\n        } else {\\n            Map[key] = []int{min(val[0], num), val[1] + 1}\\n        }\\n    }\\n   \\n    for _, val := range Map {\\n        if val[1] > maximum {\\n            ans = val[0]\\n            maximum = val[1]\\n        } else if val[1] == maximum {\\n            ans = min(ans, val[0])\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = 0, maximum = 0;\\n        unordered_map<int, pair<int, int>> Map;\\n        for(int num: nums) {\\n            int val = num % space;\\n            if(Map.find(val) == Map.end()) {\\n                Map[val] = {num, 1};\\n            } else {\\n                Map[val] = {min(Map[val].first, num), Map[val].second + 1};\\n            }\\n        }\\n        for( auto &[key, val]: Map) {\\n            if(val.second > maximum) {\\n                ans = val.first;\\n                maximum = val.second;\\n            } else if(val.second == maximum) {\\n                ans = min(ans, val.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n// Golang\\nfunc min(a, b int) int {\\n    if a < b {return a}\\n    return b\\n}\\nfunc destroyTargets(nums []int, space int) int {\\n    var ans, maximum = 0, 0\\n    Map := make(map[int][]int)\\n    for _, num := range nums {\\n        key := num % space\\n        if val, ok := Map[key]; !ok {\\n            Map[key] = []int{num, 1}\\n        } else {\\n            Map[key] = []int{min(val[0], num), val[1] + 1}\\n        }\\n    }\\n   \\n    for _, val := range Map {\\n        if val[1] > maximum {\\n            ans = val[0]\\n            maximum = val[1]\\n        } else if val[1] == maximum {\\n            ans = min(ans, val[0])\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3154409,
                "title": "c-easy-fast",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = INT_MAX;\\n        unordered_map<int, int> mp;\\n        int mx = INT_MIN;\\n        for(auto n: nums){\\n            int r = n % space;                  \\n            mp[r]++;                               \\n            if(mx < mp[r])  mx = mp[r];  \\n        }\\n        for(auto n: nums){ \\n            if(mx == mp[n%space])  ans = min(ans, n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int ans = INT_MAX;\\n        unordered_map<int, int> mp;\\n        int mx = INT_MIN;\\n        for(auto n: nums){\\n            int r = n % space;                  \\n            mp[r]++;                               \\n            if(mx < mp[r])  mx = mp[r];  \\n        }\\n        for(auto n: nums){ \\n            if(mx == mp[n%space])  ans = min(ans, n);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134013,
                "title": "c-o-n-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int>mp1;\\n        vector<pair<int,int>>v;\\n        for(auto x:nums)\\n        {\\n            int val=x%space;\\n            mp1[val]++;\\n            v.push_back({val,x});\\n        }\\n        int ans=INT_MAX;\\n        int val=INT_MIN;\\n        for(auto x:v)\\n        {\\n          if(mp1[x.first]>val)\\n          {\\n              val=mp1[x.first];\\n              ans=x.second;\\n          }\\n          if(mp1[x.first]==val)\\n          {\\n              ans=min(ans,x.second);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int>mp1;\\n        vector<pair<int,int>>v;\\n        for(auto x:nums)\\n        {\\n            int val=x%space;\\n            mp1[val]++;\\n            v.push_back({val,x});\\n        }\\n        int ans=INT_MAX;\\n        int val=INT_MIN;\\n        for(auto x:v)\\n        {\\n          if(mp1[x.first]>val)\\n          {\\n              val=mp1[x.first];\\n              ans=x.second;\\n          }\\n          if(mp1[x.first]==val)\\n          {\\n              ans=min(ans,x.second);\\n          }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112319,
                "title": "scala-1-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def destroyTargets(nums: Array[Int], space: Int): Int = {\\n        nums.groupBy(_ % space).values.maxBy(n => (n.length, -n.head)).min\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def destroyTargets(nums: Array[Int], space: Int): Int = {\\n        nums.groupBy(_ % space).values.maxBy(n => (n.length, -n.head)).min\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3063484,
                "title": "c-clean-short-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int n=nums.size();\\n        int k=space;map<int,int> p;\\n        for(auto i : nums)\\n        p[i%k]++;\\n        sort(nums.begin(),nums.end());\\n        int l=0,id;\\n        for(auto i : nums)\\n        {\\n            if(l<p[i%k])\\n            {\\n                l=p[i%k];\\n                id=i;\\n            }\\n        }\\n        return id;\\n    }\\n};\\n//Upvote if u like it\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int n=nums.size();\\n        int k=space;map<int,int> p;\\n        for(auto i : nums)\\n        p[i%k]++;\\n        sort(nums.begin(),nums.end());\\n        int l=0,id;\\n        for(auto i : nums)\\n        {\\n            if(l<p[i%k])\\n            {\\n                l=p[i%k];\\n                id=i;\\n            }\\n        }\\n        return id;\\n    }\\n};\\n//Upvote if u like it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3037795,
                "title": "python-simple-remainder-map-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nReverse sort the array. Store the remainder for every number encountered in a map. Update the count for the same remainder seen so far. Result will be the maximum count remainder.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        prefixRem = {}\\n        maxSoFar = 0\\n        res = 0\\n        nums.sort(reverse=True)\\n        for num in nums:\\n            curRem = num % space\\n            prefixRem[curRem] = 1 + prefixRem.get(curRem, 0)\\n            if prefixRem[curRem] >= maxSoFar:\\n                res = num\\n                maxSoFar = prefixRem[curRem]\\n        return res\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        prefixRem = {}\\n        maxSoFar = 0\\n        res = 0\\n        nums.sort(reverse=True)\\n        for num in nums:\\n            curRem = num % space\\n            prefixRem[curRem] = 1 + prefixRem.get(curRem, 0)\\n            if prefixRem[curRem] >= maxSoFar:\\n                res = num\\n                maxSoFar = prefixRem[curRem]\\n        return res\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032799,
                "title": "no-modulo-solution-exlpained-python",
                "content": "**How to group elements that belong to the same linear sequence?**\\n\\nFor example 1,3,5,7,... they all belong to same sequence but what metric should we use to group them together?\\n\\nWe need two values: any value of the sequence, and increment factor (space)\\nIts analagous to straight line y = mx + c, in that case (m, c) is the metric.\\n\\nIn this problelm all sequences have the same increment (space), \\nso we just need to choose some value of that sequence to be the representative of that sequence group. \\n\\nI decided to choose the first value of the sequence that is `<= 0` as the representative.\\nTime: O(n)\\nSpace: O(n)\\n```\\ndef destroyTargets(self, nums: List[int], space: int) -> int:\\n    count = defaultdict(lambda: [inf, 0])\\n    for i in nums:\\n        origin = i - ceil(i/space)*space\\n        prev_min, freq = count[origin]\\n        count[origin] = [min(prev_min, i), freq + 1]\\n    return max(count.values(), key=lambda x: (x[1], -x[0]))[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\ndef destroyTargets(self, nums: List[int], space: int) -> int:\\n    count = defaultdict(lambda: [inf, 0])\\n    for i in nums:\\n        origin = i - ceil(i/space)*space\\n        prev_min, freq = count[origin]\\n        count[origin] = [min(prev_min, i), freq + 1]\\n    return max(count.values(), key=lambda x: (x[1], -x[0]))[0]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3009532,
                "title": "easy-c-solution",
                "content": "\\n# Code\\n```\\n// AUTHOR  :: RAHUL MISTRY\\n// DATE    :: 06/01/2023\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int, vector<int>> m;\\n        for(auto i:nums){\\n            int r=i%space;\\n            m[r].push_back(i);\\n        }\\n\\n    int maxm=INT_MIN;\\n    for(auto it:m){\\n        int x=it.second.size();\\n        if(x>maxm){\\n            maxm=it.second.size();\\n        }\\n    }    \\n        int ans=INT_MAX;\\n        for(auto it:m){\\n            if(it.second.size()==maxm){\\n                vector<int> temp=it.second;\\n                sort(temp.begin(), temp.end());\\n                ans=min(ans, temp[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// AUTHOR  :: RAHUL MISTRY\\n// DATE    :: 06/01/2023\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int, vector<int>> m;\\n        for(auto i:nums){\\n            int r=i%space;\\n            m[r].push_back(i);\\n        }\\n\\n    int maxm=INT_MIN;\\n    for(auto it:m){\\n        int x=it.second.size();\\n        if(x>maxm){\\n            maxm=it.second.size();\\n        }\\n    }    \\n        int ans=INT_MAX;\\n        for(auto it:m){\\n            if(it.second.size()==maxm){\\n                vector<int> temp=it.second;\\n                sort(temp.begin(), temp.end());\\n                ans=min(ans, temp[0]);\\n            }\\n        }\\n        return ans;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969578,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int> mp;\\n        int n=nums.size();\\n        int high=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]%space]++;\\n            high=max(high,mp[nums[i]%space]);\\n        }\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[nums[i]%space]==high)\\n            {\\n                ans=min(ans,nums[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int> mp;\\n        int n=nums.size();\\n        int high=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]%space]++;\\n            high=max(high,mp[nums[i]%space]);\\n        }\\n\\n        int ans=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(mp[nums[i]%space]==high)\\n            {\\n                ans=min(ans,nums[i]);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2962140,
                "title": "c-simple-approach-for-interesting-math-problem",
                "content": "# Intuition\\nWe are looking for the first element of the longest arithmetic progression in nums array.\\n\\n\\n# Approach\\nSuppose A0 represents the first number in some Arithmetic progression that may or may not be present in array. We can say any other number in the progression can be written as.\\n\\n```\\nnums[i] = A0 + c*space\\n```\\n\\nIn first loop, We can simply take modulo (% space) for each number in nums and store in the hashmap.\\n```\\nmodulo[nums[i]] = nums[i] % space; // modulo[nums[i]] = A0 % space\\n```\\n\\nSince, every number in the AP is gonna produce the same modulo; we can store the count of numbers in AP (present in nums array) for their resp. modulo result. i.e.\\n\\n```\\ncount[modulo[nums[i]]]\\n``` \\nrepresents the count of the AP.\\n\\nIn second loop, we can iterate over all the numbers in nums array and check if their modulo (% space) produces the maximum length and store the minimum of nums[i] in a separate variable.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int n = nums.size();\\n\\n        unordered_map<int, int> count;\\n        unordered_map<int, int> modulo;\\n        set<int> nums_unique;\\n\\n        for(int i = 0; i < n; i++) {\\n            int a = nums[i] % space;\\n            modulo[nums[i]] = a;\\n            count[a]++;\\n        }\\n\\n        int ans = INT_MAX;\\n        int len = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(count[modulo[nums[i]]] == len) {\\n                ans = min(ans, nums[i]);\\n            }\\n            else if(count[modulo[nums[i]]] > len) {\\n                len = count[modulo[nums[i]]];\\n                ans = nums[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```\\nnums[i] = A0 + c*space\\n```\n```\\nmodulo[nums[i]] = nums[i] % space; // modulo[nums[i]] = A0 % space\\n```\n```\\ncount[modulo[nums[i]]]\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int n = nums.size();\\n\\n        unordered_map<int, int> count;\\n        unordered_map<int, int> modulo;\\n        set<int> nums_unique;\\n\\n        for(int i = 0; i < n; i++) {\\n            int a = nums[i] % space;\\n            modulo[nums[i]] = a;\\n            count[a]++;\\n        }\\n\\n        int ans = INT_MAX;\\n        int len = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            if(count[modulo[nums[i]]] == len) {\\n                ans = min(ans, nums[i]);\\n            }\\n            else if(count[modulo[nums[i]]] > len) {\\n                len = count[modulo[nums[i]]];\\n                ans = nums[i];\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938403,
                "title": "modulo-hashmap-99-5-faster-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int destroyTargets(vector<int>& nums, int space) {\\n        ll n=nums.size(),max_freq=INT_MIN,value,answer=INT_MAX;\\n        unordered_map<ll,ll>mp;\\n        for(auto &x:nums){\\n            max_freq=max(max_freq,++mp[x%space]);\\n        }\\n        for(auto &x:nums){\\n            if(mp[x%space]==max_freq){\\n                answer=min(answer,(ll)x);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    int destroyTargets(vector<int>& nums, int space) {\\n        ll n=nums.size(),max_freq=INT_MIN,value,answer=INT_MAX;\\n        unordered_map<ll,ll>mp;\\n        for(auto &x:nums){\\n            max_freq=max(max_freq,++mp[x%space]);\\n        }\\n        for(auto &x:nums){\\n            if(mp[x%space]==max_freq){\\n                answer=min(answer,(ll)x);\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2929733,
                "title": "java-o-n-solution",
                "content": "# Approach\\niterate ```nums``` and classify ```nums[i]``` using ```nums[i] %= space```\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        int n = nums.length;\\n        int[] process = new int[n];\\n        Map<Integer, List<Integer>> spaceMap = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            process[i] = nums[i] % space;\\n            if (!spaceMap.containsKey(process[i])) {\\n                spaceMap.put(process[i], new ArrayList<>());\\n            }\\n            spaceMap.get(process[i]).add(nums[i]);\\n        }\\n\\n        int maxCnt = 0;\\n        Set<Integer> maxSet = new HashSet<>();\\n        for (Map.Entry<Integer, List<Integer>> entry : spaceMap.entrySet()) {\\n            int cnt = entry.getValue().size();\\n            if (cnt > maxCnt) {\\n                maxCnt = cnt;\\n                maxSet.clear();\\n                maxSet.addAll(entry.getValue());\\n            } else if (cnt == maxCnt) {\\n                maxSet.addAll(entry.getValue());\\n            }\\n        }\\n\\n        int min = Integer.MAX_VALUE, absMin = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            absMin = Math.min(absMin, num);\\n            if (maxSet.contains(num)) {\\n                min = Math.min(min, num);\\n            }\\n        }\\n\\n        return min == Integer.MAX_VALUE ? absMin : min;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```nums```\n```nums[i]```\n```nums[i] %= space```\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        int n = nums.length;\\n        int[] process = new int[n];\\n        Map<Integer, List<Integer>> spaceMap = new HashMap<>();\\n\\n        for (int i = 0; i < n; i++) {\\n            process[i] = nums[i] % space;\\n            if (!spaceMap.containsKey(process[i])) {\\n                spaceMap.put(process[i], new ArrayList<>());\\n            }\\n            spaceMap.get(process[i]).add(nums[i]);\\n        }\\n\\n        int maxCnt = 0;\\n        Set<Integer> maxSet = new HashSet<>();\\n        for (Map.Entry<Integer, List<Integer>> entry : spaceMap.entrySet()) {\\n            int cnt = entry.getValue().size();\\n            if (cnt > maxCnt) {\\n                maxCnt = cnt;\\n                maxSet.clear();\\n                maxSet.addAll(entry.getValue());\\n            } else if (cnt == maxCnt) {\\n                maxSet.addAll(entry.getValue());\\n            }\\n        }\\n\\n        int min = Integer.MAX_VALUE, absMin = Integer.MAX_VALUE;\\n        for (int num : nums) {\\n            absMin = Math.min(absMin, num);\\n            if (maxSet.contains(num)) {\\n                min = Math.min(min, num);\\n            }\\n        }\\n\\n        return min == Integer.MAX_VALUE ? absMin : min;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902214,
                "title": "javascript-find-most-frequent-remainder-among-numbers",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif `nums[i] + c*space = x` where `x` is number which we looking for, it means that\\n`nums[i]/space + c = x/space` , `c` is natural number so if `nums[i]/space` and `x/space` have the same remainder, we can recreate left side  by just adding some natural number (if `x/space` is smaller but that doesn\\'t really matter for purposes of this question)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the most popular remainder among nums and then find smallest num with that most frequent remainder\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} space\\n * @return {number}\\n */\\nvar destroyTargets = function(nums, space) {\\n   const remaindersMap = {} \\n   let maxFreq = null\\n\\n   for(let i = 0; i < nums.length; i++) {\\n       const currRemainder = nums[i]%space\\n\\n       if(!(currRemainder in remaindersMap)) {\\n           remaindersMap[currRemainder] = 0\\n       }\\n       remaindersMap[currRemainder]++\\n\\n       if(maxFreq === null || remaindersMap[currRemainder] > maxFreq) {\\n           maxFreq = remaindersMap[currRemainder]\\n       }\\n   }\\n\\n   let res = null\\n\\n   for(let i = 0; i < nums.length; i++) {\\n       const currRemainder = nums[i]%space\\n\\n       if(remaindersMap[currRemainder] === maxFreq) {\\n           if(res === null || res > nums[i]) {\\n               res = nums[i]\\n           }  \\n       }\\n   }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} space\\n * @return {number}\\n */\\nvar destroyTargets = function(nums, space) {\\n   const remaindersMap = {} \\n   let maxFreq = null\\n\\n   for(let i = 0; i < nums.length; i++) {\\n       const currRemainder = nums[i]%space\\n\\n       if(!(currRemainder in remaindersMap)) {\\n           remaindersMap[currRemainder] = 0\\n       }\\n       remaindersMap[currRemainder]++\\n\\n       if(maxFreq === null || remaindersMap[currRemainder] > maxFreq) {\\n           maxFreq = remaindersMap[currRemainder]\\n       }\\n   }\\n\\n   let res = null\\n\\n   for(let i = 0; i < nums.length; i++) {\\n       const currRemainder = nums[i]%space\\n\\n       if(remaindersMap[currRemainder] === maxFreq) {\\n           if(res === null || res > nums[i]) {\\n               res = nums[i]\\n           }  \\n       }\\n   }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2894888,
                "title": "hashmap-simple-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n// CREATING HASHMAP\\n        Map<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n// STORE THE FREQUNCY \\n            map.put(nums[i]%space , map.getOrDefault(nums[i]%space,0)+ 1);\\nSTORE THE MAXIMUM FREQUENCY ELEMENT\\n         max=Math.max(max,map.get(nums[i]%space));\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n       if(map.get(nums[i]%space)==max)\\n       min=Math.min(nums[i],min);\\n        }\\n        return min;\\n\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Rolling Hash",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n// CREATING HASHMAP\\n        Map<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        for(int i=0;i<nums.length;i++){\\n// STORE THE FREQUNCY \\n            map.put(nums[i]%space , map.getOrDefault(nums[i]%space,0)+ 1);\\nSTORE THE MAXIMUM FREQUENCY ELEMENT\\n         max=Math.max(max,map.get(nums[i]%space));\\n        }\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<nums.length;i++){\\n       if(map.get(nums[i]%space)==max)\\n       min=Math.min(nums[i],min);\\n        }\\n        return min;\\n\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892733,
                "title": "c-o-n",
                "content": "# Intuition\\nif num2 = num1 + c * space, then (num2 - num1) / space = c\\nbecause c is a integer, then num2 % space == num1 % space;\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //vector<pair<int, int>> vp(space, {0, 1e9 + 1});\\n        unordered_map<int, pair<int, int>> vp;\\n        for(const auto& num : nums){\\n            if(!vp.count(num % space)){\\n                vp[num % space] = {1, num};\\n            }\\n            else{\\n                vp[num % space].first++;\\n                vp[num % space].second = min(vp[num % space].second, num);\\n            }\\n        }\\n        int cnt = 0;\\n        int res = 1e9 + 1;\\n        for(const auto& [mod, node] : vp){\\n            int left = node.first;\\n            int right = node.second;\\n            if(left > cnt){\\n                cnt = left;\\n                res = right;\\n            }\\n            else if(left == cnt){\\n                res = min(res, right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //vector<pair<int, int>> vp(space, {0, 1e9 + 1});\\n        unordered_map<int, pair<int, int>> vp;\\n        for(const auto& num : nums){\\n            if(!vp.count(num % space)){\\n                vp[num % space] = {1, num};\\n            }\\n            else{\\n                vp[num % space].first++;\\n                vp[num % space].second = min(vp[num % space].second, num);\\n            }\\n        }\\n        int cnt = 0;\\n        int res = 1e9 + 1;\\n        for(const auto& [mod, node] : vp){\\n            int left = node.first;\\n            int right = node.second;\\n            if(left > cnt){\\n                cnt = left;\\n                res = right;\\n            }\\n            else if(left == cnt){\\n                res = min(res, right);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889762,
                "title": "easy-c-solution",
                "content": "If you like the solution please upvote it......\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(),nums.end());\\n        map<int,int>mp;\\n        int n  = nums.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            mp[(nums[i])%space]++;\\n        }\\n        int maxCount = 0;\\n        int ans = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            int target = (nums[i]%space);\\n            if(mp[target] > maxCount)\\n            {\\n                maxCount = mp[target];\\n                ans = i;\\n            }\\n        }\\n        return nums[ans];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        sort(nums.begin(),nums.end());\\n        map<int,int>mp;\\n        int n  = nums.size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            mp[(nums[i])%space]++;\\n        }\\n        int maxCount = 0;\\n        int ans = 0;\\n        for(int i = 0;i<n;i++)\\n        {\\n            int target = (nums[i]%space);\\n            if(mp[target] > maxCount)\\n            {\\n                maxCount = mp[target];\\n                ans = i;\\n            }\\n        }\\n        return nums[ans];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853712,
                "title": "hashing-c-o-n-solution-92-faster",
                "content": "\\'\\'\\'\\n int destroyTargets(vector<int>& nums, int space) {\\n        \\n        int ans = INT_MAX ;\\n        int count = INT_MIN ;\\n        int n = nums.size() ;\\n        \\n        unordered_map< int , int >mp ;\\n        \\n        for( auto i : nums )\\n        {\\n            mp[i%space]++ ;\\n        }\\n        \\n        for( auto i : nums )\\n        {\\n            if( mp[i%space] > count )\\n            {\\n                count = mp[i%space] ;\\n                ans = i ;\\n            }\\n            \\n            if( mp[i%space] == count )\\n            {\\n                ans = min( ans , i ) ;\\n            }\\n        }\\n      /*  for( int i = 0 ; i < n ; i++ )\\n        {\\n            int temp = 0 ;\\n            for( int j = 0 ; j < n ; j++ )\\n            {\\n                \\n                if( i != j && nums[j] >= nums[i] )\\n                {\\n                    if( (nums[j]-nums[i])%space == 0 )\\n                    {\\n                        temp++ ;\\n                    }\\n                }\\n            }\\n            \\n           \\n            if( temp > count )\\n            {\\n                ans = nums[i] ;\\n                count = temp  ;\\n            }\\n            \\n            if( temp == count )\\n            {\\n                ans = min( ans , nums[i] ) ;\\n            }\\n            \\n             // cout<<temp<<\" \"<<ans<<\" \"<<count<<endl ;\\n        }*/\\n        \\n        return ans ;\\n        \\n        // return 0\\n    }\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n int destroyTargets(vector<int>& nums, int space) {\\n        \\n        int ans = INT_MAX ;\\n        int count = INT_MIN ;\\n        int n = nums.size() ;\\n        \\n        unordered_map< int , int >mp ;\\n        \\n        for( auto i : nums )\\n        {\\n            mp[i%space]++ ;\\n        }\\n        \\n        for( auto i : nums )\\n        {\\n            if( mp[i%space] > count )\\n            {\\n                count = mp[i%space] ;\\n                ans = i ;\\n            }\\n            \\n            if( mp[i%space] == count )\\n            {\\n                ans = min( ans , i ) ;\\n            }\\n        }\\n      /*  for( int i = 0 ; i < n ; i++ )\\n        {\\n            int temp = 0 ;\\n            for( int j = 0 ; j < n ; j++ )\\n            {\\n                \\n                if( i != j && nums[j] >= nums[i] )\\n                {\\n                    if( (nums[j]-nums[i])%space == 0 )\\n                    {\\n                        temp++ ;\\n                    }\\n                }\\n            }\\n            \\n           \\n            if( temp > count )\\n            {\\n                ans = nums[i] ;\\n                count = temp  ;\\n            }\\n            \\n            if( temp == count )\\n            {\\n                ans = min( ans , nums[i] ) ;\\n            }\\n            \\n             // cout<<temp<<\" \"<<ans<<\" \"<<count<<endl ;\\n        }*/\\n        \\n        return ans ;\\n        \\n        // return 0\\n    }\\n\\t\\'\\'\\'",
                "codeTag": "C++"
            },
            {
                "id": 2844702,
                "title": "python3-commented-and-concise-solution-modulo-and-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to count the difference modulos of num % space we can find.\\n\\nThis can be derived looking at the formula, where it says num + c*space. This formula should remind you of this:\\na = a//space*space + a % space\\n\\nOnce we have figured that out, we need to find the highest count of the same modulo value and the smallest number with that modulo.\\n\\nWe can do that in one pass.\\n\\nOnce we have the counts, we need to find the highest count and with the smallest number and return that value.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe use a hashmap to store the counts for each value and the smallest number with that modulo.\\n\\nSince we are required to find the maximum count with the minimum value, our max function uses two keys.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N + min(space, N)) as we need one pass through our nums and the one pass through the dict which can have space keys at max (0 -> space-1) from the modulo operation.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(min(space, N)) since we cannot have more keys than the modulo operation gives or we have elements.\\n\\n# Code\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n\\n        # get a dict of modulos\\n        modulo_dict = dict()\\n\\n        # go through the array and compute the modulo and their counter\\n        for idx, num in enumerate(nums):\\n            # compute the modulo\\n            modi = num % space\\n\\n            # check whether we need to create one\\n            if modi in modulo_dict:\\n\\n                # keep track of the smalles number\\n                modulo_dict[modi][0] = min(num, modulo_dict[modi][0])\\n\\n                # keep track of the count of this specific modulo\\n                modulo_dict[modi][1] += 1\\n            else:\\n\\n                # create this modulo\\n                modulo_dict[modi] = [num, 1]\\n        \\n        # go through the dict and element with the highest modulo count\\n        best_ele = max(modulo_dict.values(), key=lambda x: (x[1], -x[0]))\\n        \\n        # return the good element\\n        return best_ele[0]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n\\n        # get a dict of modulos\\n        modulo_dict = dict()\\n\\n        # go through the array and compute the modulo and their counter\\n        for idx, num in enumerate(nums):\\n            # compute the modulo\\n            modi = num % space\\n\\n            # check whether we need to create one\\n            if modi in modulo_dict:\\n\\n                # keep track of the smalles number\\n                modulo_dict[modi][0] = min(num, modulo_dict[modi][0])\\n\\n                # keep track of the count of this specific modulo\\n                modulo_dict[modi][1] += 1\\n            else:\\n\\n                # create this modulo\\n                modulo_dict[modi] = [num, 1]\\n        \\n        # go through the dict and element with the highest modulo count\\n        best_ele = max(modulo_dict.values(), key=lambda x: (x[1], -x[0]))\\n        \\n        # return the good element\\n        return best_ele[0]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2824309,
                "title": "simple-sorting-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& a, int s) {\\n        int n=a.size(),mlen=1,ans=a[n-1];\\n        unordered_map<int,int> mp;\\n        sort(a.begin(),a.end());\\n        mp[a[n-1]%s]++;\\n        for(int i=n-2;i>=0;i--){\\n            int len=1+mp[a[i]%s];\\n            if(len>=mlen){\\n                ans=a[i];\\n                mlen=len;\\n            }\\n            mp[a[i]%s]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& a, int s) {\\n        int n=a.size(),mlen=1,ans=a[n-1];\\n        unordered_map<int,int> mp;\\n        sort(a.begin(),a.end());\\n        mp[a[n-1]%s]++;\\n        for(int i=n-2;i>=0;i--){\\n            int len=1+mp[a[i]%s];\\n            if(len>=mlen){\\n                ans=a[i];\\n                mlen=len;\\n            }\\n            mp[a[i]%s]++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2813364,
                "title": "c-simple-approach-with-explaination-o-n-map",
                "content": "# Approach\\na+c * space = b\\nc * space = b-a\\n(c*space)%space = (b-a)%space\\n(b-a)%space = 0\\nb%space - a%space =0\\na%space = b%space\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int> mp;\\n        int maxVal=0;\\n        int ans=INT_MAX;\\n        for(auto& num:nums){\\n            mp[num%space]++;\\n            maxVal=max(maxVal,mp[num%space]);\\n        }\\n        \\n        for(auto& num:nums){\\n            if(mp[num%space]==maxVal){\\n                 ans=min(ans,num);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int> mp;\\n        int maxVal=0;\\n        int ans=INT_MAX;\\n        for(auto& num:nums){\\n            mp[num%space]++;\\n            maxVal=max(maxVal,mp[num%space]);\\n        }\\n        \\n        for(auto& num:nums){\\n            if(mp[num%space]==maxVal){\\n                 ans=min(ans,num);\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792176,
                "title": "java-solution-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        int n = nums.length;\\n\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n    \\n        for(int i = 0 ; i < n ; i++){\\n            int reminder = nums[i] % space;\\n            int freq = map.getOrDefault(reminder , 0);\\n            map.put(reminder , freq+1);\\n        }\\n\\n        int maxCount = 0;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int count : map.values()){\\n            maxCount = Math.max(count , maxCount);\\n        }\\n\\n        for(int val : nums){\\n            if(map.get(val%space) == maxCount){\\n                ans = Math.min(ans , val);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        int n = nums.length;\\n\\n        HashMap<Integer , Integer> map = new HashMap<>();\\n    \\n        for(int i = 0 ; i < n ; i++){\\n            int reminder = nums[i] % space;\\n            int freq = map.getOrDefault(reminder , 0);\\n            map.put(reminder , freq+1);\\n        }\\n\\n        int maxCount = 0;\\n        int ans = Integer.MAX_VALUE;\\n\\n        for(int count : map.values()){\\n            maxCount = Math.max(count , maxCount);\\n        }\\n\\n        for(int val : nums){\\n            if(map.get(val%space) == maxCount){\\n                ans = Math.min(ans , val);\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792011,
                "title": "using-hash-map-in-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int>mp;\\n        int high=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n             mp[nums[i]%space]++;\\n             high=max(high,mp[nums[i]%space]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]%space]==high){\\n                ans=min(ans,nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int>mp;\\n        int high=INT_MIN;\\n        for(int i=0;i<nums.size();i++){\\n             mp[nums[i]%space]++;\\n             high=max(high,mp[nums[i]%space]);\\n        }\\n        int ans=INT_MAX;\\n        for(int i=0;i<nums.size();i++){\\n            if(mp[nums[i]%space]==high){\\n                ans=min(ans,nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788846,
                "title": "intuitive-mod",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    struct Rec {\\n        int cnt {0};\\n        int min_val {INT_MAX};\\n    };\\n\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, Rec> hits;\\n\\n        int res = INT_MAX;\\n        int max_hits = 0;\\n\\n        for (auto n : nums) {\\n            auto t = n % space;\\n            hits[t].cnt++;\\n            hits[t].min_val = min(hits[t].min_val, n);\\n            if (hits[t].cnt > max_hits) {\\n                max_hits = hits[t].cnt;\\n                res = hits[t].min_val;\\n            } else if (hits[t].cnt == max_hits) {\\n                res = min(res, hits[t].min_val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n\\n    struct Rec {\\n        int cnt {0};\\n        int min_val {INT_MAX};\\n    };\\n\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, Rec> hits;\\n\\n        int res = INT_MAX;\\n        int max_hits = 0;\\n\\n        for (auto n : nums) {\\n            auto t = n % space;\\n            hits[t].cnt++;\\n            hits[t].min_val = min(hits[t].min_val, n);\\n            if (hits[t].cnt > max_hits) {\\n                max_hits = hits[t].cnt;\\n                res = hits[t].min_val;\\n            } else if (hits[t].cnt == max_hits) {\\n                res = min(res, hits[t].min_val);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2788048,
                "title": "c-98-memory-usage-hashtable",
                "content": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> reminder;\\n        int mx = INT_MIN;\\n\\t\\t// find the max num of destroied targets\\n        for(const int& num: nums) {\\n            int r = num % space;\\n            if(!reminder[r])    reminder[r] = 0;\\n            reminder[r]++;\\n            if(reminder[r] > mx)    mx = reminder[r];\\n        }\\n\\t\\t// find the min position\\n        int pos = INT_MAX;\\n        for(const int& num: nums) {\\n            if(reminder[num % space] == mx) {\\n                pos = min(num, pos);\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int, int> reminder;\\n        int mx = INT_MIN;\\n\\t\\t// find the max num of destroied targets\\n        for(const int& num: nums) {\\n            int r = num % space;\\n            if(!reminder[r])    reminder[r] = 0;\\n            reminder[r]++;\\n            if(reminder[r] > mx)    mx = reminder[r];\\n        }\\n\\t\\t// find the min position\\n        int pos = INT_MAX;\\n        for(const int& num: nums) {\\n            if(reminder[num % space] == mx) {\\n                pos = min(num, pos);\\n            }\\n        }\\n        return pos;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787607,
                "title": "my-logic-seems-to-be-correct-what-am-i-doing-wrong",
                "content": "I basically applied the logic for longest consecutive sequence but its giving WA for the below 2 testcases\\nAm I understanding the question wrong?\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        long long int max_count = -1, curr_count = 1, ans = -1;\\n        set<long long int> s(nums.begin(), nums.end());\\n        map<long long int, long long int> m;\\n        for(int i = 0; i < nums.size(); i++)\\n            m[nums[i]]++;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(s.find(nums[i] - space) == s.end()){\\n                curr_count = 0;\\n                int k = 0;\\n                while(s.find(nums[i] + k * space) != s.end()){\\n                    k++;\\n                    curr_count+=m[nums[i]];\\n                }\\n                if(max_count < curr_count){\\n                    max_count = curr_count;\\n                    ans = nums[i];\\n                }\\n                if(max_count == curr_count){\\n                    ans = min(ans, (long long) nums[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nTC: 1\\n[625879766,235326233,250224393,501422042,683823101,948619719,680305710,733191937,182186779,353350082]\\n4\\nMy Answer: 182186779           Correct Answer: 235326233\\n\\nTC: 2\\n[810,570,844,373,108,124,348,786,717,536,364,315,619,483,640,865,814,738,465,199,413,494,249,824,886,36,418,846,57,5,84,471,846,918,345,248,929,999,160,591,279,30,652,334,965,302,928,849,161,486,208,5,695,598,153,962,634,198,930,906,307,651,399,568,185,480,667,511,955,791,344,532,258,275,493,675,66,538,907,201,236,377,546,901,420,273,397,228,187,341,608,539,256,183,776,162,995,781,340,494]\\n4\\nMy Answer: 340                Correct Answer: 30\\nfor this 340 has 3 seeds while 30 has only 1",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        long long int max_count = -1, curr_count = 1, ans = -1;\\n        set<long long int> s(nums.begin(), nums.end());\\n        map<long long int, long long int> m;\\n        for(int i = 0; i < nums.size(); i++)\\n            m[nums[i]]++;\\n        for(int i = 0; i < nums.size(); i++){\\n            if(s.find(nums[i] - space) == s.end()){\\n                curr_count = 0;\\n                int k = 0;\\n                while(s.find(nums[i] + k * space) != s.end()){\\n                    k++;\\n                    curr_count+=m[nums[i]];\\n                }\\n                if(max_count < curr_count){\\n                    max_count = curr_count;\\n                    ans = nums[i];\\n                }\\n                if(max_count == curr_count){\\n                    ans = min(ans, (long long) nums[i]);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782566,
                "title": "python-5-lines-o-n",
                "content": "```python\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        hmap = defaultdict(lambda: [0, inf])  # len, min_val\\n        for n in nums:\\n            hmap[n % space][0] += 1\\n            hmap[n % space][1] = min(hmap[n % space][1], n)                  \\n        return max(hmap.values(), key=lambda x: (x[0], -x[1]))[1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        hmap = defaultdict(lambda: [0, inf])  # len, min_val\\n        for n in nums:\\n            hmap[n % space][0] += 1\\n            hmap[n % space][1] = min(hmap[n % space][1], n)                  \\n        return max(hmap.values(), key=lambda x: (x[0], -x[1]))[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2782069,
                "title": "ruby-solution",
                "content": "```\\n# @param {Integer[]} nums\\n# @param {Integer} space\\n# @return {Integer}\\ndef destroy_targets(nums, space)\\n    mod_hash = Hash.new\\n    nums.each do |num|\\n        if mod_hash[num % space]==nil\\n            mod_hash[num % space]=[num]\\n        else\\n            mod_hash[num % space]<<num\\n        end\\n    end\\n    \\n    # Now the magic: the hash values are arrays of values with the same modulus result, so we need\\n    # to (1) find the smallest of the values of the (2) longest arrays. So sort for first length, then,\\n    # where lengths are equal, the smallest value.\\n    mod_hash.values.map {|val| val.sort }.sort {|a,b| [-a.length, a] <=> [-b.length, b]}[0][0]\\nend\\n",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} space\\n# @return {Integer}\\ndef destroy_targets(nums, space)\\n    mod_hash = Hash.new\\n    nums.each do |num|\\n        if mod_hash[num % space]==nil\\n            mod_hash[num % space]=[num]\\n        else\\n            mod_hash[num % space]<<num\\n        end\\n    end\\n    \\n    # Now the magic: the hash values are arrays of values with the same modulus result, so we need\\n    # to (1) find the smallest of the values of the (2) longest arrays. So sort for first length, then,\\n    # where lengths are equal, the smallest value.\\n    mod_hash.values.map {|val| val.sort }.sort {|a,b| [-a.length, a] <=> [-b.length, b]}[0][0]\\nend\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2781458,
                "title": "simple-c-solution-with-map-and-modulus",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Sort and brute force. Later on, thought occured that we can keep track of num%space.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> keep a map to track num%space and keep increasing the counter whenever we encounter a number with the same remainder.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ --> \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int maxTargets = INT_MIN;\\n        unordered_map<int, int> numOfSpaceModulo;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            numOfSpaceModulo[nums[i]%space]++;\\n\\n            if(maxTargets < numOfSpaceModulo[nums[i]%space])\\n            {\\n                maxTargets = numOfSpaceModulo[nums[i]%space];\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(auto &num : nums)\\n        {\\n            if(maxTargets == numOfSpaceModulo[num%space])\\n            {\\n                ans = min(ans, num);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int maxTargets = INT_MIN;\\n        unordered_map<int, int> numOfSpaceModulo;\\n\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            numOfSpaceModulo[nums[i]%space]++;\\n\\n            if(maxTargets < numOfSpaceModulo[nums[i]%space])\\n            {\\n                maxTargets = numOfSpaceModulo[nums[i]%space];\\n            }\\n        }\\n        \\n        int ans = INT_MAX;\\n        for(auto &num : nums)\\n        {\\n            if(maxTargets == numOfSpaceModulo[num%space])\\n            {\\n                ans = min(ans, num);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2781287,
                "title": "java-easy-to-understand-with-explanation-o-nlogn",
                "content": "Intution:\\n1. nums[i] + c * space = num[j],\\n2. ( nums[i] - nums[j] ) % space = 0\\n3. nums[i] % space = nums[j] % space\\n\\nApproach:\\n1. From above explanation, we understand that we have to count, num[i]%space, whoever has maximum nums[i]%space, answer will be from that nums[i], but we have to take minimum nums[i].\\n\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int maxFrq=0;\\n        for(int i:nums){\\n\\t\\t// counting the nums[i] % space\\n            int tmp=i%space;\\n            map.put(tmp,map.getOrDefault(tmp,0)+1);\\n            if(map.get(tmp)>maxFrq){\\n\\t\\t\\t// keep track of maximum frq\\n                maxFrq=map.get(tmp);\\n            }\\n        }\\n        for(int i:nums){\\n\\t\\t// as array is sorted , first nums[i] who give that maxFrq in map will be the answer\\n            if(map.get(i%space)==maxFrq){\\n                return i;\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums);\\n        Map<Integer,Integer>map=new HashMap<>();\\n        int maxFrq=0;\\n        for(int i:nums){\\n\\t\\t// counting the nums[i] % space\\n            int tmp=i%space;\\n            map.put(tmp,map.getOrDefault(tmp,0)+1);\\n            if(map.get(tmp)>maxFrq){\\n\\t\\t\\t// keep track of maximum frq\\n                maxFrq=map.get(tmp);\\n            }\\n        }\\n        for(int i:nums){\\n\\t\\t// as array is sorted , first nums[i] who give that maxFrq in map will be the answer\\n            if(map.get(i%space)==maxFrq){\\n                return i;\\n            }\\n        }\\n        return nums[0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2780804,
                "title": "hashmap-approach-java-solution",
                "content": "```java\\npublic int destroyTargets(int[] nums, int space) {\\n        Map<Integer,int[]> mp = new HashMap<>();\\n        for(var n:nums){\\n            int r = n % space;\\n            if(!mp.containsKey(r)){\\n                mp.put(r,new int[]{Integer.MAX_VALUE,0});\\n            }\\n            int[] t = mp.get(r);\\n            t[0] = Math.min(t[0],n);\\n            t[1]++;\\n            mp.put(r,t);\\n        }\\n        int max = 0;\\n        int ans = 0;\\n        for(var ent:mp.entrySet()){\\n            int[] a = ent.getValue();\\n            if(max < a[1]){\\n                max = a[1];\\n                ans = a[0];\\n            }\\n            else if(max == a[1]) ans = Math.min(ans,a[0]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int destroyTargets(int[] nums, int space) {\\n        Map<Integer,int[]> mp = new HashMap<>();\\n        for(var n:nums){\\n            int r = n % space;\\n            if(!mp.containsKey(r)){\\n                mp.put(r,new int[]{Integer.MAX_VALUE,0});\\n            }\\n            int[] t = mp.get(r);\\n            t[0] = Math.min(t[0],n);\\n            t[1]++;\\n            mp.put(r,t);\\n        }\\n        int max = 0;\\n        int ans = 0;\\n        for(var ent:mp.entrySet()){\\n            int[] a = ent.getValue();\\n            if(max < a[1]){\\n                max = a[1];\\n                ans = a[0];\\n            }\\n            else if(max == a[1]) ans = Math.min(ans,a[0]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2780375,
                "title": "simple-and-fast-solution-beats-80-submission",
                "content": "# Brute Force\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n Brute Force Solution of this problem  could be first sort the elements of the array and then start from 0th index to find out how many elements are there in its right(1 2 --- n-1th index) which could be reached from it . repeat above process for all the elements and calulate which minimum element can reach maximum number of elements.\\n\\n# Optimized approach\\nBefore moving to the algorithm we have to look at  the some observation\\n **nums[j]** could be reached from **nums[i]**  iff \\n**nums[j]=nums[i]+c * space**    // condition 1\\n**nums[j]-nums[i]=c * space**\\nso for **(nums[j]-nums[i])** be multiple of space result of the  **nums[j]%space** should be equal to **nums[i]%space**;\\n\\ni.e **nums[j]=c1 * space + q**  //q < space; \\n    **nums[i]=c2 * space + q**  //q < space; \\n\\nso from here we can conclude that all the group  of the elements  which have exact same result of the mudulo operation wrt **space**  can be reached from the minimum elements of that group.\\n\\n\\n\\n\\n\\n# Algo\\n<!-- Describe your approach to solving the problem. -->\\n\\n Group all the elements whose modulo result wrt **space** are same with key as result of modulo operation and value as pair of integer whose first value is number of elements in the group and second  value is minimum elemenst of that group.\\n**MOD= element%space**    //  **element** belong to **G**;\\n**map[MOD]={x,y}**\\nwhere **x**  is total number of elements in group **G**\\n     **y** is minimum element of **G**\\n\\n Then find out which group have maximum number of the elements and retur minimum elements of that group.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n      \\n      \\n     \\n      \\n      unordered_map<int,pair<int,int>>mp;\\n      int n=nums.size();\\n      int MOD;\\n      for(int i=0;i<n;i++){\\n        \\n          MOD =nums[i]%space;\\n        if(mp.find(MOD)!=mp.end()){\\n                       mp[MOD].first++;\\n          \\n          if(mp[MOD].second > nums[i])\\n                     mp[MOD].second=nums[i];\\n          \\n                              }\\n        else\\n          mp[MOD]={1,nums[i]};\\n             \\n        \\n        \\n                                 }\\n                 \\n      \\n      \\n      int ans=INT_MIN,ans1;\\n      for(auto it=mp.begin();it!=mp.end();it++){\\n        \\n        \\n        \\n        if(it->second.first >ans){\\n             ans=it->second.first;\\n            ans1=it->second.second;\\n                                 }\\n        \\n        else if(it->second.first==ans&&it->second.second<ans1)\\n             ans1=it->second.second;\\n             \\n                               }\\n\\n               \\n        \\n      return ans1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n      \\n      \\n     \\n      \\n      unordered_map<int,pair<int,int>>mp;\\n      int n=nums.size();\\n      int MOD;\\n      for(int i=0;i<n;i++){\\n        \\n          MOD =nums[i]%space;\\n        if(mp.find(MOD)!=mp.end()){\\n                       mp[MOD].first++;\\n          \\n          if(mp[MOD].second > nums[i])\\n                     mp[MOD].second=nums[i];\\n          \\n                              }\\n        else\\n          mp[MOD]={1,nums[i]};\\n             \\n        \\n        \\n                                 }\\n                 \\n      \\n      \\n      int ans=INT_MIN,ans1;\\n      for(auto it=mp.begin();it!=mp.end();it++){\\n        \\n        \\n        \\n        if(it->second.first >ans){\\n             ans=it->second.first;\\n            ans1=it->second.second;\\n                                 }\\n        \\n        else if(it->second.first==ans&&it->second.second<ans1)\\n             ans1=it->second.second;\\n             \\n                               }\\n\\n               \\n        \\n      return ans1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2778353,
                "title": "mathematical-explanation-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\na+c*space=b\\nc*space = b-a\\nc*space%space=(b-a)%space\\n-> since space%space=0 : hence c*0\\nc*0 = (b-a)%space\\n0=b%space - a%space\\nb%space = a%space\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\naccording to the formula the numbers which have the same remainder after dividning with  space come under the same grp where the smallest will divide the others with the formula.\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer,PriorityQueue<Integer>> ans = new HashMap<>();\\n        for(int i : nums){\\n            int num = i%space;\\n            if(!ans.containsKey(num)){\\n                ans.put(num,new PriorityQueue<>());\\n            }\\n            ans.get(num).add(i);\\n        }\\n        // System.out.println(ans);\\n        int max = -1,size=0;\\n        for(int i : ans.keySet()){\\n            if(size<ans.get(i).size()||(size==ans.get(i).size() && ans.get(max).peek()>ans.get(i).peek())){\\n                size=ans.get(i).size();\\n                max=i;\\n            }\\n        }\\n        return ans.get(max).poll();\\n    }    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        HashMap<Integer,PriorityQueue<Integer>> ans = new HashMap<>();\\n        for(int i : nums){\\n            int num = i%space;\\n            if(!ans.containsKey(num)){\\n                ans.put(num,new PriorityQueue<>());\\n            }\\n            ans.get(num).add(i);\\n        }\\n        // System.out.println(ans);\\n        int max = -1,size=0;\\n        for(int i : ans.keySet()){\\n            if(size<ans.get(i).size()||(size==ans.get(i).size() && ans.get(max).peek()>ans.get(i).peek())){\\n                size=ans.get(i).size();\\n                max=i;\\n            }\\n        }\\n        return ans.get(max).poll();\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2777313,
                "title": "c-simple-map-solution",
                "content": "# Intuition\\n- The element with same remainder after dividing by space can be destroyed together\\n- nums[i] + c*space = target\\n- as for each target we are adding some factor of space\\n\\n\\n# Approach\\n- use map to store the count of every possible remainder\\n- store the remainder with maximum count in m\\n- find the minimum element in nums which satisfy above criteria i.e. (nums[i]%space == m)\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n    int destroyTargets(vector<int> &nums, int space)\\n    {\\n        map<int, int> mp;\\n        int m = 0;\\n        for (auto &x : nums)\\n        {\\n            mp[x % space]++;\\n            m = max(m, mp[x % space]);\\n        }\\n        int ans = INT_MAX;\\n        for (auto &x : nums)\\n            if (mp[x % space] == m)\\n                ans = min(ans, x);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int destroyTargets(vector<int> &nums, int space)\\n    {\\n        map<int, int> mp;\\n        int m = 0;\\n        for (auto &x : nums)\\n        {\\n            mp[x % space]++;\\n            m = max(m, mp[x % space]);\\n        }\\n        int ans = INT_MAX;\\n        for (auto &x : nums)\\n            if (mp[x % space] == m)\\n                ans = min(ans, x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774793,
                "title": "c-simple-hashmap-math",
                "content": "The elements with same remainder module by space,\\ncan be destroyed together.\\nCount the frequency of A[i] % space.\\nThe maximum frequency maxe is the the maximum number of targets we can destroy.\\nFind the minimum element A[i] that A[i] % space = maxe.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int> m;\\n        int maxe = INT_MIN;\\n        for(auto it : nums)\\n        {\\n            m[it%space]++;\\n            maxe = max(maxe , m[it%space]);\\n        }\\n        sort(nums.begin() , nums.end());\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if(maxe == m[nums[i]%space]) return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        map<int,int> m;\\n        int maxe = INT_MIN;\\n        for(auto it : nums)\\n        {\\n            m[it%space]++;\\n            maxe = max(maxe , m[it%space]);\\n        }\\n        sort(nums.begin() , nums.end());\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            if(maxe == m[nums[i]%space]) return nums[i];\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773080,
                "title": "counter-python",
                "content": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        count = Counter(n % space for n in nums)\\n        mxFreq = max(count.values())\\n        ans = float(\\'inf\\')\\n        for n in nums:\\n            if count[n % space] == mxFreq:\\n                ans = min(ans, n)\\n        return ans\\n    # Time: O(N) where N is the length of nums\\n    # Space: O(M) where M is space, since counter has at most space keys.\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        count = Counter(n % space for n in nums)\\n        mxFreq = max(count.values())\\n        ans = float(\\'inf\\')\\n        for n in nums:\\n            if count[n % space] == mxFreq:\\n                ans = min(ans, n)\\n        return ans\\n    # Time: O(N) where N is the length of nums\\n    # Space: O(M) where M is space, since counter has at most space keys.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2771952,
                "title": "javascript-from-brute-force-to-optimal-solution",
                "content": "1. Brute force - n^2 time\\n```\\nvar destroyTargets = function(nums, space) {\\n  let min = Infinity\\n  let maxFreq = -Infinity\\n    \\n  for(let i = 0; i < nums.length; i++) {\\n    const map = {}\\n    \\n    //Take num one by one and check how many other numbers have the same remainder\\n    // If they have the same remainder it means, they can be recreated with nums[i] + c*space as\\n    // if num = nums[i] + c*space then \\n    // num/space = nums[i]/space + c\\n    const currSelected = nums[i]\\n    const remainder = currSelected%space\\n      \\n    if(!(currSelected in map)) map[currSelected] = 0\\n    for(let j = 0; j < nums.length; j++) {\\n      const curr = nums[j]\\n      if(curr%space=== remainder) {\\n          map[currSelected]++\\n      }\\n     }\\n      \\n\\t // 2. Select smallest num with highest frequency\\n    for(const key in map) {\\n       const val = map[key] \\n       \\n       if(val > maxFreq) {\\n           maxFreq = val\\n           min = Number(key)\\n       } else if(val===maxFreq) {\\n           if(Number(key) < min) {\\n               min = Number(key)\\n           }\\n       }\\n    }\\n  }  \\n  \\n  return min\\n};\\n```\\n\\n2. Optimized\\n```\\nvar destroyTargets = function(nums, space) {\\n    let maxFreq = 0\\n    const map = {}\\n    \\n    // 1. Check for repeated remainder, it remainder the same, it means the number can be recreated with nums[i]+c*space\\n    for(let i = 0; i < nums.length; i++) {\\n        const curr = nums[i]\\n        const remainder = nums[i] % space\\n        \\n        if(!(remainder in map)) map[remainder] = 0\\n        map[remainder]++\\n        maxFreq = Math.max(maxFreq, map[remainder])\\n    }\\n    \\n    // 2. Select smallest num with highest frequency\\n    let res = Infinity\\n    for(let i = 0; i < nums.length; i++) {\\n        const curr = nums[i]\\n        const remainder = nums[i] % space\\n        \\n        if(map[remainder]===maxFreq) {\\n            if(res > curr) {\\n                res = curr\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar destroyTargets = function(nums, space) {\\n  let min = Infinity\\n  let maxFreq = -Infinity\\n    \\n  for(let i = 0; i < nums.length; i++) {\\n    const map = {}\\n    \\n    //Take num one by one and check how many other numbers have the same remainder\\n    // If they have the same remainder it means, they can be recreated with nums[i] + c*space as\\n    // if num = nums[i] + c*space then \\n    // num/space = nums[i]/space + c\\n    const currSelected = nums[i]\\n    const remainder = currSelected%space\\n      \\n    if(!(currSelected in map)) map[currSelected] = 0\\n    for(let j = 0; j < nums.length; j++) {\\n      const curr = nums[j]\\n      if(curr%space=== remainder) {\\n          map[currSelected]++\\n      }\\n     }\\n      \\n\\t // 2. Select smallest num with highest frequency\\n    for(const key in map) {\\n       const val = map[key] \\n       \\n       if(val > maxFreq) {\\n           maxFreq = val\\n           min = Number(key)\\n       } else if(val===maxFreq) {\\n           if(Number(key) < min) {\\n               min = Number(key)\\n           }\\n       }\\n    }\\n  }  \\n  \\n  return min\\n};\\n```\n```\\nvar destroyTargets = function(nums, space) {\\n    let maxFreq = 0\\n    const map = {}\\n    \\n    // 1. Check for repeated remainder, it remainder the same, it means the number can be recreated with nums[i]+c*space\\n    for(let i = 0; i < nums.length; i++) {\\n        const curr = nums[i]\\n        const remainder = nums[i] % space\\n        \\n        if(!(remainder in map)) map[remainder] = 0\\n        map[remainder]++\\n        maxFreq = Math.max(maxFreq, map[remainder])\\n    }\\n    \\n    // 2. Select smallest num with highest frequency\\n    let res = Infinity\\n    for(let i = 0; i < nums.length; i++) {\\n        const curr = nums[i]\\n        const remainder = nums[i] % space\\n        \\n        if(map[remainder]===maxFreq) {\\n            if(res > curr) {\\n                res = curr\\n            }\\n        }\\n    }\\n    \\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2769093,
                "title": "javascript-greedy-238ms",
                "content": "\\n```\\nconst destroyTargets = (a, space) => {\\n    let m = new Map(), res = 0, max = 0;\\n    for (const x of a) {\\n        let rem = x % space;\\n        if (!m.has(rem)) m.set(rem, []);\\n        m.get(rem).push(x);\\n    }\\n    for (const [, d] of m) {\\n        if (d.length > max) {\\n            max = d.length;\\n            res = Math.min(...d);\\n        } else if (d.length == max) {\\n            res = Math.min(res, Math.min(...d));\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst destroyTargets = (a, space) => {\\n    let m = new Map(), res = 0, max = 0;\\n    for (const x of a) {\\n        let rem = x % space;\\n        if (!m.has(rem)) m.set(rem, []);\\n        m.get(rem).push(x);\\n    }\\n    for (const [, d] of m) {\\n        if (d.length > max) {\\n            max = d.length;\\n            res = Math.min(...d);\\n        } else if (d.length == max) {\\n            res = Math.min(res, Math.min(...d));\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2768760,
                "title": "c-easy-explanation-well-commented-code",
                "content": "I have put the whole explanation in a well commented format, which would be easier rather than explaning first and then writing the code. \\n**Please upVote if you like it! :D**\\nAll the best!\\n\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //Base case\\n        int n=nums.size();\\n        if(n==1){\\n            return nums[0];\\n        }\\n        //to make sure that we get the smallest value accordingly, as is asked in the question\\n        sort(nums.begin(),nums.end());\\n        \\n        /*                                               **SOME THEORY**\\n        // Here we can do one thing mathematically. Let ai be the seeding element and bi be the corresponding integer in the nums array\\n        // So, ai + c*space = bi  ==>  bi - ai = c*space  ==>  (bi - ai)%space = c*space%space  ==>  (bi - ai)%space = 0  ==>  \\n        // bi%space = ai%space  ==> We have a pair ai and bi, which will both be destroyed if we seed the gun with ai.\\n        // ==> 1.) All the elements bi\\'s, which satisfy this condition:  (ai%space == bi%space)  will be destroyed\\n        // ==> 2.) We can, in the nums array, devide all the elements with space number, only as we only care about remainders!!\\n        // ==> 3.) Once we have all remainders, we can simply see which remainder has the highest frequency, and hence get the value \\n        // in nums, which is the least, corresponding to that remainder value. \\n        */ \\n        \\n        //map for remainder vs freq of that remainder value\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            mp[rem]++;\\n        }\\n        //Finding the maximum freq of the remainder & corresponding rem for which that max freq is there\\n        int maxRemFreq=0;\\n        int reqRem=0;\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            if(mp[rem]>maxRemFreq){\\n                maxRemFreq=mp[rem];\\n                reqRem=rem;\\n            }\\n        }\\n        //Finally finding that smallest element in nums with this target remainder value\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            if(rem==reqRem){\\n                ans=nums[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        //Base case\\n        int n=nums.size();\\n        if(n==1){\\n            return nums[0];\\n        }\\n        //to make sure that we get the smallest value accordingly, as is asked in the question\\n        sort(nums.begin(),nums.end());\\n        \\n        /*                                               **SOME THEORY**\\n        // Here we can do one thing mathematically. Let ai be the seeding element and bi be the corresponding integer in the nums array\\n        // So, ai + c*space = bi  ==>  bi - ai = c*space  ==>  (bi - ai)%space = c*space%space  ==>  (bi - ai)%space = 0  ==>  \\n        // bi%space = ai%space  ==> We have a pair ai and bi, which will both be destroyed if we seed the gun with ai.\\n        // ==> 1.) All the elements bi\\'s, which satisfy this condition:  (ai%space == bi%space)  will be destroyed\\n        // ==> 2.) We can, in the nums array, devide all the elements with space number, only as we only care about remainders!!\\n        // ==> 3.) Once we have all remainders, we can simply see which remainder has the highest frequency, and hence get the value \\n        // in nums, which is the least, corresponding to that remainder value. \\n        */ \\n        \\n        //map for remainder vs freq of that remainder value\\n        unordered_map<int,int> mp;\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            mp[rem]++;\\n        }\\n        //Finding the maximum freq of the remainder & corresponding rem for which that max freq is there\\n        int maxRemFreq=0;\\n        int reqRem=0;\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            if(mp[rem]>maxRemFreq){\\n                maxRemFreq=mp[rem];\\n                reqRem=rem;\\n            }\\n        }\\n        //Finally finding that smallest element in nums with this target remainder value\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            int rem=nums[i]%space;\\n            if(rem==reqRem){\\n                ans=nums[i];\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2768648,
                "title": "javascript-hashmap",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} space\\n * @return {number}\\n */\\nvar destroyTargets = function (nums, space) {\\n  let maxCount = -Infinity;\\n  const map = {};\\n\\n  for (const num of nums) {\\n    const reminder = num % space;\\n    map[reminder] = (map[reminder] || 0) + 1;\\n    maxCount = Math.max(maxCount, map[reminder]);\\n  }\\n\\n  let ans = Infinity;\\n  for (const num of nums) {\\n    if (map[num % space] === maxCount) {\\n      ans = Math.min(ans, num);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} space\\n * @return {number}\\n */\\nvar destroyTargets = function (nums, space) {\\n  let maxCount = -Infinity;\\n  const map = {};\\n\\n  for (const num of nums) {\\n    const reminder = num % space;\\n    map[reminder] = (map[reminder] || 0) + 1;\\n    maxCount = Math.max(maxCount, map[reminder]);\\n  }\\n\\n  let ans = Infinity;\\n  for (const num of nums) {\\n    if (map[num % space] === maxCount) {\\n      ans = Math.min(ans, num);\\n    }\\n  }\\n\\n  return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2768598,
                "title": "c-concise-o-n",
                "content": "```\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,pair<int,int>> m; //mod, {cnt, min}\\n        int maxCnt = 0, xmin = 1e9;\\n        for(auto x:nums){\\n            auto& [cnt, xmin] = m[x%space];\\n            cnt++;\\n            maxCnt = max(maxCnt, cnt);\\n            if(xmin == 0) xmin = x;\\n            else xmin = min(xmin, x);\\n        }\\n        for(auto& [mod, p] : m)\\n            if(p.first == maxCnt) xmin = min(xmin, p.second);\\n        return xmin;\\n    }",
                "solutionTags": [],
                "code": "```\\n    int destroyTargets(vector<int>& nums, int space) {\\n        unordered_map<int,pair<int,int>> m; //mod, {cnt, min}\\n        int maxCnt = 0, xmin = 1e9;\\n        for(auto x:nums){\\n            auto& [cnt, xmin] = m[x%space];\\n            cnt++;\\n            maxCnt = max(maxCnt, cnt);\\n            if(xmin == 0) xmin = x;\\n            else xmin = min(xmin, x);\\n        }\\n        for(auto& [mod, p] : m)\\n            if(p.first == maxCnt) xmin = min(xmin, p.second);\\n        return xmin;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2767754,
                "title": "python3-count-num-k-o-n-solution",
                "content": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        container = {}\\n        currmax = float(\"-inf\")\\n        for num in nums:\\n            container[num % space] = container.get(num % space, 0) + 1\\n            currmax = max(currmax, container[num % space])\\n        \\n        # print(container, currmax)\\n        res = float(\"inf\")\\n        for num in nums:\\n            if container[num % space] == currmax:\\n                res = min(res, num)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        container = {}\\n        currmax = float(\"-inf\")\\n        for num in nums:\\n            container[num % space] = container.get(num % space, 0) + 1\\n            currmax = max(currmax, container[num % space])\\n        \\n        # print(container, currmax)\\n        res = float(\"inf\")\\n        for num in nums:\\n            if container[num % space] == currmax:\\n                res = min(res, num)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766934,
                "title": "one-pass-no-sorting-59-speed",
                "content": "![image](https://assets.leetcode.com/users/images/9c547696-7cd4-45be-ab9b-a25f9b2def33_1667310421.0064335.png)\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        d = dict()\\n        for n in nums:\\n            rem = n % space\\n            if rem in d:\\n                if n < d[rem][1]:\\n                    d[rem][1] = n\\n                d[rem][0] -= 1\\n            else:\\n                d[rem] = [-1, n]\\n        return min(d.values())[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        d = dict()\\n        for n in nums:\\n            rem = n % space\\n            if rem in d:\\n                if n < d[rem][1]:\\n                    d[rem][1] = n\\n                d[rem][0] -= 1\\n            else:\\n                d[rem] = [-1, n]\\n        return min(d.values())[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766464,
                "title": "c-solution-using-modulo-and-map",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        map<int,pair<int,int>> m; // <nums[x]%space,<count,smallest>>\\n        int k=space;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(m.find(nums[x]%k)!=m.end())\\n            {\\n                m[nums[x]%k].first++;\\n            }\\n            else\\n            {\\n                m[nums[x]%k]={1,nums[x]};\\n            }\\n        }\\n        vector<pair<int,int>> vp;\\n        for(auto it: m)\\n        {\\n            vp.push_back({it.second.first,it.second.second});\\n        }\\n        sort(vp.begin(),vp.end(), greater<pair<int,int>> ());\\n        int i=0;\\n        while(i+1<vp.size() && vp[i].first==vp[i+1].first)\\n        {\\n            i++;\\n        }\\n        return vp[i].second;\\n    }\\n};\\n\\n\\n// Kshipra Malviya",
                "solutionTags": [],
                "code": "class Solution \\n{\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) \\n    {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        map<int,pair<int,int>> m; // <nums[x]%space,<count,smallest>>\\n        int k=space;\\n        for(int x=0; x<n; x++)\\n        {\\n            if(m.find(nums[x]%k)!=m.end())\\n            {\\n                m[nums[x]%k].first++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2764318,
                "title": "get-the-minimum-number-with-maximum-frequency-of-num-space",
                "content": "all numbers in nums is a function A + c * space\\nx = A + c * space\\nx - A = c * space\\nx % space - A % space = c\\nx % space = c + A % space (A % space is fixed if A is choosen)\\n\\nLet\\'s observe the arr\\n\\n    //  nums         = [3,7,8,1,1,5], space = 2\\n    //  n%space      [1,1,0,1,1,1]\\n        \\n\\t\\t// [1,3,5,2,4,6], space = 2\\n        // [1, 1, 1, 0, 0, 0]\\n        \\n        // [6,2,5] space = 100\\n        // [6,2,5]\\n\\nSo we should find the number with max frequency, then choose the smallest A\\n\\n```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int n = nums.size();\\n        int maxCount = 1;\\n        \\n        \\n        // find the frequency of num % space\\n        // check minimum number with the highest freq\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            if (++counter[nums[i] % space] > maxCount) {\\n                maxCount = counter[nums[i] % space];\\n            }\\n        }\\n        \\n        int target = INT_MAX;        \\n        for (int i = 0; i < n; i++) {\\n            if (counter[nums[i] % space] == maxCount) {\\n                target = min(target, nums[i]);\\n            }\\n        }        \\n        return target;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        int n = nums.size();\\n        int maxCount = 1;\\n        \\n        \\n        // find the frequency of num % space\\n        // check minimum number with the highest freq\\n        unordered_map<int, int> counter;\\n        for (int i = 0; i < n; i++) {\\n            if (++counter[nums[i] % space] > maxCount) {\\n                maxCount = counter[nums[i] % space];\\n            }\\n        }\\n        \\n        int target = INT_MAX;        \\n        for (int i = 0; i < n; i++) {\\n            if (counter[nums[i] % space] == maxCount) {\\n                target = min(target, nums[i]);\\n            }\\n        }        \\n        return target;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762718,
                "title": "c-code",
                "content": "class Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        int maxi=-1e9;\\n        int rem=0;\\n        map<int,int> map;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            map[nums[i]%space]++;\\n                maxi=max(maxi,map[nums[i]%space]); \\n         }\\n\\t\\t \\n        int ans=INT_MAX;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            if(map[nums[i]%space]==maxi)\\n            {\\n                ans=min(ans,nums[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        \\n        int maxi=-1e9;\\n        int rem=0;\\n        map<int,int> map;\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            map[nums[i]%space]++;\\n                maxi=max(maxi,map[nums[i]%space]); \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 2762675,
                "title": "c-bucketing-by-modulo-166ms-66-3mb",
                "content": "This one was rather straightforward: just group the elements by buckets depending on their modulo and pick the lowest value matching the bucket with the most elements in (ie: the most \"targets\"): if we can destroy each elements given a starting value `nums[i]` so that we can reach all the ones adding `c * space` to it for any `c` we want, then we are just going to find all the elements that are found by multiples of `space`, plus the same constant (the modulo).\\n\\nTo progress with our solution, we will first of all declare a few support variables:\\n* `maxTargets` will store what is the maximum amount of elements we can erase in one bucket, initially set to `0`;\\n* `res` is our final result, initially set to `INT_MAX`;\\n* `mod` is a support variable we will use to store the modulo of a given value (ie: the bucket it belongs to);\\n* `mins` and `seeds` are two maps where we will store the minimum value and the number of elements in each bucket, respectively.\\n\\nThen, for each `n` in `nums`, we will:\\n* store `n % space` in `mod`;\\n* store in `pos` the position of `mod` in `mins`;\\n* deal with two possible cases:\\n\\t* if we never worked on this bucket (ie: `pos == end(mins)`), then we will just create the entry `mins[mod]` and set it to be `n`;\\n\\t* alternatively, we will store as a value of it (`pos->second`) the minimum between its current value and `mod` - since we are tasked to `return` the minimum possible element that can erase as many targets as possible;\\n* increase `seeds[mod]` by `1`, to keep track of the extra element here;\\n* deal with three possible cases:\\n\\t* if `seeds[mod] == maxTargets`, then we:\\n\\t\\t* set `res` to be the minimum between its current value and `mins[mod]`;\\n\\t* if `seeds[mod] > maxTargets`, then we have a new maximum, thus we:\\n\\t\\t* update `maxTarget` to be `seeds[mod]`;\\n\\t\\t* set `res` to be `mins[mod]`;\\n\\t* if `seeds[mod] < maxTargets`, then we do nothing - it is not relevant (yet: it might be later, if `seeds[mod]` increases further after this).\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        // support variables\\n        int maxTargets = 0, res = INT_MAX, mod;\\n        unordered_map<int, int> mins, seeds;\\n        // parsing nums into buckets\\n        for (int n: nums) {\\n            mod = n % space;\\n            auto pos = mins.find(mod);\\n            // case 1: first time n was found\\n            if (pos == end(mins)) mins[mod] = n;\\n            // case 2: we already found n\\n            else pos->second = min(pos->second, n);\\n            seeds[mod]++;\\n            // updating res depending on seeds[mod]\\n            if (seeds[mod] == maxTargets) {\\n                res = min(res, mins[mod]);\\n            }\\n            else if (seeds[mod] > maxTargets) {\\n                maxTargets = seeds[mod];\\n                res = mins[mod];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nMicro-optimised version pre-sizing the hashmaps; it runs consistently a bit better:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        // support variables\\n        int maxTargets = 0, res = INT_MAX, mod, len = nums.size();\\n        unordered_map<int, int> mins, seeds;\\n        // pre-sizing mins and seeds to avoid reallocations\\n        mins.reserve(len);\\n        seeds.reserve(len);\\n        // parsing nums into buckets\\n        for (int n: nums) {\\n            mod = n % space;\\n            auto pos = mins.find(mod);\\n            // case 1: first time n was found\\n            if (pos == end(mins)) mins[mod] = n;\\n            // case 2: we already found n\\n            else pos->second = min(pos->second, n);\\n            seeds[mod]++;\\n            // updating res depending on seeds[mod]\\n            if (seeds[mod] == maxTargets) {\\n                res = min(res, mins[mod]);\\n            }\\n            else if (seeds[mod] > maxTargets) {\\n                maxTargets = seeds[mod];\\n                res = mins[mod];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        // support variables\\n        int maxTargets = 0, res = INT_MAX, mod;\\n        unordered_map<int, int> mins, seeds;\\n        // parsing nums into buckets\\n        for (int n: nums) {\\n            mod = n % space;\\n            auto pos = mins.find(mod);\\n            // case 1: first time n was found\\n            if (pos == end(mins)) mins[mod] = n;\\n            // case 2: we already found n\\n            else pos->second = min(pos->second, n);\\n            seeds[mod]++;\\n            // updating res depending on seeds[mod]\\n            if (seeds[mod] == maxTargets) {\\n                res = min(res, mins[mod]);\\n            }\\n            else if (seeds[mod] > maxTargets) {\\n                maxTargets = seeds[mod];\\n                res = mins[mod];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    int destroyTargets(vector<int>& nums, int space) {\\n        // support variables\\n        int maxTargets = 0, res = INT_MAX, mod, len = nums.size();\\n        unordered_map<int, int> mins, seeds;\\n        // pre-sizing mins and seeds to avoid reallocations\\n        mins.reserve(len);\\n        seeds.reserve(len);\\n        // parsing nums into buckets\\n        for (int n: nums) {\\n            mod = n % space;\\n            auto pos = mins.find(mod);\\n            // case 1: first time n was found\\n            if (pos == end(mins)) mins[mod] = n;\\n            // case 2: we already found n\\n            else pos->second = min(pos->second, n);\\n            seeds[mod]++;\\n            // updating res depending on seeds[mod]\\n            if (seeds[mod] == maxTargets) {\\n                res = min(res, mins[mod]);\\n            }\\n            else if (seeds[mod] > maxTargets) {\\n                maxTargets = seeds[mod];\\n                res = mins[mod];\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762384,
                "title": "java-map-pq",
                "content": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums);\\n\\n        Map<Integer, List<Integer>> freq = new HashMap<>(); // remainder, elements\\n        for (int num : nums) {\\n            int key = num % space;\\n            if (!freq.containsKey(key)) freq.put(key, new ArrayList<>());\\n            freq.get(key).add(num);\\n        }\\n\\n        PriorityQueue<Pair<Integer, List<Integer>>> pq = new PriorityQueue<>((o1, o2) -> {\\n            if (o1.getValue().size() < o2.getValue().size()) return 1;\\n            if (o1.getValue().size() > o2.getValue().size()) return -1;\\n            return o1.getValue().get(0).compareTo(o2.getValue().get(0));\\n        }); //  remainder -> elements\\n\\n        for (Map.Entry<Integer, List<Integer>> entry : freq.entrySet()) {\\n            pq.offer(new Pair<>(entry.getKey(), entry.getValue()));\\n        }\\n\\n        return pq.poll().getValue().get(0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int destroyTargets(int[] nums, int space) {\\n        Arrays.sort(nums);\\n\\n        Map<Integer, List<Integer>> freq = new HashMap<>(); // remainder, elements\\n        for (int num : nums) {\\n            int key = num % space;\\n            if (!freq.containsKey(key)) freq.put(key, new ArrayList<>());\\n            freq.get(key).add(num);\\n        }\\n\\n        PriorityQueue<Pair<Integer, List<Integer>>> pq = new PriorityQueue<>((o1, o2) -> {\\n            if (o1.getValue().size() < o2.getValue().size()) return 1;\\n            if (o1.getValue().size() > o2.getValue().size()) return -1;\\n            return o1.getValue().get(0).compareTo(o2.getValue().get(0));\\n        }); //  remainder -> elements\\n\\n        for (Map.Entry<Integer, List<Integer>> entry : freq.entrySet()) {\\n            pq.offer(new Pair<>(entry.getKey(), entry.getValue()));\\n        }\\n\\n        return pq.poll().getValue().get(0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762330,
                "title": "python3-using-statistics-multimode-to-look-for-most-frequently-occurring-modulo",
                "content": "Many people use `Counter` or even `dict` to look for most frequently occuring modulo, here I wanted to share another way to look for it.\\n\\n```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        ns = [n%space for n in nums]\\n            \\n        ms = set(multimode(ns))\\n        a = inf\\n        for n,m in zip(nums, ns):\\n            if m in ms and n < a:\\n                a = n\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        ns = [n%space for n in nums]\\n            \\n        ms = set(multimode(ns))\\n        a = inf\\n        for n,m in zip(nums, ns):\\n            if m in ms and n < a:\\n                a = n\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762245,
                "title": "python3-straight-forward-count-num-space-on-the-fly",
                "content": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        mp = collections.defaultdict(list)\\n        for num in nums:\\n            rem = num % space\\n            if rem in mp:\\n                mp[rem].append(num)\\n                mp[rem][0] = min(mp[rem][0], num)\\n            else:\\n                mp[rem] = [num, num]\\n        ans = float(\\'inf\\')\\n        cur = 0\\n        for rem, lst in mp.items():\\n            if len(lst) > cur:\\n                cur = len(lst)\\n                ans = lst[0]\\n            elif len(lst) == cur:\\n                ans = min(ans, lst[0])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def destroyTargets(self, nums: List[int], space: int) -> int:\\n        mp = collections.defaultdict(list)\\n        for num in nums:\\n            rem = num % space\\n            if rem in mp:\\n                mp[rem].append(num)\\n                mp[rem][0] = min(mp[rem][0], num)\\n            else:\\n                mp[rem] = [num, num]\\n        ans = float(\\'inf\\')\\n        cur = 0\\n        for rem, lst in mp.items():\\n            if len(lst) > cur:\\n                cur = len(lst)\\n                ans = lst[0]\\n            elif len(lst) == cur:\\n                ans = min(ans, lst[0])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762240,
                "title": "java-map-modulo",
                "content": "Runtime: 26 ms, faster than 66.67% of Java online submissions for Destroy Sequential Targets.\\nMemory Usage: 83 MB, less than 16.67% of Java online submissions for Destroy Sequential Targets.\\n```\\nclass Solution {\\n  public int destroyTargets(int[] nums, int space) {\\n    int mini = 0, len = 0;\\n    \\n    HashMap<Integer, int[]> table = new HashMap<>();\\n    for(int n : nums){\\n      int mod = n % space;\\n      int[] key = table.get(mod);\\n      if(key == null) table.put(mod, key = new int[]{n, 1});\\n      else {\\n        key[0] = Math.min(key[0], n);\\n        key[1]++;\\n      }\\n      \\n      if(key[1] > len || (key[1] == len && mini > key[0])) {\\n        mini = key[0];\\n        len  = key[1];\\n      }\\n    }\\n    \\n    return mini;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int destroyTargets(int[] nums, int space) {\\n    int mini = 0, len = 0;\\n    \\n    HashMap<Integer, int[]> table = new HashMap<>();\\n    for(int n : nums){\\n      int mod = n % space;\\n      int[] key = table.get(mod);\\n      if(key == null) table.put(mod, key = new int[]{n, 1});\\n      else {\\n        key[0] = Math.min(key[0], n);\\n        key[1]++;\\n      }\\n      \\n      if(key[1] > len || (key[1] == len && mini > key[0])) {\\n        mini = key[0];\\n        len  = key[1];\\n      }\\n    }\\n    \\n    return mini;\\n  }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1663524,
                "content": [
                    {
                        "username": "jatindigra",
                        "content": "It\\'s a % problem basically !! from some observation you can conclude that all elements being destroyed will give same remainder with k , just find the max occurring remainder and done .. detailed explanation here :\\nhttps://leetcode.com/problems/destroy-sequential-targets/solutions/2756840/explained-approach-basic-maths-with-map/"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "if we have [1,3,5,9,13,17,21,25] and space = 2, then c may varies or not. if c is fixed as 1, then we could eliminate 1,3,5 and if varies, we could remove all element with seed being 1, otherwise seed will be 9"
                    },
                    {
                        "username": "layyy",
                        "content": "hash remainders"
                    },
                    {
                        "username": "anau99",
                        "content": "This is my solution, i don\\'t understand why the solution wrong? \\nnums =\\n[625879766,235326233,250224393,501422042,683823101,948619719,680305710,733191937,182186779,353350082]\\nspace =4\\nOutput\\n182186779\\nExpected\\n235326233\\n\\nclass Solution {\\n     HashMap<Integer,Integer>map;\\n    int min;\\n    int maxNumberOf;\\n    public int destroyTargets(int[] nums, int space) {\\n          map = new HashMap<>();\\n        min =Integer.MAX_VALUE;\\n        maxNumberOf = -1;\\n\\n        for (int i: nums){\\n            if(map.containsKey(i))\\n                map.put(i,map.get(i)+1);\\n            else{\\n                map.put(i,1);\\n            }\\n\\n        }\\n        int l = 0, r = (int) 1e9;\\n        while (l<=r){\\n            int mid =l+(r-l)/2;\\n           if(help(nums,space,mid))\\n                l = mid+1;\\n           else r=mid-1;\\n\\n        }\\n        return min;\\n    }\\n\\n     private boolean help(int[]nums,int space,int mid){\\n       int n = nums.length;\\n        boolean isOk = false;\\n        for(int i = 0; i <n;i++){\\n            long k = (long)(nums[i]+mid*space);\\n            if(map.containsKey((int)k)){\\n                isOk = true;\\n                if(maxNumberOf < map.get((int)k)){\\n                    maxNumberOf = map.get((int)k).intValue();\\n                    min= nums[i];\\n                }\\n                else if(maxNumberOf == map.get((int)k))\\n                    min = Math.min(min,nums[i]);\\n            }\\n\\n        }\\n        return isOk;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codez_01",
                        "content": " Basically the problem is to find maximum number of elements that can be represented in form of           nums[i]+c* space , not an arithmetic progression , \nfor example:\nnums[i] = [1 ,5 , 7 , 11]\nspace =2\n expected answer : 1\nbut you may get output :5\nas [5,7,11] are in continuous arithmetic progression .\nexplanation why expected answer is 1 , because if we pass 1 , then every number can be represented in form of   nums[i]+c* space.\n\n1 =1+0*2\n5=1+2*2\n7=1+3*2\n11=1+5*2\n\nso expected answer is =1 by which we can destroy maximum targets i.e., 4 targets.\n\nFor solution please refer :\nhttps://leetcode.com/problems/destroy-sequential-targets/solutions/3766468/using-modulo-single-pass-very-intuitive/\n\nHope this helps!!"
                    },
                    {
                        "username": "user7232YD",
                        "content": "My answer also coming same problem do you find it\\'s explanation."
                    }
                ]
            },
            {
                "id": 2064144,
                "content": [
                    {
                        "username": "jatindigra",
                        "content": "It\\'s a % problem basically !! from some observation you can conclude that all elements being destroyed will give same remainder with k , just find the max occurring remainder and done .. detailed explanation here :\\nhttps://leetcode.com/problems/destroy-sequential-targets/solutions/2756840/explained-approach-basic-maths-with-map/"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "if we have [1,3,5,9,13,17,21,25] and space = 2, then c may varies or not. if c is fixed as 1, then we could eliminate 1,3,5 and if varies, we could remove all element with seed being 1, otherwise seed will be 9"
                    },
                    {
                        "username": "layyy",
                        "content": "hash remainders"
                    },
                    {
                        "username": "anau99",
                        "content": "This is my solution, i don\\'t understand why the solution wrong? \\nnums =\\n[625879766,235326233,250224393,501422042,683823101,948619719,680305710,733191937,182186779,353350082]\\nspace =4\\nOutput\\n182186779\\nExpected\\n235326233\\n\\nclass Solution {\\n     HashMap<Integer,Integer>map;\\n    int min;\\n    int maxNumberOf;\\n    public int destroyTargets(int[] nums, int space) {\\n          map = new HashMap<>();\\n        min =Integer.MAX_VALUE;\\n        maxNumberOf = -1;\\n\\n        for (int i: nums){\\n            if(map.containsKey(i))\\n                map.put(i,map.get(i)+1);\\n            else{\\n                map.put(i,1);\\n            }\\n\\n        }\\n        int l = 0, r = (int) 1e9;\\n        while (l<=r){\\n            int mid =l+(r-l)/2;\\n           if(help(nums,space,mid))\\n                l = mid+1;\\n           else r=mid-1;\\n\\n        }\\n        return min;\\n    }\\n\\n     private boolean help(int[]nums,int space,int mid){\\n       int n = nums.length;\\n        boolean isOk = false;\\n        for(int i = 0; i <n;i++){\\n            long k = (long)(nums[i]+mid*space);\\n            if(map.containsKey((int)k)){\\n                isOk = true;\\n                if(maxNumberOf < map.get((int)k)){\\n                    maxNumberOf = map.get((int)k).intValue();\\n                    min= nums[i];\\n                }\\n                else if(maxNumberOf == map.get((int)k))\\n                    min = Math.min(min,nums[i]);\\n            }\\n\\n        }\\n        return isOk;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codez_01",
                        "content": " Basically the problem is to find maximum number of elements that can be represented in form of           nums[i]+c* space , not an arithmetic progression , \nfor example:\nnums[i] = [1 ,5 , 7 , 11]\nspace =2\n expected answer : 1\nbut you may get output :5\nas [5,7,11] are in continuous arithmetic progression .\nexplanation why expected answer is 1 , because if we pass 1 , then every number can be represented in form of   nums[i]+c* space.\n\n1 =1+0*2\n5=1+2*2\n7=1+3*2\n11=1+5*2\n\nso expected answer is =1 by which we can destroy maximum targets i.e., 4 targets.\n\nFor solution please refer :\nhttps://leetcode.com/problems/destroy-sequential-targets/solutions/3766468/using-modulo-single-pass-very-intuitive/\n\nHope this helps!!"
                    },
                    {
                        "username": "user7232YD",
                        "content": "My answer also coming same problem do you find it\\'s explanation."
                    }
                ]
            },
            {
                "id": 1969497,
                "content": [
                    {
                        "username": "jatindigra",
                        "content": "It\\'s a % problem basically !! from some observation you can conclude that all elements being destroyed will give same remainder with k , just find the max occurring remainder and done .. detailed explanation here :\\nhttps://leetcode.com/problems/destroy-sequential-targets/solutions/2756840/explained-approach-basic-maths-with-map/"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "if we have [1,3,5,9,13,17,21,25] and space = 2, then c may varies or not. if c is fixed as 1, then we could eliminate 1,3,5 and if varies, we could remove all element with seed being 1, otherwise seed will be 9"
                    },
                    {
                        "username": "layyy",
                        "content": "hash remainders"
                    },
                    {
                        "username": "anau99",
                        "content": "This is my solution, i don\\'t understand why the solution wrong? \\nnums =\\n[625879766,235326233,250224393,501422042,683823101,948619719,680305710,733191937,182186779,353350082]\\nspace =4\\nOutput\\n182186779\\nExpected\\n235326233\\n\\nclass Solution {\\n     HashMap<Integer,Integer>map;\\n    int min;\\n    int maxNumberOf;\\n    public int destroyTargets(int[] nums, int space) {\\n          map = new HashMap<>();\\n        min =Integer.MAX_VALUE;\\n        maxNumberOf = -1;\\n\\n        for (int i: nums){\\n            if(map.containsKey(i))\\n                map.put(i,map.get(i)+1);\\n            else{\\n                map.put(i,1);\\n            }\\n\\n        }\\n        int l = 0, r = (int) 1e9;\\n        while (l<=r){\\n            int mid =l+(r-l)/2;\\n           if(help(nums,space,mid))\\n                l = mid+1;\\n           else r=mid-1;\\n\\n        }\\n        return min;\\n    }\\n\\n     private boolean help(int[]nums,int space,int mid){\\n       int n = nums.length;\\n        boolean isOk = false;\\n        for(int i = 0; i <n;i++){\\n            long k = (long)(nums[i]+mid*space);\\n            if(map.containsKey((int)k)){\\n                isOk = true;\\n                if(maxNumberOf < map.get((int)k)){\\n                    maxNumberOf = map.get((int)k).intValue();\\n                    min= nums[i];\\n                }\\n                else if(maxNumberOf == map.get((int)k))\\n                    min = Math.min(min,nums[i]);\\n            }\\n\\n        }\\n        return isOk;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codez_01",
                        "content": " Basically the problem is to find maximum number of elements that can be represented in form of           nums[i]+c* space , not an arithmetic progression , \nfor example:\nnums[i] = [1 ,5 , 7 , 11]\nspace =2\n expected answer : 1\nbut you may get output :5\nas [5,7,11] are in continuous arithmetic progression .\nexplanation why expected answer is 1 , because if we pass 1 , then every number can be represented in form of   nums[i]+c* space.\n\n1 =1+0*2\n5=1+2*2\n7=1+3*2\n11=1+5*2\n\nso expected answer is =1 by which we can destroy maximum targets i.e., 4 targets.\n\nFor solution please refer :\nhttps://leetcode.com/problems/destroy-sequential-targets/solutions/3766468/using-modulo-single-pass-very-intuitive/\n\nHope this helps!!"
                    },
                    {
                        "username": "user7232YD",
                        "content": "My answer also coming same problem do you find it\\'s explanation."
                    }
                ]
            },
            {
                "id": 1945226,
                "content": [
                    {
                        "username": "jatindigra",
                        "content": "It\\'s a % problem basically !! from some observation you can conclude that all elements being destroyed will give same remainder with k , just find the max occurring remainder and done .. detailed explanation here :\\nhttps://leetcode.com/problems/destroy-sequential-targets/solutions/2756840/explained-approach-basic-maths-with-map/"
                    },
                    {
                        "username": "b14ck_5m0k3",
                        "content": "if we have [1,3,5,9,13,17,21,25] and space = 2, then c may varies or not. if c is fixed as 1, then we could eliminate 1,3,5 and if varies, we could remove all element with seed being 1, otherwise seed will be 9"
                    },
                    {
                        "username": "layyy",
                        "content": "hash remainders"
                    },
                    {
                        "username": "anau99",
                        "content": "This is my solution, i don\\'t understand why the solution wrong? \\nnums =\\n[625879766,235326233,250224393,501422042,683823101,948619719,680305710,733191937,182186779,353350082]\\nspace =4\\nOutput\\n182186779\\nExpected\\n235326233\\n\\nclass Solution {\\n     HashMap<Integer,Integer>map;\\n    int min;\\n    int maxNumberOf;\\n    public int destroyTargets(int[] nums, int space) {\\n          map = new HashMap<>();\\n        min =Integer.MAX_VALUE;\\n        maxNumberOf = -1;\\n\\n        for (int i: nums){\\n            if(map.containsKey(i))\\n                map.put(i,map.get(i)+1);\\n            else{\\n                map.put(i,1);\\n            }\\n\\n        }\\n        int l = 0, r = (int) 1e9;\\n        while (l<=r){\\n            int mid =l+(r-l)/2;\\n           if(help(nums,space,mid))\\n                l = mid+1;\\n           else r=mid-1;\\n\\n        }\\n        return min;\\n    }\\n\\n     private boolean help(int[]nums,int space,int mid){\\n       int n = nums.length;\\n        boolean isOk = false;\\n        for(int i = 0; i <n;i++){\\n            long k = (long)(nums[i]+mid*space);\\n            if(map.containsKey((int)k)){\\n                isOk = true;\\n                if(maxNumberOf < map.get((int)k)){\\n                    maxNumberOf = map.get((int)k).intValue();\\n                    min= nums[i];\\n                }\\n                else if(maxNumberOf == map.get((int)k))\\n                    min = Math.min(min,nums[i]);\\n            }\\n\\n        }\\n        return isOk;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "codez_01",
                        "content": " Basically the problem is to find maximum number of elements that can be represented in form of           nums[i]+c* space , not an arithmetic progression , \nfor example:\nnums[i] = [1 ,5 , 7 , 11]\nspace =2\n expected answer : 1\nbut you may get output :5\nas [5,7,11] are in continuous arithmetic progression .\nexplanation why expected answer is 1 , because if we pass 1 , then every number can be represented in form of   nums[i]+c* space.\n\n1 =1+0*2\n5=1+2*2\n7=1+3*2\n11=1+5*2\n\nso expected answer is =1 by which we can destroy maximum targets i.e., 4 targets.\n\nFor solution please refer :\nhttps://leetcode.com/problems/destroy-sequential-targets/solutions/3766468/using-modulo-single-pass-very-intuitive/\n\nHope this helps!!"
                    },
                    {
                        "username": "user7232YD",
                        "content": "My answer also coming same problem do you find it\\'s explanation."
                    }
                ]
            }
        ]
    }
]