[
    {
        "title": "Number of Unequal Triplets in Array",
        "question_content": "You are given a 0-indexed array of positive integers nums. Find the number of triplets (i, j, k) that meet the following conditions:\n\n\t0 <= i < j < k < nums.length\n\tnums[i], nums[j], and nums[k] are pairwise distinct.\n\t\n\t\tIn other words, nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k].\n\t\n\t\n\nReturn the number of triplets that meet the conditions.\n&nbsp;\nExample 1:\n\nInput: nums = [4,4,2,4,3]\nOutput: 3\nExplanation: The following triplets meet the conditions:\n- (0, 2, 4) because 4 != 2 != 3\n- (1, 2, 4) because 4 != 2 != 3\n- (2, 3, 4) because 2 != 4 != 3\nSince there are 3 triplets, we return 3.\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.\n\nExample 2:\n\nInput: nums = [1,1,1,1,1]\nOutput: 0\nExplanation: No triplets meet the conditions so we return 0.\n\n&nbsp;\nConstraints:\n\n\t3 <= nums.length <= 100\n\t1 <= nums[i] <= 1000",
        "solutions": [
            {
                "id": 2831702,
                "title": "o-n",
                "content": "\\nFirst, we count numbers using a hash map `m`.\\n    \\nFor numbers `a`, `b` and `c`, we can form `m[a] * m[b] * m[c]` unique triplets.\\n\\nSay we have 26 numbers (`a...z`). Number `n` forms these number of triplets:\\n- `m[a] * m[n] * m[o] + ... + m[a] * m[n] * m[z]` +\\n- `m[b] * m[n] * m[o] + ... + m[b] * m[n] * m[z]` +\\n- `...`\\n- `m[m] * m[n] * m[o] + ... + m[m] * m[n] * m[z]`.\\n \\nThis formula can be simplified as `sum(m[a]...m[m]) * m[n] * sum(m[o]...m[z])`.\\n\\nWe can track sum on the `left` and `right` of `m[n]` as we go.\\n\\n> What about `0 <= i < j < k` condition? Actually, the relation does not matter. \\n> What matters is that `[i, j, k]`, `[i, k, j]`, `[k, i, j]` and `[k, j, i]` represent the same triplet, so it should only be counted once.\\n\\n**C++**\\n```cpp\\nint unequalTriplets(vector<int>& nums) {\\n    unordered_map<int, int> m;\\n    for (int n : nums)\\n        ++m[n];\\n    int res = 0, left = 0, right = nums.size();\\n    for (auto [n, cnt] : m) {\\n        right -= cnt;\\n        res += left * cnt * right;\\n        left += cnt;\\n    }\\n    return res;\\n}\\n```\\n**Python 3**\\nUsing counter with prefix sum.\\n\\n```python\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        s = list(accumulate(Counter(nums).values()))\\n        return sum(s[i - 1] * (s[i] - s[i - 1]) * (s[-1] - s[i]) for i in range(1, len(s)))\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint unequalTriplets(vector<int>& nums) {\\n    unordered_map<int, int> m;\\n    for (int n : nums)\\n        ++m[n];\\n    int res = 0, left = 0, right = nums.size();\\n    for (auto [n, cnt] : m) {\\n        right -= cnt;\\n        res += left * cnt * right;\\n        left += cnt;\\n    }\\n    return res;\\n}\\n```\n```python\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        s = list(accumulate(Counter(nums).values()))\\n        return sum(s[i - 1] * (s[i] - s[i - 1]) * (s[-1] - s[i]) for i in range(1, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833367,
                "title": "java-c-python-one-pass-o-n",
                "content": "# **Intuition**\\n`O(n^3)` Brute Force is easy,\\n`O(n^2)` optimisation is normal,\\n`O(n)` soluiton is awesome.\\n\\n`O(n)` one pass is coming now.\\n<br>\\n\\n# **Explanation**\\nIterate the input one by one,\\n`count[a]` counts the frequency of element `a` we have seen.\\n`pair` is the number of  pairwise distinct pair\\n`trips` is the number of  pairwise distinct triplet.\\n\\nSo for every element `A[i]`,\\nThere are already `pairs`\\namong them `pairs_with_a = count[A[i]] * (i - count[A[i]])` pairs contains `A[i]`\\nso `pairs_without_a = pairs - pairs_with_a`\\nand `A[i]` can combine `new_triplets_with_a = pairs_without_a`\\nSo that we update trips.\\n\\nFor `pairs`, will be easier if you get the above process,\\nwe update `pairs += i - count[A[i]]`\\n\\nAlso need to update `count[A[i]] += 1`\\n\\nAfter all, we simply return `triplets`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Java**\\n```java\\n    public int unequalTriplets(int[] A) {\\n        int trips = 0, pairs = 0, count[] = new int[1001];\\n        for (int i = 0; i < A.length; ++i) {\\n            trips += pairs - count[A[i]] * (i - count[A[i]]);\\n            pairs += i - count[A[i]];\\n            count[A[i]] += 1;\\n        }\\n        return trips;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int unequalTriplets(vector<int>& A) {\\n        int trips = 0, pairs = 0, count[1001] = {};\\n        for (int i = 0; i < A.size(); ++i) {\\n            trips += pairs - count[A[i]] * (i - count[A[i]]);\\n            pairs += i - count[A[i]];\\n            count[A[i]] += 1;\\n        }\\n        return trips;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def unequalTriplets(self, A: List[int]) -> int:\\n        trips = pairs = 0\\n        count = Counter()\\n        for i,a in enumerate(A):\\n            trips += pairs - count[a] * (i - count[a])\\n            pairs += i - count[a]\\n            count[a] += 1\\n        return trips\\n```\\n\\n# **Follow-up Question**\\n`O(n^3)` Brute Force is easy,\\n`O(n^2)` optimisation is normal,\\n`O(n)` soluiton is awesome.\\n`O(n)` one pass is done\\n\\nwhat else now?\\nCan you try to solve 4-plets question?\\nCan you try to solve k-plets question?",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int unequalTriplets(int[] A) {\\n        int trips = 0, pairs = 0, count[] = new int[1001];\\n        for (int i = 0; i < A.length; ++i) {\\n            trips += pairs - count[A[i]] * (i - count[A[i]]);\\n            pairs += i - count[A[i]];\\n            count[A[i]] += 1;\\n        }\\n        return trips;\\n    }\\n```\n```cpp\\n    int unequalTriplets(vector<int>& A) {\\n        int trips = 0, pairs = 0, count[1001] = {};\\n        for (int i = 0; i < A.size(); ++i) {\\n            trips += pairs - count[A[i]] * (i - count[A[i]]);\\n            pairs += i - count[A[i]];\\n            count[A[i]] += 1;\\n        }\\n        return trips;\\n    }\\n```\n```py\\n    def unequalTriplets(self, A: List[int]) -> int:\\n        trips = pairs = 0\\n        count = Counter()\\n        for i,a in enumerate(A):\\n            trips += pairs - count[a] * (i - count[a])\\n            pairs += i - count[a]\\n            count[a] += 1\\n        return trips\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2833105,
                "title": "the-fastest-o-n-solution-math-combinations",
                "content": "[Leetcode](https://leetcode.com/) [2475. Number of Unequal Triplets in Array](https://leetcode.com/problems/number-of-unequal-triplets-in-array/).\\n\\n\\n# Intuition\\n\\nInspired by [@Vlad](https://leetcode.com/votrubac/) and his solution [O(n)](https://leetcode.com/problems/number-of-unequal-triplets-in-array/solutions/2831702/o-n/) , I found a **faster** $O(n)$ solution. \\n\\nLet\\'s recall the **Elementary Math**: [Combination](http://en.wikipedia.org/wiki/Combination) .\\n\\nWe can choose $3$ nums from the array and the combination number is $\\n\\\\frac{n \\\\times (n-1) \\\\times (n-2)}{6}$ , $n$ is the length of the array $\\\\textit{nums}$.\\n\\nHowever, the array would have **duplicated** numbers, so we have to **remove** the **unlegal** combinations.\\n\\nThe following $2$ conditions are **NOT** legal:\\n\\n- The $3$ choosed numbers are all the same numbers, then this combination is $\\\\frac{x \\\\times (x-1) \\\\times (x-2)}{6}$, $x$ is count of the same number. \\n\\n- The $2$ of the $3$ choosed numbers are the same numbers, then this combination is $\\\\frac{(n - x) \\\\times x \\\\times (x-1)}{2}$, $x$ is count of the same number. \\n\\nThis solution is the **Fastest** Solution, beats $100\\\\%$.\\n\\n```java\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int x : nums) {\\n            map.put(x, map.getOrDefault(x, 0) + 1);\\n        }\\n\\n        // total combinations\\n        int ans = n * (n - 1) * (n - 2) / 6;\\n\\n        for (int cnt : map.values()) {\\n            if (cnt < 2) {\\n                continue;\\n            }\\n\\n            int same3cnt = cnt * (cnt - 1) * (cnt - 2) / 6;\\n            int same2cnt = (n - cnt) * cnt * (cnt - 1) / 2;\\n            ans -= same3cnt + same2cnt;\\n        }\\n\\n        return ans; \\n    }\\n}\\n```\\n\\n# Complexity Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n)$.\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Sorting"
                ],
                "code": "```java\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int x : nums) {\\n            map.put(x, map.getOrDefault(x, 0) + 1);\\n        }\\n\\n        // total combinations\\n        int ans = n * (n - 1) * (n - 2) / 6;\\n\\n        for (int cnt : map.values()) {\\n            if (cnt < 2) {\\n                continue;\\n            }\\n\\n            int same3cnt = cnt * (cnt - 1) * (cnt - 2) / 6;\\n            int same2cnt = (n - cnt) * cnt * (cnt - 1) / 2;\\n            ans -= same3cnt + same2cnt;\\n        }\\n\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834169,
                "title": "python-hashmap-o-n-with-diagrams",
                "content": "You can refer to this [video solution](https://youtu.be/d_CHEvI9gQU).\\n\\n\\nLet\\'s first try to understand the properties of the triplets.\\n\\n\\n\\n# Connected\\n![image](https://assets.leetcode.com/users/images/22faf1fa-bfbb-4fd1-9754-0a80be13acfd_1668971330.2726495.png)\\n\\n\\n\\nIf we have these 3 numbers with multiple numbers between them, they will still be a triplet. \\n\\nSo, they don\\'t have to be connected.\\n\\n\\n# Ordering\\n\\n\\n![image](https://assets.leetcode.com/users/images/924aceec-5766-41e8-8243-4842edb23500_1668971281.6670713.png)\\n\\n\\n\\nIf we rearrange them, they will actually be the same triplet. \\n\\nSo, we can get a hint that ordering doesn\\'t affect the number of triplets.\\n\\n\\n\\n\\n# Repetition of Numbers\\n\\n![image](https://assets.leetcode.com/users/images/7ecb9c83-90e3-4865-9851-abe88a276fe6_1668971447.0865786.png)\\n\\nLet\\'s take the case where there is repetition of numbers.\\n\\nYou can again count that there are 4 valid triplets.\\n\\nThe ordering or the spacing/distance between the elements don\\'t affect the answer.\\n\\nThe count of the triplets can also be calculated by multiplying the product of their frequencies `2*2*1`.\\n\\n# More than 4 distinct numbers\\n\\n\\n![image](https://assets.leetcode.com/users/images/6e78ba71-96e4-4679-8874-71cde0dd7076_1668971686.4104624.png)\\n\\nLet\\'s take a scenario where there are more than 3 distinct numbers to form triplets.\\n\\nHere, since we have to take 3 elements together, we can choose either of \\n1. `1,2,3`\\n2. `1,2,4`\\n3. `2,3,4`\\n\\nThe count of these triplets would be the product of their individual frequencies.\\n\\nThe total count would be the addition of all these group.\\n\\n# Avoid Repetitive Counting \\n\\n![image](https://assets.leetcode.com/users/images/8b464844-cc15-44be-bfaa-1564318bf662_1668971910.6921546.png)\\n\\nThese are all the permutations for 3 elements.\\n\\nWe have to avoid counting repetitions of the same triplet.\\n\\n# Middle Element\\n\\n\\n![image](https://assets.leetcode.com/users/images/79519e40-c959-4e9d-ae1b-26939c093f0f_1668972091.7264884.png)\\n\\nThis can be avoided by fixing `b` as middle element and making sure that arrangement `c, a, b` never happens.\\n\\nIt can be a good idea to keep same elements contiguous. \\nThis will make sure that we never consider palindromic triplets.\\n\\n# Left, Mid, Right\\n\\n\\n\\n![image](https://assets.leetcode.com/users/images/98ec17d9-b0e5-4a36-9f9d-383b43e2fb0b_1668972253.7653008.png)\\n\\nThis will work even for more distinct elements on the left and right, as long as there are no same elements both on left & right.\\n\\nThis can\\'t be the case since we already are keeping same elements together to avoid palindromic triplets.\\n\\nThe total number of triplets in this case, with the middle element `b` would be ```left * mid * right ```\\nHere, \\n1. `mid` would be the frequency of `b`\\n2. `left` would be the number of elements on the left.\\n3. `right` would be the number of elements on the right.\\n\\nWe can store the frequencies of elements in a HashMap.\\n\\n# Example\\n\\n![image](https://assets.leetcode.com/users/images/6c0e53e4-4a0e-4470-bcac-1b7137ca4066_1668972490.7243066.png)\\n\\nWe can initialize `left=0, right=(no. of elements)` as shown in the diagram.\\n\\n# Iteration 1\\n\\n![image](https://assets.leetcode.com/users/images/37cc7422-9990-4496-8544-04370f85273d_1668972644.365396.png)\\n\\nEach time, we chose an element we decrement `right -= (frequency of element)`.\\n\\nAnd after we are done with that element, we will increment `left += (frequency of element)`.\\n\\nWe\\'ll have to add the product of `left * freq * right` to result.\\n\\n# Iteration 2\\n\\n\\n![image](https://assets.leetcode.com/users/images/63de6bb6-bf40-4781-a170-9371f344c73d_1668972933.1438584.png)\\n\\nWhen we choose `b` to be the middle element, `left=2, right=4`.\\n\\n# Iteration 3\\n\\n\\n![image](https://assets.leetcode.com/users/images/b79bf7f5-659f-4189-b1ee-1e623489cbae_1668973084.831597.png)\\n\\nWhen we choose `c` to be the middle element, `left=5, right=2`.\\n\\nAt the end, we will have to add all these products to our result.\\n\\n# Iteration 4\\n\\n\\n![image](https://assets.leetcode.com/users/images/52d9ccc7-da98-4c81-8e7c-c4da1a263d46_1668973155.3390157.png)\\n\\nWhen we choose `d` to be the middle element, `left=7, right=0`.\\n\\nNote: \\n1. The first element will always have left-->0 \\n2. The last element will have right-->0.\\n\\n# Time, Space Complexity\\n\\n`Time: O(n)`  We are creating frequency map by iterating over the array.\\n`Space: O(n)`  We are using a HashMap to store the frequency of the elements.\\n\\nIf this was helpful, please leave a like, upvote, or even subscribe to the channel.\\n\\nCheers\\n\\n\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        c = Counter(nums)\\n        res = 0\\n        \\n        left = 0\\n        right = len(nums)\\n        \\n        for _, freq in c.items():\\n            right -= freq\\n            res += left * freq * right\\n            left += freq\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```left * mid * right ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2831700,
                "title": "python-c-linear-time-vs-brute-force-explained",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\nThis solution employs counting of frequencines in order to compute the number of unequal triplets. Time complexity is linear: **O(N)**. Space complexity is linear: **O(N)**.\\n****\\n\\n**Comment.** Given the constraints, a brute force solution (#2) is fast enough. However, if we expect numbers to repeat then counting of frequencies with subsequent calculation of combinations is the way to go. The strategy is as follows:\\n1. The number of unequal triplets is equal to the sum of all possible 3-products of frequencies (for each triple of unique numbers). For a simple case, e.g., `[2,5,5,4,4,4]`, it is `count of 2 * count of 5 * count of 4 = 1 * 2 * 3 = 6`.\\n2. If we had to calculate the analagous number of \"unequal **pairs**\", we would then iterate over each unqiue number and multiply its frequency by the sum of **remaining** (in order not to count twice) frequencies, giving us the number of all unequal pairs with this number. \\n3. For triplets, we have to slightly modify this approach. When iterating over frequencies, we would keep track not only of the sum of remaining frequencies but also of the sum of previously seen frequencies. The product of the current number\\'s frequency with this two numbers would give us the number of combinations (unequal triplets) for this number.\\n4. Finally, we sum all such combinations.\\n\\n**Python #1.** Combinatorial solution with smart counting.\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        \\n        cnt, prv, nxt = 0, 0, len(nums)\\n        \\n        for _, cur in Counter(nums).items(): \\n            nxt -= cur                         # update sum of remaining frequencies\\n            cnt += prv * cur * nxt             # number of tiples for each unique number\\n            prv += cur                         # update sum of seen frequencies\\n        return cnt\\n```\\n\\n**Python #2.** Trivial brute-force solution.\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        triplets = 0\\n        for i, a in enumerate(nums):\\n            for j, b in enumerate(nums[i+1:], start=i+1):\\n                for c in nums[j+1:]:\\n                    if len(set({a,b,c})) == 3:\\n                           triplets += 1\\n        return triplets\\n```\\n\\n**C++.**\\n```\\nclass Solution \\n{\\npublic:\\n    int unequalTriplets(vector<int>& nums)\\n    {\\n        int cnt = 0, prv = 0, nxt = nums.size();\\n        unordered_map<int,int> freq;\\n        for (int n : nums) freq[n]++;\\n        \\n        for (auto[n,cur] : freq)\\n        {\\n            nxt -= cur;\\n            cnt += prv * cur * nxt;\\n            prv += cur;\\n\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        \\n        cnt, prv, nxt = 0, 0, len(nums)\\n        \\n        for _, cur in Counter(nums).items(): \\n            nxt -= cur                         # update sum of remaining frequencies\\n            cnt += prv * cur * nxt             # number of tiples for each unique number\\n            prv += cur                         # update sum of seen frequencies\\n        return cnt\\n```\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        triplets = 0\\n        for i, a in enumerate(nums):\\n            for j, b in enumerate(nums[i+1:], start=i+1):\\n                for c in nums[j+1:]:\\n                    if len(set({a,b,c})) == 3:\\n                           triplets += 1\\n        return triplets\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int unequalTriplets(vector<int>& nums)\\n    {\\n        int cnt = 0, prv = 0, nxt = nums.size();\\n        unordered_map<int,int> freq;\\n        for (int n : nums) freq[n]++;\\n        \\n        for (auto[n,cur] : freq)\\n        {\\n            nxt -= cur;\\n            cnt += prv * cur * nxt;\\n            prv += cur;\\n\\n        }\\n\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832078,
                "title": "python-c-javascript-o-n-beats-100",
                "content": "# Intuition\\nCalculate the `sum of prev freq & next freq and sum them`.\\n\\n# Approach\\n1. Iterate over frequencies.\\n2. Track the sum of previous frequencies.\\n3. Track the sum of next frequences.\\n4. Sum them all.\\n#### Example\\nLet `nums = [1, 3, 1, 2, 4]`\\nFrequiencies: `1: 2, 3: 1, 2: 1, 4: 1`\\n```\\n    prev       frequency       nxt                 count\\n      0            2          5-2=3             0+(0*2*3)=0\\n      2            1          3-1=2             0+(2*1*2)=4\\n      3            1          2-1=1             4+(3*1*1)=7\\n      4            1          1-1=0             4+(4*1*0)=7\\nprev += freq               nxt -= freq      count += (prev * freq * nxt)\\ncount = 7\\n```\\n\\n\\n# Code\\n\\n```python []\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        count = 0\\n        prev, nxt = 0, len(nums)\\n        for _, frequency in Counter(nums).items():\\n            nxt -= frequency\\n            count += prev * frequency * nxt\\n            prev += frequency\\n        return count\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0, prev = 0, nxt = nums.size();\\n        unordered_map<int, int> frequency;\\n\\n        for (int n : nums) \\n            frequency[n]++;\\n        \\n        for (auto[n, freq] : frequency)\\n        {\\n            nxt -= freq;\\n            count += prev * freq * nxt;\\n            prev += freq;\\n        }\\n        return count;\\n    }\\n};\\n```\\n```JavaScript []\\nvar unequalTriplets = function(nums) {\\n    let count = 0,\\n        prev = 0,\\n        nxt = nums.length;\\n    let frequencies = nums.reduce((count, currentValue) => {\\n        return (count[currentValue] ? ++count[currentValue] : (count[currentValue] = 1), count);\\n    }, {});\\n    \\n    for (freq of Object.values(frequencies)) {\\n        nxt -= freq;\\n        count += (prev * freq * nxt);\\n        prev += freq\\n    }\\n    return count\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n    prev       frequency       nxt                 count\\n      0            2          5-2=3             0+(0*2*3)=0\\n      2            1          3-1=2             0+(2*1*2)=4\\n      3            1          2-1=1             4+(3*1*1)=7\\n      4            1          1-1=0             4+(4*1*0)=7\\nprev += freq               nxt -= freq      count += (prev * freq * nxt)\\ncount = 7\\n```\n```python []\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        count = 0\\n        prev, nxt = 0, len(nums)\\n        for _, frequency in Counter(nums).items():\\n            nxt -= frequency\\n            count += prev * frequency * nxt\\n            prev += frequency\\n        return count\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0, prev = 0, nxt = nums.size();\\n        unordered_map<int, int> frequency;\\n\\n        for (int n : nums) \\n            frequency[n]++;\\n        \\n        for (auto[n, freq] : frequency)\\n        {\\n            nxt -= freq;\\n            count += prev * freq * nxt;\\n            prev += freq;\\n        }\\n        return count;\\n    }\\n};\\n```\n```JavaScript []\\nvar unequalTriplets = function(nums) {\\n    let count = 0,\\n        prev = 0,\\n        nxt = nums.length;\\n    let frequencies = nums.reduce((count, currentValue) => {\\n        return (count[currentValue] ? ++count[currentValue] : (count[currentValue] = 1), count);\\n    }, {});\\n    \\n    for (freq of Object.values(frequencies)) {\\n        nxt -= freq;\\n        count += (prev * freq * nxt);\\n        prev += freq\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831684,
                "title": "brute-force-solution-very-simple-easy-to-understand",
                "content": "<b>Up Vote if you like the solution\\n```\\n/*\\nAs the constraints are small, simple bruteforce approch will run fine \\nJust itterate 3 loop and check for uniqe elements and increament answer.\\n*/\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            for(int j = i + 1; j < nums.size(); ++j){\\n                for(int k = j +1; k < nums.size(); ++k){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nAs the constraints are small, simple bruteforce approch will run fine \\nJust itterate 3 loop and check for uniqe elements and increament answer.\\n*/\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            for(int j = i + 1; j < nums.size(); ++j){\\n                for(int k = j +1; k < nums.size(); ++k){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832961,
                "title": "intuitive-solution-recursion-c-brute-force-o-n-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a brute force solution, we can use recursion to tryout all possible triplets. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will keep the following variables with a recursion call every time:\\n```\\nint index // The index at which are currently standing.\\nint n // Length of the array.\\nint req: (default value = 3) // It indicates how many elements more we need to select to form triplet.\\nvector<int> nums // Given array nums.\\nint prev: (default value = anything) // It stores the previous element in the sequence of triplets. Eg: If req = 2, then prev stores the value of third element and when req = 1, prev stores second element.\\nint prev_prev: (default value = anything) // It stores the previous of previous element in the sequence of triplets. Eg: If req = 1, then prev_prev stores the value of third element.\\n\\n// Initial call would look-like..\\nreturn rec(0, n, 3, nums, 0, 0);\\n```\\nIf you haven\\'t understood till this part, please don\\'t go ahead and read all over again.\\n\\n\\nIn the function if req = 0, then we can return 1, because we would only get there when we have triplet with us.\\nIf not, then kindly check if we are getting out of bounds, if yes return 0, because there is no way we can find elements beyond the array\\'s size.\\n\\nNow very important part,\\nWe can either select element at current index or move with the next one.\\nTo not select element at the current index, simply call the recursion with the incremented index value.\\n\\nIf we want to select the element, then we must check for the following three cases,\\n\\n- Case 1: If req = 3\\nCall recursion with incremented index, prev parameter as an element at current index.\\n\\n- Case 2: If req = 2\\nIf prev is not same as current element then and only then call recursion with incremented index, prev parameter as an element at current index and prev_prev parameter as prev.\\n\\n- Case 3: If req = 1\\nIf prev, prev_prev and current elements are distinct then and only then call recursion with incremented index, prev parameter as an element at current index and prev_prev parameter as prev.\\n\\nFinally sum-up and return.\\n\\nIf you have any-doubts or suggestion, feel free to comment down below.\\nJust in case you understood, please make sure upvote the solution and help others find it too.\\n\\nFollow-up questions:\\nCan we memoize this solution?\\nIf yes, is it feasible?\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nAuxiliary Stack Space: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int rec(int index, int n, int req, vector<int>& nums, int prev, int prev_prev){\\n        // Gathered required elements, so return 1\\n        if(req == 0){ \\n            return 1;\\n        }\\n        // Reached beyond the array without collecting all the elements then return 0\\n        if(index == n) return 0; \\n\\n        // Case 1: Try triplet by selecting next element\\n        int t = rec(index+1, n, req, nums, prev, prev_prev);\\n\\n        // Case 2: Try the triplet by selecting current element for first candidate\\n        if(req == 3){\\n            // (selected, not-selected, not-selected)\\n            t += rec(index+1, n, req-1, nums, nums[index], prev_prev);\\n        }\\n        // Case 2: Try the triplet by selecting current element for second candidate\\n        else if(req == 2){\\n            if(prev != nums[index]){\\n                // (selected, selected, not-selected)\\n                t += rec(index+1, n, req-1, nums, nums[index], prev);\\n            }\\n        }\\n        // Case 2: Try the triplet by selecting current element for third candidate\\n        else if(req == 1){\\n            if(prev != nums[index] && prev_prev != nums[index]){\\n                // (selected, selected, selected)\\n                t += rec(index+1, n, req-1, nums, nums[index], prev_prev);\\n            }\\n        }\\n        // Return the possible number of tripets\\n        return t;\\n    }\\n    \\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n        return rec(0, n, 3, nums, 0, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nint index // The index at which are currently standing.\\nint n // Length of the array.\\nint req: (default value = 3) // It indicates how many elements more we need to select to form triplet.\\nvector<int> nums // Given array nums.\\nint prev: (default value = anything) // It stores the previous element in the sequence of triplets. Eg: If req = 2, then prev stores the value of third element and when req = 1, prev stores second element.\\nint prev_prev: (default value = anything) // It stores the previous of previous element in the sequence of triplets. Eg: If req = 1, then prev_prev stores the value of third element.\\n\\n// Initial call would look-like..\\nreturn rec(0, n, 3, nums, 0, 0);\\n```\n```\\nclass Solution {\\npublic:\\n    int rec(int index, int n, int req, vector<int>& nums, int prev, int prev_prev){\\n        // Gathered required elements, so return 1\\n        if(req == 0){ \\n            return 1;\\n        }\\n        // Reached beyond the array without collecting all the elements then return 0\\n        if(index == n) return 0; \\n\\n        // Case 1: Try triplet by selecting next element\\n        int t = rec(index+1, n, req, nums, prev, prev_prev);\\n\\n        // Case 2: Try the triplet by selecting current element for first candidate\\n        if(req == 3){\\n            // (selected, not-selected, not-selected)\\n            t += rec(index+1, n, req-1, nums, nums[index], prev_prev);\\n        }\\n        // Case 2: Try the triplet by selecting current element for second candidate\\n        else if(req == 2){\\n            if(prev != nums[index]){\\n                // (selected, selected, not-selected)\\n                t += rec(index+1, n, req-1, nums, nums[index], prev);\\n            }\\n        }\\n        // Case 2: Try the triplet by selecting current element for third candidate\\n        else if(req == 1){\\n            if(prev != nums[index] && prev_prev != nums[index]){\\n                // (selected, selected, selected)\\n                t += rec(index+1, n, req-1, nums, nums[index], prev_prev);\\n            }\\n        }\\n        // Return the possible number of tripets\\n        return t;\\n    }\\n    \\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n        return rec(0, n, 3, nums, 0, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832800,
                "title": "o-n-c-hashmap-two-pointer",
                "content": "Source Code From: https://leetcode.com/problems/number-of-unequal-triplets-in-array/solutions/2831702/o-n/\\n\\nIn this problem we actually only need count the sum of all possiable solution. if there is no duplicate element in this nums list, we can find a eazy math solution, that should be a Combination method to get 3 element in `n`.\\n$$C_n^3$$\\nHowever, in this problem, the nums list might have duplicate elements. So we need reconsider the logic of Combination.\\nwe can find for each possibale solution should the `Set(nums).size()` \\'s combination. \\n$$C_{Set(nums).size()}^3$$\\nthen we can find a format of solution:\\n\\n```\\nnums[left] nums[i] nums[right]\\n```\\nfor this formate we can get\\n```\\nsubSum = Count(nums[left]) * Count(nums[i]) * Count(nums[right])\\n```\\nthen we can find all left that less than i and nums[left] != nums[i] can be the solution.\\nthen we can get the solution\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for (int n : nums)\\n            ++m[n];\\n        int res = 0, left = 0, right = nums.size();\\n        for (auto [n, cnt] : m) {\\n            right -= cnt;\\n            res += left * cnt * right;\\n            left += cnt;\\n        }\\n        return res;\\n    }\\n\\n};\\n```\\n\\u5199\\u8FD9\\u4E2A\\u9898\\u89E3\\u4E8B\\u5B9E\\u4E0A\\u53EA\\u662F\\u60F3\\u7ED9\\u81EA\\u5DF1\\u4E00\\u4E2AO\\uFF08n\\uFF09\\u89E3\\u7684\\u7B14\\u8BB0\\uFF0C\\u4E8B\\u5B9E\\u4E0A\\uFF0C\\u5BF9\\u4E8E\\u8FD9\\u4E2A\\u9898\\u76EE\\u7684O\\uFF08n\\uFF09\\u89E3\\uFF0C\\u5982\\u679C\\u6211\\u4EEC\\u53EA\\u7528\\u4E00\\u4E2Aitr\\u8BB0\\u5F55\\u6211\\u4EEC\\u5F53\\u524D\\u53EF\\u80FD\\u7684\\u4E2D\\u503C\\u7684\\u65F6\\u5019\\uFF0C\\u90A3\\u4E48\\u5BF9\\u4E8E\\u53D6\\u8FD9\\u4E2A\\u6570\\u503C\\u7684\\u5B50\\u89E3\\u5E94\\u8BE5\\u662Fleft * count[itr] * right. \\u7136\\u540E\\u6211\\u4EEC\\u6BCF\\u6B21\\u904D\\u5386\\u5B8C\\u5F53\\u524D\\u7684\\u6570\\u91CF\\uFF0C\\u5C31\\u6254\\u5230\\u5DE6\\u4FA7\\u53BB\\uFF0C\\u8FD9\\u4E2A\\u65F6\\u5019\\u6211\\u4EEC\\u5C31\\u53EF\\u4EE5\\u904D\\u5386\\u5B8C\\u6240\\u6709\\u53EF\\u80FD\\u4E86\\u3002",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nnums[left] nums[i] nums[right]\\n```\n```\\nsubSum = Count(nums[left]) * Count(nums[i]) * Count(nums[right])\\n```\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        unordered_map<int, int> m;\\n        for (int n : nums)\\n            ++m[n];\\n        int res = 0, left = 0, right = nums.size();\\n        for (auto [n, cnt] : m) {\\n            right -= cnt;\\n            res += left * cnt * right;\\n            left += cnt;\\n        }\\n        return res;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831674,
                "title": "java-triple-loop-solution-brute-force",
                "content": "```\\n/**\\n\\tTime: O(n^3)\\n*/\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                for (int k = j+1; k < nums.length; k++) {\\n                   if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                       count++;\\n                   } \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n\\tTime: O(n^3)\\n*/\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                for (int k = j+1; k < nums.length; k++) {\\n                   if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                       count++;\\n                   } \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2846100,
                "title": "cpp-brute-force-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& n) {\\n        int cnt=0;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            for(int j=i+1;j<n.size();j++)\\n            {\\n                if(n[i]==n[j])\\n                continue;\\n                for(int k=j+1;k<n.size();k++)\\n                {\\n                    if(n[j]==n[k] || n[i]==n[k])\\n                    continue;\\n                    else\\n                     cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& n) {\\n        int cnt=0;\\n        for(int i=0;i<n.size();i++)\\n        {\\n            for(int j=i+1;j<n.size();j++)\\n            {\\n                if(n[i]==n[j])\\n                continue;\\n                for(int k=j+1;k<n.size();k++)\\n                {\\n                    if(n[j]==n[k] || n[i]==n[k])\\n                    continue;\\n                    else\\n                     cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832709,
                "title": "java-soltuion-o-n",
                "content": "//Lets say we have 4 kinds of numbers in m, denote them as a, b, c, d, and their frequency m[a], m[b], m[c], m[d]\\n    //What we want to find is\\n    //m[a] * m[b] * m[c]\\n    //m[a] * m[b] * m[d]\\n    //m[a] * m[c] * m[d]\\n    //m[b] * m[c] * m[d]\\n    //Actually, there are nC3 kinds of combinations we have to consider.\\n    //If you look closer, the above combinations can be reduce as\\n    //\\n    //       left             cnt           right\\n    //(0)                   * m[a] * (m[b] + m[c] + m[d])\\n    //(m[a])                * m[b] * (m[c] + m[d])\\n    //(m[a] + m[b])         * m[c] * (m[d])\\n    //(m[a] + m[b] + m[c])  * m[d] * (0)\\n\\t\\n    \\'public int unequalTriplets(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            if(map.containsKey(i)){\\n                map.put(i,map.get(i)+1);\\n            }else{\\n                map.put(i,1);\\n            }\\n        }\\n        int res=0,left =0,right = nums.length;\\n        //here we are doing the approach as we above mentioned\\n        for(Map.Entry<Integer,Integer> entr :map.entrySet()){\\n             right-= entr.getValue();\\n             res+= right*entr.getValue()*left;\\n             left+=entr.getValue();\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Math"
                ],
                "code": "//Lets say we have 4 kinds of numbers in m, denote them as a, b, c, d, and their frequency m[a], m[b], m[c], m[d]\\n    //What we want to find is\\n    //m[a] * m[b] * m[c]\\n    //m[a] * m[b] * m[d]\\n    //m[a] * m[c] * m[d]\\n    //m[b] * m[c] * m[d]\\n    //Actually, there are nC3 kinds of combinations we have to consider.\\n    //If you look closer, the above combinations can be reduce as\\n    //\\n    //       left             cnt           right\\n    //(0)                   * m[a] * (m[b] + m[c] + m[d])\\n    //(m[a])                * m[b] * (m[c] + m[d])\\n    //(m[a] + m[b])         * m[c] * (m[d])\\n    //(m[a] + m[b] + m[c])  * m[d] * (0)\\n\\t\\n    \\'public int unequalTriplets(int[] nums) {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        for(int i:nums){\\n            if(map.containsKey(i)){\\n                map.put(i,map.get(i)+1);\\n            }else{\\n                map.put(i,1);\\n            }\\n        }\\n        int res=0,left =0,right = nums.length;\\n        //here we are doing the approach as we above mentioned\\n        for(Map.Entry<Integer,Integer> entr :map.entrySet()){\\n             right-= entr.getValue();\\n             res+= right*entr.getValue()*left;\\n             left+=entr.getValue();\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2831993,
                "title": "easy-brute-force-solution-python-tc-o-n-3",
                "content": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        c = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                for k in range(j+1, len(nums)):\\n                    if nums[i]!=nums[j] and nums[i]!=nums[k] and nums[j] != nums[k]:\\n                        c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        c = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                for k in range(j+1, len(nums)):\\n                    if nums[i]!=nums[j] and nums[i]!=nums[k] and nums[j] != nums[k]:\\n                        c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831749,
                "title": "python-simple-python-solution-using-brute-force",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1995 ms, faster than 33.33% of Python3 online submissions for Number of Unequal Triplets in Array.\\n# Memory Usage: 14 MB, less than 33.33% of Python3 online submissions for Number of Unequal Triplets in Array.\\n\\n\\tclass Solution:\\n\\t\\tdef unequalTriplets(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor i in range(len(nums)-2):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums)-1):\\n\\t\\t\\t\\t\\tfor k in range(j+1,len(nums)):\\n\\n\\t\\t\\t\\t\\t\\tif nums[i] != nums[j] and nums[j] != nums[k] and nums[i] != nums[k]:\\n\\t\\t\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 1995 ms, faster than 33.33% of Python3 online submissions for Number of Unequal Triplets in Array.\\n# Memory Usage: 14 MB, less than 33.33% of Python3 online submissions for Number of Unequal Triplets in Array.\\n\\n\\tclass Solution:\\n\\t\\tdef unequalTriplets(self, nums: List[int]) -> int:\\n\\n\\t\\t\\tresult = 0\\n\\n\\t\\t\\tfor i in range(len(nums)-2):\\n\\t\\t\\t\\tfor j in range(i+1,len(nums)-1):\\n\\t\\t\\t\\t\\tfor k in range(j+1,len(nums)):\\n\\n\\t\\t\\t\\t\\t\\tif nums[i] != nums[j] and nums[j] != nums[k] and nums[i] != nums[k]:\\n\\t\\t\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2831682,
                "title": "java-c-python-brute-force",
                "content": "* *Time Complexity :* **O(n^3)**\\n* *Space Complexity :* **O(1)**\\n##### Java\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i < nums.length; i++)\\n            for(int j=i+1; j < nums.length; j++)\\n                for(int k=j+1; k < nums.length; k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n        return ans;\\n    }\\n}\\n```\\n##### C++\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            for(int j = i + 1; j < nums.size(); j++)\\n                for(int k = j + 1; k < nums.size(); k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) \\n\\t\\t\\t\\t\\t\\tans++;\\n        return ans;\\n    }\\n};\\n```\\n##### Python\\n```\\nclass Solution(object):\\n    def unequalTriplets(self, nums):\\n        ans = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                for k in range(j+1, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int ans=0;\\n        for(int i=0; i < nums.length; i++)\\n            for(int j=i+1; j < nums.length; j++)\\n                for(int k=j+1; k < nums.length; k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++)\\n            for(int j = i + 1; j < nums.size(); j++)\\n                for(int k = j + 1; k < nums.size(); k++)\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) \\n\\t\\t\\t\\t\\t\\tans++;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def unequalTriplets(self, nums):\\n        ans = 0\\n        for i in range(len(nums)):\\n            for j in range(i+1, len(nums)):\\n                for k in range(j+1, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225769,
                "title": "c-one-pass-short-and-simple-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        vector<int> v(1001,0);\\n        for(auto &i: nums)v[i]++;\\n        vector<int> tmp;\\n        for(auto &i: v)if(i)tmp.push_back(i);\\n        int ans = 0,i,j,k,n=tmp.size();\\n        for(i=0;i<n;i++)\\n            for(j=i+1;j<n;j++)\\n                for(k=j+1;k<n;k++){\\n                    ans += tmp[i]*tmp[j]*tmp[k];\\n                }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        vector<int> v(1001,0);\\n        for(auto &i: nums)v[i]++;\\n        vector<int> tmp;\\n        for(auto &i: v)if(i)tmp.push_back(i);\\n        int ans = 0,i,j,k,n=tmp.size();\\n        for(i=0;i<n;i++)\\n            for(j=i+1;j<n;j++)\\n                for(k=j+1;k<n;k++){\\n                    ans += tmp[i]*tmp[j]*tmp[k];\\n                }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837115,
                "title": "try-all-brute-force",
                "content": "# Intuition\\nBrute Force \\n`3` loops for each element.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: *`O(n^3)`*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: *`O(1)`*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = i + 1; j < n; j++){\\n                for(int k = j + 1; k < n; k++){\\n                    if(nums[i] != nums[j] && nums[j] != nums[k] && nums[k] != nums[i])\\n                        count++;\\n                }\\n            }\\n        }\\n        return\\xA0count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0, n = nums.size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = i + 1; j < n; j++){\\n                for(int k = j + 1; k < n; k++){\\n                    if(nums[i] != nums[j] && nums[j] != nums[k] && nums[k] != nums[i])\\n                        count++;\\n                }\\n            }\\n        }\\n        return\\xA0count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832919,
                "title": "java-easy-solution-brute-force-to-optimal",
                "content": "### **Solution**\\n#### **Approach 1:  Brute Force - Nested For Loops**\\n##### **Logic**\\nThis approach is pretty straightforward. We use 3 nested loops, each loop will allow us to get the three distinct integers. The condition in the inner loops will be simply to check whether the current element is equal to either of the elements obtained in the outer loops.\\n\\n##### **Implementation**\\n```\\nclass Solution {    \\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            int first = nums[i];\\n            \\n            for(int j=i+1; j<n; j++){\\n                int second = nums[j];\\n                if(second==first){ // skip\\n                    continue;\\n                }\\n        \\n                for(int k=j+1; k<n; k++){\\n                    int third = nums[k];\\n                    \\n                    if(third==first || third==second){ //skip\\n                        continue;\\n                    } else{\\n                        count++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\n##### **Complexity Analysis**\\n* Time Complexity: O(n^3)\\n* Space Complexity: O(1)\\n\\n#### **Approach 2:  HashMap**\\n##### **Code**\\n```\\nclass Solution {    \\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i: nums){\\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        }\\n        \\n        int l=0, r = n;\\n        for(int key: map.keySet()){\\n            int freq = map.get(key);\\n            r -= freq;\\n            count += l*freq*r;\\n            l += freq;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n##### **Complexity Analysis**\\n* Time Complexity: O(n)\\n* Space Complexity: O(n)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {    \\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            int first = nums[i];\\n            \\n            for(int j=i+1; j<n; j++){\\n                int second = nums[j];\\n                if(second==first){ // skip\\n                    continue;\\n                }\\n        \\n                for(int k=j+1; k<n; k++){\\n                    int third = nums[k];\\n                    \\n                    if(third==first || third==second){ //skip\\n                        continue;\\n                    } else{\\n                        count++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {    \\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        \\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i: nums){\\n            map.put(i, map.getOrDefault(i, 0)+1);\\n        }\\n        \\n        int l=0, r = n;\\n        for(int key: map.keySet()){\\n            int freq = map.get(key);\\n            r -= freq;\\n            count += l*freq*r;\\n            l += freq;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832899,
                "title": "java-2-solutions",
                "content": "# 2.count\\n```\\n\\t//2.count\\n    //Runtime: 4 ms, faster than 100.00% of Java online submissions for Number of Unequal Triplets in Array.\\n    //Memory Usage: 41.9 MB, less than 50.00% of Java online submissions for Number of Unequal Triplets in Array.\\n    //Time: O(N + N); space: O(N)\\n    //Time: O(N); space: O(N)\\n    public int unequalTriplets(int[] nums) {\\n\\n        //Time: O(N); space: O(N)\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums)\\n            map.put(num , map.getOrDefault(num ,0) + 1);\\n\\n        int res = 0;\\n        int left = 0, right = nums.length;\\n        //Time: O(N)\\n        // leftCount * midCount * rightCount\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int midCount = entry.getValue();\\n            right -= midCount;\\n            res += left * midCount * right;\\n\\n            left += midCount;\\n        }\\n        return res;\\n    }\\n```\\n# 1.brute force\\n```\\n    //1.brute force\\n    //Runtime: 7 ms, faster than 100.00% of Java online submissions for Number of Unequal Triplets in Array.\\n    //Memory Usage: 40.2 MB, less than 100.00% of Java online submissions for Number of Unequal Triplets in Array.\\n    //Time: O(N*N*N); space: O(1)\\n    public int unequalTriplets_1(int[] nums) {\\n        int res = 0;\\n        for(int i = 0; i<nums.length - 2; i++){\\n            for(int j = i + 1; j<nums.length - 1; j++){\\n                if (nums[i] == nums[j]) continue;\\n                for(int k = j + 1; k<nums.length; k++){\\n                    if (nums[i] != nums[k] && nums[j] != nums[k]) res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t//2.count\\n    //Runtime: 4 ms, faster than 100.00% of Java online submissions for Number of Unequal Triplets in Array.\\n    //Memory Usage: 41.9 MB, less than 50.00% of Java online submissions for Number of Unequal Triplets in Array.\\n    //Time: O(N + N); space: O(N)\\n    //Time: O(N); space: O(N)\\n    public int unequalTriplets(int[] nums) {\\n\\n        //Time: O(N); space: O(N)\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int num : nums)\\n            map.put(num , map.getOrDefault(num ,0) + 1);\\n\\n        int res = 0;\\n        int left = 0, right = nums.length;\\n        //Time: O(N)\\n        // leftCount * midCount * rightCount\\n        for (Map.Entry<Integer, Integer> entry : map.entrySet()) {\\n            int midCount = entry.getValue();\\n            right -= midCount;\\n            res += left * midCount * right;\\n\\n            left += midCount;\\n        }\\n        return res;\\n    }\\n```\n```\\n    //1.brute force\\n    //Runtime: 7 ms, faster than 100.00% of Java online submissions for Number of Unequal Triplets in Array.\\n    //Memory Usage: 40.2 MB, less than 100.00% of Java online submissions for Number of Unequal Triplets in Array.\\n    //Time: O(N*N*N); space: O(1)\\n    public int unequalTriplets_1(int[] nums) {\\n        int res = 0;\\n        for(int i = 0; i<nums.length - 2; i++){\\n            for(int j = i + 1; j<nums.length - 1; j++){\\n                if (nums[i] == nums[j]) continue;\\n                for(int k = j + 1; k<nums.length; k++){\\n                    if (nums[i] != nums[k] && nums[j] != nums[k]) res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832759,
                "title": "easy-c-solution-brute-force",
                "content": "Here is my C++ Solution :-\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int cnt=0; int n= nums.size();\\n        for (int i=0; i<n; i++){\\n            for (int j=i+1; j<n; j++){\\n                if (nums[j]!=nums[i]){\\n                    for (int k=j+1; k<n; k++){\\n                        if (nums[k]!=nums[j] && nums[k]!=nums[i]){cnt++;}\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int cnt=0; int n= nums.size();\\n        for (int i=0; i<n; i++){\\n            for (int j=i+1; j<n; j++){\\n                if (nums[j]!=nums[i]){\\n                    for (int k=j+1; k<n; k++){\\n                        if (nums[k]!=nums[j] && nums[k]!=nums[i]){cnt++;}\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832527,
                "title": "java-100-faster-beats100-easy-understanding",
                "content": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            for(int j = i+1; j<n; j++){\\n                for(int k = j+1; k<n; k++){\\n                    if(nums[i]!= nums[j] && nums[j]!=nums[k] && nums[k] != nums[i]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i = 0; i<n; i++){\\n            for(int j = i+1; j<n; j++){\\n                for(int k = j+1; k<n; k++){\\n                    if(nums[i]!= nums[j] && nums[j]!=nums[k] && nums[k] != nums[i]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832038,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem \\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint unequalTriplets(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int, int>m;\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){m[nums[i]]++;}\\n\\t\\t\\tif(m.size()<3){return 0;}\\n\\t\\t\\tint cnt=0;\\n\\t\\t\\tvector<int>v;\\n\\t\\t\\tfor(auto it:m){\\n\\t\\t\\t\\tv.push_back(it.second);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i<v.size(); i++){\\n\\t\\t\\t\\tfor(int j=i+1; j<v.size(); j++){\\n\\t\\t\\t\\t\\tfor(int k=j+1; k<v.size(); k++){\\n\\t\\t\\t\\t\\t\\tcnt+=(v[i]*v[j]*v[k]);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn cnt;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint unequalTriplets(vector<int>& nums) {\\n\\t\\t\\tunordered_map<int, int>m;\\n\\t\\t\\tfor(int i=0; i<nums.size(); i++){m[nums[i]]++;}",
                "codeTag": "Java"
            },
            {
                "id": 2831722,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n      int count=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n      {\\n          int ni=nums[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n               int nj=nums[j];\\n                if(nj!=ni)\\n                {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(nums[k]!=ni && nums[k]!=nj) count++;\\n                }\\n                }\\n            }\\n      }\\n        return count;\\n    }\\n        \\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n      int count=0;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n      {\\n          int ni=nums[i];\\n            for(int j=i+1;j<n;j++)\\n            {\\n               int nj=nums[j];\\n                if(nj!=ni)\\n                {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(nums[k]!=ni && nums[k]!=nj) count++;\\n                }\\n                }\\n            }\\n      }\\n        return count;\\n    }\\n        \\n};```",
                "codeTag": "Java"
            },
            {
                "id": 3359415,
                "title": "c-array-easy-to-understand",
                "content": "* ***Brute Force***\\n\\n* ***Time Complexity :- O(N ^ 3)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        // run three nested loop\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    if(nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        \\n        int count = 0;\\n        \\n        // run three nested loop\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            for(int j = i + 1; j < n; j++)\\n            {\\n                for(int k = j + 1; k < n; k++)\\n                {\\n                    if(nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3356059,
                "title": "solution-with-three-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    let count = 0;\\n    for(let i=0;i<nums.length ;i++){\\n       for(let j=i+1 ;j<nums.length ;j++){\\n           for(let k=j+1;k<nums.length;k++){\\n             if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k]){\\n                 count++;\\n             }\\n           }\\n       }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    let count = 0;\\n    for(let i=0;i<nums.length ;i++){\\n       for(let j=i+1 ;j<nums.length ;j++){\\n           for(let k=j+1;k<nums.length;k++){\\n             if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k]){\\n                 count++;\\n             }\\n           }\\n       }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3321456,
                "title": "number-of-unequal-triplets-in-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int i, j, k, count=0;\\n        \\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=i+1 ; j<nums.size() ; j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    for(k=j+1 ; k<nums.size() ; k++)\\n                    {\\n                        if(nums[i]!=nums[k] && nums[j]!=nums[k])\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int i, j, k, count=0;\\n        \\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            for(j=i+1 ; j<nums.size() ; j++)\\n            {\\n                if(nums[i]!=nums[j])\\n                {\\n                    for(k=j+1 ; k<nums.size() ; k++)\\n                    {\\n                        if(nums[i]!=nums[k] && nums[j]!=nums[k])\\n                        {\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3309909,
                "title": "c-easy-and-shorter-solution-intuitive-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(N^3)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n\\n        int i,j,k,n = nums.size();\\n        int count=0;\\n\\n        for(k=0;k<n;k++)\\n        {\\n            for(j=0;j<k;j++)\\n            {\\n                for(i=0;i<j;i++)\\n                {\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n\\n        int i,j,k,n = nums.size();\\n        int count=0;\\n\\n        for(k=0;k<n;k++)\\n        {\\n            for(j=0;j<k;j++)\\n            {\\n                for(i=0;i<j;i++)\\n                {\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    count++;\\n                }\\n            }\\n        }\\n\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196636,
                "title": "python-beats-97-o-n-clear-explanation",
                "content": "## Please upvote/favourite/comment if you like this solution!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLet `n` be the length of `nums`.\\n1. Find all the combinations of triplets which is $$n \\\\choose 3$$\\n2. We count the frequency of each number in `nums`\\n3. We remove all the triplets that have a repeated digit either two or three times. For a given number `x` in `nums` with frequency `count`, there are $$count \\\\choose 3$$ triplets with all `x` and $$(n-count)  \\\\times$$ $$count \\\\choose 2$$ triplets with exactly 2 `x`. Remove all these triplets from the total for every number in `nums`. \\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        numFreq = Counter(nums)\\n        total = n*(n-1)*(n-2)//6\\n        for count in numFreq.values():\\n            tripletEqual = count*(count-1)*(count-2)//6\\n            pairEqual = (count*(count-1)//2)*(n-count)\\n            total -= (pairEqual + tripletEqual)\\n        return total\\n```\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "Math",
                    "Counting"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        numFreq = Counter(nums)\\n        total = n*(n-1)*(n-2)//6\\n        for count in numFreq.values():\\n            tripletEqual = count*(count-1)*(count-2)//6\\n            pairEqual = (count*(count-1)//2)*(n-count)\\n            total -= (pairEqual + tripletEqual)\\n        return total\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194900,
                "title": "c-brute-force-and-o-n-solution-with-o-n-space",
                "content": "\\n# Code\\n```\\npublic class Solution {\\n    public int UnequalTriplets(int[] nums) {\\n        int[] counts = new int[1001];\\n        foreach(int num in nums) {\\n            counts[num]++;\\n        }\\n       \\n        int left = 0, right = nums.Length, count = 0;\\n        foreach(int freq in counts) {\\n            if(freq == 0) continue;\\n            right -= freq;\\n            count += left * freq * right;\\n            left += freq;\\n        } \\n\\n        return count;\\n    }\\n    \\n    public int UnequalTripletsBF(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.Length; i++) {\\n            for(int j = i + 1; j < nums.Length; j++) {\\n                for(int k = j + 1; k < nums.Length; k++) {\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        } \\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int UnequalTriplets(int[] nums) {\\n        int[] counts = new int[1001];\\n        foreach(int num in nums) {\\n            counts[num]++;\\n        }\\n       \\n        int left = 0, right = nums.Length, count = 0;\\n        foreach(int freq in counts) {\\n            if(freq == 0) continue;\\n            right -= freq;\\n            count += left * freq * right;\\n            left += freq;\\n        } \\n\\n        return count;\\n    }\\n    \\n    public int UnequalTripletsBF(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.Length; i++) {\\n            for(int j = i + 1; j < nums.Length; j++) {\\n                for(int k = j + 1; k < nums.Length; k++) {\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        } \\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126406,
                "title": "easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        \\n        int count = 0 ; \\n        for(int i = 0 ; i < nums.length ; i++){\\n            for(int j = i+1 ; j < nums.length ; j++){\\n                for(int k = j+1 ; k <nums.length ; k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        \\n        int count = 0 ; \\n        for(int i = 0 ; i < nums.length ; i++){\\n            for(int j = i+1 ; j < nums.length ; j++){\\n                for(int k = j+1 ; k <nums.length ; k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052902,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.size();i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                for(int k=j+1; k<nums.size(); k++) \\n                    if(nums[i]!=nums[j] && nums[j]!= nums[k] && nums[i]!=nums[k])\\n                        ans++; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans=0;\\n        for(int i=0; i<nums.size();i++){\\n            for(int j=i+1; j<nums.size(); j++){\\n                for(int k=j+1; k<nums.size(); k++) \\n                    if(nums[i]!=nums[j] && nums[j]!= nums[k] && nums[i]!=nums[k])\\n                        ans++; \\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3038416,
                "title": "using-counter-99-45",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n       \\n       int count  [] = new int[1001];\\n\\n       for(int i = 0;i<nums.length;i++){\\n           count[nums[i]]++;\\n       }\\n       \\n      int left = 0;\\n      int right = nums.length;\\n      int res= 0 ;\\n      for(int i =0;i<count.length;i++){\\n          int freq = count[i];\\n          if(freq!=0){\\n          right = right - freq;\\n          res += left*freq*right;\\n          left+=freq;\\n          }\\n      }\\n\\n     return res;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n       \\n       int count  [] = new int[1001];\\n\\n       for(int i = 0;i<nums.length;i++){\\n           count[nums[i]]++;\\n       }\\n       \\n      int left = 0;\\n      int right = nums.length;\\n      int res= 0 ;\\n      for(int i =0;i<count.length;i++){\\n          int freq = count[i];\\n          if(freq!=0){\\n          right = right - freq;\\n          res += left*freq*right;\\n          left+=freq;\\n          }\\n      }\\n\\n     return res;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976633,
                "title": "easy-c-solution-brute-force",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        for(int i=0; i<n;i++){\\n            for(int j=i+1; j<n; j++){\\n                for(int k=j+1; k<n; k++) \\n                    if(nums[i]!=nums[j] && nums[j]!= nums[k] && nums[i]!=nums[k])\\n                        count++; \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n=nums.size();\\n        int count=0;\\n        for(int i=0; i<n;i++){\\n            for(int j=i+1; j<n; j++){\\n                for(int k=j+1; k<n; k++) \\n                    if(nums[i]!=nums[j] && nums[j]!= nums[k] && nums[i]!=nums[k])\\n                        count++; \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2845884,
                "title": "linear-with-combinatorics",
                "content": "```\\nclass Solution {\\npublic:\\n    static int choose2(int n) {\\n        return 2 <= n ? (n-1)*n/2 : 0;\\n    }\\n    \\n    static int choose3(int n) {\\n        return 3 <= n ? (n-2)*(n-1)*n/6 : 0;\\n    }\\n    \\n    int unequalTriplets(vector<int>& nums) {\\n        const auto n = size(nums);\\n        int h[1001] = {};\\n        for (int x: nums) h[x]++;\\n        int ans = choose3(n);\\n        for (int x: h) ans -= choose2(x)*(n-x) + choose3(x);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static int choose2(int n) {\\n        return 2 <= n ? (n-1)*n/2 : 0;\\n    }\\n    \\n    static int choose3(int n) {\\n        return 3 <= n ? (n-2)*(n-1)*n/6 : 0;\\n    }\\n    \\n    int unequalTriplets(vector<int>& nums) {\\n        const auto n = size(nums);\\n        int h[1001] = {};\\n        for (int x: nums) h[x]++;\\n        int ans = choose3(n);\\n        for (int x: h) ans -= choose2(x)*(n-x) + choose3(x);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843209,
                "title": "o-n-simple-one-pass-math-solution-with-detailed-explanation",
                "content": "# Intuition\\nWe can solve this problem by first counting all possible triplets, and then removing the ones that violate the two conditions.\\n\\n# Approach\\nIf there are total `n` elements in `nums`, the number of triplets is the number of ways in which you can choose 3 elements out of `n`, which is $$^{n}P_{3}=\\\\frac{n!}{(n-3)!}$$. From this we must remove triplets that violate the two conditions given:\\n1. `0 <= i < j < k < nums.length`\\nThis constraint effectively makes it the same as counting combinations instead of permutations. For example if `nums = [1,2,3]`,  $$^{3}P_{3}$$ gives us 6, that\\'s because permutations counts `[1,2,3]` and `[1,3,2]` as two triplets. For each i,j,k we are counting 6 triplets `ijk, ikj, kij, kji, jik, jki`. Only one of these will satisfy the condition `i < j < k`, so for each triplet we need to divide by 6. That makes it  $$^{n}C_{3}=\\\\frac{n!}{{3!}(n-3)!}$$\\n\\n2. `nums[i], nums[j], and nums[k] are pairwise distinct.`\\nThis means we need to remove the triplets where either 1) all three numbers or 2) any two numbers are the same. \\nFor the first case we simply remove $$^{m}C_{3}$$ where `m` is the frequency of the element.\\nFor example if $$nums = [1_{(0)},1_{(1)},2_{(2)},1_{(3)},3_{(4)},1_{(5)}]$$ (subscript is index), we have to remove a total of four `[1,1,1]` triplets with `i,j,k` = `0,1,3`, `0,1,5`, `1,3,5`, `0,3,5`. So this is the same as removing $$^{4}C_{3}$$\\nAnd for the second case of only two numbers being same, we need to remove $$^{m}C_{2} * (n - m)$$. That\\'s because $$^{m}C_{2}$$ counts all ways in which we can get two 1\\'s (`0,1`, `0,3`, `0,5`, `1,3`, `1,5`, `3,5`) and for each of those, the third number could be any of the remaining numbers $$(6 - 4)$$, in this case 2 and 3.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$ as we create a hash table for the counter\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        combinations = math.comb(n, 3)\\n\\n        for num, frq in Counter(nums).items():\\n            if frq >= 3:\\n                combinations -= math.comb(frq, 3)\\n            if frq >= 2:\\n                combinations -= math.comb(frq, 2) * (n - frq)\\n        \\n        return(combinations)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        combinations = math.comb(n, 3)\\n\\n        for num, frq in Counter(nums).items():\\n            if frq >= 3:\\n                combinations -= math.comb(frq, 3)\\n            if frq >= 2:\\n                combinations -= math.comb(frq, 2) * (n - frq)\\n        \\n        return(combinations)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837592,
                "title": "python-math-algorithm-o-n-vs-brute-force-o-n-3",
                "content": "# Math algorithm\\nhttps://leetcode.com/submissions/detail/847738444/  \\n```\\nRuntime: 65 ms, faster than 98.80% of Python3 online submissions for Number of Unequal Triplets in Array.\\nMemory Usage: 13.9 MB, less than 63.70% of Python3 online submissions for Number of Unequal Triplets in Array.\\n```\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        d = defaultdict(lambda:0)\\n        ## numbers of invalid pairs and triplets\\n        n_pair, n_triplet = 0, 0\\n        for i,num in enumerate(nums):\\n            n_num = d[num]\\n            n_triplet += (i-n_num)*n_num\\n            n_triplet += n_pair\\n            n_pair += n_num\\n            d[num] += 1\\n        l = len(nums)\\n        ## n*(n-1)*(n-2)/6 is the number of triples that can be chosen from n items\\n        return l*(l-1)*(l-2)//6 - n_triplet\\n```\\n\\n# Bruth force\\nhttps://leetcode.com/submissions/detail/847735616/  \\n```\\nRuntime: 656 ms, faster than 88.16% of Python3 online submissions for Number of Unequal Triplets in Array.\\nMemory Usage: 13.9 MB, less than 17.66% of Python3 online submissions for Number of Unequal Triplets in Array.\\n```\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        l, res = len(nums), 0\\n        if l<3: return res\\n        for i in range(l-2):\\n            for j in range(i+1,l-1):\\n                if nums[i]!=nums[j]:\\n                    for k in range(j+1,l):\\n                        if nums[j]!=nums[k] and nums[i]!=nums[k]:\\n                            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nRuntime: 65 ms, faster than 98.80% of Python3 online submissions for Number of Unequal Triplets in Array.\\nMemory Usage: 13.9 MB, less than 63.70% of Python3 online submissions for Number of Unequal Triplets in Array.\\n```\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        d = defaultdict(lambda:0)\\n        ## numbers of invalid pairs and triplets\\n        n_pair, n_triplet = 0, 0\\n        for i,num in enumerate(nums):\\n            n_num = d[num]\\n            n_triplet += (i-n_num)*n_num\\n            n_triplet += n_pair\\n            n_pair += n_num\\n            d[num] += 1\\n        l = len(nums)\\n        ## n*(n-1)*(n-2)/6 is the number of triples that can be chosen from n items\\n        return l*(l-1)*(l-2)//6 - n_triplet\\n```\n```\\nRuntime: 656 ms, faster than 88.16% of Python3 online submissions for Number of Unequal Triplets in Array.\\nMemory Usage: 13.9 MB, less than 17.66% of Python3 online submissions for Number of Unequal Triplets in Array.\\n```\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        l, res = len(nums), 0\\n        if l<3: return res\\n        for i in range(l-2):\\n            for j in range(i+1,l-1):\\n                if nums[i]!=nums[j]:\\n                    for k in range(j+1,l):\\n                        if nums[j]!=nums[k] and nums[i]!=nums[k]:\\n                            res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834376,
                "title": "python-one-pass-o-n-count-invalid-triplets",
                "content": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        num_count = Counter()\\n        n_invalid_pairs = 0\\n        n_invalid_triplets = 0\\n        for (i, num) in enumerate(nums):\\n            n_invalid_triplets += (i-num_count.get(num, 0)) * num_count.get(num, 0)\\n            n_invalid_triplets += n_invalid_pairs\\n            n_invalid_pairs += num_count[num]\\n            num_count[num] += 1\\n        n_nums = len(nums)\\n        return n_nums * (n_nums-1) * (n_nums-2) // 6 - n_invalid_triplets\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        from collections import Counter\\n        num_count = Counter()\\n        n_invalid_pairs = 0\\n        n_invalid_triplets = 0\\n        for (i, num) in enumerate(nums):\\n            n_invalid_triplets += (i-num_count.get(num, 0)) * num_count.get(num, 0)\\n            n_invalid_triplets += n_invalid_pairs\\n            n_invalid_pairs += num_count[num]\\n            num_count[num] += 1\\n        n_nums = len(nums)\\n        return n_nums * (n_nums-1) * (n_nums-2) // 6 - n_invalid_triplets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2834140,
                "title": "c-brute-force-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[i]!=nums[k]) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size()-2;i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[i]!=nums[k]) count++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2832968,
                "title": "brute-force-set-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSmaller constraint gives the idea regarding brute force.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimple brute force approach by iterating over given thrice & whenever set size becomes == 3 we increase the counter.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nWorst Case T.C. = $$O(N^3)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nConstant Space i.e.  $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size(); int cnt =0 ;\\n        for(int i=0;i<n;i++){\\n            unordered_set<int> st;\\n            st.insert(nums[i]);\\n            for(int j =i+1 ;j<n;j++){\\n                st.insert(nums[j]);\\n                if(st.size()==2){for(int k = j+1;k<n;k++){\\n                    st.insert(nums[k]);\\n                    if(st.size() == 3) {cnt++;st.erase(nums[k]);}\\n                }}\\n                if(st.size()==2) st.erase(nums[j]);\\n            }\\n            if(st.size() == 1)st.erase(nums[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size(); int cnt =0 ;\\n        for(int i=0;i<n;i++){\\n            unordered_set<int> st;\\n            st.insert(nums[i]);\\n            for(int j =i+1 ;j<n;j++){\\n                st.insert(nums[j]);\\n                if(st.size()==2){for(int k = j+1;k<n;k++){\\n                    st.insert(nums[k]);\\n                    if(st.size() == 3) {cnt++;st.erase(nums[k]);}\\n                }}\\n                if(st.size()==2) st.erase(nums[j]);\\n            }\\n            if(st.size() == 1)st.erase(nums[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832782,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn unequal_triplets(nums: Vec<i32>) -> i32 {\\n        let l = nums.len();\\n        let mut res = 0;\\n        for (i, &a) in nums.iter().enumerate().take(l - 2) {\\n            for (j, &b) in nums.iter().enumerate().take(l - 1).skip(i + 1) {\\n                nums[j + 1..]\\n                    .iter()\\n                    .filter(|&&c| a != b && b != c && c != a)\\n                    .for_each(|_| res += 1);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn unequal_triplets(nums: Vec<i32>) -> i32 {\\n        let l = nums.len();\\n        let mut res = 0;\\n        for (i, &a) in nums.iter().enumerate().take(l - 2) {\\n            for (j, &b) in nums.iter().enumerate().take(l - 1).skip(i + 1) {\\n                nums[j + 1..]\\n                    .iter()\\n                    .filter(|&&c| a != b && b != c && c != a)\\n                    .for_each(|_| res += 1);\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832654,
                "title": "c-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans=0; \\n        int n=nums.size(); \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(nums[i]!=nums[j] and nums[j]!=nums[k] and nums[i]!=nums[k]) ans++; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans=0; \\n        int n=nums.size(); \\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=i+1;j<n;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    if(nums[i]!=nums[j] and nums[j]!=nums[k] and nums[i]!=nums[k]) ans++; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832511,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j-i+1,len(nums)):\\n                    if i<j<k and nums[i]!=nums[j] and nums[i]!=nums[k] and nums[j]!=nums[k]:\\n                        c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j-i+1,len(nums)):\\n                    if i<j<k and nums[i]!=nums[j] and nums[i]!=nums[k] and nums[j]!=nums[k]:\\n                        c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832440,
                "title": "easiest-solution-using-brute-force-with-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt does this by comparing each element with every other element. If all three elements are unequal, it increments a counter variable.\\n\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count =0;\\n        int n = nums.length;\\n        for(int i=0;i<n-2;i++){\\n          for(int j=i+1;j<n-1;j++){\\n              for(int k=i+2;k<n;k++){\\n                  if(i<j && j<k){\\n                  if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])\\n                      count++;\\n                  }\\n              }\\n          }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count =0;\\n        int n = nums.length;\\n        for(int i=0;i<n-2;i++){\\n          for(int j=i+1;j<n-1;j++){\\n              for(int k=i+2;k<n;k++){\\n                  if(i<j && j<k){\\n                  if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])\\n                      count++;\\n                  }\\n              }\\n          }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832199,
                "title": "python-js-easy-logic-brute-force",
                "content": "**Upvote if the solution is easy enough :)**\\n### Python\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        res = 0\\n        \\n        for i in range(len(nums) - 2):\\n            for j in range(i, len(nums) - 1):\\n                for k in range(j, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]: res += 1\\n        \\n        return res\\n```\\n### Javascript\\n```\\nvar unequalTriplets = function(nums) {\\n    n = nums.length\\n    res = 0\\n    \\n    for (let i = 0; i < n - 2; i++)\\n        for (let j = i + 1; j < n - 1; j++)\\n            for (let k = j + 1; k < n; k++)\\n                if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    res++\\n    \\n    return res\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        res = 0\\n        \\n        for i in range(len(nums) - 2):\\n            for j in range(i, len(nums) - 1):\\n                for k in range(j, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]: res += 1\\n        \\n        return res\\n```\n```\\nvar unequalTriplets = function(nums) {\\n    n = nums.length\\n    res = 0\\n    \\n    for (let i = 0; i < n - 2; i++)\\n        for (let j = i + 1; j < n - 1; j++)\\n            for (let k = j + 1; k < n; k++)\\n                if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    res++\\n    \\n    return res\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832141,
                "title": "beats-100-o-n-m-dp-solution-in-c",
                "content": "# Intuition\\nUse Dynamic Program to perform the O(n+m) time complexity algorithm where n is the number of while digits and m is the number of unique digits.\\n\\n# Approach\\nFirstly, use a hash table to collect the number of each digit. It reduces \"m\" from the number of nums[] to the number of unique digits.\\n\\nSecondly,  fill the number of combinations to:\\n- dp1[i] = number of 1-digit combinations after/at i\\n       = dp1[i] + dp[i+1] + ... + dp[n-1]\\n       = v_ndigits[i] + dp[i+1]\\n\\n- dp2[i] = number of 2-digit combinations after/at i\\n       = pick i => (number of digit i) * (number of 1-digit combinations after/at i+1)\\n         + not pick i => dp2[i+1]\\n       = v_ndigits[i] * dp1[i+1]    +    dp2[i+1]\\n\\n- dp3[i] = number of 3-digit combinations after/at i\\n       = pick i => (number of digit i) * (number of 2-digit combinations after/at i+1)\\n         + not pick i => dp3[i+1]\\n       = v_ndigits[i] * dp2[i+1] + dp3[i+1];  \\n\\nThen dp3[n-1] is the answer.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n+m)$$\\nwhere n is the number of whole digits and m is the number of unique digits.\\n\\n- Space complexity:\\n$$O(m)$$\\nwhere m is the number of unique digits.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    int unequalTriplets(vector<int>& nums) {        \\n        unordered_map<int,int> m_ndigits; //number of digits\\n        for(auto val : nums) \\n            m_ndigits[val]++;\\n        int n= m_ndigits.size(); \\n        if( n<3 )\\n            return 0;\\n        \\n        //map to vector\\n        vector<int> v_ndigits;\\n        for(auto p : m_ndigits) {\\n            v_ndigits.push_back(p.second);\\n        }\\n        \\n        vector<int> dp1(n, 0), dp2(n, 0), dp3(n, 0);\\n        //dp1[i] = number of 1-digit combinations after/at i\\n        dp1[n-1]= v_ndigits[n-1];\\n        for(int i=n-2 ; i>=0 ; i--) \\n            dp1[i]= dp1[i+1] + v_ndigits[i];\\n            \\n        //dp2[i] = number of 2-digit combinations after/at i\\n        for(int i=n-2 ; i>=0 ; i--) \\n            dp2[i]= v_ndigits[i]*dp1[i+1]+dp2[i+1];\\n            \\n        //dp3[i] = number of 3-digit combinations after/at i\\n        for(int i=n-3 ; i>=0 ; i--) \\n            dp3[i]= v_ndigits[i]*dp2[i+1]+dp3[i+1];        \\n            \\n        return dp3[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    int unequalTriplets(vector<int>& nums) {        \\n        unordered_map<int,int> m_ndigits; //number of digits\\n        for(auto val : nums) \\n            m_ndigits[val]++;\\n        int n= m_ndigits.size(); \\n        if( n<3 )\\n            return 0;\\n        \\n        //map to vector\\n        vector<int> v_ndigits;\\n        for(auto p : m_ndigits) {\\n            v_ndigits.push_back(p.second);\\n        }\\n        \\n        vector<int> dp1(n, 0), dp2(n, 0), dp3(n, 0);\\n        //dp1[i] = number of 1-digit combinations after/at i\\n        dp1[n-1]= v_ndigits[n-1];\\n        for(int i=n-2 ; i>=0 ; i--) \\n            dp1[i]= dp1[i+1] + v_ndigits[i];\\n            \\n        //dp2[i] = number of 2-digit combinations after/at i\\n        for(int i=n-2 ; i>=0 ; i--) \\n            dp2[i]= v_ndigits[i]*dp1[i+1]+dp2[i+1];\\n            \\n        //dp3[i] = number of 3-digit combinations after/at i\\n        for(int i=n-3 ; i>=0 ; i--) \\n            dp3[i]= v_ndigits[i]*dp2[i+1]+dp3[i+1];        \\n            \\n        return dp3[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832138,
                "title": "simple-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n^3)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    let ans = 0\\n    let seen = {}\\n\\n    for (let i =0; i< nums.length; i++) {\\n        if (seen.hasOwnProperty(nums[i])){\\n            continue\\n        } \\n        \\n        for (let j = i+1; j< nums.length; j++) {\\n            for (let k = j+1; k < nums.length; k++) {\\n                if (nums[i] !== nums[j] && nums[j] !== nums[k] && nums[i] !==nums[k]) {\\n                    ans++\\n                }\\n            }\\n        }\\n        \\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    let ans = 0\\n    let seen = {}\\n\\n    for (let i =0; i< nums.length; i++) {\\n        if (seen.hasOwnProperty(nums[i])){\\n            continue\\n        } \\n        \\n        for (let j = i+1; j< nums.length; j++) {\\n            for (let k = j+1; k < nums.length; k++) {\\n                if (nums[i] !== nums[j] && nums[j] !== nums[k] && nums[i] !==nums[k]) {\\n                    ans++\\n                }\\n            }\\n        }\\n        \\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2832059,
                "title": "java-3-solutions-brute-force-optimal",
                "content": "### **Please Upvote** :D\\n##### 1. Using HashSet:\\nThis is not an efficient solution though, using a new empty set at each iteration, addition and removal at each nested iteration costs a lot of runtime.\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        Set<Integer> set;\\n\\n        for (int i = 0; i < n; i++){\\n            set = new HashSet<>();\\n            set.add(nums[i]);\\n\\n            for (int j = i + 1; j < n; j++){\\n                set.add(nums[j]);\\n\\n                if (set.size() == 2) {\\n                    for (int k = j + 1; k < n; k++){\\n                        set.add(nums[k]);\\n\\n                        if (set.size() == 3) {\\n                            count++;\\n                            set.remove(nums[k]);\\n                        }\\n                    }\\n\\n                    set.remove(nums[j]);\\n                }\\n\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 3)\\n// SC: O(1) - because size of hashset is atmost 3\\n```\\n#### 2. Without extra space:\\nThis is a comparitively fast solution.\\nNo extra space, just iterations and comparisons.\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++)\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                        count++;\\n                    }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```\\n##### 3. Optimal solution using HashMap:\\nHead over to **[votrubac\\'s solution](https://leetcode.com/problems/number-of-unequal-triplets-in-array/discuss/2831702/O(n))** for explanation.\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int num : nums){\\n            map.put(num , map.getOrDefault(num ,0)+1);\\n        }\\n\\n        int left = 0, right = nums.length;\\n        int ans = 0;\\n\\n        for (int key : map.keySet()){\\n            int count = map.get(key);\\n            right -= count;\\n            ans += left * count * right;\\n            left += count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        Set<Integer> set;\\n\\n        for (int i = 0; i < n; i++){\\n            set = new HashSet<>();\\n            set.add(nums[i]);\\n\\n            for (int j = i + 1; j < n; j++){\\n                set.add(nums[j]);\\n\\n                if (set.size() == 2) {\\n                    for (int k = j + 1; k < n; k++){\\n                        set.add(nums[k]);\\n\\n                        if (set.size() == 3) {\\n                            count++;\\n                            set.remove(nums[k]);\\n                        }\\n                    }\\n\\n                    set.remove(nums[j]);\\n                }\\n\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 3)\\n// SC: O(1) - because size of hashset is atmost 3\\n```\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                for (int k = j + 1; k < n; k++)\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                        count++;\\n                    }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n ^ 3), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int num : nums){\\n            map.put(num , map.getOrDefault(num ,0)+1);\\n        }\\n\\n        int left = 0, right = nums.length;\\n        int ans = 0;\\n\\n        for (int key : map.keySet()){\\n            int count = map.get(key);\\n            right -= count;\\n            ans += left * count * right;\\n            left += count;\\n        }\\n\\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832025,
                "title": "c-o-n-n-n-easy-explanation",
                "content": "**Time Complexity:** O(N*N*N)\\n**Space Complexity:** O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            for(int j = i + 1; j < nums.size(); ++j){\\n                for(int k = j +1; k < nums.size(); ++k){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        \\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); ++i){\\n            for(int j = i + 1; j < nums.size(); ++j){\\n                for(int k = j +1; k < nums.size(); ++k){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) ans++;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831810,
                "title": "c-code-easy-to-understand-faster-than-100",
                "content": "***If you find this helpful, Please Upvote \\uD83D\\uDD3C\\nThank You !***\\n\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int cnt = 0;\\n        for (int i = 0; i < n - 2; i++) \\n            for (int j = i + 1; j < n - 1; j++) \\n                for (int k = j + 1; k < n; k++)\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) \\n                        cnt++;\\n                    \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        int cnt = 0;\\n        for (int i = 0; i < n - 2; i++) \\n            for (int j = i + 1; j < n - 1; j++) \\n                for (int k = j + 1; k < n; k++)\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) \\n                        cnt++;\\n                    \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831773,
                "title": "c-easy-and-simple-solution",
                "content": "***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***<br>\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n***Guy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE. By doing that it motivate\\'s me to create more better post like this \\u270D\\uFE0F***<br>",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]) count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831723,
                "title": "cpp-using-three-loops-beginner-friendly",
                "content": "class Solution {\\npublic:\\n\\n\\n    int unequalTriplets(vector<int>& a) {\\n        int n = a.size();\\n        int count = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(a[i] != a[j] && a[j] != a[k] && a[k] != a[i]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    int unequalTriplets(vector<int>& a) {\\n        int n = a.size();\\n        int count = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(a[i] != a[j] && a[j] != a[k] && a[k] != a[i]){\\n                        count++;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2831720,
                "title": "simple-short-naive-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int unequalTriplets(vector<int>&v) {\\n        ll ans=0, n=v.size();\\n        for(ll i=0;i<n;++i){\\n            for(ll j=i+1;j<n;++j){\\n                for(ll k=j+1;k<n;++k){\\n                    ans+=v[i]!=v[j] && v[j]!=v[k] && v[k]!=v[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\npublic:\\n    int unequalTriplets(vector<int>&v) {\\n        ll ans=0, n=v.size();\\n        for(ll i=0;i<n;++i){\\n            for(ll j=i+1;j<n;++j){\\n                for(ll k=j+1;k<n;++k){\\n                    ans+=v[i]!=v[j] && v[j]!=v[k] && v[k]!=v[i];\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831714,
                "title": "c-brute-force",
                "content": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[i]!=nums[k]) cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[i]!=nums[k]) cnt++;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831664,
                "title": "easy-brute-force-accepted",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n         int res = 0;\\n        for(int i= 0;i<nums.size()-2;i++){\\n            for(int j = i+1;j<nums.size()-1;j++){\\n                for(int k = j+1;k<nums.size();k++){\\n                    if(nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k])++res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n         int res = 0;\\n        for(int i= 0;i<nums.size()-2;i++){\\n            for(int j = i+1;j<nums.size()-1;j++){\\n                for(int k = j+1;k<nums.size();k++){\\n                    if(nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k])++res;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4098831,
                "title": "c-best-bruteforce-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n    int count=0;\\n    int n=nums.size();\\n    for(int i=0;i<n;i++){\\n    for(int j=0;j<n;j++){\\n        for(int k=0;k<n;k++){\\n            if(nums[i]<nums[j]&&nums[j]<nums[k]&&nums[k]>nums[i])\\n            count++;\\n        }\\n    }   \\n    }\\n    return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n    int count=0;\\n    int n=nums.size();\\n    for(int i=0;i<n;i++){\\n    for(int j=0;j<n;j++){\\n        for(int k=0;k<n;k++){\\n            if(nums[i]<nums[j]&&nums[j]<nums[k]&&nums[k]>nums[i])\\n            count++;\\n        }\\n    }   \\n    }\\n    return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083517,
                "title": "c-brute-force-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^3)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\npublic class Solution\\n{\\n    public int UnequalTriplets(int[] nums)\\n    {\\n        var count = 0;\\n        \\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            for (var j = i + 1; j < nums.Length; j++)\\n            {\\n                for (var k = j + 1; k < nums.Length; k++)\\n                {\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    public int UnequalTriplets(int[] nums)\\n    {\\n        var count = 0;\\n        \\n        for (var i = 0; i < nums.Length; i++)\\n        {\\n            for (var j = i + 1; j < nums.Length; j++)\\n            {\\n                for (var k = j + 1; k < nums.Length; k++)\\n                {\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4074966,
                "title": "dart-solution-using-3-loops",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int unequalTriplets(List<int> nums) {\\n      int count = 0;\\n      for(int i=0; i<nums.length-2; i++){\\n          for(int j=i+1; j<nums.length-1; j++){\\n              for(int k=j+1; k<nums.length; k++){\\n                  if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[i]!=nums[k]){\\n                      count++;\\n                  }\\n              }\\n          }\\n      }\\n      return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int unequalTriplets(List<int> nums) {\\n      int count = 0;\\n      for(int i=0; i<nums.length-2; i++){\\n          for(int j=i+1; j<nums.length-1; j++){\\n              for(int k=j+1; k<nums.length; k++){\\n                  if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[i]!=nums[k]){\\n                      count++;\\n                  }\\n              }\\n          }\\n      }\\n      return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038849,
                "title": "basic-and-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n\\tTime: O(n^3)\\n*/\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                for (int k = j+1; k < nums.length; k++) {\\n                   if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                       count++;\\n                   } \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n\\tTime: O(n^3)\\n*/\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                for (int k = j+1; k < nums.length; k++) {\\n                   if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                       count++;\\n                   } \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019598,
                "title": "java-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCount all triplets, minus triples with exactly 2 dupelicate numbers, and triplets with exactly 3 identical numbers.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        // count all then deduct triplets with dupes\\n        Map<Integer, Integer> count = new HashMap();\\n        for(int num : nums)\\n            if(count.get(num) == null) count.put(num, 1);\\n            else count.put(num, count.get(num) + 1);\\n        int n = nums.length;\\n        int threeDupes = 0;\\n        int twoDupes = 0;\\n        int numOfKeys = count.keySet().size();\\n        for(int k : count.keySet()){\\n            int v = count.get(k);\\n            if(v >= 2)\\n                twoDupes += v * (v - 1) * (n - v) / 2; // C(v, 2) *  (numOfKeys - 1)\\n            if(v >= 3)\\n                threeDupes += v * (v - 1) * (v - 2) / 6; // C(v, 3)\\n        }\\n\\n        return n * (n - 1) * (n - 2) / 6 // all triplets\\n            - twoDupes - threeDupes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        // count all then deduct triplets with dupes\\n        Map<Integer, Integer> count = new HashMap();\\n        for(int num : nums)\\n            if(count.get(num) == null) count.put(num, 1);\\n            else count.put(num, count.get(num) + 1);\\n        int n = nums.length;\\n        int threeDupes = 0;\\n        int twoDupes = 0;\\n        int numOfKeys = count.keySet().size();\\n        for(int k : count.keySet()){\\n            int v = count.get(k);\\n            if(v >= 2)\\n                twoDupes += v * (v - 1) * (n - v) / 2; // C(v, 2) *  (numOfKeys - 1)\\n            if(v >= 3)\\n                threeDupes += v * (v - 1) * (v - 2) / 6; // C(v, 3)\\n        }\\n\\n        return n * (n - 1) * (n - 2) / 6 // all triplets\\n            - twoDupes - threeDupes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003535,
                "title": "optimized-solution-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn summary, this code efficiently counts the number of triplets (i, j, k) in the nums array such that i < j < k and nums[i] < nums[j] < nums[k]. It does this by using an unordered map to store counts of unique numbers and then iterating through them while maintaining variables for left, right, and the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The code starts by calculating the size of the input array nums and initializes an unordered map mp to store the count of each unique number in nums.\\n\\n2. It then iterates through the nums array and updates the counts of each unique number in the mp map.\\n\\n3. The code initializes three variables: left to 0, right to n (the size of nums), and res to 0. These variables will be used to calculate the result.\\n\\n4. Next, there\\'s a loop that iterates through the unique numbers and their counts in the mp map.\\n\\n5. Inside the loop, it updates right by subtracting the current number\\'s count. This is because the code is trying to count triplets (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. By subtracting the count of the current number from right, it effectively counts the number of elements greater than the current number that can be used as k.\\n\\n6. It then updates the res variable by multiplying left, right, and the count of the current number. This multiplication effectively counts the number of triplets that satisfy the condition for the current number.\\n\\n7. Finally, it increments the left variable by the count of the current number. This is done to prepare for the next iteration, as it represents the count of numbers less than the current number that can be used as i.\\n\\n8. After the loop completes, the res variable contains the total count of triplets that satisfy the given condition, and it is returned as the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++) {\\n            mp[nums[i]]++;\\n        }\\n\\n        int left = 0;\\n        int right = n;\\n        int res = 0;\\n\\n        for(auto it : mp) {\\n            right -= it.second;\\n            res += left*it.second*right;\\n            left += it.second;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<n;i++) {\\n            mp[nums[i]]++;\\n        }\\n\\n        int left = 0;\\n        int right = n;\\n        int res = 0;\\n\\n        for(auto it : mp) {\\n            right -= it.second;\\n            res += left*it.second*right;\\n            left += it.second;\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998451,
                "title": "should-be-a-medium",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef unequal_triplets(nums)\\n    # No numbers can be the same in a set of i,j,k.\\n    # i, j and k are indexes.\\n    i = 0\\n    j = 1\\n    k = 2\\n\\n    answer = 0\\n    current_set = Set.new()\\n    while k < nums.size\\n        \\n        final_j_index = nums.size - 1 \\n        \\n        current_set << nums[i]\\n        while j < final_j_index\\n            \\n            if !current_set.include? nums[j] \\n                current_set << nums[j]\\n\\n                k = j + 1\\n                while k < nums.size\\n                    if !current_set.include? nums[k]\\n                        answer = answer + 1\\n                    end\\n                    \\n                    k = k + 1\\n                end\\n\\n                current_set.delete nums[j]\\n            end\\n            \\n            j = j + 1\\n            k = j + 1\\n        end\\n            \\n        i = i + 1\\n        j = i + 1\\n        k = j + 1\\n        current_set.clear\\n    end\\n    \\n    answer\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef unequal_triplets(nums)\\n    # No numbers can be the same in a set of i,j,k.\\n    # i, j and k are indexes.\\n    i = 0\\n    j = 1\\n    k = 2\\n\\n    answer = 0\\n    current_set = Set.new()\\n    while k < nums.size\\n        \\n        final_j_index = nums.size - 1 \\n        \\n        current_set << nums[i]\\n        while j < final_j_index\\n            \\n            if !current_set.include? nums[j] \\n                current_set << nums[j]\\n\\n                k = j + 1\\n                while k < nums.size\\n                    if !current_set.include? nums[k]\\n                        answer = answer + 1\\n                    end\\n                    \\n                    k = k + 1\\n                end\\n\\n                current_set.delete nums[j]\\n            end\\n            \\n            j = j + 1\\n            k = j + 1\\n        end\\n            \\n        i = i + 1\\n        j = i + 1\\n        k = j + 1\\n        current_set.clear\\n    end\\n    \\n    answer\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3976326,
                "title": "very-easy-solution-without-counter-function",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n\\tdef unequalTriplets(self, nums: List[int]) -> int:\\n\\n\\t\\tresult = 0\\n\\n\\t\\tfor i in range(len(nums)-2):\\n\\t\\t\\tfor j in range(i+1,len(nums)-1):\\n\\t\\t\\t\\tfor k in range(j+1,len(nums)):\\n\\n\\t\\t\\t\\t\\tif nums[i] != nums[j] and nums[j] != nums[k] and nums[i] != nums[k]:\\n\\t\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\treturn result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef unequalTriplets(self, nums: List[int]) -> int:\\n\\n\\t\\tresult = 0\\n\\n\\t\\tfor i in range(len(nums)-2):\\n\\t\\t\\tfor j in range(i+1,len(nums)-1):\\n\\t\\t\\t\\tfor k in range(j+1,len(nums)):\\n\\n\\t\\t\\t\\t\\tif nums[i] != nums[j] and nums[j] != nums[k] and nums[i] != nums[k]:\\n\\t\\t\\t\\t\\t\\tresult = result + 1\\n\\n\\t\\treturn result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973333,
                "title": "java-three-pointers",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        int i = 0, j = 1, k = 2;\\n        while(i<nums.length-2)\\n        {\\n            if(nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]){\\n                count++;\\n            }\\n            k++;\\n            if(k == nums.length){\\n                j++;\\n                k = j+1;\\n            }\\n            if(j == nums.length - 1){\\n                i++;\\n                j = i + 1;\\n                k = j + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        int i = 0, j = 1, k = 2;\\n        while(i<nums.length-2)\\n        {\\n            if(nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]){\\n                count++;\\n            }\\n            k++;\\n            if(k == nums.length){\\n                j++;\\n                k = j+1;\\n            }\\n            if(j == nums.length - 1){\\n                i++;\\n                j = i + 1;\\n                k = j + 1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3971239,
                "title": "java-easiest-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                for(int k=j+1; k<n; k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int count = 0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n; j++){\\n                for(int k=j+1; k<n; k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964871,
                "title": "super-simple-o-n-c-solution",
                "content": "# Approach\\nSee the code\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  const int N = 1000;\\n  int unequalTriplets(vector<int> &a) {\\n    vector<int> cnt(N + 1);\\n    for (int x : a) cnt[x]++;\\n    a = cnt;\\n    auto f = [&]() { \\n      for (int i = 1; i <= N; i++) cnt[i] += cnt[i - 1];\\n      for (int i = N; i >= 1; i--) cnt[i] = a[i] * cnt[i - 1];\\n    };\\n    f(); f();\\n    int res = 0;\\n    for (int i = 1; i <= N; i++) res += cnt[i];\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  const int N = 1000;\\n  int unequalTriplets(vector<int> &a) {\\n    vector<int> cnt(N + 1);\\n    for (int x : a) cnt[x]++;\\n    a = cnt;\\n    auto f = [&]() { \\n      for (int i = 1; i <= N; i++) cnt[i] += cnt[i - 1];\\n      for (int i = N; i >= 1; i--) cnt[i] = a[i] * cnt[i - 1];\\n    };\\n    f(); f();\\n    int res = 0;\\n    for (int i = 1; i <= N; i++) res += cnt[i];\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3953129,
                "title": "easy-solution-in-c",
                "content": "# Intuition\\n\\n\\n# Approach\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            for (int j = i + 1; j < nums.size() - 1; j++) {\\n                for (int k = j + 1; k < nums.size(); k++) {\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n\\n        for (int i = 0; i < nums.size() - 2; i++) {\\n            for (int j = i + 1; j < nums.size() - 1; j++) {\\n                for (int k = j + 1; k < nums.size(); k++) {\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952635,
                "title": "java-solution-easy-understanding-runtime-8ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int res = 0;\\n\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            for(int j = i+1; j>i && j<nums.length; j++)\\n            {\\n                for(int k = j+1; k>j && k<nums.length; k++)\\n                {\\n                    if(nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                    {\\n                        res++;\\n                    }   \\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int res = 0;\\n\\n        for(int i = 0; i<nums.length; i++)\\n        {\\n            for(int j = i+1; j>i && j<nums.length; j++)\\n            {\\n                for(int k = j+1; k>j && k<nums.length; k++)\\n                {\\n                    if(nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                    {\\n                        res++;\\n                    }   \\n                }\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946502,
                "title": "number-of-unequal-triplets-in-array",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           for(int j=i+1;j<nums.length;j++)\\n            {\\n                for(int k=j+1;k<nums.length;k++)\\n                {\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i])\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n           for(int j=i+1;j<nums.length;j++)\\n            {\\n                for(int k=j+1;k<nums.length;k++)\\n                {\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i])\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946073,
                "title": "ruby-nested-for-loops",
                "content": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef unequal_triplets(nums)\\n  c = 0\\n  for i in 0...nums.length\\n    for j in i...nums.length\\n      for k in j...nums.length\\n        c+= 1 if nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]\\n      end\\n    end\\n  end\\n  c\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef unequal_triplets(nums)\\n  c = 0\\n  for i in 0...nums.length\\n    for j in i...nums.length\\n      for k in j...nums.length\\n        c+= 1 if nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]\\n      end\\n    end\\n  end\\n  c\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3944740,
                "title": "best-sollution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j]&&nums[i]!=nums[k]&&nums[j]!=nums[k]){\\n                        count = count + 1;\\n                    }\\n                    // else{\\n                    //     break;\\n                    // }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j]&&nums[i]!=nums[k]&&nums[j]!=nums[k]){\\n                        count = count + 1;\\n                    }\\n                    // else{\\n                    //     break;\\n                    // }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944023,
                "title": "simple-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ct=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++)\\n             {\\n                 for(int k=j+1;k<n;k++)\\n                 {\\n                     if(nums[i]!=nums[j] and nums[j]!=nums[k] and nums[i]!=nums[k])\\n                            ct++;\\n                 }\\n             }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ct=0,n=nums.size();\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++)\\n             {\\n                 for(int k=j+1;k<n;k++)\\n                 {\\n                     if(nums[i]!=nums[j] and nums[j]!=nums[k] and nums[i]!=nums[k])\\n                            ct++;\\n                 }\\n             }\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3941378,
                "title": "python-3-o-n-sc-and-o-n-3-worst-case-tc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        dd = {}\\n\\n        for n in nums:\\n            dd[n] = dd.get(n, 0) + 1\\n\\n        res = 0\\n\\n        counts = list(dd.values())\\n        for i in range(len(dd.values())):\\n            for j in range(i + 1, len(dd.values())):\\n                for k in range(j + 1, len(dd.values())):\\n                    res += counts[i] * counts[j] * counts[k]\\n\\n        if len(dd) == 1 or len(dd) == 2:\\n            return 0\\n        else:\\n            return res        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        dd = {}\\n\\n        for n in nums:\\n            dd[n] = dd.get(n, 0) + 1\\n\\n        res = 0\\n\\n        counts = list(dd.values())\\n        for i in range(len(dd.values())):\\n            for j in range(i + 1, len(dd.values())):\\n                for k in range(j + 1, len(dd.values())):\\n                    res += counts[i] * counts[j] * counts[k]\\n\\n        if len(dd) == 1 or len(dd) == 2:\\n            return 0\\n        else:\\n            return res        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3938271,
                "title": "beats-easy-beginner-friendly-solution-simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0,n=nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0,n=nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928834,
                "title": "closed-formula-using-a-single-counter-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to compute the number of triplets (i<j<k) such that the associated values are pairwise different.\\n The cardinal of the complementary set is much easier to compute: it is made of triplets (i<j<k) such that there is exactly a pair of equal values or (disjoint or) a triplet of equal values.\\n\\n\\n# Approach\\n\\nWe want to compute \"#triplets - #triplets which are not pairwise different\". Observe that a triplet is not pairwise different if either (=exclusive or) exactly one of its pairs is of equal values or it is a triplet of equal values.\\n\\nDo a single pass to count the number of time each element appears. In Python, Counter() does that nicely.\\n\\nThe total number of triplets is n chose 3. Now, given an arbitrary element num of nums appearing k (=k_num) times, we have that:\\n- k chose 2 ways to make a pair using num and (n-k) ways to complete it in a triplet with a different element of nums,\\n- k chose 3 ways to make a triplet of num.\\n\\nHence the closed formula given in the code.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n), the complexity of Counter().\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n), the complexity of Counter().\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        d = Counter(nums)\\n \\xA0 \\xA0 \\xA0 \\xA0return comb(n,3)  sum(comb(k,2)*(n-k) + comb(k,3)  for k in d.values())\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        d = Counter(nums)\\n \\xA0 \\xA0 \\xA0 \\xA0return comb(n,3)  sum(comb(k,2)*(n-k) + comb(k,3)  for k in d.values())\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3928270,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int ans = 0;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    if (nums[i] == nums[j]) break;\\n                    if ((nums[i] != nums[j]) && (nums[j] != nums[k]) && (nums[k] != nums[i])) ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length;\\n        int ans = 0;\\n\\n        for (int i = 0; i < n - 2; i++) {\\n            for (int j = i + 1; j < n - 1; j++) {\\n                for (int k = j + 1; k < n; k++) {\\n                    if (nums[i] == nums[j]) break;\\n                    if ((nums[i] != nums[j]) && (nums[j] != nums[k]) && (nums[k] != nums[i])) ans++;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918566,
                "title": "2475-number-of-unequal-triplets-in-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c = 0 ;\\n        for(int i = 0 ; i<nums.length ; i++){\\n            for(int j = i+1 ; j<nums.length ; j++){\\n                for(int k = j+1 ; k<nums.length ; k++){\\n                    if((nums[i] != nums[j])  && \\n                       (nums[i] != nums[k])  &&\\n                       (nums[j] != nums[k])){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return c ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c = 0 ;\\n        for(int i = 0 ; i<nums.length ; i++){\\n            for(int j = i+1 ; j<nums.length ; j++){\\n                for(int k = j+1 ; k<nums.length ; k++){\\n                    if((nums[i] != nums[j])  && \\n                       (nums[i] != nums[k])  &&\\n                       (nums[j] != nums[k])){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return c ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3895726,
                "title": "brute-force-solution-beats-80-must-read-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        lenN = len(nums)\\n        uneq_trip  = 0\\n        for i in range(lenN-2):\\n            n1 = nums[i]\\n            for j in range(i+1,lenN):\\n                n2 = nums[j]\\n                if n1 != n2:\\n                    for k in range(j+1,lenN):\\n                        n3 = nums[k]\\n                        if n1 != n3:\\n                            if n3!=n2:\\n                                uneq_trip +=1\\n        return uneq_trip\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        lenN = len(nums)\\n        uneq_trip  = 0\\n        for i in range(lenN-2):\\n            n1 = nums[i]\\n            for j in range(i+1,lenN):\\n                n2 = nums[j]\\n                if n1 != n2:\\n                    for k in range(j+1,lenN):\\n                        n3 = nums[k]\\n                        if n1 != n3:\\n                            if n3!=n2:\\n                                uneq_trip +=1\\n        return uneq_trip\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888821,
                "title": "easy-java-soultion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n              for(int k=j+1;k<nums.length;k++){\\n                  if(nums[i]!=nums[j]&&nums[j]!=nums[k]&& nums[i]!=nums[k])\\n                   count++;\\n            \\n              }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n              for(int k=j+1;k<nums.length;k++){\\n                  if(nums[i]!=nums[j]&&nums[j]!=nums[k]&& nums[i]!=nums[k])\\n                   count++;\\n            \\n              }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3888820,
                "title": "easy-java-soultion",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n              for(int k=j+1;k<nums.length;k++){\\n                  if(nums[i]!=nums[j]&&nums[j]!=nums[k]&& nums[i]!=nums[k])\\n                   count++;\\n            \\n              }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n              for(int k=j+1;k<nums.length;k++){\\n                  if(nums[i]!=nums[j]&&nums[j]!=nums[k]&& nums[i]!=nums[k])\\n                   count++;\\n            \\n              }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856617,
                "title": "java-2ms-beats-90-18",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n\\n        // 2ms Beats 90.18%\\n\\n        int numTriplets = 0;  // what we\\'ll return\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int n : nums) {\\n            map.merge(n, 1, Integer::sum);\\n        }\\n\\n        int left = 0;\\n        int right = nums.length;\\n\\n        for (int n : map.values()) {\\n            right -= n;\\n            numTriplets += left * n * right;\\n            left += n;\\n        }\\n\\n        return numTriplets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n\\n        // 2ms Beats 90.18%\\n\\n        int numTriplets = 0;  // what we\\'ll return\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int n : nums) {\\n            map.merge(n, 1, Integer::sum);\\n        }\\n\\n        int left = 0;\\n        int right = nums.length;\\n\\n        for (int n : map.values()) {\\n            right -= n;\\n            numTriplets += left * n * right;\\n            left += n;\\n        }\\n\\n        return numTriplets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3851903,
                "title": "number-of-unequal-triplets-in-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        int i=0;\\n        int j = 1;\\n        int k=2;\\n        while(i<nums.length-2)\\n        {\\n            if(nums[i]!=nums[j]&&nums[i]!=nums[k]&&nums[j]!=nums[k])\\n            count++;\\n            k++;\\n            if(k==nums.length)\\n            {\\n                j=j+1;\\n                k=j+1;\\n            }\\n            if(j==nums.length-1)\\n            {\\n                i=i+1;\\n                j=i+1;\\n                k=j+1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        int i=0;\\n        int j = 1;\\n        int k=2;\\n        while(i<nums.length-2)\\n        {\\n            if(nums[i]!=nums[j]&&nums[i]!=nums[k]&&nums[j]!=nums[k])\\n            count++;\\n            k++;\\n            if(k==nums.length)\\n            {\\n                j=j+1;\\n                k=j+1;\\n            }\\n            if(j==nums.length-1)\\n            {\\n                i=i+1;\\n                j=i+1;\\n                k=j+1;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3838116,
                "title": "nested-loops-with-set",
                "content": "# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(len(nums) - 2):\\n            for j in range(i + 1, len(nums) - 1):\\n                for k in range(j + 1, len(nums)):\\n                    if len({nums[i], nums[j], nums[k]}) == 3:\\n                        result += 1\\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        result = 0\\n        for i in range(len(nums) - 2):\\n            for j in range(i + 1, len(nums) - 1):\\n                for k in range(j + 1, len(nums)):\\n                    if len({nums[i], nums[j], nums[k]}) == 3:\\n                        result += 1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820745,
                "title": "simple-solution-using-for-loop",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length, count=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n;j++){\\n                for(int k = j; k<n;k++){\\n                    if(i>=0 && k<n && k>j && j>i){\\n                        if(nums[i]!=nums[j] && nums[j]!= nums[k] && nums[k]!= nums[i]){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int n = nums.length, count=0;\\n        for(int i=0; i<n; i++){\\n            for(int j=i+1; j<n;j++){\\n                for(int k = j; k<n;k++){\\n                    if(i>=0 && k<n && k>j && j>i){\\n                        if(nums[i]!=nums[j] && nums[j]!= nums[k] && nums[k]!= nums[i]){\\n                            count++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815983,
                "title": "c",
                "content": "# Approach\\n\\nbrute force\\n# Code\\n```\\nint unequalTriplets(int* nums, int numsSize){\\n    int n=0;\\n    for(int i=0; i<numsSize; i++){\\n        for(int j=i+1; j<numsSize; j++){\\n            for(int k=i+2; k<numsSize; k++){\\n                if((i<j && j<k) && nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                    n++;\\n            }\\n        }\\n    }\\nreturn n;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint unequalTriplets(int* nums, int numsSize){\\n    int n=0;\\n    for(int i=0; i<numsSize; i++){\\n        for(int j=i+1; j<numsSize; j++){\\n            for(int k=i+2; k<numsSize; k++){\\n                if((i<j && j<k) && nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                    n++;\\n            }\\n        }\\n    }\\nreturn n;\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3805685,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0; \\n        int n = nums.size(); \\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                for(int k = j+1; k < n; k++){\\n                    if(nums[i] != nums[j] &&\\n                        nums[j] != nums[k] &&\\n                        nums[i] != nums[k]) \\n                        ans++; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```\\n![image.png](https://assets.leetcode.com/users/images/712df975-bef8-42cc-82f9-ff1c4586bedd_1690115813.2888684.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0; \\n        int n = nums.size(); \\n\\n        for(int i = 0; i < n; i++){\\n            for(int j = i+1; j < n; j++){\\n                for(int k = j+1; k < n; k++){\\n                    if(nums[i] != nums[j] &&\\n                        nums[j] != nums[k] &&\\n                        nums[i] != nums[k]) \\n                        ans++; \\n                }\\n            }\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804041,
                "title": "easy-solution-in-java-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] a) {\\n        int n=a.length,c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(a[i]!=a[j] && a[j]!=a[k] && a[i]!=a[k])\\n                    {\\n                       // System.out.println(i+\" \"+j+\" \"+k+\" \");\\n                        c++;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] a) {\\n        int n=a.length,c=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(a[i]!=a[j] && a[j]!=a[k] && a[i]!=a[k])\\n                    {\\n                       // System.out.println(i+\" \"+j+\" \"+k+\" \");\\n                        c++;\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798640,
                "title": "number-of-unequal-triplets-js-intuitive",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    count = 0\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i; j < nums.length; j++) {\\n            for (let k = j; k < nums.length; k++)  {\\n                if (nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]) count++\\n            }\\n        }\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    count = 0\\n\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i; j < nums.length; j++) {\\n            for (let k = j; k < nums.length; k++)  {\\n                if (nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]) count++\\n            }\\n        }\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3793316,
                "title": "easy-javascript-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    let count = 0; // initialize count to zero\\n    for(let i=0; i<nums.length; i++){ // loop through the every element of array nums\\n        for(let j=i+1; j<nums.length; j++){ // loop through the every element of array nums starts from i+1\\n            for (let k = j+1; k < nums.length; k++) { // loop through the every element of array nums starts from j+1\\n                if (nums[i] !== nums[j] && nums[j] !== nums[k] && nums[i] !==nums[k]) { // if nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k] then increment count\\n                    count++\\n                }\\n            }\\n        }\\n        \\n    }\\n    return count; // return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    let count = 0; // initialize count to zero\\n    for(let i=0; i<nums.length; i++){ // loop through the every element of array nums\\n        for(let j=i+1; j<nums.length; j++){ // loop through the every element of array nums starts from i+1\\n            for (let k = j+1; k < nums.length; k++) { // loop through the every element of array nums starts from j+1\\n                if (nums[i] !== nums[j] && nums[j] !== nums[k] && nums[i] !==nums[k]) { // if nums[i] != nums[j], nums[i] != nums[k], and nums[j] != nums[k] then increment count\\n                    count++\\n                }\\n            }\\n        }\\n        \\n    }\\n    return count; // return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3782745,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                for (int k = j + 1; k < nums.length; k++) {\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[k] != nums[j]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                for (int k = j + 1; k < nums.length; k++) {\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[k] != nums[j]) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780479,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int r = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            for (int j=i+1; j<nums.length; j++) {\\n                for (int k = j+1; k<nums.length; k++) {\\n                    \\n                    if (nums[i] != nums[j] \\n                        && nums[j] != nums[k] \\n                        && nums[i] != nums[k] ) {\\n                        r++;\\n                    }\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int r = 0;\\n        for (int i=0; i<nums.length; i++) {\\n            for (int j=i+1; j<nums.length; j++) {\\n                for (int k = j+1; k<nums.length; k++) {\\n                    \\n                    if (nums[i] != nums[j] \\n                        && nums[j] != nums[k] \\n                        && nums[i] != nums[k] ) {\\n                        r++;\\n                    }\\n                }\\n            }\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762129,
                "title": "this-is-easy-solution-for-begginner-js-developer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    let num = nums.sort((a,b) => a - b)\\n    let count = 0\\n    for(let i = 0; i < num.length; i++){\\n        for(let j = i + 1; j < num.length; j++){\\n            for(let k = j + 1; k < num.length; k++){\\n                if(num[i] != num[j] && num[i] != num[k] && num[j] != num[k]){\\n                    count++\\n                }\\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar unequalTriplets = function(nums) {\\n    let num = nums.sort((a,b) => a - b)\\n    let count = 0\\n    for(let i = 0; i < num.length; i++){\\n        for(let j = i + 1; j < num.length; j++){\\n            for(let k = j + 1; k < num.length; k++){\\n                if(num[i] != num[j] && num[i] != num[k] && num[j] != num[k]){\\n                    count++\\n                }\\n            }\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3738844,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>&n){\\n        int c=0;\\n        for(int i=0; i<n.size()-2; i++){\\n            for(int j=i+1; j<n.size()-1; j++){\\n                if(n[i]!=n[j]){\\n                    for(int k=j+1; k<n.size(); k++){\\n                        if(n[i]!=n[k] && n[j]!=n[k]){\\n                            c++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>&n){\\n        int c=0;\\n        for(int i=0; i<n.size()-2; i++){\\n            for(int j=i+1; j<n.size()-1; j++){\\n                if(n[i]!=n[j]){\\n                    for(int k=j+1; k<n.size(); k++){\\n                        if(n[i]!=n[k] && n[j]!=n[k]){\\n                            c++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3734381,
                "title": "easy-solution-2-lines",
                "content": "# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        return sum(1 for i in range(n) for j in range(i+1, n) for k in range(j+1, n) if nums[i] != nums[j] != nums[k] != nums[i])\\n```\\n\\nPlease let me know if any improvements can be made.\\n\\nThanks",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        return sum(1 for i in range(n) for j in range(i+1, n) for k in range(j+1, n) if nums[i] != nums[j] != nums[k] != nums[i])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3729065,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i=0 ; i<nums.size()-2 ; i++){\\n            for (int j=i+1 ; j<nums.size()-1 ; j++){\\n                for (int k=j+1 ; k<nums.size() ; k++){\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int ans = 0;\\n        for (int i=0 ; i<nums.size()-2 ; i++){\\n            for (int j=i+1 ; j<nums.size()-1 ; j++){\\n                for (int k=j+1 ; k<nums.size() ; k++){\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                        ans++;\\n                }\\n            }\\n        }    \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3713431,
                "title": "c-solution-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n         int c=0,n=nums.size();\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=i+1;j<n-1;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    \\n                    if((nums[i]!=nums[j])&&(nums[i]!=nums[k])&&(nums[j]!=nums[k]))\\n                        c++;\\n                }\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n         int c=0,n=nums.size();\\n        for(int i=0;i<n-2;i++)\\n        {\\n            for(int j=i+1;j<n-1;j++)\\n            {\\n                for(int k=j+1;k<n;k++)\\n                {\\n                    \\n                    if((nums[i]!=nums[j])&&(nums[i]!=nums[k])&&(nums[j]!=nums[k]))\\n                        c++;\\n                }\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697480,
                "title": "simple-c-solution-beats-100-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] != nums[j])\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[j] != nums[k])\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                if(nums[i] != nums[j])\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[j] != nums[k])\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697472,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666846,
                "title": "c-beats-95-hashmap-approach-with-explanation-o-n-approach",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe logic counts the number of unequal triplets by considering each element as the middle element of the triplet and calculating the number of possibilities for the left and right elements. By summing up these counts for all elements, the total count of unequal triplets is obtained.\\n\\n# Complexity\\n- Time complexity - O(n)\\n- Space complexity - O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> unor;\\n        for(int i : nums){\\n            unor[i]++;\\n        }\\n        int left = 0,right=n,count=0;\\n        for(auto it = unor.begin();it!=unor.end();it++){\\n            right-=it->second;\\n            count+=left*it->second*right;\\n            left+=it->second;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n        unordered_map<int,int> unor;\\n        for(int i : nums){\\n            unor[i]++;\\n        }\\n        int left = 0,right=n,count=0;\\n        for(auto it = unor.begin();it!=unor.end();it++){\\n            right-=it->second;\\n            count+=left*it->second*right;\\n            left+=it->second;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661213,
                "title": "brute-force-solution-dart",
                "content": "# Code\\n```\\nclass Solution {\\n  int unequalTriplets(List<int> nums) {\\n    int count = 0;\\n\\n    for(int i = 0; i<nums.length;i++){\\n      for(int j = i+1; j<nums.length;j++){\\n        for(int k = j+1; k<nums.length;k++){\\n          if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n            count++;\\n          }\\n        }\\n      }\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int unequalTriplets(List<int> nums) {\\n    int count = 0;\\n\\n    for(int i = 0; i<nums.length;i++){\\n      for(int j = i+1; j<nums.length;j++){\\n        for(int k = j+1; k<nums.length;k++){\\n          if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n            count++;\\n          }\\n        }\\n      }\\n    }\\n\\n    return count;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3652726,
                "title": "frequency-array-solution-o-n-time-complexity-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        \\n        unordered_map<int, int> freqs;\\n        int count = 0;\\n        int prev = 0;\\n        int next=nums.size();\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            freqs[nums[i]]++;\\n        }\\n        for(auto &[key, value] : freqs)\\n        {\\n            next -=value;\\n            int calc = prev * value * next;\\n            if(calc == 0 && calc<count) break;\\n            count+= prev * value * next;\\n            prev += value;\\n        }\\n\\n\\n\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        \\n        unordered_map<int, int> freqs;\\n        int count = 0;\\n        int prev = 0;\\n        int next=nums.size();\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            freqs[nums[i]]++;\\n        }\\n        for(auto &[key, value] : freqs)\\n        {\\n            next -=value;\\n            int calc = prev * value * next;\\n            if(calc == 0 && calc<count) break;\\n            count+= prev * value * next;\\n            prev += value;\\n        }\\n\\n\\n\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3651024,
                "title": "python-3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n ** 3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        s = 0\\n\\n        for i in range(l):\\n            for j in range(i+1, l):\\n                for k in range(j+1, l):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        s += 1\\n\\n        return s \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        l = len(nums)\\n        s = 0\\n\\n        for i in range(l):\\n            for j in range(i+1, l):\\n                for k in range(j+1, l):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        s += 1\\n\\n        return s \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3631293,
                "title": "o-n-solution-hashtable-java-python-kotlin-javascrypt-c",
                "content": "# Intuition\\n\\nIf we have count1 number1, count2 number2, count3 number3 ...\\n\\nThe answer is all combinations of (count_a * count_b * count_c)\\n\\n# Approach\\n\\nUse a hashtable to count each number\\n\\nTraversal numbers, each of current number can combinate with all previous number and all numbers that have not traversed.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n# Code\\n\\n\\n```java []\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        var map = new HashMap<Integer,Integer>();\\n        for(int i : nums) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        int ans = 0;\\n        int left = 0;\\n        int right = nums.length;\\n        for(int i : map.values()) {\\n            right -= i;\\n            ans += left * i * right;\\n            left += i;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```kotlin []\\nclass Solution {\\n    fun unequalTriplets(nums: IntArray): Int {\\n        var map = mutableMapOf<Int,Int>()\\n        for(i in nums) {\\n            map[i] = map.getOrDefault(i, 0) + 1\\n        }\\n        var ans = 0\\n        var left = 0\\n        var right = nums.size\\n        map.forEach{(_ , count) -> \\n            right -= count\\n            ans += left * count * right \\n            left += count \\n        }\\n        return ans\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        count = Counter(nums)\\n        left = 0\\n        right = len(nums)\\n        ans = 0\\n        for i,cnt in count.items():\\n            right -= cnt\\n            ans += left * cnt * right\\n            left += cnt\\n        return ans\\n```\\n```js []\\nvar unequalTriplets = function(nums) {\\n    debugger;\\n    let map = new Map();\\n    for(let i of nums) {\\n        map.set(i, (map.get(i) || 0) + 1);\\n    }\\n    let right = nums.length;\\n    let left = 0;\\n    let ans = 0;\\n    for(let cnt of map.values()) {\\n        right -= cnt;\\n        ans += left * cnt * right;\\n        left += cnt;\\n    }\\n    return ans;\\n};\\n```\\n```cpp []\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(auto i: nums) {\\n            map[i]++;\\n        }\\n        int left = 0;\\n        int right = nums.size();\\n        int ans = 0;\\n        for(auto [_,cnt] : map) {\\n            right -= cnt;\\n            ans += left * cnt * right;\\n            left += cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Kotlin",
                    "Hash Table"
                ],
                "code": "```java []\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        var map = new HashMap<Integer,Integer>();\\n        for(int i : nums) {\\n            map.put(i, map.getOrDefault(i, 0) + 1);\\n        }\\n        int ans = 0;\\n        int left = 0;\\n        int right = nums.length;\\n        for(int i : map.values()) {\\n            right -= i;\\n            ans += left * i * right;\\n            left += i;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```kotlin []\\nclass Solution {\\n    fun unequalTriplets(nums: IntArray): Int {\\n        var map = mutableMapOf<Int,Int>()\\n        for(i in nums) {\\n            map[i] = map.getOrDefault(i, 0) + 1\\n        }\\n        var ans = 0\\n        var left = 0\\n        var right = nums.size\\n        map.forEach{(_ , count) -> \\n            right -= count\\n            ans += left * count * right \\n            left += count \\n        }\\n        return ans\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        count = Counter(nums)\\n        left = 0\\n        right = len(nums)\\n        ans = 0\\n        for i,cnt in count.items():\\n            right -= cnt\\n            ans += left * cnt * right\\n            left += cnt\\n        return ans\\n```\n```js []\\nvar unequalTriplets = function(nums) {\\n    debugger;\\n    let map = new Map();\\n    for(let i of nums) {\\n        map.set(i, (map.get(i) || 0) + 1);\\n    }\\n    let right = nums.length;\\n    let left = 0;\\n    let ans = 0;\\n    for(let cnt of map.values()) {\\n        right -= cnt;\\n        ans += left * cnt * right;\\n        left += cnt;\\n    }\\n    return ans;\\n};\\n```\n```cpp []\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        unordered_map<int,int> map;\\n        for(auto i: nums) {\\n            map[i]++;\\n        }\\n        int left = 0;\\n        int right = nums.size();\\n        int ans = 0;\\n        for(auto [_,cnt] : map) {\\n            right -= cnt;\\n            ans += left * cnt * right;\\n            left += cnt;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606189,
                "title": "bruite-force-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        \\n        int h = n-1;\\n        for(int i =0; i<n; i++){\\n            int l = i+1;\\n            for(int j =i+1; j<n; j++){\\n               for(int k=j+1; k<n; k++){\\n                   if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                       count++;\\n                   }\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        int n = nums.size();\\n        \\n        int h = n-1;\\n        for(int i =0; i<n; i++){\\n            int l = i+1;\\n            for(int j =i+1; j<n; j++){\\n               for(int k=j+1; k<n; k++){\\n                   if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                       count++;\\n                   }\\n               }\\n           }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3585131,
                "title": "sumit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        x=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        x+=1\\n        return x\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        x=0\\n        for i in range(len(nums)):\\n            for j in range(i+1,len(nums)):\\n                for k in range(j+1,len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        x+=1\\n        return x\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579815,
                "title": "easy-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                for(int k = j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                for(int k = j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579814,
                "title": "easy-to-understand-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                for(int k = j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i = 0;i<nums.length;i++){\\n            for(int j = i+1;j<nums.length;j++){\\n                for(int k = j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579635,
                "title": "simple-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                for (int k = j+1; k < nums.length; k++) {\\n                   if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                       count++;\\n                   } \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                for (int k = j+1; k < nums.length; k++) {\\n                   if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                       count++;\\n                   } \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575714,
                "title": "c-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int cnt = 0;\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++ ){\\n            for(int j = i+1 ; j < n ; j++){\\n                for(int k = j+1 ; k < n ; k++){\\n                    if((nums[i]!=nums[j])&&((nums[j]!=nums[k]) && (nums[i]!=nums[k]))){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int cnt = 0;\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++ ){\\n            for(int j = i+1 ; j < n ; j++){\\n                for(int k = j+1 ; k < n ; k++){\\n                    if((nums[i]!=nums[j])&&((nums[j]!=nums[k]) && (nums[i]!=nums[k]))){\\n                        cnt++;\\n                    }\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572968,
                "title": "fastest-100-0ms-easy-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                for (int k = j+1; k < nums.length; k++) {\\n                   if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                       count++;\\n                   } \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            for (int j = i+1; j < nums.length; j++) {\\n                for (int k = j+1; k < nums.length; k++) {\\n                   if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                       count++;\\n                   } \\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538029,
                "title": "it-s-o-n-n-n-solution-if-any-one-have-o-n-solution-please-reply",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        int n=nums.length;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                        c=c+1;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        int n=nums.length;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                        c=c+1;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529080,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nfrom math import factorial\\n\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        triplets = 0\\n\\n        def helper(seen, i):\\n            if len(seen) == 3:\\n                nonlocal triplets\\n                triplets += 1\\n                return\\n            elif i >= len(nums):\\n                return\\n\\n            if nums[i] not in seen:\\n                seen.add(nums[i])\\n                helper(seen, i+1)\\n                seen.remove(nums[i])\\n            \\n            helper(seen, i+1)\\n        \\n        helper(set(), 0)\\n\\n        return triplets\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nfrom math import factorial\\n\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        triplets = 0\\n\\n        def helper(seen, i):\\n            if len(seen) == 3:\\n                nonlocal triplets\\n                triplets += 1\\n                return\\n            elif i >= len(nums):\\n                return\\n\\n            if nums[i] not in seen:\\n                seen.add(nums[i])\\n                helper(seen, i+1)\\n                seen.remove(nums[i])\\n            \\n            helper(seen, i+1)\\n        \\n        helper(set(), 0)\\n\\n        return triplets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528308,
                "title": "easy-java-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n         int n = nums.length;\\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            int first = nums[i];\\n            \\n            for(int j=i+1; j<n; j++){\\n                int second = nums[j];\\n                if(second==first){ // skip\\n                    continue;\\n                }\\n        \\n                for(int k=j+1; k<n; k++){\\n                    int third = nums[k];\\n                    \\n                    if(third==first || third==second){ //skip\\n                        continue;\\n                    } else{\\n                        count++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n         int n = nums.length;\\n        int count = 0;\\n        \\n        for(int i=0; i<n; i++){\\n            int first = nums[i];\\n            \\n            for(int j=i+1; j<n; j++){\\n                int second = nums[j];\\n                if(second==first){ // skip\\n                    continue;\\n                }\\n        \\n                for(int k=j+1; k<n; k++){\\n                    int third = nums[k];\\n                    \\n                    if(third==first || third==second){ //skip\\n                        continue;\\n                    } else{\\n                        count++;\\n                    }\\n                }\\n                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3522073,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)-2):\\n            for j in range(i+1,len(nums)-1):\\n                for k in range(j+1,len(nums)):\\n                    if(nums[i]!=nums[j] and nums[i]!=nums[k] and nums[j]!=nums[k]):\\n                        c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        c=0\\n        for i in range(len(nums)-2):\\n            for j in range(i+1,len(nums)-1):\\n                for k in range(j+1,len(nums)):\\n                    if(nums[i]!=nums[j] and nums[i]!=nums[k] and nums[j]!=nums[k]):\\n                        c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3518946,
                "title": "easy-to-understand-solution-swift",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    func unequalTriplets(_ nums: [Int]) -> Int {\\n        var counter = Int()\\n    \\n        for i in 0..<nums.count {\\n            for j in i..<nums.count {\\n                for k in j..<nums.count {\\n                    if nums[i] != nums[k] && nums[i] != nums[j] && nums[j] != nums[k] {\\n                        counter += 1\\n                    }\\n                }\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func unequalTriplets(_ nums: [Int]) -> Int {\\n        var counter = Int()\\n    \\n        for i in 0..<nums.count {\\n            for j in i..<nums.count {\\n                for k in j..<nums.count {\\n                    if nums[i] != nums[k] && nums[i] != nums[j] && nums[j] != nums[k] {\\n                        counter += 1\\n                    }\\n                }\\n            }\\n        }\\n        return counter\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497694,
                "title": "easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        \\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3497446,
                "title": "easiest-java-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3492778,
                "title": "direct-approach-beat-100-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n    int count =0;\\n    for(int i =0;i<nums.length;i++){\\n        for(int j = i;j<nums.length;j++){\\n            for(int k = j;k<nums.length;k++){\\n                if((nums[i]!=nums[j])&&(nums[i]!=nums[k])&&(nums[j])!=nums[k])\\n                    count++;\\n            }\\n        }\\n    }\\n    return count;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n    int count =0;\\n    for(int i =0;i<nums.length;i++){\\n        for(int j = i;j<nums.length;j++){\\n            for(int k = j;k<nums.length;k++){\\n                if((nums[i]!=nums[j])&&(nums[i]!=nums[k])&&(nums[j])!=nums[k])\\n                    count++;\\n            }\\n        }\\n    }\\n    return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3491462,
                "title": "c",
                "content": "# Approach\\nbrute force, make sure i<j<k\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n\\n# Code\\n```\\npublic class Solution\\n        {\\n            public int UnequalTriplets(int[] nums)\\n            {\\n                int result = 0;\\n                for(int i = 0;i<nums.Length-2 ;i++)\\n                    for(int j = i+1;j<nums.Length-1;j++)\\n                        for(int k = j+1;k<nums.Length; k++)\\n                            if (nums[i] != nums[j] && nums[j] != nums[k] && nums[k] != nums[i])\\n                                result++;\\n                return result;\\n                \\n            }\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n        {\\n            public int UnequalTriplets(int[] nums)\\n            {\\n                int result = 0;\\n                for(int i = 0;i<nums.Length-2 ;i++)\\n                    for(int j = i+1;j<nums.Length-1;j++)\\n                        for(int k = j+1;k<nums.Length; k++)\\n                            if (nums[i] != nums[j] && nums[j] != nums[k] && nums[k] != nums[i])\\n                                result++;\\n                return result;\\n                \\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469803,
                "title": "beats-100-faster-easy-c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int n=nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            bool f=false;\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        cout.tie(NULL);\\n        int n=nums.size();\\n        int c=0;\\n        for(int i=0;i<n;i++){\\n            bool f=false;\\n            for(int j=i+1;j<n;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3466355,
                "title": "java-simple-loops-solution",
                "content": "\\n```\\n    class Solution {\\n        public int unequalTriplets(int[] nums) {\\n            int total = 0;\\n            for(int i=0; i<nums.length; i++){\\n                int temp1 = nums[i];\\n                int j = i+1;\\n                int temp2;\\n                while(j<nums.length){\\n                    if(nums[j] != temp1){\\n                    temp2 = nums[j];\\n                        for(int k=j+1; k<nums.length; k++){\\n                            if(nums[k] != temp1 && nums[k] != temp2){\\n                                total++;\\n                            }\\n                        }\\n                    }\\n                    j++;\\n                }\\n            }\\n            return total;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    class Solution {\\n        public int unequalTriplets(int[] nums) {\\n            int total = 0;\\n            for(int i=0; i<nums.length; i++){\\n                int temp1 = nums[i];\\n                int j = i+1;\\n                int temp2;\\n                while(j<nums.length){\\n                    if(nums[j] != temp1){\\n                    temp2 = nums[j];\\n                        for(int k=j+1; k<nums.length; k++){\\n                            if(nums[k] != temp1 && nums[k] != temp2){\\n                                total++;\\n                            }\\n                        }\\n                    }\\n                    j++;\\n                }\\n            }\\n            return total;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455648,
                "title": "brute-force-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:O(n^3)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                for k in range(j + 1, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        count=0\\n        for i in range(len(nums)):\\n            for j in range(i + 1, len(nums)):\\n                for k in range(j + 1, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3453831,
                "title": "simple-fast-nested-loops-solution",
                "content": "\\n```\\n\\nconst unequalTriplets = nums => {\\n  let count = 0;\\n\\n  const { length } = nums;\\n\\n  for (let i = 0; i < length; i++)\\n    for (let j = i + 1; j < length; j++)\\n      for (let k = j + 1; k < length; k++) {\\n        const el1 = nums[i];\\n        const el2 = nums[j];\\n        const el3 = nums[k];\\n\\n        if (\\n          el1 !== el2 &&\\n          el1 !== el3 &&\\n          el2 !== el3\\n        )\\n          count++;\\n      }\\n\\n  return count;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst unequalTriplets = nums => {\\n  let count = 0;\\n\\n  const { length } = nums;\\n\\n  for (let i = 0; i < length; i++)\\n    for (let j = i + 1; j < length; j++)\\n      for (let k = j + 1; k < length; k++) {\\n        const el1 = nums[i];\\n        const el2 = nums[j];\\n        const el3 = nums[k];\\n\\n        if (\\n          el1 !== el2 &&\\n          el1 !== el3 &&\\n          el2 !== el3\\n        )\\n          count++;\\n      }\\n\\n  return count;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3440230,
                "title": "runtime-104-ms-beats-30-25-memory-8-6-mb-beats-34-59",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple using loops \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^3).\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1).\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n       int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n        for(int j=i+1;j<nums.size();j++){\\n        for(int k=j+1;k<nums.size();k++){\\n            if(nums[i]!=nums[j]&&nums[j]!=nums[k]&&nums[i]!=nums[k]){\\n                ans++;\\n            }\\n        }\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n       int ans=0;\\n        for(int i=0;i<nums.size();i++){\\n        for(int j=i+1;j<nums.size();j++){\\n        for(int k=j+1;k<nums.size();k++){\\n            if(nums[i]!=nums[j]&&nums[j]!=nums[k]&&nums[i]!=nums[k]){\\n                ans++;\\n            }\\n        }\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434265,
                "title": "simple-math-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. count the occurrence frequency of all elements with a `dict`.\\n2. count the number of **combinations** of any `3` elements in nums.\\n3. Calculate the number of **repeated** combinations.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        d = {}\\n        for n in nums:\\n            d[n] = d[n] + 1 if n in d else 1\\n        return math.comb(len(nums), 3) - \\n          sum(\\n            math.comb(d[n], 2) * (len(nums) - d[n]) +\\n            math.comb(d[n], 3)\\n            for n in d if d[n] > 1\\n          )\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        d = {}\\n        for n in nums:\\n            d[n] = d[n] + 1 if n in d else 1\\n        return math.comb(len(nums), 3) - \\n          sum(\\n            math.comb(d[n], 2) * (len(nums) - d[n]) +\\n            math.comb(d[n], 3)\\n            for n in d if d[n] > 1\\n          )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432749,
                "title": "number-of-unequal-triplets-in-array",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length - 2; i++){\\n            for(int j = i + 1; j < nums.length - 1; j++){\\n                for(int k = j + 1; k < nums.length; k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count = 0;\\n        for(int i = 0; i < nums.length - 2; i++){\\n            for(int j = i + 1; j < nums.length - 1; j++){\\n                for(int k = j + 1; k < nums.length; k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k])\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3430428,
                "title": "brute-force-aprroach-c-python3",
                "content": "# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]!=nums[j] and nums[j]!=nums[k] and nums[i]!=nums[k])\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```Python []\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        res=0\\n        n = len(nums)\\n        for i in range(n-2):\\n            for j in range(i+1, n-1):\\n                for k in range(j+1, n):\\n                    if nums[i]!=nums[j] and nums[j]!=nums[k] and nums[i]!=nums[k]:\\n                        res+=1\\n\\n        return res \\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n = nums.size();\\n        int res = 0;\\n        for(int i=0;i<n-2;i++){\\n            for(int j=i+1;j<n-1;j++){\\n                for(int k=j+1;k<n;k++){\\n                    if(nums[i]!=nums[j] and nums[j]!=nums[k] and nums[i]!=nums[k])\\n                    res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python []\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        res=0\\n        n = len(nums)\\n        for i in range(n-2):\\n            for j in range(i+1, n-1):\\n                for k in range(j+1, n):\\n                    if nums[i]!=nums[j] and nums[j]!=nums[k] and nums[i]!=nums[k]:\\n                        res+=1\\n\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3422875,
                "title": "java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int result = 0;\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                for (int k = j + 1; k < nums.length; k++) {\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                        result++;\\n                    }\\n                }\\n            } \\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int result = 0;\\n\\n        for (int i = 0; i < nums.length - 2; i++) {\\n            for (int j = i + 1; j < nums.length - 1; j++) {\\n                for (int k = j + 1; k < nums.length; k++) {\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]) {\\n                        result++;\\n                    }\\n                }\\n            } \\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416903,
                "title": "java-very-easy-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                for(int k=j+1;k<nums.length;k++)\\n                {\\n                    if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])c+=1;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<nums.length;j++)\\n            {\\n                for(int k=j+1;k<nums.length;k++)\\n                {\\n                    if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k])c+=1;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3415969,
                "title": "simple-python-code-beginner",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        res=0\\n        for i in range(len(nums)-2):\\n            for j in range(i+1,len(nums)-1):\\n                for k in range(j+1,len(nums)):\\n                    if nums[i]!=nums[j] and nums[i]!=nums[k] and nums[j]!=nums[k]:\\n                        res+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        res=0\\n        for i in range(len(nums)-2):\\n            for j in range(i+1,len(nums)-1):\\n                for k in range(j+1,len(nums)):\\n                    if nums[i]!=nums[j] and nums[i]!=nums[k] and nums[j]!=nums[k]:\\n                        res+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414780,
                "title": "combinatoria-o-n-en-espa-ol",
                "content": "# Approach\\nUs\\xE9 combinatoria y el conocimiento de que los \\xEDndices no importaban mientras s\\xF3lo contara una vez cada tercia.\\n\\n# Complejidad\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# C\\xF3digo\\n```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef unequal_triplets(nums)\\n  # Vamos a hacer una soluci\\xF3n usando combinatoria\\n  # El n\\xFAmero total de combinaciones de n\\xFAmeros distintos -en el sentido de que\\n  # son entradas distinas en el arreglo- es, si n = nums.length,\\n  #    nC3 = (n!)/((n-3)! * 3!)\\n  #    = (n!)/((n-3)! * 6)    -- sustituyendo 3!\\n  #    = (n * (n-1) * (n-2) * (n-3)!) / ((n-3)! * 3)  -- abrimos el factorial del numerador\\n  #    = (n * (n-1) * (n-2)) / 6    -- dividimos los dos (n-3)!\\n  n = nums.length\\n  total_combinations = n * (n-1) * (n-2) / 6 # divisi\\xF3n entera porque n >=3, por tanto 6 est\\xE1 en los factores de esta multiplicaci\\xF3n\\n  # aqu\\xED total_combinations tambi\\xE9n contiene las combinaciones que tienen los mismos n\\xFAmeros. Por ejemplo, si nuestros nums son [1, 2, 2, 2], el subarreglo\\n  # [2, 2, 2] est\\xE1 en nuestras combinaciones. Igual el [1, 2, 2]\\n  # Para encontrar estas combinaciones, debemos saber cu\\xE1ntas combinaciones se pueden hacer con n\\xFAmeros repetidos. Necesitamos saber cu\\xE1ntas veces se repite cada n\\xFAmero. Vamos a hacerlo un poco ineficiente, usando m\\xE9todos de ruby\\n  frequencies = nums.group_by(&:itself).transform_values(&:count)\\n\\n  frequencies.each do |_number, frequency|\\n    next unless frequency > 1 # no es posible combinar dos si no hay dos al menos\\n    # Primero nos vamos a deshacer de todas las combinaciones que tengan s\\xF3lo un n\\xFAmero, i.e. [x, x, x]\\n    total_combinations -= frequency * (frequency-1) * (frequency-2) / 6 # restamos las combinaciones posibles con la cantidad de apariciones de cada n\\xFAmero\\n    # Ahora nos deshacemos de todas las combinaciones que tengan dos veces este n\\xFAmero. Aqu\\xED tambi\\xE9n se refleja algo importante. El problema tiene el constraint \\n    # 0 <= i < j < k <= nums.length\\n    # la cosa es que [1, 2, 3], [2, 1, 3], [3, 2, 1], son la misma combinaci\\xF3n\\n    # no importa el orden de los \\xEDndices mientras s\\xF3lo la contemos una vez\\n    # Para las combinaciones donde hay dos n\\xFAmeros repetidos, hay que recordar \\n    # nuestra f\\xF3rmula de combinaciones inicial:\\n    #   nC3 = (n!)/((n-3)! * 3!)\\n    # y el hecho de que usamos el factorial porque si nuestros nums son:\\n    #   [n_0, n_1, ..., n_n]\\n    # una vez que fijamos nuestro primer n\\xFAmero, digamos en n_0, quedan\\n    #    nums.length - 1\\n    #  n\\xFAmeros para elegir el siguiente de nuestra combinaci\\xF3n, y una vez elegimos el segundo, quedan:\\n    #    nums.length - 2\\n    # n\\xFAmeros para elegir el siguiente. Sin embargo, si consideramos que queremos que el primer n\\xFAmero\\n    # sea distinto de los otros dos, tenemos que cambiar nuestra f\\xF3rmula para que refleje\\n    # que el primer n\\xFAmero lo vamos a elegir de entre todos los que no son nuestro n\\xFAmero repetido\\n    # Entonces, por cada n\\xFAmero que no sea en el que estamos parados en el loop,\\n    # tenemos:\\n    #   frequencyC2 = (frequency * (frequency-1)) / 2\\n    # posibles combinaciones. Nuestras combinaciones con dos n\\xFAmeros repetidos son, entonces,\\n    # las combinaciones posibles de cada n\\xFAmero que se repite, multiplicado por \\n    # los n\\xFAmeros sobrantes:\\n    #   = (n - frequency) * frequencyC2\\n    total_combinations -= (n - frequency) * frequency * (frequency-1) / 2\\n  end\\n  # retornamos las combinaciones restantes\\n  total_combinations\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Math"
                ],
                "code": "```ruby\\n# @param {Integer[]} nums\\n# @return {Integer}\\ndef unequal_triplets(nums)\\n  # Vamos a hacer una soluci\\xF3n usando combinatoria\\n  # El n\\xFAmero total de combinaciones de n\\xFAmeros distintos -en el sentido de que\\n  # son entradas distinas en el arreglo- es, si n = nums.length,\\n  #    nC3 = (n!)/((n-3)! * 3!)\\n  #    = (n!)/((n-3)! * 6)    -- sustituyendo 3!\\n  #    = (n * (n-1) * (n-2) * (n-3)!) / ((n-3)! * 3)  -- abrimos el factorial del numerador\\n  #    = (n * (n-1) * (n-2)) / 6    -- dividimos los dos (n-3)!\\n  n = nums.length\\n  total_combinations = n * (n-1) * (n-2) / 6 # divisi\\xF3n entera porque n >=3, por tanto 6 est\\xE1 en los factores de esta multiplicaci\\xF3n\\n  # aqu\\xED total_combinations tambi\\xE9n contiene las combinaciones que tienen los mismos n\\xFAmeros. Por ejemplo, si nuestros nums son [1, 2, 2, 2], el subarreglo\\n  # [2, 2, 2] est\\xE1 en nuestras combinaciones. Igual el [1, 2, 2]\\n  # Para encontrar estas combinaciones, debemos saber cu\\xE1ntas combinaciones se pueden hacer con n\\xFAmeros repetidos. Necesitamos saber cu\\xE1ntas veces se repite cada n\\xFAmero. Vamos a hacerlo un poco ineficiente, usando m\\xE9todos de ruby\\n  frequencies = nums.group_by(&:itself).transform_values(&:count)\\n\\n  frequencies.each do |_number, frequency|\\n    next unless frequency > 1 # no es posible combinar dos si no hay dos al menos\\n    # Primero nos vamos a deshacer de todas las combinaciones que tengan s\\xF3lo un n\\xFAmero, i.e. [x, x, x]\\n    total_combinations -= frequency * (frequency-1) * (frequency-2) / 6 # restamos las combinaciones posibles con la cantidad de apariciones de cada n\\xFAmero\\n    # Ahora nos deshacemos de todas las combinaciones que tengan dos veces este n\\xFAmero. Aqu\\xED tambi\\xE9n se refleja algo importante. El problema tiene el constraint \\n    # 0 <= i < j < k <= nums.length\\n    # la cosa es que [1, 2, 3], [2, 1, 3], [3, 2, 1], son la misma combinaci\\xF3n\\n    # no importa el orden de los \\xEDndices mientras s\\xF3lo la contemos una vez\\n    # Para las combinaciones donde hay dos n\\xFAmeros repetidos, hay que recordar \\n    # nuestra f\\xF3rmula de combinaciones inicial:\\n    #   nC3 = (n!)/((n-3)! * 3!)\\n    # y el hecho de que usamos el factorial porque si nuestros nums son:\\n    #   [n_0, n_1, ..., n_n]\\n    # una vez que fijamos nuestro primer n\\xFAmero, digamos en n_0, quedan\\n    #    nums.length - 1\\n    #  n\\xFAmeros para elegir el siguiente de nuestra combinaci\\xF3n, y una vez elegimos el segundo, quedan:\\n    #    nums.length - 2\\n    # n\\xFAmeros para elegir el siguiente. Sin embargo, si consideramos que queremos que el primer n\\xFAmero\\n    # sea distinto de los otros dos, tenemos que cambiar nuestra f\\xF3rmula para que refleje\\n    # que el primer n\\xFAmero lo vamos a elegir de entre todos los que no son nuestro n\\xFAmero repetido\\n    # Entonces, por cada n\\xFAmero que no sea en el que estamos parados en el loop,\\n    # tenemos:\\n    #   frequencyC2 = (frequency * (frequency-1)) / 2\\n    # posibles combinaciones. Nuestras combinaciones con dos n\\xFAmeros repetidos son, entonces,\\n    # las combinaciones posibles de cada n\\xFAmero que se repite, multiplicado por \\n    # los n\\xFAmeros sobrantes:\\n    #   = (n - frequency) * frequencyC2\\n    total_combinations -= (n - frequency) * frequency * (frequency-1) / 2\\n  end\\n  # retornamos las combinaciones restantes\\n  total_combinations\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3394777,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j] && nums[i]!=nums[k] && nums[j]!=nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3394578,
                "title": "very-simple-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n=nums.size(),c=0;\\n        for(int i=0; i<n-2; i++)\\n            for(int j=i+1; j<n-1; j++)\\n                for(int k=j+1; k<n; k++)\\n                    if(nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                        c++;\\n\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int n=nums.size(),c=0;\\n        for(int i=0; i<n-2; i++)\\n            for(int j=i+1; j<n-1; j++)\\n                for(int k=j+1; k<n; k++)\\n                    if(nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k])\\n                        c++;\\n\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3387928,
                "title": "o-n-combination-solution-faster-than-100-c",
                "content": "# Intuition\\r\\n<!-- Describe your first thoughts on how to solve this problem. -->\\r\\nWe need to calculate the total number of triplets that can be formed from all the elements in the array. To do that we use nC3 where n is the size of the array. Then we need to subtract the triplets that have only two unique values and one unique value. \\r\\n# Approach\\r\\n<!-- Describe your approach to solving the problem. -->\\r\\n\\r\\n# Complexity\\r\\n- Time complexity: O(N)\\r\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n- Space complexity: O(1)\\r\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\r\\n\\r\\n# Code\\r\\n```\\r\\nclass Solution\\r\\n{\\r\\n    public:\\r\\n        int unequalTriplets(vector<int> &nums)\\r\\n        {\\r\\n            int n = nums.size();\\r\\n            int res = (n *(n - 1) *(n - 2)) / 6;\\r\\n            unordered_map<int, int> m;\\r\\n            for (auto a: nums) ++m[a];\\r\\n            int twoUnique = 0;\\r\\n            for (auto b: m)\\r\\n            {\\r\\n                if (b.second > 1)\\r\\n                    twoUnique += ((n - b.second) *(b.second) *(b.second - 1)) / 2;\\r\\n            }\\r\\n            int OneUnique = 0;\\r\\n            for (auto c: m)\\r\\n            {\\r\\n                if (c.second > 2)\\r\\n                    OneUnique += ((c.second) *(c.second - 1) *(c.second - 2)) / 6;\\r\\n            }\\r\\n            return res - (twoUnique + OneUnique);\\r\\n        }\\r\\n};\\r\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\r\\nclass Solution\\r\\n{\\r\\n    public:\\r\\n        int unequalTriplets(vector<int> &nums)\\r\\n        {\\r\\n            int n = nums.size();\\r\\n            int res = (n *(n - 1) *(n - 2)) / 6;\\r\\n            unordered_map<int, int> m;\\r\\n            for (auto a: nums) ++m[a];\\r\\n            int twoUnique = 0;\\r\\n            for (auto b: m)\\r\\n            {\\r\\n                if (b.second > 1)\\r\\n                    twoUnique += ((n - b.second) *(b.second) *(b.second - 1)) / 2;\\r\\n            }\\r\\n            int OneUnique = 0;\\r\\n            for (auto c: m)\\r\\n            {\\r\\n                if (c.second > 2)\\r\\n                    OneUnique += ((c.second) *(c.second - 1) *(c.second - 2)) / 6;\\r\\n            }\\r\\n            return res - (twoUnique + OneUnique);\\r\\n        }\\r\\n};\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3383445,
                "title": "brute-force",
                "content": "# Code\\n```\\npublic class Solution \\n{\\n    public int UnequalTriplets(int[] nums) \\n    {\\n        int ans=0;\\n        for(var i=0;i<nums.Length-2;i++)\\n        {\\n            for(var j=i+1;j<nums.Length-1;j++)\\n            {\\n                if(nums[i]==nums[j]) continue;\\n                for(var k=j+1;k<nums.Length;k++)\\n                    if(nums[j]!=nums[k] && nums[k]!=nums[i]) \\n                        ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int UnequalTriplets(int[] nums) \\n    {\\n        int ans=0;\\n        for(var i=0;i<nums.Length-2;i++)\\n        {\\n            for(var j=i+1;j<nums.Length-1;j++)\\n            {\\n                if(nums[i]==nums[j]) continue;\\n                for(var k=j+1;k<nums.Length;k++)\\n                    if(nums[j]!=nums[k] && nums[k]!=nums[i]) \\n                        ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3382470,
                "title": "easy-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                       count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                       count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3373864,
                "title": "easy-python-solution",
                "content": "Easy To Understand\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        lst = []\\n        for i,j,k in combinations(nums,3):\\n            if i != j and j != k and k != i:\\n                lst.append(1)\\n        return sum(lst)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        lst = []\\n        for i,j,k in combinations(nums,3):\\n            if i != j and j != k and k != i:\\n                lst.append(1)\\n        return sum(lst)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366928,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n\\n        ans = 0 \\n        def dfs(m,path): \\n            nonlocal ans \\n            if len(path) == 3: \\n                ans += 1 \\n                return \\n            for n in range(m,len(nums)):\\n                if nums[n] not in path: \\n                    dfs(n,path+[nums[n]]) \\n\\n        for i in range(len(nums)): \\n            dfs(i,[nums[i]])\\n\\n        return ans \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n\\n        ans = 0 \\n        def dfs(m,path): \\n            nonlocal ans \\n            if len(path) == 3: \\n                ans += 1 \\n                return \\n            for n in range(m,len(nums)):\\n                if nums[n] not in path: \\n                    dfs(n,path+[nums[n]]) \\n\\n        for i in range(len(nums)): \\n            dfs(i,[nums[i]])\\n\\n        return ans \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362757,
                "title": "quite-moderate-in-runtime-java",
                "content": "# Intuition\\nSelf explanatory with loops\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j]&&(nums[i]!=nums[k])&&(nums[j]!=nums[k]))\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    if(nums[i]!=nums[j]&&(nums[i]!=nums[k])&&(nums[j]!=nums[k]))\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3358475,
                "title": "brute-force-approach-but-easy-to-understand",
                "content": "# Intuition\\nIterate through every element and if they aren\\'t same increment the counter.\\n\\n# Complexity\\n- Time complexity:\\nO(n^3)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int result = 0;\\n\\n        for (int i = 0; i < nums.length-2; i++) {\\n            for (int j = i+1; j < nums.length-1; j++) {\\n                if(nums[i]!=nums[j]){\\n                    for (int k = j+1; k < nums.length; k++) {\\n                        if (nums[j]!=nums[k] && nums[k]!=nums[i])\\n                            result++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int result = 0;\\n\\n        for (int i = 0; i < nums.length-2; i++) {\\n            for (int j = i+1; j < nums.length-1; j++) {\\n                if(nums[i]!=nums[j]){\\n                    for (int k = j+1; k < nums.length; k++) {\\n                        if (nums[j]!=nums[k] && nums[k]!=nums[i])\\n                            result++;\\n                    }\\n                }\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353230,
                "title": "python-one-liner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        return len([0 for i in range(len(nums)-2) for j in range(i+1, len(nums)-1) if nums[i] != nums[j] for k in range(j+1, len(nums)) if nums[i] != nums[k] and nums[j] != nums[k]])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        return len([0 for i in range(len(nums)-2) for j in range(i+1, len(nums)-1) if nums[i] != nums[j] for k in range(j+1, len(nums)) if nums[i] != nums[k] and nums[j] != nums[k]])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351671,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                if(nums[i]!=nums[j])\\n                {\\n                    for( int k=j+1;k<nums.size();k++)\\n                    {\\n                        if(nums[j]!=nums[k] && nums[k]!=nums[i])\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int c=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size()-1;j++){\\n                if(nums[i]!=nums[j])\\n                {\\n                    for( int k=j+1;k<nums.size();k++)\\n                    {\\n                        if(nums[j]!=nums[k] && nums[k]!=nums[i])\\n                        c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345728,
                "title": "trivial-brute-force-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^3)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        cnt = 0\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        cnt += 1\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        cnt = 0\\n        for i in range(len(nums)):\\n            for j in range(i, len(nums)):\\n                for k in range(j, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        cnt += 1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344020,
                "title": "python-1-liner-with-combinations",
                "content": "# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        from itertools import combinations\\n        return sum([1 for x, y, z in combinations(nums, 3) if x != y != z != x])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        from itertools import combinations\\n        return sum([1 for x, y, z in combinations(nums, 3) if x != y != z != x])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343804,
                "title": "java-brute-force-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for (int i=0;i<nums.length-2;i++){\\n            for (int j=i+1;j<nums.length-1;j++){\\n                for (int k=j+1;k<nums.length;k++){\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }    \\n        return count;\\n    }\\n}\\n```\\n\\n![90f09615-d42d-402c-897e-8d81a9fb5f37_1677988379.954136.jpeg](https://assets.leetcode.com/users/images/aa6fa27a-f531-46b8-9863-d7c58dd8a753_1679833946.064297.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int count=0;\\n        for (int i=0;i<nums.length-2;i++){\\n            for (int j=i+1;j<nums.length-1;j++){\\n                for (int k=j+1;k<nums.length;k++){\\n                    if (nums[i] != nums[j] && nums[i] != nums[k] && nums[j] != nums[k]){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }    \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3341521,
                "title": "java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    {\\n                        if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                            ans++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int ans = 0;\\n        for(int i=0;i<nums.length-2;i++){\\n            for(int j=i+1;j<nums.length-1;j++){\\n                for(int k=j+1;k<nums.length;k++){\\n                    {\\n                        if(nums[i]!=nums[j] && nums[j]!=nums[k] && nums[k]!=nums[i]){\\n                            ans++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3322355,
                "title": "java-verysimpleapproach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]!=nums[j]){\\n                    for(int k=j+1;k<nums.length;k++){\\n                        if(nums[i]!=nums[k] && nums[j]!=nums[k]) c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int c=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=i+1;j<nums.length;j++){\\n                if(nums[i]!=nums[j]){\\n                    for(int k=j+1;k<nums.length;k++){\\n                        if(nums[i]!=nums[k] && nums[j]!=nums[k]) c++;\\n                    }\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313113,
                "title": "easiest-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int res = 0;\\n        for(int i = 0; i<nums.length - 2; i++){\\n            for(int j = i + 1; j<nums.length - 1; j++){\\n                if (nums[i] != nums[j])\\n                for(int k = j + 1; k<nums.length; k++){\\n                    if (nums[i] != nums[k] && nums[j] != nums[k]) res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int unequalTriplets(int[] nums) {\\n        int res = 0;\\n        for(int i = 0; i<nums.length - 2; i++){\\n            for(int j = i + 1; j<nums.length - 1; j++){\\n                if (nums[i] != nums[j])\\n                for(int k = j + 1; k<nums.length; k++){\\n                    if (nums[i] != nums[k] && nums[j] != nums[k]) res++;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306870,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if((nums[i]!=nums[j])&&(nums[i]!=nums[k])&&(nums[j]!=nums[k])){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums) {\\n        int count=0;\\n        for(int i=0;i<nums.size();i++){\\n            for(int j=i+1;j<nums.size();j++){\\n                for(int k=j+1;k<nums.size();k++){\\n                    if((nums[i]!=nums[j])&&(nums[i]!=nums[k])&&(nums[j]!=nums[k])){\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3301378,
                "title": "simple-c-o-n3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums)\\n    {\\n        int cnt=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                for(int k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]!=nums[j]&&nums[j]!=nums[k]&&nums[i]!=nums[k])\\n                    cnt++;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int unequalTriplets(vector<int>& nums)\\n    {\\n        int cnt=0;\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i+1;j<nums.size();j++)\\n            {\\n                for(int k=j+1;k<nums.size();k++)\\n                {\\n                    if(nums[i]!=nums[j]&&nums[j]!=nums[k]&&nums[i]!=nums[k])\\n                    cnt++;\\n                }\\n            }\\n        }\\n\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3292829,
                "title": "python-just-bruth-force",
                "content": "Thanks for reading :)\\n# Code\\n```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(len(nums)-2):\\n            for j in range(i, len(nums)-1):\\n                for k in range(j, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def unequalTriplets(self, nums: List[int]) -> int:\\n        ans = 0\\n        for i in range(len(nums)-2):\\n            for j in range(i, len(nums)-1):\\n                for k in range(j, len(nums)):\\n                    if nums[i] != nums[j] and nums[i] != nums[k] and nums[j] != nums[k]:\\n                        ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1771213,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1764802,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 2068298,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 2043017,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1980042,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1876080,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1873021,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1811865,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1794444,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1701802,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1771213,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1764802,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 2068298,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 2043017,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1980042,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1876080,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1873021,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1811865,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1794444,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            },
            {
                "id": 1701802,
                "content": [
                    {
                        "username": "MrDLt000",
                        "content": "An EASY... problem :("
                    },
                    {
                        "username": "Alexander_TMT",
                        "content": " `Input: nums = [4,4,2,4,3]\\nOutput: 3\\nExplanation: The following triplets meet the conditions:\\n- (0, 2, 4) because 4 != 2 != 3\\n- (1, 2, 4) because 4 != 2 != 3\\n- (2, 3, 4) because 2 != 4 != 3\\nSince there are 3 triplets, we return 3.\\nNote that (2, 0, 4) is not a valid triplet because 2 > 0.`\\nfrom where in example he get 0? There is no 0 value in nums... \\n(0, 2, 4) because 4 != 2 != 3 where is 3???"
                    },
                    {
                        "username": "rajmohit7114",
                        "content": "here (0,2,4) indicates indexes.\\n"
                    },
                    {
                        "username": "johncarlotevesjobs",
                        "content": "why is the answer for this test case  7?\\n[1,3,1,2,4]\\nthe only valid ones are\\n132\\n134\\n312\\n314\\n124\\nright???????"
                    },
                    {
                        "username": "Chris1337",
                        "content": "Was able to complete this problem but it should be a medium imo"
                    },
                    {
                        "username": "kartikdangi01",
                        "content": "Really good question if constraints were 3 <= nums.length <= 1e5"
                    },
                    {
                        "username": "liymouse",
                        "content": "If limit algorithm to O(n), it becomes a Middle problem."
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Oh man those duplicates........"
                    },
                    {
                        "username": "suyash2810",
                        "content": "Can someone please explain what is wrong in this approach? What needs to be rectified in this? \\n \\n`class Solution {\\npublic:\\n\\n    void triplets(vector<int> nums, int index, int k, int &count, vector<int> v) {\\n        if(index < 0) {\\n            return;\\n        }\\n\\n        if(k==0) {\\n            if(v[0] != v[1] && v[0] != v[2] && v[1] != v[2]) {\\n                count+=1;\\n            }\\n            return;\\n        }\\n\\n        v.push_back(nums[index]);\\n        triplets(nums, index-1, k-1, count, v);\\n        v.pop_back();\\n        triplets(nums, index-1, k, count, v);\\n    }\\n\\n    int unequalTriplets(vector<int>& nums) {\\n        int count = 0;\\n        vector<int> v;\\n        triplets(nums, nums.size()-1, 3, count, v);\\n        return count;\\n    }\\n};`"
                    },
                    {
                        "username": "shekharaditya",
                        "content": "i think leetcode should bring an basic level difficulty also : ()"
                    },
                    {
                        "username": "sarvar_raxmonov",
                        "content": "How  i < a < b < len(nums) why \\n\\n2 < 4 < 3    is True\\ni < a < b     \\n\\nPlease explain it ..."
                    },
                    {
                        "username": "Johnny_Tsou",
                        "content": "i, j, k is the index, not the value in array. The nums[i], nums[j], nums[k] only required not to be the same number. So it\\'s 2 != 4 != 3 == True"
                    }
                ]
            }
        ]
    }
]