[
    {
        "title": "Defanging an IP Address",
        "question_content": "Given a valid (IPv4) IP address, return a defanged version of that IP address.\r\n\r\nA defanged&nbsp;IP address&nbsp;replaces every period \".\" with \"[.]\".\r\n\r\n&nbsp;\r\nExample 1:\r\nInput: address = \"1.1.1.1\"\r\nOutput: \"1[.]1[.]1[.]1\"\r\nExample 2:\r\nInput: address = \"255.100.50.0\"\r\nOutput: \"255[.]100[.]50[.]0\"\r\n\r\n&nbsp;\r\nConstraints:\r\n\r\n\r\n\tThe given address is a valid IPv4 address.",
        "solutions": [
            {
                "id": 328895,
                "title": "java-python-3-3-one-liners-one-w-o-lib-w-analysis",
                "content": "```java\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n    public String defangIPaddr(String address) {\\n        return String.join(\"[.]\", address.split(\"\\\\\\\\.\"));\\n    }\\n    public String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : address.toCharArray()) {\\n            sb.append(c == \\'.\\' ? \"[.]\" : c);\\n        }\\n        return sb.toString();\\n    }\\n```\\n\\n```python\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\', \\'[.]\\')\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n    def defangIPaddr(self, address: str) -> str:\\n        return re.sub(\\'\\\\.\\', \\'[.]\\', address)\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'\\'.join(\\'[.]\\' if c == \\'.\\' else c for c in address)\\n```\\n\\n**Analysis:**\\n\\nAll characters are visited at most twice, therefore, \\n\\nTime & space: `O(n)`, where `n = address.length()`.",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```java\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n    public String defangIPaddr(String address) {\\n        return String.join(\"[.]\", address.split(\"\\\\\\\\.\"));\\n    }\\n    public String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        for (char c : address.toCharArray()) {\\n            sb.append(c == \\'.\\' ? \"[.]\" : c);\\n        }\\n        return sb.toString();\\n    }\\n```\n```python\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\', \\'[.]\\')\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n    def defangIPaddr(self, address: str) -> str:\\n        return re.sub(\\'\\\\.\\', \\'[.]\\', address)\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'\\'.join(\\'[.]\\' if c == \\'.\\' else c for c in address)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 328855,
                "title": "c-1-liner-regex-replace",
                "content": "```\\nstring defangIPaddr(string address) {\\n  return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstring defangIPaddr(string address) {\\n  return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 351240,
                "title": "c-100-faster-solution-with-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string res;\\n        for(auto c: address) {\\n            if(c==\\'.\\') {\\n                res+=\"[.]\";\\n            } else res+=c;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string res;\\n        for(auto c: address) {\\n            if(c==\\'.\\') {\\n                res+=\"[.]\";\\n            } else res+=c;\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 332184,
                "title": "java-solution",
                "content": "Here is my solution. Runs in O(n) runtime.\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++){\\n            if (address.charAt(i) == \\'.\\'){\\n                str.append(\"[.]\");\\n            } else {\\n                str.append(address.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++){\\n            if (address.charAt(i) == \\'.\\'){\\n                str.append(\"[.]\");\\n            } else {\\n                str.append(address.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570466,
                "title": "python-3-solutions",
                "content": "**First Solution**\\n\\nTime: O(N)\\nSpace: O(1)\\n\\nUses Python\\'s built-in string replace method\\n\\n``` \\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\treturn address.replace(\\'.\\', \\'[.]\\')\\n```\\n\\n**Second Solution**\\n\\nTime: O(N)\\nSpace: O(1)\\n\\nConvert the ip address into a list of the numbers using the split method. Add the \"[.]\" chars between the numbers using the join method.\\n\\n```\\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\treturn \"[.]\".join(address.split(\".\"))\\n```\\n\\n**Third Solution**\\n\\nTime: O(N)\\nSpace: O(N)\\n\\nCreate an empty list. Iterate through the characters in the address, numbers get appended to the list while periods signal that \"[.]\" chars must be appended. This method had the best speed results out of all others.\\n\\n```\\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\tans = []\\n\\t\\tfor ch in address:\\n\\t\\t\\tif ch.isdigit():\\n\\t\\t\\t\\tans.append(ch)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(\"[.]\")\\n\\n\\t\\treturn \"\".join(ans)\\n```\\n\\t\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\treturn address.replace(\\'.\\', \\'[.]\\')\\n```\n```\\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\treturn \"[.]\".join(address.split(\".\"))\\n```\n```\\nclass Solution:\\n\\tdef defangIPaddr(self, address: str) -> str:\\n\\t\\tans = []\\n\\t\\tfor ch in address:\\n\\t\\t\\tif ch.isdigit():\\n\\t\\t\\t\\tans.append(ch)\\n\\t\\t\\telse:\\n\\t\\t\\t\\tans.append(\"[.]\")\\n\\n\\t\\treturn \"\".join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340369,
                "title": "python-one-line",
                "content": "Using split and join functions\\n```\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 428284,
                "title": "javascript-w-o-cheating-o-n-time-o-n-space",
                "content": "Yeah, your one-liner set operations are cute, but clearly defeat the purpose of the exercise, which is having you understand the underlying, abstracted algorithms and what their complexity is.\\n\\n```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    var result=\"\";\\n    \\n    for(var i=0;i<address.length;i++) {\\n        if(address[i] === \".\")\\n            result += \"[.]\";\\n        else\\n            result += address[i];\\n    }\\n    \\n    return result;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    var result=\"\";\\n    \\n    for(var i=0;i<address.length;i++) {\\n        if(address[i] === \".\")\\n            result += \"[.]\";\\n        else\\n            result += address[i];\\n    }\\n    \\n    return result;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3366971,
                "title": "simple-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Just iterate through string and copy every character same into `ans` and replace `\\'.\\'` to `\\'[.]\\'`.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n`Upvote ! It just takes a click :)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.size();i++){\\n            if(address[i] == \\'.\\'){\\n                ans+=\"[.]\";\\n            }\\n            else{\\n                ans+=address[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/cc50bb3d-5e68-4825-9a63-30100c047ab9_1680369640.3874342.jpeg)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.size();i++){\\n            if(address[i] == \\'.\\'){\\n                ans+=\"[.]\";\\n            }\\n            else{\\n                ans+=address[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 840879,
                "title": "replace-insert-simple-100-00",
                "content": "**replace**\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str=\"[.]\";\\n        for(int i=0;i<address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                address.replace(i,1,str);\\n                i+=2;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```\\ninsert \\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                address.insert(i,1,\\'[\\');\\n                address.insert(i+2,1,\\']\\');\\n                i+=2;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```\\nsimple \\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string m = \"[.]\";\\n        string sol = \"\";\\n        for(int i=0;i<address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                sol+=m;\\n            }else{\\n                sol+=address[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str=\"[.]\";\\n        for(int i=0;i<address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                address.replace(i,1,str);\\n                i+=2;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                address.insert(i,1,\\'[\\');\\n                address.insert(i+2,1,\\']\\');\\n                i+=2;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string m = \"[.]\";\\n        string sol = \"\";\\n        for(int i=0;i<address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                sol+=m;\\n            }else{\\n                sol+=address[i];\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 442529,
                "title": "c-c-java-python-c-php-ruby-js-ts-go-rust-swift-regex-and-replace",
                "content": "### C using a for loop:\\n\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstatic const char *defangIPaddr(\\n    const char *address\\n) {\\n    char *ipv4_memory = calloc(1, sizeof(\"###[.]###[.]###[.]###\"));\\n    char *defanged = ipv4_memory;\\n\\n    for (const char *character = address; *character; character++) {\\n        if (*character == \\'.\\') {\\n            *ipv4_memory++ = \\'[\\';\\n            *ipv4_memory++ = \\'.\\';\\n            *ipv4_memory++ = \\']\\';\\n\\n        } else {\\n            *ipv4_memory++ = *character;\\n        }\\n    }\\n\\n    return defanged;\\n}\\n\\n```\\n\\n\\n### C using `asprintf()` (from Code Review SE):\\n\\n```\\n#include <stdio.h>\\n\\nchar *defangIPaddr(const char *address) {\\n    char *defanged;\\n    int ip[4];\\n\\n    if (sscanf(address, \"%d.%d.%d.%d\", &ip[0], &ip[1], &ip[2], &ip[3]) != 4) {\\n        return NULL;\\n    }\\n\\n    if (asprintf(&defanged, \"%d[.]%d[.]%d[.]%d\", ip[0], ip[1], ip[2], ip[3]) == -1) {\\n        return NULL;\\n    }\\n\\n    return defanged;\\n}\\n```\\n\\n### C using a for loop a bit simplified:\\n\\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstatic const char *defangIPaddr(\\n    const char *address\\n) {\\n    char *q = calloc(1, sizeof(\"###[.]###[.]###[.]###\"));\\n    char *defanged = q;\\n\\n    for (const char *p = address; *p; p++) {\\n        if (*p == \\'.\\') {\\n            *q++ = \\'[\\';\\n            *q++ = \\'.\\';\\n            *q++ = \\']\\';\\n\\n        } else {\\n            *q++ = *p;\\n        }\\n    }\\n\\n    return defanged;\\n}\\n```\\n\\n\\n**C++**: with regex (using character class: `[]`):\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        return regex_replace(a, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```\\n\\n**C++**: with regex (without using character class: `[]` with just escaping `\\\\\\\\.`):\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        return regex_replace(a, regex(\"\\\\\\\\.\"), \"[.]\");\\n    }\\n};\\n```\\n\\n**Java**: using `replace()`:\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replace(\".\", \"[.]\");\\n    }\\n}\\n```\\n\\n**Java**: using `replaceAll()`:\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n}\\n```\\n\\n**Java**: similar to C++ using a character class `[]` with `replaceAll()`:\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replaceAll(\"[.]\", \"[.]\");\\n    }\\n}\\n```\\n\\n**Python3 or Python:** with `re.sub()`:\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, a):\\n        return re.sub(\\'\\\\.\\', \\'[.]\\', a)\\n```\\n\\n**Python3 or Python:** with `replace()`:\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, a):\\n        return a.replace(\".\", \"[.]\")\\n```\\n\\n\\n**PHP**: using `str_replace()`:\\n\\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return str_replace(\\'.\\', \\'[.]\\', $a);\\n    }\\n}\\n```\\n\\n\\n**PHP**: using `preg_replace()`:\\n\\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return preg_replace(\\'/\\\\./\\', \\'[.]\\', $a);\\n    }\\n}\\n```\\n\\n**PHP**: using `preg_replace()` and a character class `[]`:\\n\\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return preg_replace(\\'/[.]/\\', \\'[.]\\', $a);\\n    }\\n}\\n```\\n\\n**Ruby**: similar to PHP using `gsub()`:\\n\\n```\\ndef defang_i_paddr(a)\\n  a.gsub(/\\\\./, \"[.]\")\\nend\\n```\\n\\n\\n**JavaScript/TypeScript**: using the `g` global flag (modifier) with `replace()`:\\n\\n```\\nconst defangIPaddr = function(a) {\\n    return a.replace(/\\\\./g, \"[.]\")\\n}\\n```\\n\\n```\\nfunction defangIPaddr(a: string): string {\\n    return a.replace(/\\\\./g, \"[.]\")\\n}\\n```\\n\\n**C#**: using `Replace()`:\\n\\n```\\nclass Solution {\\n    public string DefangIPaddr(string a) {\\n        return a.Replace(\".\", \"[.]\");\\n    }\\n}\\n```\\n\\n\\n**Go**: using `strings.Replace()`:\\n\\n```\\nfunc defangIPaddr(a string) string {\\n    return strings.Replace(a, \".\", \"[.]\", -1)\\n}\\n```\\n\\n**Rust**: using `replace()`:\\n\\n```\\nimpl Solution {\\n    pub fn defang_i_paddr(a: String) -> String {\\n       a.replace( \".\", \"[.]\" )\\n    }\\n}\\n```\\n\\n**Swift**: using `replacingOccurrences()`:\\n\\n\\n```\\nclass Solution {\\n    func defangIPaddr(_ a: String) -> String {\\n        return a.replacingOccurrences(of: \".\", with: \"[.]\")\\n    }\\n}\\n```\\n\\n\\n**Explanation**:\\n\\nThe `.` is a metachar in RegEx engines. We would either use a character class `[]` as a wrapper or we have to escape such metachars using one or two backslashes (depending on the language and functions).\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Swift",
                    "Go",
                    "Rust",
                    "PHP",
                    "TypeScript"
                ],
                "code": "```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstatic const char *defangIPaddr(\\n    const char *address\\n) {\\n    char *ipv4_memory = calloc(1, sizeof(\"###[.]###[.]###[.]###\"));\\n    char *defanged = ipv4_memory;\\n\\n    for (const char *character = address; *character; character++) {\\n        if (*character == \\'.\\') {\\n            *ipv4_memory++ = \\'[\\';\\n            *ipv4_memory++ = \\'.\\';\\n            *ipv4_memory++ = \\']\\';\\n\\n        } else {\\n            *ipv4_memory++ = *character;\\n        }\\n    }\\n\\n    return defanged;\\n}\\n\\n```\n```\\n#include <stdio.h>\\n\\nchar *defangIPaddr(const char *address) {\\n    char *defanged;\\n    int ip[4];\\n\\n    if (sscanf(address, \"%d.%d.%d.%d\", &ip[0], &ip[1], &ip[2], &ip[3]) != 4) {\\n        return NULL;\\n    }\\n\\n    if (asprintf(&defanged, \"%d[.]%d[.]%d[.]%d\", ip[0], ip[1], ip[2], ip[3]) == -1) {\\n        return NULL;\\n    }\\n\\n    return defanged;\\n}\\n```\n```\\n#include <stdio.h>\\n#include <stdlib.h>\\n\\nstatic const char *defangIPaddr(\\n    const char *address\\n) {\\n    char *q = calloc(1, sizeof(\"###[.]###[.]###[.]###\"));\\n    char *defanged = q;\\n\\n    for (const char *p = address; *p; p++) {\\n        if (*p == \\'.\\') {\\n            *q++ = \\'[\\';\\n            *q++ = \\'.\\';\\n            *q++ = \\']\\';\\n\\n        } else {\\n            *q++ = *p;\\n        }\\n    }\\n\\n    return defanged;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        return regex_replace(a, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        return regex_replace(a, regex(\"\\\\\\\\.\"), \"[.]\");\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replace(\".\", \"[.]\");\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String a) {\\n        return a.replaceAll(\"[.]\", \"[.]\");\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def defangIPaddr(self, a):\\n        return re.sub(\\'\\\\.\\', \\'[.]\\', a)\\n```\n```\\nclass Solution:\\n    def defangIPaddr(self, a):\\n        return a.replace(\".\", \"[.]\")\\n```\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return str_replace(\\'.\\', \\'[.]\\', $a);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return preg_replace(\\'/\\\\./\\', \\'[.]\\', $a);\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\n    public function defangIPaddr($a)\\n    {\\n        return preg_replace(\\'/[.]/\\', \\'[.]\\', $a);\\n    }\\n}\\n```\n```\\ndef defang_i_paddr(a)\\n  a.gsub(/\\\\./, \"[.]\")\\nend\\n```\n```\\nconst defangIPaddr = function(a) {\\n    return a.replace(/\\\\./g, \"[.]\")\\n}\\n```\n```\\nfunction defangIPaddr(a: string): string {\\n    return a.replace(/\\\\./g, \"[.]\")\\n}\\n```\n```\\nclass Solution {\\n    public string DefangIPaddr(string a) {\\n        return a.Replace(\".\", \"[.]\");\\n    }\\n}\\n```\n```\\nfunc defangIPaddr(a string) string {\\n    return strings.Replace(a, \".\", \"[.]\", -1)\\n}\\n```\n```\\nimpl Solution {\\n    pub fn defang_i_paddr(a: String) -> String {\\n       a.replace( \".\", \"[.]\" )\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func defangIPaddr(_ a: String) -> String {\\n        return a.replacingOccurrences(of: \".\", with: \"[.]\")\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 343181,
                "title": "simple-java-solution",
                "content": "The manual version is the best efficiency-wise, 0ms and 100% in both time and memory\\n\\n```\\nfinal StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++) {\\n            if (address.charAt(i) == \\'.\\')\\n                sb.append(\"[.]\");\\n            else\\n                sb.append(address.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n```\\n\\nBut a slightly less efficient solution is archivied using java\\'s build-in libraries, like so\\n\\n```\\nreturn address.replace(\".\", \"[.]\");\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nfinal StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++) {\\n            if (address.charAt(i) == \\'.\\')\\n                sb.append(\"[.]\");\\n            else\\n                sb.append(address.charAt(i));\\n        }\\n        \\n        return sb.toString();\\n```\n```\\nreturn address.replace(\".\", \"[.]\");\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 338888,
                "title": "c-solution-o-n-100-time-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for (int i = address.size() - 2; i >= 0; i--)\\n            if (address[i + 1] == \\'.\\')\\n                address = address.substr(0, i + 1) + \"[.]\" + address.substr(i + 2);\\n        return address;\\n    }\\n};\\n```\\n\\nWe start looking from the second to last position because we know the last character in address will never be \\'.\\'\\nWe look backward through the string because we don\\'t want to mess up our indices when we start inserting the brackets.\\n\\nThis scored in",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for (int i = address.size() - 2; i >= 0; i--)\\n            if (address[i + 1] == \\'.\\')\\n                address = address.substr(0, i + 1) + \"[.]\" + address.substr(i + 2);\\n        return address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4031868,
                "title": "two-java-simple-solution-in-1-line-runtime-0ms-beats100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# code1\\n```Java\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\" , \"[.]\");\\n    }\\n}\\n```\\n\\n\\n# Code2\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (char c : address.toCharArray()){\\n            str.append((c == \\'.\\')? \"[.]\" : c );\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/5db11db7-1336-477d-af6c-d0ca683bb9b1_1694447536.287339.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Java\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\" , \"[.]\");\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (char c : address.toCharArray()){\\n            str.append((c == \\'.\\')? \"[.]\" : c );\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 328909,
                "title": "very-simple-inbuilt-function",
                "content": "Java has inbuilt function\\nreplace(CharSequence target, CharSequence replacement)\\nreplaceAll(String regex, String replacement)\\n```\\npublic String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n```\\n\\n```\\npublic String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n```\n```\\npublic String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 392115,
                "title": "quick-c-solution",
                "content": "quick c solution\\n```c\\nchar * defangIPaddr(char * address){\\n    char *re = malloc(24);\\n    char *out = re;\\n    while (*address) {\\n        if (*address == \\'.\\') {\\n            *out++ = \\'[\\';\\n            *out++ = \\'.\\';\\n            *out++ = \\']\\';\\n            *address++;\\n        } else {\\n            *out++ = *address++;\\n        }\\n    }\\n    *out = \\'\\\\0\\';\\n    return re;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```c\\nchar * defangIPaddr(char * address){\\n    char *re = malloc(24);\\n    char *out = re;\\n    while (*address) {\\n        if (*address == \\'.\\') {\\n            *out++ = \\'[\\';\\n            *out++ = \\'.\\';\\n            *out++ = \\']\\';\\n            *address++;\\n        } else {\\n            *out++ = *address++;\\n        }\\n    }\\n    *out = \\'\\\\0\\';\\n    return re;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3125643,
                "title": "java-best-solution-o-n-time-complexity-beats-100",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++) {\\n            if (address.charAt(i) == \\'.\\') {\\n                str.append(\"[.]\");\\n            } else {\\n                str.append(address.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for (int i = 0; i < address.length(); i++) {\\n            if (address.charAt(i) == \\'.\\') {\\n                str.append(\"[.]\");\\n            } else {\\n                str.append(address.charAt(i));\\n            }\\n        }\\n        return str.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1190287,
                "title": "java-1-line-code-beats-100",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      \\n        String replaceString = address.replace(\".\",\"[.]\");\\n        return replaceString;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String defangIPaddr(String address) {\\n      \\n        String replaceString = address.replace(\".\",\"[.]\");\\n        return replaceString;\\n        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 989884,
                "title": "99-faster-1-liner-python-why-did-somebody-downvote-this",
                "content": "class Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n\\t\\n        address = address.replace(\\'.\\',\\'[.]\\')\\n        return(address)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n\\t\\n        address = address.replace(\\'.\\',\\'[.]\\')\\n        return(address)",
                "codeTag": "Java"
            },
            {
                "id": 575813,
                "title": "c-0ms-simple-and-short",
                "content": "```\\nchar * defangIPaddr(char * address){\\n    char *d = calloc(1, sizeof(\"xxx[.]xxx[.]xxx[.]xxx\")), *t = d;\\n    for (char *a = address ; *a ; a++)\\n        *a == \\'.\\' ? *d++ = \\'[\\', *d++ = \\'.\\', *d++ = \\']\\' : (*d++ = *a);\\n    return t;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * defangIPaddr(char * address){\\n    char *d = calloc(1, sizeof(\"xxx[.]xxx[.]xxx[.]xxx\")), *t = d;\\n    for (char *a = address ; *a ; a++)\\n        *a == \\'.\\' ? *d++ = \\'[\\', *d++ = \\'.\\', *d++ = \\']\\' : (*d++ = *a);\\n    return t;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331694,
                "title": "javascript-regex-solution",
                "content": "Simple one line that uses regex and the string.replace() method. \\n\\n```\\nvar defangIPaddr = function(address) {\\n    return address.replace(/\\\\./g, \"[.]\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    return address.replace(/\\\\./g, \"[.]\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2785391,
                "title": "c-beats-100-0ms-best-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n# Code\\n```\\n//Please upvote if it helps..........\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.length();++i){\\n            if(address[i]==\\'.\\')\\n            ans+=\"[.]\";\\n            else\\n            ans+=address[i];\\n        } return ans;\\n    }\\n};\\n//.........\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\n//Please upvote if it helps..........\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.length();++i){\\n            if(address[i]==\\'.\\')\\n            ans+=\"[.]\";\\n            else\\n            ans+=address[i];\\n        } return ans;\\n    }\\n};\\n//.........\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673600,
                "title": "simple-c-solution-3-method-100-faster",
                "content": "```\\n\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n```\\n# Simple\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string result;\\n        for(int i = 0 ; i < address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                result +=\"[.]\";\\n            }\\n            else result += address[i];\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n\\n\\n# Code using insert\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\n        for(int i = 0 ; i < address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                address.insert(address.begin() + (i), \\'[\\');\\n                i++;\\n                address.insert(address.begin() + (i + 1), \\']\\');\\n            }\\n        }\\n\\n        return address;\\n    }\\n};\\n```\\n# Code using regex_replace\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n\\u2705 PLEASE UPVOTE IF YOU LIKE! \\u2705\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string result;\\n        for(int i = 0 ; i < address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                result +=\"[.]\";\\n            }\\n            else result += address[i];\\n        }\\n\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\n        for(int i = 0 ; i < address.length();i++){\\n            if(address[i]==\\'.\\'){\\n                address.insert(address.begin() + (i), \\'[\\');\\n                i++;\\n                address.insert(address.begin() + (i + 1), \\']\\');\\n            }\\n        }\\n\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641851,
                "title": "js-one-line",
                "content": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1224178,
                "title": "java-100-stringbuilder-solution",
                "content": "if you like it pls upvote\\n\\nJAVA\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int i = 0;i<address.length();i++){\\n            if(address.charAt(i) == \\'.\\')\\n                res.append(\"[.]\");\\n            else\\n                res.append(address.charAt(i));\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder res = new StringBuilder();\\n        \\n        for(int i = 0;i<address.length();i++){\\n            if(address.charAt(i) == \\'.\\')\\n                res.append(\"[.]\");\\n            else\\n                res.append(address.charAt(i));\\n        }\\n        \\n        return res.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 471519,
                "title": "c-100",
                "content": "class Solution \\n{\\n    public:\\n    \\n    std::string defangIPaddr(std::string a) \\n    {       \\n        for(size_t i = 0 ;; i++)\\n        {\\n            if(a[i] == \\'.\\')\\n            {\\n                a.replace(i, 1, std::string(\"[.]\"));\\n                i++;\\n            }\\n                          \\n            if(i == a.size() - 1) break;\\n        }\\n        \\n        return a;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution \\n{\\n    public:\\n    \\n    std::string defangIPaddr(std::string a) \\n    {       \\n        for(size_t i = 0 ;; i++)\\n        {\\n            if(a[i] == \\'.\\')\\n            {\\n                a.replace(i, 1, std::string(\"[.]\"));\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 438253,
                "title": "python-3-24-ms-faster-than-96-73",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 381707,
                "title": "javascript",
                "content": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2808184,
                "title": "java-one-line-code",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673917,
                "title": "python-simple-solution-in-7-lines-faster-than-96-41",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        s=\\'\\'\\n        for i in address:\\n            if i==\\'.\\':\\n                s+=\\'[.]\\'\\n            else:\\n                s+=i\\n        return s\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        s=\\'\\'\\n        for i in address:\\n            if i==\\'.\\':\\n                s+=\\'[.]\\'\\n            else:\\n                s+=i\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1094299,
                "title": "c-solution",
                "content": "```\\nchar * defangIPaddr(char * address){\\n    char * buffer = (char *)malloc(30*sizeof(char));\\n    int a = 0, b = 0, c = 0, d = 0;\\n    sscanf(address,\"%d.%d.%d.%d\",&a ,&b ,&c ,&d);\\n    sprintf(buffer,\"%d[.]%d[.]%d[.]%d\",a ,b ,c ,d);\\n    return buffer;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * defangIPaddr(char * address){\\n    char * buffer = (char *)malloc(30*sizeof(char));\\n    int a = 0, b = 0, c = 0, d = 0;\\n    sscanf(address,\"%d.%d.%d.%d\",&a ,&b ,&c ,&d);\\n    sprintf(buffer,\"%d[.]%d[.]%d[.]%d\",a ,b ,c ,d);\\n    return buffer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 872844,
                "title": "c-o-n-one-line-replace-easy-answer",
                "content": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        return address.Replace(\".\", \"[.]\");\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public string DefangIPaddr(string address) {\\n        return address.Replace(\".\", \"[.]\");\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3436082,
                "title": "java-easy-solution-beats-100-runtime-0ms-2-methods-to-solve",
                "content": "Hope this helps!!\\nDo Upvote if you like it.\\n\\nThanks :)\\n# Code\\n```\\n//Method-1\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb= new StringBuilder();\\n        for(int i=0; i<address.length(); i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                sb.append(\"[.]\");\\n            }else{\\n                sb.append(address.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }    \\n}\\n\\n\\n// Method-2\\n\\n// class Solution {\\n//     public String defangIPaddr(String address) {\\n//         String str= address.replace(\".\",\"[.]\");\\n//         return str;\\n//     }    \\n// }\\n\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n//Method-1\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb= new StringBuilder();\\n        for(int i=0; i<address.length(); i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                sb.append(\"[.]\");\\n            }else{\\n                sb.append(address.charAt(i));\\n            }\\n        }\\n        return sb.toString();\\n    }    \\n}\\n\\n\\n// Method-2\\n\\n// class Solution {\\n//     public String defangIPaddr(String address) {\\n//         String str= address.replace(\".\",\"[.]\");\\n//         return str;\\n//     }    \\n// }\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 479795,
                "title": "c-solution",
                "content": "```\\nchar * defangIPaddr(char * address){\\n    char *result = (char *)malloc(sizeof(char) * (strlen(address) + 10));\\n    memset(result,0,strlen(address) + 10);\\n    int k = 0;\\n    for (int i = 0;address[i] != \\'\\\\0\\';i++) {\\n        if (address[i]==\\'.\\') {\\n            result[k] = \\'[\\';\\n            result[k+1] = \\'.\\';\\n            result[k+2] = \\']\\';\\n            k+=3;\\n        }else {\\n            result[k++] = address[i];\\n        }\\n    }\\n    result[k] = 0;\\n    return result;\\n}\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * defangIPaddr(char * address){\\n    char *result = (char *)malloc(sizeof(char) * (strlen(address) + 10));\\n    memset(result,0,strlen(address) + 10);\\n    int k = 0;\\n    for (int i = 0;address[i] != \\'\\\\0\\';i++) {\\n        if (address[i]==\\'.\\') {\\n            result[k] = \\'[\\';\\n            result[k+1] = \\'.\\';\\n            result[k+2] = \\']\\';\\n            k+=3;\\n        }else {\\n            result[k++] = address[i];\\n        }\\n    }\\n    result[k] = 0;\\n    return result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 427653,
                "title": "c-two-solutions",
                "content": "It is important for me as a C# programmer to warm up all kinds of class and common APIs. string.Join and string.Split are two APIs which can be used to solve the problem. \\n\\n\\n\\nSolution 1: \\n\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n     \\n        if(address == null || address.Length == 0)\\n            return \"\";\\n        \\n        return string.Join(\"[.]\", address.Split(\\'.\\'));\\n    }\\n}\\n```\\nSolution II:\\n```\\npublic string DefangIPaddr(string address)\\n{\\n\\tif (address == null || address.Length == 0)\\n\\t\\treturn \"\";\\n\\n    var defangled = new StringBuilder();\\n\\n    foreach (var item in address)\\n    {\\n\\t\\tif (item == \\'.\\')\\n        {\\n\\t\\t\\tdefangled.Append(\"[.]\");\\n        }\\n        else\\n        {\\n\\t\\t\\tdefangled.Append(item);\\n        }\\n\\t}\\n\\n    return defangled.ToString();\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n     \\n        if(address == null || address.Length == 0)\\n            return \"\";\\n        \\n        return string.Join(\"[.]\", address.Split(\\'.\\'));\\n    }\\n}\\n```\n```\\npublic string DefangIPaddr(string address)\\n{\\n\\tif (address == null || address.Length == 0)\\n\\t\\treturn \"\";\\n\\n    var defangled = new StringBuilder();\\n\\n    foreach (var item in address)\\n    {\\n\\t\\tif (item == \\'.\\')\\n        {\\n\\t\\t\\tdefangled.Append(\"[.]\");\\n        }\\n        else\\n        {\\n\\t\\t\\tdefangled.Append(item);\\n        }\\n\\t}\\n\\n    return defangled.ToString();\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077687,
                "title": "100-beats-with-0ms-easy-solve",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string s;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                s=s+\"[.]\";\\n            }\\n            else\\n            {\\n                s=s+address[i];\\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string s;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                s=s+\"[.]\";\\n            }\\n            else\\n            {\\n                s=s+address[i];\\n            }\\n        }\\n        return s;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900111,
                "title": "beats-98-93-of-python-solutions-at-runtime-beats-95-22-of-python-solutions-in-memory-usage",
                "content": "Please Upvote if you find the solution useful.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Used String replace() function. \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        x = address.replace(\".\",\"[.]\")\\n        return x\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        x = address.replace(\".\",\"[.]\")\\n        return x\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833009,
                "title": "c-std-regex-replace-one-liner",
                "content": "Maybe a bit of an overkill, but quick to write. :)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address, regex(\"[.]\"), \"[.]\");\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2432727,
                "title": "java-easy-100-fast-stringbuilder-class",
                "content": "# Please Upvote\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F\\n\\n```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Defanging an IP Address.\\nMemory Usage: 41.9 MB, less than 64.91% of Java online submissions for Defanging an IP Address.\\n```\\n```\\nStringBuilder sb = new StringBuilder();\\n        for(char c : address.toCharArray()){\\n            if(c == \\'.\\'){\\n                sb.append(\\'[\\');\\n                sb.append(c);\\n                sb.append(\\']\\');\\n            }else\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Defanging an IP Address.\\nMemory Usage: 41.9 MB, less than 64.91% of Java online submissions for Defanging an IP Address.\\n```\n```\\nStringBuilder sb = new StringBuilder();\\n        for(char c : address.toCharArray()){\\n            if(c == \\'.\\'){\\n                sb.append(\\'[\\');\\n                sb.append(c);\\n                sb.append(\\']\\');\\n            }else\\n                sb.append(c);\\n        }\\n        return sb.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1340914,
                "title": "simple-c-faster-than-100-00-basic-string",
                "content": "Using basic string operation we can solve this problem.\\nIn the given string where we find `\\'.\\'`, we add `[.]` to the answer string, otherwise we add the character normally.\\n```class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans = \"\" ;\\n        for(auto i:address)\\n        {\\n            if(i == \\'.\\')\\n            {\\n                ans += \"[.]\" ;\\n            }\\n            else\\n            {\\n                ans += i ;\\n            }\\n        }\\n        return ans ;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans = \"\" ;\\n        for(auto i:address)\\n        {\\n            if(i == \\'.\\')\\n            {\\n                ans += \"[.]\" ;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1247232,
                "title": "100-faster-c-solution",
                "content": "The basic strategy for the solution is to add each character one by one to a new string and as soon as the pointer encounters \\'.\\' (period) we will add a string \\'[.]\\' to this new string else the char is added to that string.\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string re=\"\";\\n        for(int i=0;i<address.length();++i)\\n        {\\n            if(address[i]==\\'.\\')\\n                re+=\"[.]\";\\n            else\\n                re+=address[i];\\n        }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string re=\"\";\\n        for(int i=0;i<address.length();++i)\\n        {\\n            if(address[i]==\\'.\\')\\n                re+=\"[.]\";\\n            else\\n                re+=address[i];\\n        }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153918,
                "title": "swift-defanging-an-ip-address",
                "content": "```swift\\nclass Solution {\\n    func defangIPaddr(_ address: String) -> String {\\n        return address.components(separatedBy: \".\").joined(separator: \"[.]\")\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func defangIPaddr(_ address: String) -> String {\\n        return address.components(separatedBy: \".\").joined(separator: \"[.]\")\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113407,
                "title": "easy-to-understand-in-python-3",
                "content": "Easy To Understand Python Solution:\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        \\n        answerString = \"\"\\n        for c in address:\\n            if c == \".\":\\n                answerString += \"[.]\"\\n            else:\\n                answerString += c\\n        \\n        return answerString\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        \\n        answerString = \"\"\\n        for c in address:\\n            if c == \".\":\\n                answerString += \"[.]\"\\n            else:\\n                answerString += c\\n        \\n        return answerString\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996880,
                "title": "very-easy-solution-c-java-o-n-very-easy-to-understand",
                "content": "Implementation\\n\\n**1st Approach in C++**\\n\\n**Time Complexity = O(N), Space Complexity = O(N)**\\n\\n```\\nstring defangIPaddr(string address) {\\n    string str;\\n    for(int itr = 0; itr < address.size(); itr++){\\n        if(address[itr] == \\'.\\') str += \"[.]\";                \\n        else str += address[itr];                \\n    }            \\n    return str;\\n}\\n```\\n\\n\\n**2nd Approach in Java**\\n\\n**Time Complexity = O(N), Space Complexity = O(N)**\\n\\n```\\npublic String defangIPaddr(String address) {\\n    String str = \"\";\\n    for(int itr = 0; itr < address.length(); itr++){\\n        if(address.charAt(itr) == \\'.\\') str += \"[.]\";                \\n        else str += address.charAt(itr);                \\n    }            \\n    return str;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nstring defangIPaddr(string address) {\\n    string str;\\n    for(int itr = 0; itr < address.size(); itr++){\\n        if(address[itr] == \\'.\\') str += \"[.]\";                \\n        else str += address[itr];                \\n    }            \\n    return str;\\n}\\n```\n```\\npublic String defangIPaddr(String address) {\\n    String str = \"\";\\n    for(int itr = 0; itr < address.length(); itr++){\\n        if(address.charAt(itr) == \\'.\\') str += \"[.]\";                \\n        else str += address.charAt(itr);                \\n    }            \\n    return str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 810808,
                "title": "javascript-solution-1108",
                "content": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nlet defangIPaddr = function(address) {\\n        return address.replace(/[.]/g,\\'[.]\\')\\n    };\\n```\\n\\n**Runtime: 76 ms, faster than 54.73% of JavaScript online submissions for Defanging an IP Address.**\\n\\n**Memory Usage: 36.9 MB, less than 5.00% of JavaScript online submissions for Defanging an IP Address.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nlet defangIPaddr = function(address) {\\n        return address.replace(/[.]/g,\\'[.]\\')\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 774568,
                "title": "python-solution-with-and-without-inbuilt-function",
                "content": "With Inbuit Function:\\n---------------\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\", \"[.]\")\\n```\\n\\nWithout Inbuit Function: O(n)\\n--------------------\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        res=\"\"\\n        for i in range(len(address)):\\n            if (address[i]!=\\'.\\'):\\n                res+=address[i]\\n            else:\\n                res+=\"[.]\"\\n        return res\\n```\\nhttps://github.com/shubhamthrills",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\", \"[.]\")\\n```\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        res=\"\"\\n        for i in range(len(address)):\\n            if (address[i]!=\\'.\\'):\\n                res+=address[i]\\n            else:\\n                res+=\"[.]\"\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526222,
                "title": "java-replace-vs-replace-all-join",
                "content": "```\\npublic String defangIPaddr(String address) {\\n        //return String.join(\"[.]\", address.split(\"\\\\\\\\.\"));\\n        // return address.replaceAll(\"\\\\\\\\.\", \"[.]\"); // use reges \" \\\\\\\\.\" other than \".\";\\n        return address.replace(\".\", \"[.]\");\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic String defangIPaddr(String address) {\\n        //return String.join(\"[.]\", address.split(\"\\\\\\\\.\"));\\n        // return address.replaceAll(\"\\\\\\\\.\", \"[.]\"); // use reges \" \\\\\\\\.\" other than \".\";\\n        return address.replace(\".\", \"[.]\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 415553,
                "title": "it-says-runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "***Runtime: 0 ms, faster than 100.00% of C online submissions for Defanging an IP Address.\\nMemory Usage: 6.6 MB, less than 100.00% of C online submissions for Defanging an IP Address.***\\n\\nI\\'m new to programming, any suggestion with this code would be appreciated.\\n```\\n\\n\\nchar * defangIPaddr(char * address){\\n    \\n    int length = strlen(address), j = 0;\\n    char * returnIp = malloc((length + 7));\\n    \\n    for (int i = 0; i < length; i++)\\n    {\\n        if (address[i] != \\'.\\')\\n        {\\n            *(returnIp + j) = address[i];\\n            j++;\\n        }\\n        else\\n        {\\n            *(returnIp + j) = \\'[\\';\\n            *(returnIp + (j + 1)) = \\'.\\';\\n            *(returnIp + (j + 2)) = \\']\\';\\n            j = j + 3;\\n        }\\n    }\\n    \\n    *(returnIp + j) = \\'\\\\0\\';\\n    \\n    return returnIp;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\n\\nchar * defangIPaddr(char * address){\\n    \\n    int length = strlen(address), j = 0;\\n    char * returnIp = malloc((length + 7));\\n    \\n    for (int i = 0; i < length; i++)\\n    {\\n        if (address[i] != \\'.\\')\\n        {\\n            *(returnIp + j) = address[i];\\n            j++;\\n        }\\n        else\\n        {\\n            *(returnIp + j) = \\'[\\';\\n            *(returnIp + (j + 1)) = \\'.\\';\\n            *(returnIp + (j + 2)) = \\']\\';\\n            j = j + 3;\\n        }\\n    }\\n    \\n    *(returnIp + j) = \\'\\\\0\\';\\n    \\n    return returnIp;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 383317,
                "title": "0ms-c-inverse-enumeration",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i = address.size(); i >= 0; i--){\\n            if(address[i] == \\'.\\'){\\n                address.replace(i, 1, \"[.]\");\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i = address.size(); i >= 0; i--){\\n            if(address[i] == \\'.\\'){\\n                address.replace(i, 1, \"[.]\");\\n            }\\n        }\\n        return address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361331,
                "title": "defang-34-1mb-and-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder output =new StringBuilder();\\n        for (char ch: address.toCharArray()) {\\n            switch(ch) {\\n                case \\'.\\' : output.append(\"[.]\"); break;\\n                default: output.append(ch); break;\\n            }\\n        }\\n        return output.toString();\\n    }\\n}\\n```\\nSwitch is faster than if/else and \\'?\\' statements. StringBuilder saves memory.\\nhttps://leetcode.com/submissions/detail/252654344/\\n\\nCheers.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder output =new StringBuilder();\\n        for (char ch: address.toCharArray()) {\\n            switch(ch) {\\n                case \\'.\\' : output.append(\"[.]\"); break;\\n                default: output.append(ch); break;\\n            }\\n        }\\n        return output.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 339583,
                "title": "kotlin-different-approach",
                "content": "```\\nclass Solution {\\n    fun defangIPaddr(address: String): String = StringBuilder().run { \\n        address.forEach{\\n            if(it.equals(\\'.\\')){\\n                append(\"[.]\")\\n            }else{\\n                append(it)\\n            }\\n        }\\n        toString()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun defangIPaddr(address: String): String = StringBuilder().run { \\n        address.forEach{\\n            if(it.equals(\\'.\\')){\\n                append(\"[.]\")\\n            }else{\\n                append(it)\\n            }\\n        }\\n        toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 330713,
                "title": "python-one-liner",
                "content": "class Solution(object):\\n    def defangIPaddr(self, address):\\n        \"\"\"\\n        :type address: str\\n        :rtype: str\\n        \"\"\"\\n        return \"[.]\".join(address.split(\\'.\\'))",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def defangIPaddr(self, address):\\n        \"\"\"\\n        :type address: str\\n        :rtype: str\\n        \"\"\"\\n        return \"[.]\".join(address.split(\\'.\\'))",
                "codeTag": "Java"
            },
            {
                "id": 3650582,
                "title": "1108-defanging-an-ip-address-100-easy-java-program",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n\\n        String str = address.replace(\".\",\"[.]\");\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n\\n        String str = address.replace(\".\",\"[.]\");\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181188,
                "title": "100-beat-zero-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        queue<char>q;\\n        int i=0;\\n        while(i<a.size()){\\n            q.push(a[i]);\\n            i++;\\n        }\\n\\n        string s;\\n        while(!q.empty()){\\n            if(q.front()==\\'.\\'){\\n                s+=\\'[\\';\\n                s+=\\'.\\';\\n                s+=\\']\\';\\n                q.pop();\\n            }\\n\\n            else{\\n                s+=q.front();\\n                q.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string a) {\\n        queue<char>q;\\n        int i=0;\\n        while(i<a.size()){\\n            q.push(a[i]);\\n            i++;\\n        }\\n\\n        string s;\\n        while(!q.empty()){\\n            if(q.front()==\\'.\\'){\\n                s+=\\'[\\';\\n                s+=\\'.\\';\\n                s+=\\']\\';\\n                q.pop();\\n            }\\n\\n            else{\\n                s+=q.front();\\n                q.pop();\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3178837,
                "title": "c-straightforward-clean-code-beginner-friendly",
                "content": "![image](https://assets.leetcode.com/users/images/12c0dc6b-6db7-4dad-bed4-8b8b710ecdbe_1676265829.7416234.png)\\n\\n**n == address.size()\\nT->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring defangIPaddr(string address) {\\n\\t\\t\\tstring defan = \"\";\\n\\n\\t\\t\\tfor(auto i : address){\\n\\t\\t\\t\\tif(i == \\'.\\'){\\n\\t\\t\\t\\t\\tdefan += \"[.]\";\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tdefan += i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn defan;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring defangIPaddr(string address) {\\n\\t\\t\\tstring defan = \"\";\\n\\n\\t\\t\\tfor(auto i : address){\\n\\t\\t\\t\\tif(i == \\'.\\'){\\n\\t\\t\\t\\t\\tdefan += \"[.]\";\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3127222,
                "title": "c-solution",
                "content": "\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            ans+=\"[.]\";\\n\\n            else\\n            ans+=address[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            ans+=\"[.]\";\\n\\n            else\\n            ans+=address[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087962,
                "title": "beats-94-61-in-time",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n# Code\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < address.Length; i++)\\n        {\\n            if (address[i] == \\'.\\')\\n                sb.Append(\"[.]\");\\n            else\\n                sb.Append(address[i]);\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) \\n    {\\n        StringBuilder sb = new StringBuilder();\\n        for (int i = 0; i < address.Length; i++)\\n        {\\n            if (address[i] == \\'.\\')\\n                sb.Append(\"[.]\");\\n            else\\n                sb.Append(address[i]);\\n        }\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2731024,
                "title": "one-line-easiest-python-solution",
                "content": "**Hi there!  Please upvote**\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str: \\n        \\n        return address.replace(\\'.\\', \\'[.]\\')\\n        \\n        \\n``` \\n**Happy Coding :)**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str: \\n        \\n        return address.replace(\\'.\\', \\'[.]\\')\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2673922,
                "title": "python-simple-one-line-solution",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\',\\'[.]\\')\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\',\\'[.]\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212726,
                "title": "c-sol-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        for(int i=0,j=0;j<3;i++){\\n            if(address[i]==\\'.\\'){\\n                address.insert(address.begin()+(i),\\'[\\');\\n                address.insert(address.begin()+(i+2),\\']\\');\\n                i++;\\n                j++;\\n            }\\n        }\\n        return address;\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        for(int i=0,j=0;j<3;i++){\\n            if(address[i]==\\'.\\'){\\n                address.insert(address.begin()+(i),\\'[\\');\\n                address.insert(address.begin()+(i+2),\\']\\');\\n                i++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1493059,
                "title": "java-solution-faster-then-100-easy-explanation-with-code-and-comments",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder ans = new StringBuilder();    // We are using StringBuilder instead of String bcz StringBuilder is mutable and using this we can change the string without creating new objects. While in case of String it will keep creating new objects hence wastage of memory\\n        \\n        for(int i=0;i<address.length();i++){\\n            if(address.charAt(i) == \\'.\\')    // if \\'.\\' is present in the string then replace it with \\'[.]\\'\\n                ans.append(\"[.]\");\\n            else\\n                ans.append(address.charAt(i));   // keep adding other things as it is\\n        }\\n        return ans.toString();    // We can\\'t directly return \"ans\" as \"ans\" is of type StringBuilder and we have to return String. Hence, ans.toString() \\n    }\\n}\\n\\n// If you find this post helpful then plz upvote :-)\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder ans = new StringBuilder();    // We are using StringBuilder instead of String bcz StringBuilder is mutable and using this we can change the string without creating new objects. While in case of String it will keep creating new objects hence wastage of memory\\n        \\n        for(int i=0;i<address.length();i++){\\n            if(address.charAt(i) == \\'.\\')    // if \\'.\\' is present in the string then replace it with \\'[.]\\'\\n                ans.append(\"[.]\");\\n            else\\n                ans.append(address.charAt(i));   // keep adding other things as it is\\n        }\\n        return ans.toString();    // We can\\'t directly return \"ans\" as \"ans\" is of type StringBuilder and we have to return String. Hence, ans.toString() \\n    }\\n}\\n\\n// If you find this post helpful then plz upvote :-)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1263589,
                "title": "simple-c-code-100-faster",
                "content": "```\\nstring defangIPaddr(string address) {\\n       for(int i=1;i<address.size();i++){\\n           if(address[i]==\\'.\\'){\\n              address.insert(i,\"[\");\\n              address.insert(i+2,\"]\");\\n               i+=2;\\n           }\\n         }\\n        return address;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring defangIPaddr(string address) {\\n       for(int i=1;i<address.size();i++){\\n           if(address[i]==\\'.\\'){\\n              address.insert(i,\"[\");\\n              address.insert(i+2,\"]\");\\n               i+=2;\\n           }\\n         }\\n        return address;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 953318,
                "title": "rust-one-liner",
                "content": "```rust\\npub fn defang_i_paddr(address: String) -> String {\\n\\taddress.replace(\\'.\\', \"[.]\")\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\npub fn defang_i_paddr(address: String) -> String {\\n\\taddress.replace(\\'.\\', \"[.]\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 857770,
                "title": "python-one-line-string-replace",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703556,
                "title": "c-speed-mem-o-n-o-n-simple-video",
                "content": "\\nClick URL: https://youtu.be/LI-Jis4xOMI\\nClicking the play button does not work.\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        \\n        string out;\\n        for(int i=0; i < address.size(); i++){\\n            if(address[i]==\\'.\\')\\n                out += \"[.]\";\\n            else\\n                out += address[i];\\n        }\\n        return out;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        \\n        string out;\\n        for(int i=0; i < address.size(); i++){\\n            if(address[i]==\\'.\\')\\n                out += \"[.]\";\\n            else\\n                out += address[i];\\n        }\\n        return out;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 621885,
                "title": "100-100-java-silly-question",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533313,
                "title": "naive-c-97-5-time-100-memory",
                "content": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        char[] newAddress = new char[address.Length + 6];\\n        int pointer = 0;\\n        \\n        foreach(char c in address) {\\n            if (c == \\'.\\') {\\n                newAddress[pointer++] = \\'[\\';\\n                newAddress[pointer++] = \\'.\\';\\n                newAddress[pointer++] = \\']\\';\\n            } else {\\n                newAddress[pointer++] = c;\\n            }\\n        }\\n        \\n        return new string(newAddress);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        char[] newAddress = new char[address.Length + 6];\\n        int pointer = 0;\\n        \\n        foreach(char c in address) {\\n            if (c == \\'.\\') {\\n                newAddress[pointer++] = \\'[\\';\\n                newAddress[pointer++] = \\'.\\';\\n                newAddress[pointer++] = \\']\\';\\n            } else {\\n                newAddress[pointer++] = c;\\n            }\\n        }\\n        \\n        return new string(newAddress);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 485800,
                "title": "1108-defanging-an-ip-address",
                "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        String result = \"\";\\n        for(int i = 0; i < address.length(); i ++){\\n            if(address.charAt(i)==\\'.\\'){\\n                result = result.concat(\"[\")\\n                               .concat(String.valueOf(address.charAt(i)))\\n                               .concat(\"]\");\\n            }else{\\n                result = result.concat(String.valueOf(address.charAt(i)));\\n            }\\n        }\\n        return result;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String defangIPaddr(String address) {\\n        String result = \"\";\\n        for(int i = 0; i < address.length(); i ++){\\n            if(address.charAt(i)==\\'.\\'){\\n                result = result.concat(\"[\")\\n                               .concat(String.valueOf(address.charAt(i)))\\n                               .concat(\"]\");\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 361663,
                "title": "c-one-liner",
                "content": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        return address.Replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        return address.Replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358386,
                "title": "1-line-in-javascript",
                "content": "```javascript\\n\\taddress.split(\\'.\\').join(\\'[.]\\')\\n```\\n\\nThat\\'s it!",
                "solutionTags": [],
                "code": "```javascript\\n\\taddress.split(\\'.\\').join(\\'[.]\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 349451,
                "title": "python-solution",
                "content": "```\\n    def defangIPaddr(self, address):\\n        return address.replace(\".\", \"[.]\")\\n```",
                "solutionTags": [],
                "code": "```\\n    def defangIPaddr(self, address):\\n        return address.replace(\".\", \"[.]\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 331492,
                "title": "javascript-solution-o-n-time",
                "content": "```\\nvar defangIPaddr = function(address) {\\n    let str = \\'\\';\\n    for(let i = 0; i < address.length; i++){\\n        let char = address.charAt(i);\\n        if(char == \\'.\\') char = \\'[.]\\';\\n        str = str + char;\\n    }\\n    return str;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    let str = \\'\\';\\n    for(let i = 0; i < address.length; i++){\\n        let char = address.charAt(i);\\n        if(char == \\'.\\') char = \\'[.]\\';\\n        str = str + char;\\n    }\\n    return str;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330484,
                "title": "c-solution",
                "content": "\\tchar * defangIPaddr(char * address)\\n\\t{\\n\\t\\tint len = strlen(address);\\n\\t\\tchar *res = malloc(sizeof(char) * (len + 7)); // 6 for 3 sets of brackets + 1 NULL\\n\\n\\t\\tint i = 0, j = 0;\\n\\t\\twhile (i < len)\\n\\t\\t{   \\n\\t\\t\\tres[j++] = address[i];\\n\\n\\t\\t\\tif (address[i+1] == \\'.\\') \\n\\t\\t\\t{\\n\\t\\t\\t\\tres[j++] = \\'[\\';\\n\\t\\t\\t\\tres[j++] = address[++i];\\n\\t\\t\\t\\tres[j++] = \\']\\';\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tres[j] = \\'\\\\0\\';\\n\\t\\treturn res;\\n\\t}",
                "solutionTags": [],
                "code": "\\tchar * defangIPaddr(char * address)\\n\\t{\\n\\t\\tint len = strlen(address);\\n\\t\\tchar *res = malloc(sizeof(char) * (len + 7)); // 6 for 3 sets of brackets + 1 NULL\\n\\n\\t\\tint i = 0, j = 0;\\n\\t\\twhile (i < len)\\n\\t\\t{   \\n\\t\\t\\tres[j++] = address[i];\\n\\n\\t\\t\\tif (address[i+1] == \\'.\\') \\n\\t\\t\\t{\\n\\t\\t\\t\\tres[j++] = \\'[\\';\\n\\t\\t\\t\\tres[j++] = address[++i];\\n\\t\\t\\t\\tres[j++] = \\']\\';\\n\\t\\t\\t}\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\t\\tres[j] = \\'\\\\0\\';\\n\\t\\treturn res;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 329626,
                "title": "javascript-1-line-faster-than-100",
                "content": "This is a simple text replacement problem. Break the string into an array by separating on \".\" . Then rejoin the string with the new text, \"[.]\" using array join.\\n```\\n//100% on speed and space \\n//https://leetcode.com/problems/defanging-an-ip-address/submissions/\\n\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    return address.split(\".\").join(\\'[.]\\')\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//100% on speed and space \\n//https://leetcode.com/problems/defanging-an-ip-address/submissions/\\n\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    return address.split(\".\").join(\\'[.]\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3993949,
                "title": "1-line",
                "content": "***String has replace method which takes two parameters String.replace(\"old one\",\"new one\");\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n\\n\\n```\\n![f9e51783-3660-4252-933c-ec2c42b2d57d_1677809905.0379472.jpeg](https://assets.leetcode.com/users/images/607eea57-2eaf-4410-9174-96cee82995a0_1693680746.2719412.jpeg)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3934872,
                "title": "easy-peasy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string adress) {\\n        string ans=\"\";\\n\\n\\n        for(int i=0;i<adress.size();i++)\\n        {\\n            if(adress[i]==\\'.\\')\\n            {\\n                ans+=\"[.]\";\\n            }\\n            else\\n            {\\n                ans+=adress[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string adress) {\\n        string ans=\"\";\\n\\n\\n        for(int i=0;i<adress.size();i++)\\n        {\\n            if(adress[i]==\\'.\\')\\n            {\\n                ans+=\"[.]\";\\n            }\\n            else\\n            {\\n                ans+=adress[i];\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862213,
                "title": "100-beats-in-time-and-99-50-beats-in-memory-java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n       int n = address.length();\\n       StringBuilder sb = new StringBuilder();\\n       for(int i=0;i<n;i++){\\n           if(address.charAt(i)==\\'.\\'){\\n               sb.append(\"[\");\\n               sb.append(\".\");\\n               sb.append(\"]\");\\n           }\\n           else{\\n               sb.append(address.charAt(i));\\n           }\\n       } \\n       String str = sb.toString();\\n       return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n       int n = address.length();\\n       StringBuilder sb = new StringBuilder();\\n       for(int i=0;i<n;i++){\\n           if(address.charAt(i)==\\'.\\'){\\n               sb.append(\"[\");\\n               sb.append(\".\");\\n               sb.append(\"]\");\\n           }\\n           else{\\n               sb.append(address.charAt(i));\\n           }\\n       } \\n       String str = sb.toString();\\n       return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3623258,
                "title": "java-very-easy-solution-with-100-beats-0ms-runtime-memory-40-6mb-t-n-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342662,
                "title": "easy-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\', \\'[.]\\')\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\', \\'[.]\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339179,
                "title": "defangipaddr-function-is-simple",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach used in the defangIPaddr function is simple. It loops through the input string character by character and checks if the character is a period .. If it is, it adds [.] to the defanged_address string. Otherwise, it adds the character as it is to the defanged_address string.\\n\\n# Complexity\\n\\nThe time complexity of this code is O(n), where n is the length of the input string. This is because the code loops through the input string character by character, and each character is examined only once.\\n\\nThe space complexity of this code is also O(n), where n is the length of the input string. This is because a new string defanged_address is created to hold the defanged IP address, and its size can be as large as the input string if every character in the input string is a period.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string defanged_address;\\n\\n        for (size_t i = 0; i < address.size(); i++) {\\n            if (address[i] == \\'.\\') {\\n                defanged_address += \"[.]\";\\n            } else {\\n                defanged_address += address[i];\\n        }\\n    }\\n\\n    return defanged_address;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string defanged_address;\\n\\n        for (size_t i = 0; i < address.size(); i++) {\\n            if (address[i] == \\'.\\') {\\n                defanged_address += \"[.]\";\\n            } else {\\n                defanged_address += address[i];\\n        }\\n    }\\n\\n    return defanged_address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181930,
                "title": "faster-than-100-with-explanation-easy",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Declare a StringBuider class or you can just create another String to modify the value\\n2. If you find **\\' . \\'** in the String then append the String by **\"[.]\"** and increase the index.\\n3. Else add other characters as it is in the String.\\n4. then return the ans in the String by using sb.**toString()** method\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<address.length();i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                sb.append(\"[.]\");\\n                i++;\\n            }\\n            sb.append(address.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<address.length();i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                sb.append(\"[.]\");\\n                i++;\\n            }\\n            sb.append(address.charAt(i));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181192,
                "title": "100-beat-0ms-run-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string s) {\\n        queue<char> s1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'.\\'){\\n                s1.push(\\'[\\');\\n                s1.push(s[i]);\\n                s1.push(\\']\\');\\n            }else{\\n                s1.push(s[i]);\\n            }\\n        }\\n        string st;\\n        while(!s1.empty()){\\n            st+=s1.front();\\n            s1.pop();\\n        }\\n        return st;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string s) {\\n        queue<char> s1;\\n        for(int i=0;i<s.size();i++){\\n            if(s[i]==\\'.\\'){\\n                s1.push(\\'[\\');\\n                s1.push(s[i]);\\n                s1.push(\\']\\');\\n            }else{\\n                s1.push(s[i]);\\n            }\\n        }\\n        string st;\\n        while(!s1.empty()){\\n            st+=s1.front();\\n            s1.pop();\\n        }\\n        return st;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181191,
                "title": "100-beat",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str;\\n        for(int i=0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                str+=\\'[\\';\\n                str+=\\'.\\';\\n                str+=\\']\\';\\n            }\\n            else\\n            str+=address[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str;\\n        for(int i=0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                str+=\\'[\\';\\n                str+=\\'.\\';\\n                str+=\\']\\';\\n            }\\n            else\\n            str+=address[i];\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181177,
                "title": "100-beat-best-and-easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string s) {\\n             queue<int>q;\\n             string p;\\n        for (int i=0;i<s.size();i++){\\n              q.push(s[i]); \\n        } \\n            while(!q.empty()){\\n                if (q.front()==\\'.\\'){\\n                  p+=\\'[\\';\\n                  p+=\\'.\\';\\n                  p+=\\']\\';\\n                }\\n                else {\\n                    p+=q.front();\\n                }\\n                q.pop();\\n            }\\n        return p; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string s) {\\n             queue<int>q;\\n             string p;\\n        for (int i=0;i<s.size();i++){\\n              q.push(s[i]); \\n        } \\n            while(!q.empty()){\\n                if (q.front()==\\'.\\'){\\n                  p+=\\'[\\';\\n                  p+=\\'.\\';\\n                  p+=\\']\\';\\n                }\\n                else {\\n                    p+=q.front();\\n                }\\n                q.pop();\\n            }\\n        return p; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3127169,
                "title": "java-solution-fast-0-ms-100-simple-and-optimal",
                "content": "\\n1 method\\nRuntime : 0ms [100%]\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for(char x:address.toCharArray()){\\n            if(x==\\'.\\')str.append(\"[.]\");\\n            else str.append(x);\\n        }\\n        return str.toString();\\n    }\\n}\\n-----------------------------------------------------------------\\n```\\n2 method \\n\\nRuntime : 2ms [29.51%]\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replaceAll(\"\\\\\\\\.\",\"[.]\");\\n    }\\n}\\n\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder str = new StringBuilder();\\n        for(char x:address.toCharArray()){\\n            if(x==\\'.\\')str.append(\"[.]\");\\n            else str.append(x);\\n        }\\n        return str.toString();\\n    }\\n}\\n-----------------------------------------------------------------\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862446,
                "title": "java-clean-char-array-solution-two-pointers-0-ms",
                "content": "# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        char[] charArray = new char[address.length() + (2 * 3)];\\n        for (int i = 0, y = 0; i < address.length(); i++, y++) {\\n            char current = address.charAt(i);\\n            if (current == \\'.\\') {\\n                charArray[y++] = \\'[\\';\\n                charArray[y++] = current;\\n                charArray[y] = \\']\\';\\n            } else {\\n                charArray[y] = current;\\n            }\\n        }\\n        return String.valueOf(charArray);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        char[] charArray = new char[address.length() + (2 * 3)];\\n        for (int i = 0, y = 0; i < address.length(); i++, y++) {\\n            char current = address.charAt(i);\\n            if (current == \\'.\\') {\\n                charArray[y++] = \\'[\\';\\n                charArray[y++] = current;\\n                charArray[y] = \\']\\';\\n            } else {\\n                charArray[y] = current;\\n            }\\n        }\\n        return String.valueOf(charArray);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2796827,
                "title": "java-2-solutions-easy",
                "content": "### **Please Upvote** :D\\n##### 1. Using in-built **`replace()`** method:\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n\\n// TC: O(n)\\n```\\n##### 2. Using StringBuilder:\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : address.toCharArray()) {\\n            if (c != \\'.\\') sb.append(c);\\n            else sb.append(\"[.]\");\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n\\n// TC: O(n)\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (char c : address.toCharArray()) {\\n            if (c != \\'.\\') sb.append(c);\\n            else sb.append(\"[.]\");\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n\\n// TC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561329,
                "title": "one-line-solution",
                "content": "```\\nvar defangIPaddr = function (address) {\\n  return address.split(\".\").join(\"[.]\");\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar defangIPaddr = function (address) {\\n  return address.split(\".\").join(\"[.]\");\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2441556,
                "title": "python-90-faster-and-low-memory-usage",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\", \"[.]\")\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\", \"[.]\")\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2415896,
                "title": "c-solution-easy-and-simple",
                "content": "class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\t\\n        string ans=\"\";\\n        for(int i=0; i<address.length(); i++){\\n            if(address[i]==\\'.\\') \\n                ans+=\"[.]\"; \\n            else\\n                ans+=address[i];\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\t\\n        string ans=\"\";\\n        for(int i=0; i<address.length(); i++){\\n            if(address[i]==\\'.\\') \\n                ans+=\"[.]\"; \\n            else\\n                ans+=address[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2389486,
                "title": "c-easiest-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n     string res;\\n        for(int i=0;i<address.length();i++){\\n         if(address[i]==\\'.\\'){\\n             res+=\"[.]\";\\n             \\n         }\\n        else{\\n                res+=address[i];\\n            }\\n     }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n     string res;\\n        for(int i=0;i<address.length();i++){\\n         if(address[i]==\\'.\\'){\\n             res+=\"[.]\";\\n             \\n         }\\n        else{\\n                res+=address[i];\\n            }\\n     }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203114,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions",
                "content": "***If you lke it, Please Upvote***\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str1 = \"[.]\";\\n        int i = 0;\\n        while(address[i] != \\'\\\\0\\') {\\n            if(address[i] == \\'.\\') {\\n                address.replace(i,1,str1);\\n                i++; //Incrementing for \\'.\\' presenting in \\'[.]\\' otherwise output will look like 255[[[[[[[.]]]]]]]100[[[[[[.]]]]]50[[[[[.]]]]]0\\n            }\\n            i++; //Incrementing for getting out of while loop\\n        }\\n        return address;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string str1 = \"[.]\";\\n        int i = 0;\\n        while(address[i] != \\'\\\\0\\') {\\n            if(address[i] == \\'.\\') {\\n                address.replace(i,1,str1);\\n                i++; //Incrementing for \\'.\\' presenting in \\'[.]\\' otherwise output will look like 255[[[[[[[.]]]]]]]100[[[[[[.]]]]]50[[[[[.]]]]]0\\n            }\\n            i++; //Incrementing for getting out of while loop\\n        }\\n        return address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076384,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string st;\\n        for(auto ch: address){\\n            if(ch==\\'.\\'){\\n                st=st+\"[.]\";\\n            }\\n            else{\\n                st=st+ch;}\\n        }\\n        return st;       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string st;\\n        for(auto ch: address){\\n            if(ch==\\'.\\'){\\n                st=st+\"[.]\";\\n            }\\n            else{\\n                st=st+ch;}\\n        }\\n        return st;       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697285,
                "title": "python-code-defanging-an-ip-address",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        address=address.replace(\".\",\"[.]\")\\n        return address\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        address=address.replace(\".\",\"[.]\")\\n        return address\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507988,
                "title": "simple-to-understand-3-different-ways-using-basic-loops-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n**1. Using Split & Join**\\n\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        var segments = address.Split(\".\");\\n        return string.Join(\"[.]\", segments);\\n    }\\n}\\n```\\n\\n**2. Using Basic Loop**\\n\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        // Create new result\\n        var result = new StringBuilder();   \\n\\t\\t\\n        foreach (var ch in address) {\\n            if (ch == \\'.\\') {\\n                result.Append(\"[.]\");\\n            } else {\\n                result.Append(ch);\\n            }\\n        }        \\n        return result.ToString();\\n    }\\n}\\n```\\n\\n**3. Reconstruct New Result By Segments**\\n\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        var segments = new List<string>();\\n        \\n        // Get the segments in the ip address\\n        var word = new StringBuilder();\\n        foreach (var ch in address) {\\n            if (ch != \\'.\\') {\\n                word.Append(ch);\\n            } else if (word.Length > 0) {\\n                segments.Add(word.ToString());\\n                word.Clear();\\n            }\\n        }\\n        \\n        // Add in any remaining data\\n        if (word.Length > 0) {\\n            segments.Add(word.ToString());\\n        }\\n        \\n        // Build the result \\n        var result = new StringBuilder();\\n        foreach (var item in segments) {\\n            if (result.Length > 0) {\\n                result.Append(\"[.]\");\\n            }\\n            result.Append(item);\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        var segments = address.Split(\".\");\\n        return string.Join(\"[.]\", segments);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        // Create new result\\n        var result = new StringBuilder();   \\n\\t\\t\\n        foreach (var ch in address) {\\n            if (ch == \\'.\\') {\\n                result.Append(\"[.]\");\\n            } else {\\n                result.Append(ch);\\n            }\\n        }        \\n        return result.ToString();\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) {\\n        var segments = new List<string>();\\n        \\n        // Get the segments in the ip address\\n        var word = new StringBuilder();\\n        foreach (var ch in address) {\\n            if (ch != \\'.\\') {\\n                word.Append(ch);\\n            } else if (word.Length > 0) {\\n                segments.Add(word.ToString());\\n                word.Clear();\\n            }\\n        }\\n        \\n        // Add in any remaining data\\n        if (word.Length > 0) {\\n            segments.Add(word.ToString());\\n        }\\n        \\n        // Build the result \\n        var result = new StringBuilder();\\n        foreach (var item in segments) {\\n            if (result.Length > 0) {\\n                result.Append(\"[.]\");\\n            }\\n            result.Append(item);\\n        }\\n        \\n        return result.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1475717,
                "title": "c-simple-solution-beginner-friendly",
                "content": "```\\nstring defangIPaddr(string address) \\n    {\\n        string answer;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                answer=answer+\"[.]\";\\n            }\\n            else \\n                answer=answer+address[i];\\n        }\\n        return answer;\\n    }\\n```\\n**Please Upvote if it helped you !!!\\nHappu Coding :)**",
                "solutionTags": [],
                "code": "```\\nstring defangIPaddr(string address) \\n    {\\n        string answer;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                answer=answer+\"[.]\";\\n            }\\n            else \\n                answer=answer+address[i];\\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1446464,
                "title": "python-solutions",
                "content": "Method-1\\n```\\ndef defangingIPAddress(ipAddress):\\n    to_replace = \\'.\\'\\n    replaced = \\'[.]\\'\\n    new_string = \\'\\'\\n    for elem in ipAddress:\\n        if elem == to_replace:\\n            new_string += replaced\\n        else:\\n            new_string += elem\\n    return new_string\\n```\\n\\nMethod-2\\n```\\ndef defangingIPAddress(ipAddress):\\n    return ipAddress.replace(\\'.\\', \\'[.]\\')\\n```\\nMethod-3\\n```\\ndef defangingIPAddress(ipAddress):\\n    return \\'[.]\\'.join(ipAddress.split(\\'.\\'))\\n```\\n",
                "solutionTags": [],
                "code": "```\\ndef defangingIPAddress(ipAddress):\\n    to_replace = \\'.\\'\\n    replaced = \\'[.]\\'\\n    new_string = \\'\\'\\n    for elem in ipAddress:\\n        if elem == to_replace:\\n            new_string += replaced\\n        else:\\n            new_string += elem\\n    return new_string\\n```\n```\\ndef defangingIPAddress(ipAddress):\\n    return ipAddress.replace(\\'.\\', \\'[.]\\')\\n```\n```\\ndef defangingIPAddress(ipAddress):\\n    return \\'[.]\\'.join(ipAddress.split(\\'.\\'))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1408967,
                "title": "java-100-faster-and-93-48-less-memory-usage",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n    StringBuilder sb = new StringBuilder();\\n    \\n    for(char a : address.toCharArray()){\\n        if(a == \\'.\\') sb.append(\"[.]\");\\n        else sb.append(a);\\n    }\\n    \\n    return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n    StringBuilder sb = new StringBuilder();\\n    \\n    for(char a : address.toCharArray()){\\n        if(a == \\'.\\') sb.append(\"[.]\");\\n        else sb.append(a);\\n    }\\n    \\n    return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1395843,
                "title": "very-very-simple-c-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        int n=address.length();\\n        string s=\"\";\\n        for(int i=0;i<n;i++){\\n            if(address[i]==\\'.\\'){\\n                s.push_back(\\'[\\');\\n                s.push_back(address[i]);\\n                s.push_back(\\']\\');\\n            }else{\\n                s.push_back(address[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        int n=address.length();\\n        string s=\"\";\\n        for(int i=0;i<n;i++){\\n            if(address[i]==\\'.\\'){\\n                s.push_back(\\'[\\');\\n                s.push_back(address[i]);\\n                s.push_back(\\']\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1265106,
                "title": "simple-java-solution-0ms-approach-100-faster",
                "content": "0ms Approach -\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");   //replacing all the occurences of  \".\"  with \"[.]\" and returning it\\n    }\\n}\\n```\\n\\nAnother approach(9ms Runtime)\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        String str = \"\";\\n        for(int i=0; i<address.length(); i++) {\\n\\t\\t//Replacing single occurence at a time and adding it to str\\n            if(address.charAt(i)==\\'.\\') {\\n                str = str + \"[.]\";\\n            }\\n            else {\\n                str = str + address.charAt(i);\\n            }\\n        }\\n        return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");   //replacing all the occurences of  \".\"  with \"[.]\" and returning it\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        String str = \"\";\\n        for(int i=0; i<address.length(); i++) {\\n\\t\\t//Replacing single occurence at a time and adding it to str\\n            if(address.charAt(i)==\\'.\\') {\\n                str = str + \"[.]\";\\n            }\\n            else {\\n                str = str + address.charAt(i);\\n            }\\n        }\\n        return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1258669,
                "title": "runtime-0-ms-faster-than-100-00-of-java-1-liner-solution",
                "content": "We have a predefined function replace in java which is used to find and replace all the occurrences. \\nwant to know more - visit https://www.javatpoint.com/java-string-replace\\n\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        String s = address.replace(\".\",\"[.]\");\\n        return s;\\n    }\\n}\\n```\\n\\n**Upvote** if it is helpfull.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        String s = address.replace(\".\",\"[.]\");\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1179242,
                "title": "cutest-solution-ever",
                "content": "**C++**\\n```\\nstring ans = \"\";\\nfor (char c: s)\\n\\tif (c == \\'.\\') ans += \"[.]\";\\n\\telse ans += c;\\nreturn ans;\\n```\\n**Java**\\n```\\nStringBuilder sb = new StringBuilder();\\nfor (int i = 0; i < s.length(); ++i)\\n\\tif (s.charAt(i) == \\'.\\') sb.append(\"[.]\");\\n\\telse sb.append(s.charAt(i));\\nreturn sb.toString();\\n```\\n**If you liked it, even a little bit then pls consider giving this solution a Upvote\\nThank You :)**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nstring ans = \"\";\\nfor (char c: s)\\n\\tif (c == \\'.\\') ans += \"[.]\";\\n\\telse ans += c;\\nreturn ans;\\n```\n```\\nStringBuilder sb = new StringBuilder();\\nfor (int i = 0; i < s.length(); ++i)\\n\\tif (s.charAt(i) == \\'.\\') sb.append(\"[.]\");\\n\\telse sb.append(s.charAt(i));\\nreturn sb.toString();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1167692,
                "title": "runtime-0-ms-faster-than-100-00",
                "content": "Memory Usage: 36.7 MB, less than 94.48%\\n\\nclass Solution {\\n    public String defangIPaddr(String address){\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String defangIPaddr(String address){\\n        return address.replace(\".\",\"[.]\");\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1137132,
                "title": "c-lambda-replace-runtime-80-ms-faster-than-85-84",
                "content": "```\\n public string DefangIPaddr( string address ) \\n        => address.Replace( \".\" ,  \"[.]\" );\\n```",
                "solutionTags": [],
                "code": "```\\n public string DefangIPaddr( string address ) \\n        => address.Replace( \".\" ,  \"[.]\" );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1125365,
                "title": "python-3-one-liner",
                "content": "```\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\" , \"[.]\")\\n```",
                "solutionTags": [],
                "code": "```\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\" , \"[.]\")\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1116190,
                "title": "c-runtime-0ms-faster-than-100-submissions",
                "content": "```\\nchar * defangIPaddr(char * address){\\n    char *result;\\n    //Max size 22: 12 IP digits + 3 . + 6 braces + 1 null terminator\\n    result = (char*)malloc(22*sizeof(char));\\n    int i = 0, j = 0;\\n    for(i = 0; address[i] != \\'\\\\0\\'; i++){\\n        if (address[i] == \\'.\\') {\\n            result[j] = \\'[\\';\\n            result[j+1] = \\'.\\';\\n            result[j+2] = \\']\\';\\n            j = j+ 3;\\n        } else{\\n            result[j++] = address[i];\\n        }\\n    }\\n\\n    result[j] = \\'\\\\0\\';\\n    return result;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * defangIPaddr(char * address){\\n    char *result;\\n    //Max size 22: 12 IP digits + 3 . + 6 braces + 1 null terminator\\n    result = (char*)malloc(22*sizeof(char));\\n    int i = 0, j = 0;\\n    for(i = 0; address[i] != \\'\\\\0\\'; i++){\\n        if (address[i] == \\'.\\') {\\n            result[j] = \\'[\\';\\n            result[j+1] = \\'.\\';\\n            result[j+2] = \\']\\';\\n            j = j+ 3;\\n        } else{\\n            result[j++] = address[i];\\n        }\\n    }\\n\\n    result[j] = \\'\\\\0\\';\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1045209,
                "title": "javascript-oneliner-replace-with-regex-solution",
                "content": "```\\nconst defangIPaddr = address => address.replace(/\\\\./g, \\'[.]\\')\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst defangIPaddr = address => address.replace(/\\\\./g, \\'[.]\\')\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1026311,
                "title": "one-line-in-java",
                "content": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941201,
                "title": "python-simple-solution",
                "content": "#### Solution 1: Using replace\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\',\\'[.]\\')\\n```\\n\\n#### Solution 2: Using join and split\\n\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\\'.\\',\\'[.]\\')\\n```\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return \\'[.]\\'.join(address.split(\\'.\\'))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 930244,
                "title": "fastest-than-100-0-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        // string s;\\n        vector<int> v;\\n       for(auto x:address)\\n       {\\n           if(x==\\'.\\'){v.push_back(\\'[\\');}\\n           v.push_back(x);\\n           if(x==\\'.\\'){v.push_back(\\']\\');}\\n       }\\n        string s={v.begin() , v.end()};\\n        return s;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        // string s;\\n        vector<int> v;\\n       for(auto x:address)\\n       {\\n           if(x==\\'.\\'){v.push_back(\\'[\\');}\\n           v.push_back(x);\\n           if(x==\\'.\\'){v.push_back(\\']\\');}\\n       }\\n        string s={v.begin() , v.end()};\\n        return s;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 817488,
                "title": "swift-1-liner-readable-solution",
                "content": "Just use the standard swift library replacingOcurrences. No need do complex & unreadable stuff.\\n\\n```\\nfunc defangIPaddr(_ address: String) -> String {\\n\\treturn address.replacingOccurrences(of: \".\", with: \"[.]\")\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfunc defangIPaddr(_ address: String) -> String {\\n\\treturn address.replacingOccurrences(of: \".\", with: \"[.]\")\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 760391,
                "title": "2-line-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        regex re(\"\\\\\\\\.\"); \\n        return regex_replace(address, re, \"[.]\");                \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        regex re(\"\\\\\\\\.\"); \\n        return regex_replace(address, re, \"[.]\");                \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 724309,
                "title": "one-line-java-code-so-easy-i-don-t-know-why-people-making-it-so-compicated",
                "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 666213,
                "title": "java-1-line-of-code-29-100",
                "content": "```\\npublic String defangIPaddr(String address) {\\n    return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic String defangIPaddr(String address) {\\n    return address.replaceAll(\"\\\\\\\\.\", \"[.]\");\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 629453,
                "title": "short-and-sweet-c-solution",
                "content": "\\tstring defangIPaddr(string address)\\n\\t{\\n\\t\\tstring result;\\n\\n\\t\\tfor (size_t i = 0; i < address.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (address[i] == \\'.\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.append(\"[.]\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.append(1, address[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "\\tstring defangIPaddr(string address)\\n\\t{\\n\\t\\tstring result;\\n\\n\\t\\tfor (size_t i = 0; i < address.length(); i++)\\n\\t\\t{\\n\\t\\t\\tif (address[i] == \\'.\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.append(\"[.]\");\\n\\t\\t\\t}\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult.append(1, address[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn result;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 562378,
                "title": "java-one-liner",
                "content": "```\\nreturn address.replaceAll(\"\\\\\\\\.\", \"[.]\")\\n```",
                "solutionTags": [],
                "code": "```\\nreturn address.replaceAll(\"\\\\\\\\.\", \"[.]\")\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 560937,
                "title": "python-one-liner",
                "content": "this was easy with python\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n",
                "solutionTags": [],
                "code": "this was easy with python\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        return address.replace(\".\",\"[.]\")\\n",
                "codeTag": "Java"
            },
            {
                "id": 555145,
                "title": "c-100-time-and-100-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string a;\\n        int x = address.length();\\n        for(int i =0;i<x;i++){\\n            if(address[i] == \\'.\\'){\\n                a.push_back(\\'[\\');\\n                a.push_back(\\'.\\');\\n                a.push_back(\\']\\');\\n                \\n            }\\n            else{\\n                a.push_back(address[i]);\\n            }\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string a;\\n        int x = address.length();\\n        for(int i =0;i<x;i++){\\n            if(address[i] == \\'.\\'){\\n                a.push_back(\\'[\\');\\n                a.push_back(\\'.\\');\\n                a.push_back(\\']\\');\\n                \\n            }\\n            else{\\n                a.push_back(address[i]);\\n            }\\n        }\\n        return a;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 465595,
                "title": "100-00-faster-in-runtime-and-memory",
                "content": "Runtime: **0 ms**, faster than 1**00.00%** of C++ online submissions for Defanging an IP Address.\\nMemory Usage: **8.1** MB, less than **100.00%** of C++ online submissions for Defanging an IP Address.\\n\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string defangIP(\"\");\\n        for(char c: address)\\n            (c==\\'.\\')? defangIP+=\"[.]\":defangIP+=c;\\n        return defangIP;\\n    }\\n};\\n```\\n\\n-----\\nRuntime: **0 ms**, faster than **100.00%** of C++ online submissions for Defanging an IP Address.\\nMemory Usage: **8 MB**, less than **100.00%** of C++ online submissions for Defanging an IP Address.\\n```\\nclass Solution { // isdigit(char) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        string defangIP(\"\");\\n        for(char c: address){\\n            if(isdigit(c)) defangIP+=c;\\n            else defangIP+=\"[.]\";\\n        }\\n        return defangIP;\\n    }\\n};\\n```\\n\\n----\\nRuntime: **4 ms**, faster than **54.08%** of C++ online submissions for Defanging an IP Address.\\nMemory Usage: **8 MB**, less than **100.00%** of C++ online submissions for Defanging an IP Address.\\n```\\nclass Solution { // using substr(pos,length) and substr(pos) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i(address.length()-1);i>=0;i--){\\n            if(address[i]==\\'.\\')\\n                address = address.substr(0,i) + \"[.]\" + address.substr(i+1);\\n        }\\n        return address;\\n    }\\n};\\n```\\nWe start looking from the second to last position because we know the last character in address will never be \\'.\\'\\nWe look backward through the string because we don\\'t want to mess up our indices when we start inserting the brackets.\\n\\n----\\nRuntime: **4 ms**, faster than **54.08%** of C++ online submissions for Defanging an IP Address.\\nMemory Usage: 8.1 MB, less than **100.00%** of C++ online submissions for Defanging an IP Address.\\n```\\nclass Solution { // using replace(pos,length,withStr) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i(address.length()-1);i>=0;i--){\\n            if(address[i]==\\'.\\')\\n                address = address.replace(i,1,\"[.]\");\\n        }\\n        return address;\\n    }\\n};\\n```\\n\\n----\\nRuntime: **12 ms**, faster than **54.08%** of C++ online submissions for Defanging an IP Address. **O(n^2)**\\nMemory Usage: **11.5 MB**, less than **100.00%** of C++ online submissions for Defanging an IP Address. \\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address,regex(\"[.]\"),\"[.]\");\\n    }\\n};\\n```\\n\\n---- \\nExtra\\n\\n----\\n\\n```\\nchar * defangIPaddr(char * address){\\n    char *re = malloc(24);\\n    char *out = re;\\n    while (*address) {\\n        if (*address == \\'.\\') {\\n            *out++ = \\'[\\';\\n            *out++ = \\'.\\';\\n            *out++ = \\']\\';\\n            *address++;\\n        } else {\\n            *out++ = *address++;\\n        }\\n    }\\n    *out = \\'\\\\0\\';\\n    return re;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string defangIP(\"\");\\n        for(char c: address)\\n            (c==\\'.\\')? defangIP+=\"[.]\":defangIP+=c;\\n        return defangIP;\\n    }\\n};\\n```\n```\\nclass Solution { // isdigit(char) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        string defangIP(\"\");\\n        for(char c: address){\\n            if(isdigit(c)) defangIP+=c;\\n            else defangIP+=\"[.]\";\\n        }\\n        return defangIP;\\n    }\\n};\\n```\n```\\nclass Solution { // using substr(pos,length) and substr(pos) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i(address.length()-1);i>=0;i--){\\n            if(address[i]==\\'.\\')\\n                address = address.substr(0,i) + \"[.]\" + address.substr(i+1);\\n        }\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution { // using replace(pos,length,withStr) stl\\npublic:\\n    string defangIPaddr(string address) {\\n        for(int i(address.length()-1);i>=0;i--){\\n            if(address[i]==\\'.\\')\\n                address = address.replace(i,1,\"[.]\");\\n        }\\n        return address;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        return regex_replace(address,regex(\"[.]\"),\"[.]\");\\n    }\\n};\\n```\n```\\nchar * defangIPaddr(char * address){\\n    char *re = malloc(24);\\n    char *out = re;\\n    while (*address) {\\n        if (*address == \\'.\\') {\\n            *out++ = \\'[\\';\\n            *out++ = \\'.\\';\\n            *out++ = \\']\\';\\n            *address++;\\n        } else {\\n            *out++ = *address++;\\n        }\\n    }\\n    *out = \\'\\\\0\\';\\n    return re;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 461799,
                "title": "go",
                "content": "```golang\\nimport \"strings\"\\nfunc defangIPaddr(address string) string {\\n    return strings.Replace(address,\".\",\"[.]\",-1)\\n}\\n```",
                "solutionTags": [],
                "code": "```golang\\nimport \"strings\"\\nfunc defangIPaddr(address string) string {\\n    return strings.Replace(address,\".\",\"[.]\",-1)\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444826,
                "title": "javascript-one-liner-less-memory-than-100-of-other-solutions",
                "content": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\')\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar defangIPaddr = function(address) {\\n    return address.split(\\'.\\').join(\\'[.]\\')\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389729,
                "title": "ruby-code-20ms-faster-than-99-77",
                "content": "**Runtime:** 20 ms, faster than 99.77% of Ruby submissions.\\n**Memory Usage:** 9.2 MB, less than 100.00% of Ruby submissions.\\n\\n```ruby\\ndef defang_i_paddr(address)\\n  address.split(\\'.\\').join(\\'[.]\\')\\nend\\n```\\n\\n[Why `split` & `join` is faster than `gsub` (stackoverflow)](https://stackoverflow.com/a/29956753/9440171)\\n",
                "solutionTags": [],
                "code": "```ruby\\ndef defang_i_paddr(address)\\n  address.split(\\'.\\').join(\\'[.]\\')\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 385850,
                "title": "simplest-of-c-0ms",
                "content": "```\\nchar * defangIPaddr(char * addr){\\n\\n    char* ret = malloc(22);\\n    int f[4];\\n\\t\\n    sscanf(addr, \"%d.%d.%d.%d\", &f[0], &f[1], &f[2], &f[3]);\\n    sprintf(ret, \"%d[.]%d[.]%d[.]%d\", f[0], f[1], f[2], f[3]);\\n    \\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar * defangIPaddr(char * addr){\\n\\n    char* ret = malloc(22);\\n    int f[4];\\n\\t\\n    sscanf(addr, \"%d.%d.%d.%d\", &f[0], &f[1], &f[2], &f[3]);\\n    sprintf(ret, \"%d[.]%d[.]%d[.]%d\", f[0], f[1], f[2], f[3]);\\n    \\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 359714,
                "title": "python3-regex-solution",
                "content": "```import re\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        newadr = re.sub(\"\\\\.\",\"[.]\",address)\\n        return newadr\\n\\t\\n100% memory,99.8% speed,20ms",
                "solutionTags": [
                    "Python"
                ],
                "code": "```import re\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        newadr = re.sub(\"\\\\.\",\"[.]\",address)\\n        return newadr\\n\\t\\n100% memory,99.8% speed,20ms",
                "codeTag": "Java"
            },
            {
                "id": 342412,
                "title": "javascript",
                "content": "```\\nvar defangIPaddr = function(address) {\\n  let str = \\'\\'\\n  \\n  for (let i in address){\\n      address[i] !== \\'.\\' ? str += address[i] : str += \\'[.]\\'\\n  }\\n  return str\\n  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar defangIPaddr = function(address) {\\n  let str = \\'\\'\\n  \\n  for (let i in address){\\n      address[i] !== \\'.\\' ? str += address[i] : str += \\'[.]\\'\\n  }\\n  return str\\n  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 330471,
                "title": "javascript-one-liner",
                "content": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    return address.replace(/[.]/g, \\'[.]\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n    return address.replace(/[.]/g, \\'[.]\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329803,
                "title": "100-very-very-easy-to-understand-python-code",
                "content": "class Solution(object):\\n    def defangIPaddr(self, address):\\n        \"\"\"\\n        :type address: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        a = list(address)\\n        for i in range(len(a)):\\n            if a[i] == \\'.\\':\\n                a[i] = \\'[.]\\'\\n                \\n        S = \"\".join(a)\\n        \\n        \\n            \\n        return S",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def defangIPaddr(self, address):\\n        \"\"\"\\n        :type address: str\\n        :rtype: str\\n        \"\"\"\\n        \\n        a = list(address)\\n        for i in range(len(a)):\\n            if a[i] == \\'.\\':\\n                a[i] = \\'[.]\\'\\n                \\n        S = \"\".join(a)\\n        \\n        \\n            \\n        return S",
                "codeTag": "Java"
            },
            {
                "id": 4008980,
                "title": "easy-efficient-code-for-beginners-using-stringbuilder",
                "content": "# Intuition\\nFirst thought was to create a new variable and store the values while simultaneousely checking for the dots(\\'.\\'). Using a regular string will waste a lot of memory hence used StringBuilder\\n\\n# Approach\\nVery Simple and beats 100%\\nkeep adding characters of string address into a StringBuilder variable build until you find a dot. if character is dot then add [.] into build.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder build=new StringBuilder();\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address.charAt(i)==\\'.\\')\\n            {\\n                build.append(\"[.]\");\\n                continue;\\n            }\\n            build.append(address.charAt(i));\\n        }\\n        return build.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder build=new StringBuilder();\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address.charAt(i)==\\'.\\')\\n            {\\n                build.append(\"[.]\");\\n                continue;\\n            }\\n            build.append(address.charAt(i));\\n        }\\n        return build.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979906,
                "title": "waste-of-time-but-still",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n*String has replace method which takes two parameters String.replace(\"old one\",\"new one\");\\n1st one is what to replace \\n2nd one for what to replace instead.*\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908104,
                "title": "100-easy-and-optimised-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb=new StringBuilder();\\n       for(int i=0;i<address.length();i++){\\n           if(address.charAt(i)==\\'.\\'){\\n               sb.append(\"[\");\\n               sb.append(\".\");\\n               sb.append(\"]\");\\n           }\\n           else{\\n               sb.append(address.charAt(i));\\n           }\\n       }\\n       String str=sb.toString(); \\n       return str;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb=new StringBuilder();\\n       for(int i=0;i<address.length();i++){\\n           if(address.charAt(i)==\\'.\\'){\\n               sb.append(\"[\");\\n               sb.append(\".\");\\n               sb.append(\"]\");\\n           }\\n           else{\\n               sb.append(address.charAt(i));\\n           }\\n       }\\n       String str=sb.toString(); \\n       return str;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3890213,
                "title": "c-easy-one-line-solution-with-explanation",
                "content": "\\n# Approach\\n\\nI used ```string.Split(\".\")``` method to get input string seperated by dots. So, that method returns an array of strings. Then I used ```string.Join(\"[.]\")``` to convert that array into one string while adding \"[.]\" between and returned via lambda expression. \\n\\n# Code\\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) => string.Join(\"[.]\", address.Split(\".\"));\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```string.Split(\".\")```\n```string.Join(\"[.]\")```\n```\\npublic class Solution {\\n    public string DefangIPaddr(string address) => string.Join(\"[.]\", address.Split(\".\"));\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864195,
                "title": "beats-100-java-one-line-solution-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3687192,
                "title": "easy-solution-c",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInside the defangIPaddr function, we iterate through each character c in the input address. If c is a period (\\'.\\'), we append \"[.]\" to the defangedAddress string. Otherwise, we simply append c to defangedAddress.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address)\\n   {\\n       string defang;\\n       \\n       for(char c:address)\\n       {\\n           if(c==\\'.\\')\\n           {\\n               defang.push_back(\\'[\\');\\n               defang.push_back(\\'.\\');\\n               defang.push_back(\\']\\');\\n           }\\n           else\\n           {\\n               defang.push_back(c);\\n           }\\n       }\\n       return defang;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address)\\n   {\\n       string defang;\\n       \\n       for(char c:address)\\n       {\\n           if(c==\\'.\\')\\n           {\\n               defang.push_back(\\'[\\');\\n               defang.push_back(\\'.\\');\\n               defang.push_back(\\']\\');\\n           }\\n           else\\n           {\\n               defang.push_back(c);\\n           }\\n       }\\n       return defang;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566642,
                "title": "beginners-friendly",
                "content": "\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder t= new StringBuilder(address);\\n        StringBuilder s= new StringBuilder();\\n        for(int i=0;i<address.length();i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s.append(\"[.]\");\\n            }else s.append(address.charAt(i));\\n\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder t= new StringBuilder(address);\\n        StringBuilder s= new StringBuilder();\\n        for(int i=0;i<address.length();i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s.append(\"[.]\");\\n            }else s.append(address.charAt(i));\\n\\n        }\\n        return s.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3541617,
                "title": "defanging-an-ip-address-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        int i=0;\\n        string defanged_ip_address;\\n        for(i=0 ; i<address.length() ; i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                defanged_ip_address += \"[.]\";\\n            }\\n            else\\n            {\\n                defanged_ip_address += address[i];\\n            }\\n        }\\n        return defanged_ip_address;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1db8f363-7ff2-4424-8ed0-adefc3973c07_1684498679.514323.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        int i=0;\\n        string defanged_ip_address;\\n        for(i=0 ; i<address.length() ; i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                defanged_ip_address += \"[.]\";\\n            }\\n            else\\n            {\\n                defanged_ip_address += address[i];\\n            }\\n        }\\n        return defanged_ip_address;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3493485,
                "title": "one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nvar defangIPaddr = function(address) {\\n \\n return address.replaceAll(\\'.\\', \\'[.]\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nvar defangIPaddr = function(address) {\\n \\n return address.replaceAll(\\'.\\', \\'[.]\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3399758,
                "title": "simple-go-solution-using-buffer",
                "content": "\\n# Code\\n```\\nfunc defangIPaddr(address string) string {\\n\\tvar b bytes.Buffer\\n\\tfor _, c := range address {\\n\\t\\tif c == \\'.\\' {\\n\\t\\t\\tb.WriteString(\"[.]\")\\n\\t\\t} else {\\n\\t\\t\\tb.WriteRune(c)\\n\\t\\t}\\n\\t}\\n\\treturn b.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc defangIPaddr(address string) string {\\n\\tvar b bytes.Buffer\\n\\tfor _, c := range address {\\n\\t\\tif c == \\'.\\' {\\n\\t\\t\\tb.WriteString(\"[.]\")\\n\\t\\t} else {\\n\\t\\t\\tb.WriteRune(c)\\n\\t\\t}\\n\\t}\\n\\treturn b.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3358474,
                "title": "c-easy-solution-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string a;\\n\\n        \\n        for(int i =0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                a.push_back(\\'[\\');\\n                a.push_back(\\'.\\');\\n                a.push_back(\\']\\');\\n            }\\n            else{\\n                a.push_back(address[i]);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string a;\\n\\n        \\n        for(int i =0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                a.push_back(\\'[\\');\\n                a.push_back(\\'.\\');\\n                a.push_back(\\']\\');\\n            }\\n            else{\\n                a.push_back(address[i]);\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3284617,
                "title": "1-line-solution-beats-100-runtime-0ms-o-n",
                "content": "\\n\\n# Complexity            \\n\\n\\n- Time complexity:\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3275843,
                "title": "java-super-easy-one-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\",\"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3274516,
                "title": "one-line-code-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        return address.replace(\".\", \"[.]\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3271905,
                "title": "defanging-an-ip-address-c-easy-approach-fast-simple",
                "content": "**PLEASEUPVOTE, IF YOU LIKE\\u2764\\uFE0F\\u2764\\uFE0F**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        string ans;\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                ans=ans+\"[.]\";\\n            }\\n            else\\n                ans=ans+address[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) \\n    {\\n        string ans;\\n        for(int i=0;i<address.length();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                ans=ans+\"[.]\";\\n            }\\n            else\\n                ans=ans+address[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3235317,
                "title": "beat-100-easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                ans.push_back(\\'[\\');\\n               ans.push_back(\\'.\\');\\n               ans.push_back(\\']\\');\\n\\n            }\\n             else\\n        {\\n            ans.push_back(address[i]);\\n        }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans;\\n        for(int i=0;i<address.size();i++)\\n        {\\n            if(address[i]==\\'.\\')\\n            {\\n                ans.push_back(\\'[\\');\\n               ans.push_back(\\'.\\');\\n               ans.push_back(\\']\\');\\n\\n            }\\n             else\\n        {\\n            ans.push_back(address[i]);\\n        }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224266,
                "title": "simple-python-code-with-if-else-statement",
                "content": "# Approach\\nsimple approch\\n\\n# Code\\n```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        s = \\'\\'\\n        for i in address:\\n            if i == \\'.\\': s+=\\'[.]\\'\\n            else: s+=i\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, address: str) -> str:\\n        s = \\'\\'\\n        for i in address:\\n            if i == \\'.\\': s+=\\'[.]\\'\\n            else: s+=i\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3195145,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\n    string ans;\\n    for (int i = 0; i < address.size(); i++)\\n    {\\n        if (address[i] == \\'.\\')\\n        {\\n            ans.push_back(\\'[\\');\\n            ans.push_back(\\'.\\');\\n            ans.push_back(\\']\\');\\n        }\\n        else\\n        {\\n            ans.push_back(address[i]);\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n\\n    string ans;\\n    for (int i = 0; i < address.size(); i++)\\n    {\\n        if (address[i] == \\'.\\')\\n        {\\n            ans.push_back(\\'[\\');\\n            ans.push_back(\\'.\\');\\n            ans.push_back(\\']\\');\\n        }\\n        else\\n        {\\n            ans.push_back(address[i]);\\n        }\\n    }\\n    return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3176670,
                "title": "simple-c-code-easy-beats-100",
                "content": "Runtime : Beats 100%\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string res=\"\";\\n        for(auto i: address){\\n            if(i==\\'.\\'){\\n                res=res+\"[.]\";\\n            }else{\\n                res=res+i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\nHope you liked the implementation of the code, if you like it feel free to upvote \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string res=\"\";\\n        for(auto i: address){\\n            if(i==\\'.\\'){\\n                res=res+\"[.]\";\\n            }else{\\n                res=res+i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3168477,
                "title": "one-line-in-python",
                "content": "```\\nclass Solution:\\n    def defangIPaddr(self, a: str) -> str:\\n        a = a.replace(\\'.\\',\"[.]\")\\n        return a\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def defangIPaddr(self, a: str) -> str:\\n        a = a.replace(\\'.\\',\"[.]\")\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125746,
                "title": "c-easy-solution",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLoop through the address checking for . and if it finds it, it will replace it with [.]\\nthen return that string\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans=\"\";\\n        for(int i=0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                ans=ans+\"[.]\";\\n            }\\n            else{\\n                ans=ans+address[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans=\"\";\\n        for(int i=0;i<address.size();i++){\\n            if(address[i]==\\'.\\'){\\n                ans=ans+\"[.]\";\\n            }\\n            else{\\n                ans=ans+address[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3083538,
                "title": "easiest-solution-c-with-0ms-beats-100-of-solutions",
                "content": "\\n# Approach\\nLoop through the address checking for `.` and if it finds it, it will replace it with `[.]`\\nthen return that string\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string temp {};\\n        for(int i {};i<address.size();i++){ if(address[i]==\\'.\\') temp+=\"[.]\";else temp+=address[i];}\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string temp {};\\n        for(int i {};i<address.size();i++){ if(address[i]==\\'.\\') temp+=\"[.]\";else temp+=address[i];}\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2901064,
                "title": "simple-kotlin-solution-without-replace-function",
                "content": "# Useful links for StringBuilder() \\nhttps://medium.com/@ramazanbullet/what-is-stringbuilder-in-kotlin-729adc76dc31\\n# Code\\n```\\nclass Solution {\\n    fun defangIPaddr(address: String): String {\\n       // Defang the given address\\n    val defanged = StringBuilder()\\n    for (ch in address) {\\n        if (ch == \\'.\\') {\\n            defanged.append(\"[.]\")\\n        } else {\\n            defanged.append(ch)\\n        }\\n    }\\n    return defanged.toString()\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun defangIPaddr(address: String): String {\\n       // Defang the given address\\n    val defanged = StringBuilder()\\n    for (ch in address) {\\n        if (ch == \\'.\\') {\\n            defanged.append(\"[.]\")\\n        } else {\\n            defanged.append(ch)\\n        }\\n    }\\n    return defanged.toString()\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860236,
                "title": "simple-c-solution-easy-to-understand",
                "content": "**Intuition:**\\n\\n---\\nSimple replace \".\" with \"[.]\";\\nand return string as answer.\\n\\n---\\n**Solution:**\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans =\"\";\\n\\n        for(char x:address)\\n        {\\n            if(x ==\\'.\\')\\n               ans = ans + \"[.]\";\\n            else\\n               ans = ans + x; \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n**Analysis:**\\n\\n**Time Complexity:** ```O(n)```  Where n is the length of the string.\\n**Space Complexity:** ```O(n)```\\n\\n---\\nIf this solution Helps you then please ```UPVOTE```.\\nTill then **Keep Learning, Keep Growing !!!!**\\n\\nThank You!!!\\n\\n---",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string defangIPaddr(string address) {\\n        string ans =\"\";\\n\\n        for(char x:address)\\n        {\\n            if(x ==\\'.\\')\\n               ans = ans + \"[.]\";\\n            else\\n               ans = ans + x; \\n        }\\n        return ans;\\n    }\\n};\\n```\n```O(n)```\n```O(n)```\n```UPVOTE```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1756452,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1564950,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1568261,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1572880,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1569852,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573980,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1575150,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1570285,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573552,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1569554,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1756452,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1564950,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1568261,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1572880,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1569852,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573980,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1575150,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1570285,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573552,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1569554,
                "content": [
                    {
                        "username": "TavisTheEngineer",
                        "content": "Can we stop putting solutions in the discussion area. People are looking for tips and hints in this area, not the answer."
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "cavidanbagiri",
                        "content": "l agree with you. "
                    },
                    {
                        "username": "alectr",
                        "content": "var defangIPaddr = function(address) {\\n  return address.split(\\'.\\').join(\\'[.]\\');\\n};"
                    },
                    {
                        "username": "Zaki-1337",
                        "content": "[@riskostorm](/riskostorm) JS has str.replaceAll(\\'.\\' , \\'[.]\\') \\uD83D\\uDE0F"
                    },
                    {
                        "username": "riskofstorm",
                        "content": "str.replace is better, less methods to call if javascript have that in built-ins. idk! Python does!"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "user5278r",
                        "content": "I\\'ve noticed there are a lot of dislikes for this problem, why? It\\'s an easy problem for a beginner, why to dislike it so hard? =)) Lol"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "\\uD83D\\uDC4C Simple C++ Optimal Code 0ms100% fast\\nhttps://leetcode.com/problems/defanging-an-ip-address/solutions/2167964/simple-c-optimal-code-0ms100-fast/"
                    },
                    {
                        "username": "abandonedforlife",
                        "content": "this is not an O(n) solution but a constant time operation and constant space operation.\\n\\na valid IPv4 address is dependent on the number of bits which is 32 (4 bytes).\\nthe input string will never exceed 255.255.255.255 so in the worst case scenario this is the length of the string."
                    },
                    {
                        "username": "rafau112",
                        "content": "return address.replace(\".\", \"[.]\");"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "santoshallu",
                        "content": "\\tpublic String defangIPaddr(String address) {\\n\\treturn address.replace(\".\",\"[.]\");\\n\\t}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "gty246",
                        "content": "`return address.replace(\\'.\\',\\'[.]\\')`"
                    },
                    {
                        "username": "hynmj",
                        "content": "[@sarthak_sachdev](/sarthak_sachdev)  write between the quotation of this character  `"
                    },
                    {
                        "username": "UTSAV_0712",
                        "content": "return address.replace(\\'.\\',\\'[.]\\')\\n--> this syntex does not work. "
                    },
                    {
                        "username": "sarthak_sachdev",
                        "content": "hey how do people write code in this highlighted form on websites unlike other code which get printed as simple text??"
                    },
                    {
                        "username": "encore0722",
                        "content": "const defangIPaddr = (address) =>address.split(\".\").join(\"[.]\")"
                    },
                    {
                        "username": "abdalaa123",
                        "content": "Runtime: 48 ms, faster than 90.34% of JavaScript\\n\\nsolved it less than one minute.\\uD83D\\uDE0E  \\n\\n..................  then  i will try other easy proplem & spend 10hours on it\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "LOL\\n"
                    },
                    {
                        "username": "akared3223",
                        "content": "too slow"
                    },
                    {
                        "username": "Billgates",
                        "content": "return \\'\\'.join(s if s !=\\'.\\' else \\'[.]\\' for s in address)"
                    }
                ]
            },
            {
                "id": 1573313,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1573225,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1572913,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1572827,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1569553,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1575282,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1573145,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1572983,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 2058583,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1918893,
                "content": [
                    {
                        "username": "Jack_oS",
                        "content": "`return address.replace(\\'.\\', \\'[.]\\')`\\n\\nCan this be made even simpler?"
                    },
                    {
                        "username": "mkrishnateja07",
                        "content": "/**\\n * @param {string} address\\n * @return {string}\\n */\\nvar defangIPaddr = function(address) {\\n   return address.split(\\'.\\').join(\"[.]\");\\n};"
                    },
                    {
                        "username": "kadoyan",
                        "content": "var defangIPaddr = address => address.split(\\'.\\').join(\\'[.]\\');"
                    },
                    {
                        "username": "rocky-andre",
                        "content": "return address.replace(\".\", \"[.]\")"
                    },
                    {
                        "username": "Abhishek_Singh_512",
                        "content": "You could just return the original one with replace.\\nI means:\\nreturn address.replace(\".\",\"[.]\");\\nBeacuse in java string is immutable, inside it (replace or other string changing methods) create another string object."
                    },
                    {
                        "username": "zengfei216",
                        "content": "What skill is this problem targeting? it seems kind of trivial.."
                    },
                    {
                        "username": "nguyenvantuyen6789",
                        "content": "I also think like you"
                    },
                    {
                        "username": "harshita12y",
                        "content": "![image](https://assets.leetcode.com/users/images/d828876e-e260-454e-9572-494a0e58665c_1621444482.0735073.png)\\n"
                    },
                    {
                        "username": "roshanjha_23",
                        "content": "WHAT LANGUAGE IS THIS?\\n"
                    },
                    {
                        "username": "MikeBarskiy",
                        "content": "Why we just can\\'t use String method: replaceAll() or replace()?\\n*Replace() in the body use replaceAll()*\\n\\nAnd our solution will be:\\n        `return address.replaceAll(\"\\\\\\\\.\", \"[.]\");`"
                    },
                    {
                        "username": "bbbbbbbbb9",
                        "content": "\\'\\'\\'\\nreturn address.Replace(\".\",\"[.]\");\\n\\'\\'\\'"
                    },
                    {
                        "username": "Code_Enthusiast232",
                        "content": "Just try to create a new string type variable, which can help you to beat 100% of users"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Hi All,\\n\\nBelow solution worked for in \\n\\n `class Solution {\\n    public String defangIPaddr(String address) {\\n      String st=address.replace(\".\",\"[.]\");\\n      return st;\\n    }\\n}`\\n\\nDo let me know if you have any suggestions."
                    }
                ]
            },
            {
                "id": 1913637,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1902989,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1854943,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1848684,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1800375,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1795323,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1793978,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1781594,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1759034,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            },
            {
                "id": 1758032,
                "content": [
                    {
                        "username": "saurabh15094",
                        "content": "#Very Easy Java Solution #\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n      return address.replace(\".\",\"[.]\"); \\n    }\\n}"
                    },
                    {
                        "username": "Cyrus0606",
                        "content": "\\u5C4C\\u4F60\\u8001\\u6BCD\\u5168\\u5BB6\\u5403\\u5C4E\\u98F2Ovaltine"
                    },
                    {
                        "username": "solutyon",
                        "content": "Javascript beginner solution\\n ( 2 lines of code)\\n\\nvar defangIPaddr = function(address) {\\n    let newAddress = address.replaceAll(\".\", \"[.]\")\\n    return newAddress\\n    \\n    };\\n\\nlet input = \"1.1.1.1\"\\nconsole.log(defangIPaddr(input))"
                    },
                    {
                        "username": "chaitanya312",
                        "content": "May be there exist a inbuilt function that can be used in this problem"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/defanging-an-ip-address/solutions/3183694/javascript-beat-92-time-beat-97-space-2-solution/\\n\\nLinear Space | Linear Time"
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || very easy\\n\\nclass Solution {\\n    public String defangIPaddr(String address) {\\n        StringBuilder sb = new StringBuilder();\\n        char[] arr = address.toCharArray();\\n\\n        for (int i = 0; i < arr.length; i++)\\n        {\\n            if (arr[i] == \\'.\\')\\n            {\\n                sb.append(\"[.]\");\\n            }\\n            else\\n            {\\n                sb.append(arr[i]);\\n            }\\n        }\\n\\n        return sb.toString();\\n    }\\n}"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public String defangIPaddr(String address) {\\n        int l = address.length();\\n        int ol = l+6;\\n        String s= \"\";\\n        for(int i=0;i<l;i++){\\n            if(address.charAt(i)==\\'.\\'){\\n                s = s + \"[\";\\n                s = s+ \".\";\\n                s = s + \"]\";\\n            }else{\\n                s = s+address.charAt(i);\\n            }\\n        }\\n        return s;\\n    }\\n} //`Defanging an IP Address`"
                    },
                    {
                        "username": "ravi-_123",
                        "content": "solutions ::\\ninsted of (.)we need to just add the string\"[.]\".\\n\\nbelow solutions link:\\nhttps://leetcode.com/problems/defanging-an-ip-address/description/"
                    },
                    {
                        "username": "StellarAlpit",
                        "content": "One Line Solution:\\n `return address.replaceAll(\".\",\"[.]\")`"
                    },
                    {
                        "username": "Darl1ng",
                        "content": "address = \\n\"1.1.1.1\"\\nOutput\\n\"255[.]100[.]50[.]0\"\\nExpected\\n\"1[.]1[.]1[.]1\"\\nStdout\\n\"1[.]1[.]1[.]1\"\\ni dont know...\\nhelp please :("
                    }
                ]
            }
        ]
    },
    {
        "title": "Strange Printer II",
        "question_content": "<p>There is a strange printer with the following two special requirements:</p>\n\n<ul>\n\t<li>On each turn, the printer will print a solid rectangular pattern of a single color on the grid. This will cover up the existing colors in the rectangle.</li>\n\t<li>Once the printer has used a color for the above operation, <strong>the same color cannot be used again</strong>.</li>\n</ul>\n\n<p>You are given a <code>m x n</code> matrix <code>targetGrid</code>, where <code>targetGrid[row][col]</code> is the color in the position <code>(row, col)</code> of the grid.</p>\n\n<p>Return <code>true</code><em> if it is possible to print the matrix </em><code>targetGrid</code><em>,</em><em> otherwise, return </em><code>false</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/print1.jpg\" style=\"width: 600px; height: 175px;\" />\n<pre>\n<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,2,2,1],[1,2,2,1],[1,1,1,1]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/12/23/print2.jpg\" style=\"width: 600px; height: 367px;\" />\n<pre>\n<strong>Input:</strong> targetGrid = [[1,1,1,1],[1,1,3,3],[1,1,3,4],[5,5,1,4]]\n<strong>Output:</strong> true\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> targetGrid = [[1,2,1],[2,1,2],[1,2,1]]\n<strong>Output:</strong> false\n<strong>Explanation:</strong> It is impossible to form targetGrid because it is not allowed to print the same color in different turns.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == targetGrid.length</code></li>\n\t<li><code>n == targetGrid[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 60</code></li>\n\t<li><code>1 &lt;= targetGrid[row][col] &lt;= 60</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 854193,
                "title": "java-python-straight-forward",
                "content": "# **Explanation**\\nFor each color, find its edge most index.\\nThen we need to paint this color from [top, left] to [bottom, right].\\n\\nIf in the rectangle, all the colors are either the same or 0,\\nwe mark all of them to 0.\\n\\nIf we can mark the whole grid to 0, it means the target if printable.\\n<br>\\n\\n# **Complexity**\\nTime `O(CCMN)`\\nSpace `O(4N)`\\n<br>\\n\\n**Java:**\\nall by @blackspinner\\n```java\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Map<Integer, int[]> pos = new HashMap<>();\\n        int n = targetGrid.length;\\n        int m = targetGrid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pos.putIfAbsent(targetGrid[i][j], new int[]{n, m, -1, -1});\\n                int[] coord = pos.get(targetGrid[i][j]);\\n                coord[0] = Math.min(coord[0], i);\\n                coord[1] = Math.min(coord[1], j);\\n                coord[2] = Math.max(coord[2], i);\\n                coord[3] = Math.max(coord[3], j);\\n            }\\n        }\\n        Set<Integer> colors = new HashSet<>(pos.keySet());\\n        while (!colors.isEmpty()) {\\n            Set<Integer> next = new HashSet<>();\\n            for (int color : colors) {\\n                if (!erase(targetGrid, pos.get(color), color)) {\\n                    next.add(color);\\n                }\\n            }\\n            if (colors.size() == next.size()) {\\n                return false;\\n            }\\n            colors = next;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean erase(int[][] targetGrid, int[] coord, int color) {\\n        for (int i = coord[0]; i <= coord[2]; i++) {\\n            for (int j = coord[1]; j <= coord[3]; j++) {\\n                if (targetGrid[i][j] > 0 && targetGrid[i][j] != color) {\\n                    return false;\\n                }\\n            }\\n        }\\n        for (int i = coord[0]; i <= coord[2]; i++) {\\n            for (int j = coord[1]; j <= coord[3]; j++) {\\n                targetGrid[i][j] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\\n\\n**Python:**\\n```py\\n    def isPrintable(self, A):\\n        m, n = len(A), len(A[0])\\n        pos = [[m, n, 0, 0] for i in xrange(61)]\\n        colors = set()\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                c = A[i][j]\\n                colors.add(c)\\n                pos[c][0] = min(pos[c][0], i)\\n                pos[c][1] = min(pos[c][1], j)\\n                pos[c][2] = max(pos[c][2], i)\\n                pos[c][3] = max(pos[c][3], j)\\n\\n        def test(c):\\n            for i in xrange(pos[c][0], pos[c][2] + 1):\\n                for j in xrange(pos[c][1], pos[c][3] + 1):\\n                    if A[i][j] > 0 and A[i][j] != c:\\n                        return False\\n            for i in xrange(pos[c][0], pos[c][2] + 1):\\n                for j in xrange(pos[c][1], pos[c][3] + 1):\\n                    A[i][j] = 0\\n            return True\\n\\n        while colors:\\n            colors2 = set()\\n            for c in colors:\\n                if not test(c):\\n                    colors2.add(c)\\n            if len(colors2) == len(colors):\\n                return False\\n            colors = colors2\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Map<Integer, int[]> pos = new HashMap<>();\\n        int n = targetGrid.length;\\n        int m = targetGrid[0].length;\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                pos.putIfAbsent(targetGrid[i][j], new int[]{n, m, -1, -1});\\n                int[] coord = pos.get(targetGrid[i][j]);\\n                coord[0] = Math.min(coord[0], i);\\n                coord[1] = Math.min(coord[1], j);\\n                coord[2] = Math.max(coord[2], i);\\n                coord[3] = Math.max(coord[3], j);\\n            }\\n        }\\n        Set<Integer> colors = new HashSet<>(pos.keySet());\\n        while (!colors.isEmpty()) {\\n            Set<Integer> next = new HashSet<>();\\n            for (int color : colors) {\\n                if (!erase(targetGrid, pos.get(color), color)) {\\n                    next.add(color);\\n                }\\n            }\\n            if (colors.size() == next.size()) {\\n                return false;\\n            }\\n            colors = next;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean erase(int[][] targetGrid, int[] coord, int color) {\\n        for (int i = coord[0]; i <= coord[2]; i++) {\\n            for (int j = coord[1]; j <= coord[3]; j++) {\\n                if (targetGrid[i][j] > 0 && targetGrid[i][j] != color) {\\n                    return false;\\n                }\\n            }\\n        }\\n        for (int i = coord[0]; i <= coord[2]; i++) {\\n            for (int j = coord[1]; j <= coord[3]; j++) {\\n                targetGrid[i][j] = 0;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```\n```py\\n    def isPrintable(self, A):\\n        m, n = len(A), len(A[0])\\n        pos = [[m, n, 0, 0] for i in xrange(61)]\\n        colors = set()\\n        for i in xrange(m):\\n            for j in xrange(n):\\n                c = A[i][j]\\n                colors.add(c)\\n                pos[c][0] = min(pos[c][0], i)\\n                pos[c][1] = min(pos[c][1], j)\\n                pos[c][2] = max(pos[c][2], i)\\n                pos[c][3] = max(pos[c][3], j)\\n\\n        def test(c):\\n            for i in xrange(pos[c][0], pos[c][2] + 1):\\n                for j in xrange(pos[c][1], pos[c][3] + 1):\\n                    if A[i][j] > 0 and A[i][j] != c:\\n                        return False\\n            for i in xrange(pos[c][0], pos[c][2] + 1):\\n                for j in xrange(pos[c][1], pos[c][3] + 1):\\n                    A[i][j] = 0\\n            return True\\n\\n        while colors:\\n            colors2 = set()\\n            for c in colors:\\n                if not test(c):\\n                    colors2.add(c)\\n            if len(colors2) == len(colors):\\n                return False\\n            colors = colors2\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854151,
                "title": "c-o-n-3-solution-checking-cycle-in-dependency-graph",
                "content": "**Idea**: Instead of thinking how to gradually print colors, we can think of the problem reversely and see this as a process of **removing colors** from the target grid to get a blank grid. In this process, a color rectangle can only be removed if and only if all the color rectangles \\u201Ccovering\\u201D it are removed first. We can model this dependency relationship between colors as a directed graph. The target can be achieved if and only if the graph doesn\\u2019t have any cycles, which can be easily checked by using a standard DFS. \\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        const int m = targetGrid.size(), n = targetGrid[0].size();\\n        // Dependency graph: dep[i] = j means color j covers color i;\\n        vector<unordered_set<int>> dep(61);\\n        for (int i = 1; i <= 60; ++i) {\\n            // Determine the rectangle of the current color i.\\n            int minx = m, miny = n, maxx = -1, maxy = -1;\\n            for (int x = 0; x < m; ++x) {\\n                for (int y = 0; y < n; ++y) {\\n                    if (targetGrid[x][y] == i) {\\n                        minx = min(x, minx);\\n                        miny = min(y, miny);\\n                        maxx = max(x, maxx);\\n                        maxy = max(y, maxy);\\n                    }\\n                }\\n            }\\n            // Add any color covering the current color as dependence.\\n            for (int tx = minx; tx <= maxx; ++tx) {\\n                for (int ty = miny; ty <= maxy; ++ty) {\\n                   if (targetGrid[tx][ty] != i) dep[i].insert(targetGrid[tx][ty]);\\n                }\\n            }\\n        }\\n        // Standard DFS to check the existence of a cycle.\\n        vector<int> vis(61, 0);\\n        for (int i = 1; i <= 60; ++i) {\\n            if (!vis[i] && hasCircle(i, dep, vis)) return false;\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    bool hasCircle(int curr, const vector<unordered_set<int>>& dep, vector<int>& vis) {\\n        vis[curr] = 1;\\n        for (const int d : dep[curr]) {\\n            if (vis[d] == 2) continue;\\n            if (vis[d] == 1) return true;\\n            if (hasCircle(d, dep, vis)) return true;\\n        }\\n        vis[curr] = 2;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        const int m = targetGrid.size(), n = targetGrid[0].size();\\n        // Dependency graph: dep[i] = j means color j covers color i;\\n        vector<unordered_set<int>> dep(61);\\n        for (int i = 1; i <= 60; ++i) {\\n            // Determine the rectangle of the current color i.\\n            int minx = m, miny = n, maxx = -1, maxy = -1;\\n            for (int x = 0; x < m; ++x) {\\n                for (int y = 0; y < n; ++y) {\\n                    if (targetGrid[x][y] == i) {\\n                        minx = min(x, minx);\\n                        miny = min(y, miny);\\n                        maxx = max(x, maxx);\\n                        maxy = max(y, maxy);\\n                    }\\n                }\\n            }\\n            // Add any color covering the current color as dependence.\\n            for (int tx = minx; tx <= maxx; ++tx) {\\n                for (int ty = miny; ty <= maxy; ++ty) {\\n                   if (targetGrid[tx][ty] != i) dep[i].insert(targetGrid[tx][ty]);\\n                }\\n            }\\n        }\\n        // Standard DFS to check the existence of a cycle.\\n        vector<int> vis(61, 0);\\n        for (int i = 1; i <= 60; ++i) {\\n            if (!vis[i] && hasCircle(i, dep, vis)) return false;\\n        }\\n        return true;\\n    }\\n    \\nprivate:\\n    bool hasCircle(int curr, const vector<unordered_set<int>>& dep, vector<int>& vis) {\\n        vis[curr] = 1;\\n        for (const int d : dep[curr]) {\\n            if (vis[d] == 2) continue;\\n            if (vis[d] == 1) return true;\\n            if (hasCircle(d, dep, vis)) return true;\\n        }\\n        vis[curr] = 2;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854219,
                "title": "java-topological-sort",
                "content": "Well, this is a straight forward solution:\\n\\n1. if `color a` contains `color b`, then we must fill `color a` then `color b`. This is pretty similar to `to finish course b, you need to finish course a first.`\\n2. So we can build a graph: `color a` pointed by all other colors contained in `color a`\\'s rectangle.\\n3. topological sort(or dfs) to check whether we can reach all node. (Please refer to the idea behind [207. Course Schedule](https://leetcode.com/problems/course-schedule/))\\n\\n\\n\\n```\\nclass Solution {\\n    // same color should form a rectangle\\n    // topological sort\\n    // if a rectangle contains another one, then there is an edge between these two color\\n    \\n    public boolean isPrintable(int[][] targetGrid) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        int[] inDegree = new int[61];\\n        for(int i = 0; i <= 60; i++) graph.add(new ArrayList<>());\\n        for(int i = 1; i <= 60; i++) search(targetGrid, i, graph, inDegree);\\n        \\n        Deque<Integer> zeros = new ArrayDeque<>();\\n        HashSet<Integer> seen = new HashSet<>();\\n        for(int i = 0; i < inDegree.length; i++) if(inDegree[i] == 0) zeros.add(i);\\n        \\n        while(!zeros.isEmpty()) {\\n            int cur = zeros.poll();\\n            if(!seen.add(cur)) continue;\\n            \\n            for(Integer nbh : graph.get(cur)) {\\n                inDegree[nbh]--;\\n                if(inDegree[nbh] == 0) zeros.add(nbh);\\n            }\\n        }\\n        return seen.size() == 61;\\n    }\\n    \\n    private void search(int[][] grid, int color, List<List<Integer>> graph, int[] inDegree) {\\n        // get range\\n        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;\\n        for(int i = 0; i < grid.length; i++) for(int j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] == color) {\\n                minX = Math.min(minX, i);\\n                maxX = Math.max(maxX, i);\\n                minY = Math.min(minY, j);\\n                maxY = Math.max(maxY, j);\\n            }\\n        }\\n        \\n        if(minX == Integer.MAX_VALUE) return ;\\n        \\n        // check relations\\n        for(int i = minX; i <= maxX; i++) for(int j = minY; j <= maxY; j++) {\\n            if(grid[i][j] != color) {\\n                graph.get(grid[i][j]).add(color); // to paint current color, we need to paint color in grid[i][j] first\\n                inDegree[color]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // same color should form a rectangle\\n    // topological sort\\n    // if a rectangle contains another one, then there is an edge between these two color\\n    \\n    public boolean isPrintable(int[][] targetGrid) {\\n        List<List<Integer>> graph = new ArrayList<>();\\n        int[] inDegree = new int[61];\\n        for(int i = 0; i <= 60; i++) graph.add(new ArrayList<>());\\n        for(int i = 1; i <= 60; i++) search(targetGrid, i, graph, inDegree);\\n        \\n        Deque<Integer> zeros = new ArrayDeque<>();\\n        HashSet<Integer> seen = new HashSet<>();\\n        for(int i = 0; i < inDegree.length; i++) if(inDegree[i] == 0) zeros.add(i);\\n        \\n        while(!zeros.isEmpty()) {\\n            int cur = zeros.poll();\\n            if(!seen.add(cur)) continue;\\n            \\n            for(Integer nbh : graph.get(cur)) {\\n                inDegree[nbh]--;\\n                if(inDegree[nbh] == 0) zeros.add(nbh);\\n            }\\n        }\\n        return seen.size() == 61;\\n    }\\n    \\n    private void search(int[][] grid, int color, List<List<Integer>> graph, int[] inDegree) {\\n        // get range\\n        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;\\n        for(int i = 0; i < grid.length; i++) for(int j = 0; j < grid[0].length; j++) {\\n            if(grid[i][j] == color) {\\n                minX = Math.min(minX, i);\\n                maxX = Math.max(maxX, i);\\n                minY = Math.min(minY, j);\\n                maxY = Math.max(maxY, j);\\n            }\\n        }\\n        \\n        if(minX == Integer.MAX_VALUE) return ;\\n        \\n        // check relations\\n        for(int i = minX; i <= maxX; i++) for(int j = minY; j <= maxY; j++) {\\n            if(grid[i][j] != color) {\\n                graph.get(grid[i][j]).add(color); // to paint current color, we need to paint color in grid[i][j] first\\n                inDegree[color]++;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854394,
                "title": "c-dfs-on-overlaps",
                "content": "Just 3 simple steps:\\n- For each color, detect the printing rectangle using the min and max coordinates where that color appears.\\n- Within each color\\'s rectangle, collect collors that `overlap`.\\n- Finally, check that colors do not mutually overlap by using DFS.\\n\\t- We can use white/gray/black coloring for visited (`vis`) colors.\\n\\n**C++**\\n```cpp\\nbool dfs(int col, unordered_set<int> overlaps[], vector<int> &vis) {\\n    if (vis[col] != 0)\\n        return vis[col] == 2;\\n    vis[col] = 1;\\n    for (auto col1 : overlaps[col])\\n        if (!dfs(col1, overlaps, vis))\\n            return false;\\n    vis[col] = 2;\\n    return true;\\n}\\nbool isPrintable(vector<vector<int>>& grid) {\\n    vector<array<int, 4>> rects(61, {INT_MAX, INT_MAX, INT_MIN, INT_MIN});\\n    unordered_set<int> overlaps[61];\\n    for (int i = 0; i < grid.size(); ++i)\\n        for (int j = 0; j < grid[0].size(); ++j) {\\n            int col = grid[i][j];\\n            rects[col][0] = min(rects[col][0], i);\\n            rects[col][1] = min(rects[col][1], j);\\n            rects[col][2] = max(rects[col][2], i);\\n            rects[col][3] = max(rects[col][3], j);\\n        }\\n    for (auto col = 0; col <= 60; ++col)\\n        for (int i = rects[col][0]; i <= rects[col][2]; ++i)\\n            for (int j = rects[col][1]; j <= rects[col][3]; ++j)\\n                if (grid[i][j] != col)\\n                    overlaps[col].insert(grid[i][j]);\\n    for (auto col = 0; col <= 60; ++col)\\n        if (!dfs(col, overlaps, vector<int>(61) = {}))\\n            return false;\\n    return true;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nbool dfs(int col, unordered_set<int> overlaps[], vector<int> &vis) {\\n    if (vis[col] != 0)\\n        return vis[col] == 2;\\n    vis[col] = 1;\\n    for (auto col1 : overlaps[col])\\n        if (!dfs(col1, overlaps, vis))\\n            return false;\\n    vis[col] = 2;\\n    return true;\\n}\\nbool isPrintable(vector<vector<int>>& grid) {\\n    vector<array<int, 4>> rects(61, {INT_MAX, INT_MAX, INT_MIN, INT_MIN});\\n    unordered_set<int> overlaps[61];\\n    for (int i = 0; i < grid.size(); ++i)\\n        for (int j = 0; j < grid[0].size(); ++j) {\\n            int col = grid[i][j];\\n            rects[col][0] = min(rects[col][0], i);\\n            rects[col][1] = min(rects[col][1], j);\\n            rects[col][2] = max(rects[col][2], i);\\n            rects[col][3] = max(rects[col][3], j);\\n        }\\n    for (auto col = 0; col <= 60; ++col)\\n        for (int i = rects[col][0]; i <= rects[col][2]; ++i)\\n            for (int j = rects[col][1]; j <= rects[col][3]; ++j)\\n                if (grid[i][j] != col)\\n                    overlaps[col].insert(grid[i][j]);\\n    for (auto col = 0; col <= 60; ++col)\\n        if (!dfs(col, overlaps, vector<int>(61) = {}))\\n            return false;\\n    return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859203,
                "title": "c-topological-sort",
                "content": "The approach to the solution can be started by removing the color instead of fill the solid rectangle with color.\\n* Maintain the starting and ending coordinates of the color .\\n* Than see when can we remove the color from rectangle i.e. this is possible only when the rectangle is filled with same color or all the color present in the rectangle is removed before removing that color.\\n* The 2 step is just smiliar to the topological ordering of the colors i.e. particular color can be removed if all the colors on which it depends is already being removed which is similar to the question [207. Course Schedule](http://https://leetcode.com/problems/course-schedule/)\\nHere is my code for the approach \\n\\nAny suggestion will be appreciated.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        unordered_set<int>st; // for keeping distant color\\n        map<int,vector<int>>row,col; // for keeping starting and ending row and column of color\\n        int n=grid.size(),m=grid[0].size();\\n\\t\\t\\n        // finding Distant color\\n\\t\\tfor(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                st.insert(grid[i][j]);\\n        }\\n\\t\\t// finding coordinates of color\\n        for(auto it:st)\\n        {\\n            int mn1=max(n,m),mn2=max(m,n),mx1=0,mx2=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(grid[i][j]==it)\\n                    {\\n                        mn1=min(i,mn1);\\n                        mx1=max(i,mx1);\\n                        mn2=min(j,mn2);\\n                        mx2=max(j,mx2);\\n                    }\\n                }\\n            }\\n            row[it].push_back(mn1);\\n            row[it].push_back(mx1);\\n            col[it].push_back(mn2);\\n            col[it].push_back(mx2);\\n        }\\n\\t\\t\\n\\t\\t// for keeping dependency\\n        vector<vector<int>>graph(61,vector<int>());\\n        int indeg[61];\\n        memset(indeg,0,sizeof indeg);\\n        for(auto it:st)\\n        {\\n            int mnr=row[it][0],mxr=row[it][1],mnc=col[it][0],mxc=col[it][1];\\n            set<int>st2;\\n            for(int i=mnr;i<=mxr;i++)\\n            {\\n                for(int j=mnc;j<=mxc;j++)\\n                {\\n                    if(it!=grid[i][j])\\n                        st2.insert(grid[i][j]);\\n                }\\n            }\\n            indeg[it]+=st2.size();\\n            for(auto pt:st2)\\n                graph[pt].push_back(it);\\n        }\\n\\t\\t\\n\\t\\t// Standard Topological Sort \\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=1;i<=61;i++)\\n        {\\n            if(st.find(i)!=st.end() and indeg[i]==0)\\n                q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto it:graph[x])\\n            {\\n                indeg[it]--;\\n                if(indeg[it]==0)\\n                    q.push(it);\\n            }\\n        }\\n        if(cnt==st.size())\\n            return true;\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        unordered_set<int>st; // for keeping distant color\\n        map<int,vector<int>>row,col; // for keeping starting and ending row and column of color\\n        int n=grid.size(),m=grid[0].size();\\n\\t\\t\\n        // finding Distant color\\n\\t\\tfor(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n                st.insert(grid[i][j]);\\n        }\\n\\t\\t// finding coordinates of color\\n        for(auto it:st)\\n        {\\n            int mn1=max(n,m),mn2=max(m,n),mx1=0,mx2=0;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(grid[i][j]==it)\\n                    {\\n                        mn1=min(i,mn1);\\n                        mx1=max(i,mx1);\\n                        mn2=min(j,mn2);\\n                        mx2=max(j,mx2);\\n                    }\\n                }\\n            }\\n            row[it].push_back(mn1);\\n            row[it].push_back(mx1);\\n            col[it].push_back(mn2);\\n            col[it].push_back(mx2);\\n        }\\n\\t\\t\\n\\t\\t// for keeping dependency\\n        vector<vector<int>>graph(61,vector<int>());\\n        int indeg[61];\\n        memset(indeg,0,sizeof indeg);\\n        for(auto it:st)\\n        {\\n            int mnr=row[it][0],mxr=row[it][1],mnc=col[it][0],mxc=col[it][1];\\n            set<int>st2;\\n            for(int i=mnr;i<=mxr;i++)\\n            {\\n                for(int j=mnc;j<=mxc;j++)\\n                {\\n                    if(it!=grid[i][j])\\n                        st2.insert(grid[i][j]);\\n                }\\n            }\\n            indeg[it]+=st2.size();\\n            for(auto pt:st2)\\n                graph[pt].push_back(it);\\n        }\\n\\t\\t\\n\\t\\t// Standard Topological Sort \\n        int cnt=0;\\n        queue<int>q;\\n        for(int i=1;i<=61;i++)\\n        {\\n            if(st.find(i)!=st.end() and indeg[i]==0)\\n                q.push(i);\\n        }\\n        while(!q.empty())\\n        {\\n            int x=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto it:graph[x])\\n            {\\n                indeg[it]--;\\n                if(indeg[it]==0)\\n                    q.push(it);\\n            }\\n        }\\n        if(cnt==st.size())\\n            return true;\\n        return false;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 911370,
                "title": "same-as-courseschedule-topological-sort",
                "content": "If color a is contained by color b, we can say a depends on b\\n```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        visited = [0] * 61\\n        graph = collections.defaultdict(set)\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        for c in range(1, 61):\\n            l,r,t,b = n,-1,m,-1\\n\\t\\t\\t#to specify the covered range of color c\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j] == c:\\n                        l = min(l, j)\\n                        r = max(r, j)\\n                        t = min(t, i)\\n                        b = max(b, i)\\n\\t\\t\\t#to find the contained colors\\n            for i in range(t, b + 1):\\n                for j in range(l, r + 1):\\n                    if targetGrid[i][j] != c:\\n                        graph[targetGrid[i][j]].add(c)\\n        \\n\\t\\t# to find if there is a cycle \\n        def dfs(graph,i):\\n            if visited[i] == -1:\\n                return False\\n            if visited[i] == 1:\\n                return True \\n            visited[i] = -1\\n            for j in graph[i]:\\n                if not dfs(graph,j):\\n                    return False\\n            visited[i] = 1\\n            return True\\n        \\n        for c in range(61):\\n            if not dfs(graph,c):\\n                return False\\n        return True\\n```\\n\\nI appreciate it if u vote up!",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        visited = [0] * 61\\n        graph = collections.defaultdict(set)\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        for c in range(1, 61):\\n            l,r,t,b = n,-1,m,-1\\n\\t\\t\\t#to specify the covered range of color c\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j] == c:\\n                        l = min(l, j)\\n                        r = max(r, j)\\n                        t = min(t, i)\\n                        b = max(b, i)\\n\\t\\t\\t#to find the contained colors\\n            for i in range(t, b + 1):\\n                for j in range(l, r + 1):\\n                    if targetGrid[i][j] != c:\\n                        graph[targetGrid[i][j]].add(c)\\n        \\n\\t\\t# to find if there is a cycle \\n        def dfs(graph,i):\\n            if visited[i] == -1:\\n                return False\\n            if visited[i] == 1:\\n                return True \\n            visited[i] = -1\\n            for j in graph[i]:\\n                if not dfs(graph,j):\\n                    return False\\n            visited[i] = 1\\n            return True\\n        \\n        for c in range(61):\\n            if not dfs(graph,c):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1079485,
                "title": "java-topological-sort-with-intuition-explanation-and-comments",
                "content": "The intuition can be as follows:\\n\\n1. Each color should be either complete rectangle (printed last) or have some other color in the middle (something has been printed on top of it).\\n2. For each color, we find the top left corner and bottom right corner of rectangle by traversing the grid. \\n3. If all inside is of the same color, it satisfies the problem conditions - nothing has been printed on top of it.\\n4. Otherwise, it has some colors printed on top. This means, our given color **depends** or **should go before** the colors printed on top of it.\\n\\nWhat do the words in bold remind of? Yeah, typological sort!\\n\\n5. Collect dependencies for all colors to form a graph.\\n6. Topsort the graph. Managed to do it? Then printing was possible, return `true`. Return `false` otherwise.\\n\\n```\\npublic boolean isPrintable(int[][] targetGrid) {\\n    /*\\n    1. For each color, find left top corner and right bottom corner\\n    2. All colors interfering with given color means they should go after given\\n    3. Create dependencies (1 -> [2,3])\\n    4. TopSort. Loops mean it is not possible\\n    */\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        Set<Integer> colors = new HashSet<>();\\n        int rows = targetGrid.length, cols = targetGrid[0].length;\\n\\n\\t\\t// just collect all distinct colors\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) colors.add(targetGrid[i][j]);\\n        }\\n\\n\\t    // for each color\\n        for (var c : colors) {\\n            int fr = -1, fc = Integer.MAX_VALUE, lr = -1, lc = -1;\\n            for (int i = 0; i < rows; i++) {\\n                for (int j = 0; j < cols; j++) {\\n                    if (targetGrid[i][j] == c) {\\n                        // update first row if not set\\n                        if (fr == -1) {\\n                            fr = i;\\n                        }\\n\\t\\t\\t\\t\\t\\t// update first column to be as left as possible\\n                        fc = Math.min(fc, j);\\n\\t\\t\\t\\t\\t\\t// update last row to be as down as possible\\n                        lr = i;\\n\\t\\t\\t\\t\\t\\t// update last col to be as right as possible\\n                        lc = Math.max(lc, j);\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// we now have coordinates for our rectangle. Left top is (fr, fc), right bottom is (lr, lc).\\n            for (int i = fr; i <= lr; i++) {\\n                for (int j = fc; j <= lc; j++) {\\n                    if (targetGrid[i][j] != c) {\\n\\t\\t\\t\\t\\t    // there is a color inside our rectangle which is not the color of main rectangle. A dependency is created.\\n                        graph.computeIfAbsent(c, z->new HashSet<>()).add(targetGrid[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n\\n\\t\\t// just try topsort, return false if not possible, true otherwise\\n        var visited = new HashSet<Integer>();\\n        var visiting = new HashSet<Integer>();\\n        for (var c : colors) {\\n            if (!topSort(visited,visiting, c, graph)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    boolean topSort(Set<Integer> visited, Set<Integer> visiting, int c, Map<Integer, Set<Integer>> graph) {\\n        if (visited.contains(c)) return true;\\n        if (visiting.contains(c)) return false;\\n        visiting.add(c);\\n        \\n        for (var nei : graph.getOrDefault(c, Collections.emptySet())) {\\n            if (!topSort(visited,visiting,nei,graph)) return false;\\n        }\\n        \\n        visiting.remove(c);\\n        visited.add(c);\\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isPrintable(int[][] targetGrid) {\\n    /*\\n    1. For each color, find left top corner and right bottom corner\\n    2. All colors interfering with given color means they should go after given\\n    3. Create dependencies (1 -> [2,3])\\n    4. TopSort. Loops mean it is not possible\\n    */\\n        Map<Integer, Set<Integer>> graph = new HashMap<>();\\n        Set<Integer> colors = new HashSet<>();\\n        int rows = targetGrid.length, cols = targetGrid[0].length;\\n\\n\\t\\t// just collect all distinct colors\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) colors.add(targetGrid[i][j]);\\n        }\\n\\n\\t    // for each color\\n        for (var c : colors) {\\n            int fr = -1, fc = Integer.MAX_VALUE, lr = -1, lc = -1;\\n            for (int i = 0; i < rows; i++) {\\n                for (int j = 0; j < cols; j++) {\\n                    if (targetGrid[i][j] == c) {\\n                        // update first row if not set\\n                        if (fr == -1) {\\n                            fr = i;\\n                        }\\n\\t\\t\\t\\t\\t\\t// update first column to be as left as possible\\n                        fc = Math.min(fc, j);\\n\\t\\t\\t\\t\\t\\t// update last row to be as down as possible\\n                        lr = i;\\n\\t\\t\\t\\t\\t\\t// update last col to be as right as possible\\n                        lc = Math.max(lc, j);\\n                    }\\n                }\\n            }\\n            \\n\\t\\t\\t// we now have coordinates for our rectangle. Left top is (fr, fc), right bottom is (lr, lc).\\n            for (int i = fr; i <= lr; i++) {\\n                for (int j = fc; j <= lc; j++) {\\n                    if (targetGrid[i][j] != c) {\\n\\t\\t\\t\\t\\t    // there is a color inside our rectangle which is not the color of main rectangle. A dependency is created.\\n                        graph.computeIfAbsent(c, z->new HashSet<>()).add(targetGrid[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n\\n\\t\\t// just try topsort, return false if not possible, true otherwise\\n        var visited = new HashSet<Integer>();\\n        var visiting = new HashSet<Integer>();\\n        for (var c : colors) {\\n            if (!topSort(visited,visiting, c, graph)) return false;\\n        }\\n        return true;\\n    }\\n    \\n    boolean topSort(Set<Integer> visited, Set<Integer> visiting, int c, Map<Integer, Set<Integer>> graph) {\\n        if (visited.contains(c)) return true;\\n        if (visiting.contains(c)) return false;\\n        visiting.add(c);\\n        \\n        for (var nei : graph.getOrDefault(c, Collections.emptySet())) {\\n            if (!topSort(visited,visiting,nei,graph)) return false;\\n        }\\n        \\n        visiting.remove(c);\\n        visited.add(c);\\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854276,
                "title": "c-o-colors-n-m-dfs-dependency-graph",
                "content": "For each color, find its maximal rectangle. Then, for each different color inside it, it must be a valid color. It will be a valid color if inside the maximal rectangle of this different color there is none of the original color. Ex:\\n\\n1 1 1 1 1\\n1 1 2 2 2\\n1 1 2 3 3\\n1 1 1 1 1\\n\\ncall dfs for color 1\\n--it will call dfs for color 2\\n----it will call dfs for color 3\\n------there is none of (1,2) inside color 3 rectangle, 3 is ok\\n----there is none of (1) inside color 2 rectangle, 2 is ok\\n--1 is ok.\\n\\n```\\nclass Solution {\\n\\nprivate: \\n    vector<int> vis; // visitation state for each color    \\n    int n, m;\\n    \\n    bool dfs(vector<vector<int>>& targetGrid, int color) {\\n        if(vis[color] == -1) return true;\\n        if(vis[color] == 1) return false;\\n        // find bounds\\n        int l = INT_MAX, r = INT_MIN, u = INT_MAX, d = INT_MIN;\\n        for(int i = 0; i < n; i ++) \\n            for(int j = 0; j < m; j ++) \\n                if(targetGrid[i][j] == color) l = min(l, j), r = max(r, j), u = min(u, i), d = max(d, i);\\n        \\n        if(l == INT_MAX) return true; // none of this color\\n\\n        vis[color] = 1;\\n        \\n        // now, start exploring inside my maximal rectangle\\n        for(int i = u; i <= d; i ++)\\n            for(int j = l; j <= r; j ++)\\n                if(targetGrid[i][j] != color && !dfs(targetGrid, targetGrid[i][j])) return false;\\n        \\n        vis[color] = -1;\\n        \\n        return true;\\n    }\\n    \\n    \\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        n = targetGrid.size();\\n        m = targetGrid[0].size();\\n        vis = vector<int> (61, 0); // 0: didnt open, 1: open, -1: closed\\n        for(int color = 1; color <= 60; color ++) if(!dfs(targetGrid, color)) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\nprivate: \\n    vector<int> vis; // visitation state for each color    \\n    int n, m;\\n    \\n    bool dfs(vector<vector<int>>& targetGrid, int color) {\\n        if(vis[color] == -1) return true;\\n        if(vis[color] == 1) return false;\\n        // find bounds\\n        int l = INT_MAX, r = INT_MIN, u = INT_MAX, d = INT_MIN;\\n        for(int i = 0; i < n; i ++) \\n            for(int j = 0; j < m; j ++) \\n                if(targetGrid[i][j] == color) l = min(l, j), r = max(r, j), u = min(u, i), d = max(d, i);\\n        \\n        if(l == INT_MAX) return true; // none of this color\\n\\n        vis[color] = 1;\\n        \\n        // now, start exploring inside my maximal rectangle\\n        for(int i = u; i <= d; i ++)\\n            for(int j = l; j <= r; j ++)\\n                if(targetGrid[i][j] != color && !dfs(targetGrid, targetGrid[i][j])) return false;\\n        \\n        vis[color] = -1;\\n        \\n        return true;\\n    }\\n    \\n    \\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        n = targetGrid.size();\\n        m = targetGrid[0].size();\\n        vis = vector<int> (61, 0); // 0: didnt open, 1: open, -1: closed\\n        for(int color = 1; color <= 60; color ++) if(!dfs(targetGrid, color)) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012697,
                "title": "c-topological-sort-queue-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& tg) \\n    {\\n        int n=tg.size(),m=tg[0].size();\\n        vector<int> xmax(61,-1),xmin(61,n),ymax(61,-1),ymin(61,m);\\n        vector<vector<int>> g(61);\\n        for(int i=0;i<n;i++)// find max &min index in x& y\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                xmax[tg[i][j]]=max(xmax[tg[i][j]],i);\\n                xmin[tg[i][j]]=min(xmin[tg[i][j]],i);\\n                ymax[tg[i][j]]=max(ymax[tg[i][j]],j);\\n                ymin[tg[i][j]]=min(ymin[tg[i][j]],j);\\n            }\\n        }\\n        vector<int> indeg(61);\\n        for(int colr=1;colr<=60;colr++)\\n        {\\n            for(int i=xmin[colr];i<=xmax[colr];i++)\\n            {\\n                for(int j=ymin[colr];j<=ymax[colr];j++)\\n                {\\n                    if(tg[i][j]!=colr)\\n                    {\\n                        g[colr].push_back(tg[i][j]);\\n                        indeg[tg[i][j]]++;// count indegree\\n                    }\\n                    \\n                }\\n            }\\n        }\\n        int visited=0;\\n        queue<int> q;\\n        for(int colr=1;colr<=60;colr++)///push whose indegree=0\\n        {\\n            if(!indeg[colr])\\n            {\\n                q.push(colr);\\n            }\\n        }\\n\\n            while(!q.empty())\\n            {\\n                int node=q.front();\\n                q.pop();\\n                visited++;\\n                for(auto &child:g[node])\\n                {\\n                    if(!(--indeg[child]))\\n                        q.push(child);\\n                }\\n            }\\n        \\n        return visited==60;\\n    }\\n};\\n// if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& tg) \\n    {\\n        int n=tg.size(),m=tg[0].size();\\n        vector<int> xmax(61,-1),xmin(61,n),ymax(61,-1),ymin(61,m);\\n        vector<vector<int>> g(61);\\n        for(int i=0;i<n;i++)// find max &min index in x& y\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                xmax[tg[i][j]]=max(xmax[tg[i][j]],i);\\n                xmin[tg[i][j]]=min(xmin[tg[i][j]],i);\\n                ymax[tg[i][j]]=max(ymax[tg[i][j]],j);\\n                ymin[tg[i][j]]=min(ymin[tg[i][j]],j);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 854187,
                "title": "c-o-m-n-c-2-think-backwards-and-brute-force-check",
                "content": "The method:\\n1. O(m\\\\*n) Iterate to get all colors and each color\\'s min x, min y, max x, max y\\n2. O(m\\\\*n\\\\*c^2) Think backwards from the last color to the first color. Loop to check each color if it satisfies the condition (from min x to max x, min y to max y, each postion\\'s value is the color or already printed(-1)).\\nReturn true if all colors are checked. Otherwise return false.\\n\\nRuntime complexity: O(m\\\\*n\\\\*c^2)\\nSpace complexity: O(c)\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_map<int, vector<int>> hmap;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int val = targetGrid[i][j];\\n                if (hmap.find(val) == hmap.end()) {\\n                    hmap[val] = {i, j, i, j};\\n                } else {\\n                    hmap[val][0] = min(hmap[val][0], i);\\n                    hmap[val][1] = min(hmap[val][1], j);\\n                    hmap[val][2] = max(hmap[val][2], i);\\n                    hmap[val][3] = max(hmap[val][3], j);\\n                }\\n            }\\n        }\\n        int count = hmap.size();\\n        for (int i = 0; i < count; i++) {\\n            int found = -1;\\n            for (auto &it : hmap) {\\n                int val = it.first;\\n                bool valid = true;\\n                for (int x = it.second[0]; x <= it.second[2]; x++) {\\n                    for (int y = it.second[1]; y <= it.second[3]; y++) {\\n                        if (targetGrid[x][y] != -1 && targetGrid[x][y] != val) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid) {\\n                    found = val;\\n                    for (int x = it.second[0]; x <= it.second[2]; x++) {\\n                        for (int y = it.second[1]; y <= it.second[3]; y++) {\\n                            targetGrid[x][y] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n            if (found != -1) {\\n                hmap.erase(found);\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_map<int, vector<int>> hmap;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int val = targetGrid[i][j];\\n                if (hmap.find(val) == hmap.end()) {\\n                    hmap[val] = {i, j, i, j};\\n                } else {\\n                    hmap[val][0] = min(hmap[val][0], i);\\n                    hmap[val][1] = min(hmap[val][1], j);\\n                    hmap[val][2] = max(hmap[val][2], i);\\n                    hmap[val][3] = max(hmap[val][3], j);\\n                }\\n            }\\n        }\\n        int count = hmap.size();\\n        for (int i = 0; i < count; i++) {\\n            int found = -1;\\n            for (auto &it : hmap) {\\n                int val = it.first;\\n                bool valid = true;\\n                for (int x = it.second[0]; x <= it.second[2]; x++) {\\n                    for (int y = it.second[1]; y <= it.second[3]; y++) {\\n                        if (targetGrid[x][y] != -1 && targetGrid[x][y] != val) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid) {\\n                    found = val;\\n                    for (int x = it.second[0]; x <= it.second[2]; x++) {\\n                        for (int y = it.second[1]; y <= it.second[3]; y++) {\\n                            targetGrid[x][y] = -1;\\n                        }\\n                    }\\n                }\\n            }\\n            if (found != -1) {\\n                hmap.erase(found);\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854185,
                "title": "python-3-n-3-with-clean-code",
                "content": "```\\n\"\"\"\\n1. Find minimal rectangle for printing each color. Its corners for color X can be found as minimal and maximal coordinates of cells with X.\\n2. Each such rectangular might contain cells with different colors, then those colors have to be printed after current one.\\n3. Using previous point, build dependency graph between colors.\\n4. If there are cycles in this graph, then it means that color X has to be printed after Y and Y after X, so it\\'s not possible to print.\\n\"\"\"\\n\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # FIND RECTANGLE BOUNDARIES FOR EACH COLOR\\n        boundaries = [(math.inf, math.inf, -math.inf, -math.inf) for _ in range(61)]\\n        for i in range(len(targetGrid)):\\n            for j in range(len(targetGrid[i])):\\n                color = targetGrid[i][j]\\n                min_i, min_j, max_i, max_j = boundaries[color]\\n                boundaries[color] = (min(min_i, i), min(min_j, j), max(max_i, i), max(max_j, j))\\n\\n        # BUILD GRAPH\\n        graph = defaultdict(set)\\n        for color in range(len(boundaries)):\\n            min_i, min_j, max_i, max_j = boundaries[color]\\n            if min_i != math.inf:\\n                for i in range(min_i, max_i + 1):\\n                    for j in range(min_j, max_j + 1):\\n                        if targetGrid[i][j] != color:\\n                            graph[color].add(targetGrid[i][j])\\n\\n        # DETECT CYCLES IN GRAPH\\n        visited = set()\\n        in_progress = set()\\n        def dfs(source):\\n            in_progress.add(source)\\n            for vertex in graph[source]:\\n                if (vertex in in_progress) or (vertex not in visited and not dfs(vertex)):\\n                    return False\\n            in_progress.remove(source)\\n            visited.add(source)\\n            return True\\n\\n        for color in range(61):\\n            if color not in visited and not dfs(color):\\n                return False\\n        return True\\n```\\n",
                "solutionTags": [],
                "code": "```\\n\"\"\"\\n1. Find minimal rectangle for printing each color. Its corners for color X can be found as minimal and maximal coordinates of cells with X.\\n2. Each such rectangular might contain cells with different colors, then those colors have to be printed after current one.\\n3. Using previous point, build dependency graph between colors.\\n4. If there are cycles in this graph, then it means that color X has to be printed after Y and Y after X, so it\\'s not possible to print.\\n\"\"\"\\n\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # FIND RECTANGLE BOUNDARIES FOR EACH COLOR\\n        boundaries = [(math.inf, math.inf, -math.inf, -math.inf) for _ in range(61)]\\n        for i in range(len(targetGrid)):\\n            for j in range(len(targetGrid[i])):\\n                color = targetGrid[i][j]\\n                min_i, min_j, max_i, max_j = boundaries[color]\\n                boundaries[color] = (min(min_i, i), min(min_j, j), max(max_i, i), max(max_j, j))\\n\\n        # BUILD GRAPH\\n        graph = defaultdict(set)\\n        for color in range(len(boundaries)):\\n            min_i, min_j, max_i, max_j = boundaries[color]\\n            if min_i != math.inf:\\n                for i in range(min_i, max_i + 1):\\n                    for j in range(min_j, max_j + 1):\\n                        if targetGrid[i][j] != color:\\n                            graph[color].add(targetGrid[i][j])\\n\\n        # DETECT CYCLES IN GRAPH\\n        visited = set()\\n        in_progress = set()\\n        def dfs(source):\\n            in_progress.add(source)\\n            for vertex in graph[source]:\\n                if (vertex in in_progress) or (vertex not in visited and not dfs(vertex)):\\n                    return False\\n            in_progress.remove(source)\\n            visited.add(source)\\n            return True\\n\\n        for color in range(61):\\n            if color not in visited and not dfs(color):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855391,
                "title": "python-solution-with-explanation-100-tc-o-cmn-100-sc-o-c-2",
                "content": "Let M, N be the dimension of the grid, and let C be the number of colors. Define a class Box representing a rectangle region in the grid.\\n\\n(1) For each color, find the minimum (bounding) box that covers all its cells. Time complexity O(MN), space complexity O(C).\\n(2) For each color, find other colors that appear in its minimum box. Time complexity O(CMN), space complexity O(C^2).\\n(3) View all colors as vertices in a directed (dependency) graph. Color u connects to color v, if color v appears in color u\\'s minimum box. That means, color v must be painted after the primary color u of the box being painted.\\n(4) Perform depth-first search to check whether the directed graph is cyclic. Time complexity O(C + C^2), space complexity O(C + C^2).\\n\\nOverall time complexity O(CMN), overall space complexity O(C^2) (excluding the space of the MxN grid).\\n\\nAn alternative solution is to reverse the edges in the dependency graph and to perform a topological sort.\\n\\n```\\nclass Box(object):\\n    def __init__(self):\\n        self.top = float(\\'inf\\')\\n        self.bot = 0\\n        self.left = float(\\'inf\\')\\n        self.right = 0\\n    \\n    def update(self, r, c):\\n        self.top = min(self.top, r)\\n        self.bot = max(self.bot, r)\\n        self.left = min(self.left, c)\\n        self.right = max(self.right, c)\\n        \\n    def colors(self, grid):\\n        return set(grid[r][c]\\n                   for r in range(self.top, self.bot+1)\\n                   for c in range(self.left, self.right+1))\\n        \\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        R, C = len(targetGrid), len(targetGrid[0])\\n\\t\\t\\n\\t\\t# get the minimum box for each color \\n        boxes = collections.defaultdict(Box)\\n        for r in range(R):\\n            for c in range(C):\\n                boxes[targetGrid[r][c]].update(r, c)\\n        \\n\\t\\t# build the directed graph\\n        graph = {color: box.colors(targetGrid) - set([color]) \\n                 for color, box in boxes.items()}\\n\\t\\t\\t\\n        # perform dfs to check whether the graph is cyclic\\n        seen = set()\\n        path = set()\\n        def isCyclic(u):\\n            if u in seen:\\n                return u in path\\n            seen.add(u)\\n            path.add(u)\\n            for v in graph[u]:\\n                if isCyclic(v):\\n                    return True\\n            path.remove(u)\\n            return False\\n        \\n        for color in boxes.keys():\\n            if isCyclic(color):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Box(object):\\n    def __init__(self):\\n        self.top = float(\\'inf\\')\\n        self.bot = 0\\n        self.left = float(\\'inf\\')\\n        self.right = 0\\n    \\n    def update(self, r, c):\\n        self.top = min(self.top, r)\\n        self.bot = max(self.bot, r)\\n        self.left = min(self.left, c)\\n        self.right = max(self.right, c)\\n        \\n    def colors(self, grid):\\n        return set(grid[r][c]\\n                   for r in range(self.top, self.bot+1)\\n                   for c in range(self.left, self.right+1))\\n        \\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n        R, C = len(targetGrid), len(targetGrid[0])\\n\\t\\t\\n\\t\\t# get the minimum box for each color \\n        boxes = collections.defaultdict(Box)\\n        for r in range(R):\\n            for c in range(C):\\n                boxes[targetGrid[r][c]].update(r, c)\\n        \\n\\t\\t# build the directed graph\\n        graph = {color: box.colors(targetGrid) - set([color]) \\n                 for color, box in boxes.items()}\\n\\t\\t\\t\\n        # perform dfs to check whether the graph is cyclic\\n        seen = set()\\n        path = set()\\n        def isCyclic(u):\\n            if u in seen:\\n                return u in path\\n            seen.add(u)\\n            path.add(u)\\n            for v in graph[u]:\\n                if isCyclic(v):\\n                    return True\\n            path.remove(u)\\n            return False\\n        \\n        for color in boxes.keys():\\n            if isCyclic(color):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3167855,
                "title": "java-very-easy-solution",
                "content": "*Comment if you have any doubt and upvote if you like the solution if I get **100** UpVote i will upload solution explantion on youtube as well*\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean isRectangle(int[][] grid , int n , int r1 , int c1,int r2, int c2, Set<Integer> rect){\\n        for(; r1 <= r2; r1++){\\n            for(int i = c1; i <= c2; i++){\\n                if(grid[r1][i] == n || rect.contains(grid[r1][i])){\\n                    continue;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPrintable(int[][] grid) {\\n        Map<Integer, int[]> colors = new HashMap<>();\\n        Set<Integer> rect = new HashSet<>();\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(colors.containsKey(grid[i][j])){\\n                    int[] arr = colors.get(grid[i][j]);\\n                    arr[0] = Math.min(arr[0], i);\\n                    arr[1] = Math.min(arr[1], j);\\n                    arr[2] = Math.max(arr[2], i);\\n                    arr[3] = Math.max(arr[3], j);\\n                }else{\\n                    colors.put(grid[i][j], new int[]{i, j, i, j});\\n                }\\n            }\\n        }\\n        for(int color : colors.keySet()){\\n            int[] arr = colors.get(color);\\n            if(isRectangle(grid, color, arr[0], arr[1], arr[2], arr[3], rect)){\\n                rect.add(color);\\n            }\\n        }\\n        for(int i = 0; i < colors.size(); i++){\\n        for(int color : colors.keySet()){\\n            if(rect.contains(color))\\n            continue;\\n            int[] arr = colors.get(color);\\n            if(isRectangle(grid, color, arr[0], arr[1], arr[2], arr[3], rect)){\\n                rect.add(color);\\n            }\\n         }\\n        }\\n        return rect.size()==colors.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isRectangle(int[][] grid , int n , int r1 , int c1,int r2, int c2, Set<Integer> rect){\\n        for(; r1 <= r2; r1++){\\n            for(int i = c1; i <= c2; i++){\\n                if(grid[r1][i] == n || rect.contains(grid[r1][i])){\\n                    continue;\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    public boolean isPrintable(int[][] grid) {\\n        Map<Integer, int[]> colors = new HashMap<>();\\n        Set<Integer> rect = new HashSet<>();\\n        for(int i = 0; i < grid.length; i++){\\n            for(int j = 0; j < grid[0].length; j++){\\n                if(colors.containsKey(grid[i][j])){\\n                    int[] arr = colors.get(grid[i][j]);\\n                    arr[0] = Math.min(arr[0], i);\\n                    arr[1] = Math.min(arr[1], j);\\n                    arr[2] = Math.max(arr[2], i);\\n                    arr[3] = Math.max(arr[3], j);\\n                }else{\\n                    colors.put(grid[i][j], new int[]{i, j, i, j});\\n                }\\n            }\\n        }\\n        for(int color : colors.keySet()){\\n            int[] arr = colors.get(color);\\n            if(isRectangle(grid, color, arr[0], arr[1], arr[2], arr[3], rect)){\\n                rect.add(color);\\n            }\\n        }\\n        for(int i = 0; i < colors.size(); i++){\\n        for(int color : colors.keySet()){\\n            if(rect.contains(color))\\n            continue;\\n            int[] arr = colors.get(color);\\n            if(isRectangle(grid, color, arr[0], arr[1], arr[2], arr[3], rect)){\\n                rect.add(color);\\n            }\\n         }\\n        }\\n        return rect.size()==colors.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1374236,
                "title": "c-explained-topological-sort-cycle-detection-o-c-m-n",
                "content": "For each colour C find its max and min x, y coordinates, say xmin,xmax,ymin,ymax. All the colours except C that appear in 2D grid bounded by these x, y are \"contained\" in C, or we can say there is a directed edge from C to these colours. This is because while painting, C must have appeared before all the colours contained in C. If we get a cycle in the auxiliary graph we create from these dependencies then it is impossible to print. See code with comments below.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        \\n        vector<vector<int>> adj(60);\\n        populateAdj(adj, targetGrid);\\n\\n        int *visited = new int[60];\\n        \\n        for(int i=0;i<60;i++) visited[i]=0;\\n        \\n        for(int i=0;i<60;i++) {\\n            if(visited[i]==0) {\\n                bool temp = dfs(i,adj,targetGrid, visited);\\n                if(temp==0) {\\n                    return 0;\\n                }\\n            }\\n        }    \\n    \\n        return 1;     \\n    }\\n    \\n    void populateAdj(vector<vector<int>> &adj, vector<vector<int>>& targetGrid) {\\n        \\n        for(int k=0;k<60;k++) {\\n            \\n\\t\\t\\t//finds min,max x, y co-ordinates\\n\\t\\t\\t//finds all colors contained in k\\n\\t\\t\\t//adds them to the adj list of k\\n\\t\\t\\t\\n            int xmin=INT_MAX, xmax=INT_MIN, ymin=INT_MAX, ymax=INT_MIN;\\n            int n = targetGrid.size();\\n            int m = targetGrid[0].size();\\n            \\n            for(int i=0;i<n;i++) {\\n                for(int j=0;j<m;j++) {\\n                    if(targetGrid[i][j]==k+1) {\\n                        xmin = min(xmin,i);\\n                        xmax = max(xmax,i);\\n                        ymin = min(ymin,j);\\n                        ymax = max(ymax,j);\\n                    }\\n                }\\n            }\\n            \\n            if(xmin==INT_MAX) {\\n                continue;\\n            }\\n            \\n            unordered_set<int> seen;\\n            for(int i=xmin;i<=xmax;i++) {\\n                for(int j=ymin;j<=ymax;j++) {\\n                    if(targetGrid[i][j]!=k+1 && seen.find(targetGrid[i][j]-1)==seen.end()) {\\n                        seen.insert(targetGrid[i][j]-1);\\n                        adj[k].push_back(targetGrid[i][j]-1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool dfs(int i, vector<vector<int>> &adj, vector<vector<int>>& targetGrid, int* &visited) {\\n        \\n\\t\\t//simple dfs for cycle detection in a graph\\n\\t\\t// See here for more explanation: https://cp-algorithms.com/graph/finding-cycle.html\\n\\t\\t\\n        visited[i]=1;\\n        \\n        for(auto &color : adj[i]) {\\n            if(visited[color]==1) {\\n                return 0;\\n            } else if(visited[color]==0) {\\n                if(!dfs(color,adj,targetGrid,visited)) {\\n                    return 0;\\n                }\\n            }\\n        }\\n        \\n        visited[i]=2;    \\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        \\n        vector<vector<int>> adj(60);\\n        populateAdj(adj, targetGrid);\\n\\n        int *visited = new int[60];\\n        \\n        for(int i=0;i<60;i++) visited[i]=0;\\n        \\n        for(int i=0;i<60;i++) {\\n            if(visited[i]==0) {\\n                bool temp = dfs(i,adj,targetGrid, visited);\\n                if(temp==0) {\\n                    return 0;\\n                }\\n            }\\n        }    \\n    \\n        return 1;     \\n    }\\n    \\n    void populateAdj(vector<vector<int>> &adj, vector<vector<int>>& targetGrid) {\\n        \\n        for(int k=0;k<60;k++) {\\n            \\n\\t\\t\\t//finds min,max x, y co-ordinates\\n\\t\\t\\t//finds all colors contained in k\\n\\t\\t\\t//adds them to the adj list of k\\n\\t\\t\\t\\n            int xmin=INT_MAX, xmax=INT_MIN, ymin=INT_MAX, ymax=INT_MIN;\\n            int n = targetGrid.size();\\n            int m = targetGrid[0].size();\\n            \\n            for(int i=0;i<n;i++) {\\n                for(int j=0;j<m;j++) {\\n                    if(targetGrid[i][j]==k+1) {\\n                        xmin = min(xmin,i);\\n                        xmax = max(xmax,i);\\n                        ymin = min(ymin,j);\\n                        ymax = max(ymax,j);\\n                    }\\n                }\\n            }\\n            \\n            if(xmin==INT_MAX) {\\n                continue;\\n            }\\n            \\n            unordered_set<int> seen;\\n            for(int i=xmin;i<=xmax;i++) {\\n                for(int j=ymin;j<=ymax;j++) {\\n                    if(targetGrid[i][j]!=k+1 && seen.find(targetGrid[i][j]-1)==seen.end()) {\\n                        seen.insert(targetGrid[i][j]-1);\\n                        adj[k].push_back(targetGrid[i][j]-1);\\n                    }\\n                }\\n            }\\n        }\\n    }\\n    \\n    bool dfs(int i, vector<vector<int>> &adj, vector<vector<int>>& targetGrid, int* &visited) {\\n        \\n\\t\\t//simple dfs for cycle detection in a graph\\n\\t\\t// See here for more explanation: https://cp-algorithms.com/graph/finding-cycle.html\\n\\t\\t\\n        visited[i]=1;\\n        \\n        for(auto &color : adj[i]) {\\n            if(visited[color]==1) {\\n                return 0;\\n            } else if(visited[color]==0) {\\n                if(!dfs(color,adj,targetGrid,visited)) {\\n                    return 0;\\n                }\\n            }\\n        }\\n        \\n        visited[i]=2;    \\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765673,
                "title": "c-solution-using-topo-sort",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool isPrintable(vector<vector<int>>& mat)\\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>dp[65];\\n        vector<int>ind(65,0);\\n        unordered_set<int>uni;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                uni.insert(mat[i][j]);\\n            }\\n        }\\n        for(auto it:uni)\\n        {\\n            int min_x,min_y,max_x,max_y;\\n            min_x=min_y=INT_MAX;\\n            max_x=max_y=INT_MIN;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(mat[i][j]==it)\\n                    {\\n                        min_x=min(min_x,i);\\n                        max_x=max(max_x,i);\\n                        min_y=min(min_y,j);\\n                        max_y=max(max_y,j);\\n                    }\\n                }\\n            }\\n            if(min_x==INT_MAX)\\n            {\\n                continue;\\n            }\\n            unordered_set<int>d;\\n            for(int i=min_x;i<=max_x;i++)\\n            {\\n                for(int j=min_y;j<=max_y;j++)\\n                {\\n                    if(mat[i][j]!=it)\\n                    {\\n                        d.insert(mat[i][j]);\\n                    }\\n                }\\n            }\\n            for(auto t:d)\\n            {\\n                dp[it].push_back(t);\\n                ind[t]++;\\n            }\\n        }\\n            queue<int>q;\\n            for(auto it:uni)\\n            {\\n                if(ind[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n             int count=0;\\n            while(q.size())\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                count++;\\n                for(auto it:dp[temp])\\n                {\\n                    if(--ind[it]==0)\\n                    {\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        return (count==uni.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool isPrintable(vector<vector<int>>& mat)\\n    {\\n        int n=mat.size();\\n        int m=mat[0].size();\\n        vector<int>dp[65];\\n        vector<int>ind(65,0);\\n        unordered_set<int>uni;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                uni.insert(mat[i][j]);\\n            }\\n        }\\n        for(auto it:uni)\\n        {\\n            int min_x,min_y,max_x,max_y;\\n            min_x=min_y=INT_MAX;\\n            max_x=max_y=INT_MIN;\\n            for(int i=0;i<n;i++)\\n            {\\n                for(int j=0;j<m;j++)\\n                {\\n                    if(mat[i][j]==it)\\n                    {\\n                        min_x=min(min_x,i);\\n                        max_x=max(max_x,i);\\n                        min_y=min(min_y,j);\\n                        max_y=max(max_y,j);\\n                    }\\n                }\\n            }\\n            if(min_x==INT_MAX)\\n            {\\n                continue;\\n            }\\n            unordered_set<int>d;\\n            for(int i=min_x;i<=max_x;i++)\\n            {\\n                for(int j=min_y;j<=max_y;j++)\\n                {\\n                    if(mat[i][j]!=it)\\n                    {\\n                        d.insert(mat[i][j]);\\n                    }\\n                }\\n            }\\n            for(auto t:d)\\n            {\\n                dp[it].push_back(t);\\n                ind[t]++;\\n            }\\n        }\\n            queue<int>q;\\n            for(auto it:uni)\\n            {\\n                if(ind[it]==0)\\n                {\\n                    q.push(it);\\n                }\\n            }\\n             int count=0;\\n            while(q.size())\\n            {\\n                auto temp=q.front();\\n                q.pop();\\n                count++;\\n                for(auto it:dp[temp])\\n                {\\n                    if(--ind[it]==0)\\n                    {\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n        return (count==uni.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1516602,
                "title": "toposort-concept-python-code",
                "content": "```\\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n#doing reverse engineering like toposort concept find that reactangle which is completely independent,and remove and process futher\\n        m,n=len(targetGrid),len(targetGrid[0])\\n        # strore upper,left,right,bottom most for every color\\n        colors={}\\n        for i in range(m):\\n            for j in range(n):\\n                c=targetGrid[i][j]\\n                if c not in colors:\\n                    colors[c]=[sys.maxsize,sys.maxsize,-1*sys.maxsize,-1*sys.maxsize]\\n                colors[c][0]=min(colors[c][0],i)\\n                colors[c][1]=min(colors[c][1],j)\\n                colors[c][2]=max(colors[c][2],j)\\n                colors[c][3]=max(colors[c][3],i)\\n        # print(colors)\\n        # this is for check is it possible to fill with this color or not\\n        def isPossibleTofill(color):\\n            upper,left,right,bottom=colors[color]\\n            for i in range(upper,bottom+1):\\n                for j in range(left,right+1):\\n                    if targetGrid[i][j]>0 and targetGrid[i][j]!=color:return False\\n            for i in range(upper,bottom+1):\\n                for j in range(left,right+1):\\n                    targetGrid[i][j]=0\\n            return True\\n                                 \\n        c1=colors.keys()\\n        while c1:\\n            c2=set()\\n            for col in c1:\\n                if isPossibleTofill(col)==False:\\n                    c2.add(col)\\n            if len(c2)==len(c1):return False\\n            c1=c2\\n        if len(c1)==0:return True\\n        return False\\n                    \\n                    \\n        \\n                            \\n        \\n                                 \\n                           \\n                                 \\n                                 \\n                                 \\n                                 \\n                    \\n\\n                                \\n                                \\n                                 \\n    \\n                                 \\n        \\n",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        \"\"\"\\n#doing reverse engineering like toposort concept find that reactangle which is completely independent,and remove and process futher\\n        m,n=len(targetGrid),len(targetGrid[0])\\n        # strore upper,left,right,bottom most for every color\\n        colors={}",
                "codeTag": "Java"
            },
            {
                "id": 885310,
                "title": "python3-simulate-the-reverse-process-of-painting",
                "content": "I think the question can be classified as **simulation**. We\\'re simulating the reverse process of painting the grid. We define color A is on top of color B if we paint A after B. Then, we\\'re removing colors from top to down. Actually, the function ```isTop``` is testing if the color is one of the top colors, if it\\'s then we won\\'t add it to ```not_top_colors```  which means we remove it. ```not_top_colors``` stores the colors that are not on the top currently and we\\'ll try to remove them after we remove the current top most colors.\\nSo, essentially the code does(**simulates**) the reverse process of painting.\\n\\nGot key inspiration from https://leetcode.com/problems/strange-printer-ii/discuss/854193/Python-Straight-Forward where the top colors are marked as 0 instead of some specific color.\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        \\'\\'\\'\\n        Remove the colors from top to bottom\\n        \\'\\'\\'\\n        colors = set()\\n        rows, cols = len(targetGrid), len(targetGrid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                colors.add(targetGrid[r][c])\\n\\t\\t# Find the left/top/right/bottom most positions of each color which can define a rectangle.\\n        # left, top, right, bottom\\n        pos = [[float(\\'inf\\'), float(\\'inf\\'), float(\\'-inf\\'), float(\\'-inf\\')] for _ in range(max(colors) + 1)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                color = targetGrid[r][c]\\n                pos[color][0] = min(pos[color][0], c)\\n                pos[color][1] = min(pos[color][1], r)\\n                pos[color][2] = max(pos[color][2], c)\\n                pos[color][3] = max(pos[color][3], r)\\n        def isTop(color):\\n            \\'\\'\\'\\n            Return True if color is current to top most\\n            else return False\\n            A color is on the top if the rectangle contains only this color or no color\\n            \\'\\'\\'\\n            for r in range(pos[color][1], pos[color][3] + 1):\\n                for c in range(pos[color][0], pos[color][2] + 1):\\n                    if targetGrid[r][c] > 0 and targetGrid[r][c] != color:\\n                        return False\\n            for r in range(pos[color][1], pos[color][3] + 1):\\n                for c in range(pos[color][0], pos[color][2] + 1):\\n                    targetGrid[r][c] = 0\\n            return True\\n        while colors:\\n            not_top_colors = set()\\n            for color in colors:\\n                if not isTop(color):\\n                    not_top_colors.add(color)\\n            if len(colors) == len(not_top_colors):\\n                # no color is on the top, so there is no way to paint the target \\n                # because there is always a color that is on top of the other colors if\\n                # we paint the grid one color by one color\\n                return False\\n            colors = not_top_colors\\n        return True\\n```",
                "solutionTags": [],
                "code": "```isTop```\n```not_top_colors```\n```not_top_colors```\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        \\'\\'\\'\\n        Remove the colors from top to bottom\\n        \\'\\'\\'\\n        colors = set()\\n        rows, cols = len(targetGrid), len(targetGrid[0])\\n        for r in range(rows):\\n            for c in range(cols):\\n                colors.add(targetGrid[r][c])\\n\\t\\t# Find the left/top/right/bottom most positions of each color which can define a rectangle.\\n        # left, top, right, bottom\\n        pos = [[float(\\'inf\\'), float(\\'inf\\'), float(\\'-inf\\'), float(\\'-inf\\')] for _ in range(max(colors) + 1)]\\n        for r in range(rows):\\n            for c in range(cols):\\n                color = targetGrid[r][c]\\n                pos[color][0] = min(pos[color][0], c)\\n                pos[color][1] = min(pos[color][1], r)\\n                pos[color][2] = max(pos[color][2], c)\\n                pos[color][3] = max(pos[color][3], r)\\n        def isTop(color):\\n            \\'\\'\\'\\n            Return True if color is current to top most\\n            else return False\\n            A color is on the top if the rectangle contains only this color or no color\\n            \\'\\'\\'\\n            for r in range(pos[color][1], pos[color][3] + 1):\\n                for c in range(pos[color][0], pos[color][2] + 1):\\n                    if targetGrid[r][c] > 0 and targetGrid[r][c] != color:\\n                        return False\\n            for r in range(pos[color][1], pos[color][3] + 1):\\n                for c in range(pos[color][0], pos[color][2] + 1):\\n                    targetGrid[r][c] = 0\\n            return True\\n        while colors:\\n            not_top_colors = set()\\n            for color in colors:\\n                if not isTop(color):\\n                    not_top_colors.add(color)\\n            if len(colors) == len(not_top_colors):\\n                # no color is on the top, so there is no way to paint the target \\n                # because there is always a color that is on top of the other colors if\\n                # we paint the grid one color by one color\\n                return False\\n            colors = not_top_colors\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863681,
                "title": "c-simple-solution-o-n-3",
                "content": "1. For each color find most left, right, bottom, top. These coordinate finally should form a rectangle.\\n2. Build graph with indegrees. So virtual grid for each color has dependencies on its nested other colors.\\n3. Use topological sort technique.\\n\\n```\\nstruct coords\\n{\\n\\tint left = INT_MAX;\\n\\tint right = INT_MIN;\\n\\tint bottom = INT_MAX;\\n\\tint top = INT_MIN;\\n};\\n\\nbool isPrintable(vector<vector<int>>& grid) \\n{\\n\\tvector<coords> colors(61);\\n\\n\\tfor (int row = 0; row < grid.size(); ++row)\\n\\t\\tfor (int col = 0; col < grid[row].size(); ++col)\\n\\t\\t\\tcolors[grid[row][col]].left = min(colors[grid[row][col]].left, col),\\n\\t\\t\\tcolors[grid[row][col]].right = max(colors[grid[row][col]].right, col),\\n\\t\\t\\tcolors[grid[row][col]].bottom = min(colors[grid[row][col]].bottom, row),\\n\\t\\t\\tcolors[grid[row][col]].top = max(colors[grid[row][col]].top, row);\\n\\n\\tunordered_map<int, unordered_set<int>> indegrees, graph;\\n\\n\\tfor (int i = 0; i < colors.size(); ++i)\\n\\t\\tfor (int row = colors[i].bottom; row >= 0 && row <= colors[i].top; ++row)\\n\\t\\t\\tfor (int col = colors[i].left; col >= 0 && col <= colors[i].right; ++col)\\n\\t\\t\\t\\tif (grid[row][col] != i)\\n\\t\\t\\t\\t\\tindegrees[i].insert(grid[row][col]), graph[grid[row][col]].insert(i);\\n\\n\\tqueue<int> queue;\\n\\n\\tfor (int i = 0; i < colors.size(); ++i)\\n\\t\\tif (!indegrees.count(i))\\n\\t\\t\\tqueue.push(i);\\n\\n\\twhile (!queue.empty())\\n\\t{\\n\\t\\tauto cur = queue.front();\\n\\t\\tqueue.pop();\\n\\n\\t\\tfor (auto adj : graph[cur])\\n\\t\\t{\\n\\t\\t\\tindegrees[adj].erase(cur);\\n\\n\\t\\t\\tif (indegrees[adj].empty())\\n\\t\\t\\t\\tqueue.push(adj), indegrees.erase(adj);\\n\\t\\t}\\n\\t}\\n\\n\\treturn indegrees.empty();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct coords\\n{\\n\\tint left = INT_MAX;\\n\\tint right = INT_MIN;\\n\\tint bottom = INT_MAX;\\n\\tint top = INT_MIN;\\n};\\n\\nbool isPrintable(vector<vector<int>>& grid) \\n{\\n\\tvector<coords> colors(61);\\n\\n\\tfor (int row = 0; row < grid.size(); ++row)\\n\\t\\tfor (int col = 0; col < grid[row].size(); ++col)\\n\\t\\t\\tcolors[grid[row][col]].left = min(colors[grid[row][col]].left, col),\\n\\t\\t\\tcolors[grid[row][col]].right = max(colors[grid[row][col]].right, col),\\n\\t\\t\\tcolors[grid[row][col]].bottom = min(colors[grid[row][col]].bottom, row),\\n\\t\\t\\tcolors[grid[row][col]].top = max(colors[grid[row][col]].top, row);\\n\\n\\tunordered_map<int, unordered_set<int>> indegrees, graph;\\n\\n\\tfor (int i = 0; i < colors.size(); ++i)\\n\\t\\tfor (int row = colors[i].bottom; row >= 0 && row <= colors[i].top; ++row)\\n\\t\\t\\tfor (int col = colors[i].left; col >= 0 && col <= colors[i].right; ++col)\\n\\t\\t\\t\\tif (grid[row][col] != i)\\n\\t\\t\\t\\t\\tindegrees[i].insert(grid[row][col]), graph[grid[row][col]].insert(i);\\n\\n\\tqueue<int> queue;\\n\\n\\tfor (int i = 0; i < colors.size(); ++i)\\n\\t\\tif (!indegrees.count(i))\\n\\t\\t\\tqueue.push(i);\\n\\n\\twhile (!queue.empty())\\n\\t{\\n\\t\\tauto cur = queue.front();\\n\\t\\tqueue.pop();\\n\\n\\t\\tfor (auto adj : graph[cur])\\n\\t\\t{\\n\\t\\t\\tindegrees[adj].erase(cur);\\n\\n\\t\\t\\tif (indegrees[adj].empty())\\n\\t\\t\\t\\tqueue.push(adj), indegrees.erase(adj);\\n\\t\\t}\\n\\t}\\n\\n\\treturn indegrees.empty();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854978,
                "title": "java-check-from-top-layer",
                "content": "real print need to print the bottom layer, then topper layer to override the lower layers.\\nto Solve the problem, we do the opposite, find the top layer which could form a rectangular, until we can not find any additonal candidate numbers.\\n\\n```\\nclass Solution {\\n    Set<Integer> vs = new HashSet<>(), pool = new HashSet<>();\\n    int m, n, l, r, u, b, g[][], dir[][] = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public boolean isPrintable(int[][] grid) {\\n        g = grid; m = g.length; n = g[0].length; \\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                pool.add(g[i][j]);\\n        while (pool.size() > 0) {\\n            Set<Integer> tr = new HashSet<>();\\n            for (int i : pool) {\\n                if (!vs.contains(i) && canPrint(i)) {\\n                    tr.add(i);\\n                    vs.add(i);\\n                }\\n            }\\n            if (tr.size() == 0) return false;\\n            for (int i : tr) pool.remove(i);\\n        }\\n        return true;\\n    }\\n    \\n    private boolean canPrint(int num) {\\n        l = m; r = 0; b = 0; u = n;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (g[i][j] == num) {\\n                    l = Math.min(l, i);\\n                    r = Math.max(r, i);\\n                    u = Math.min(u, j);\\n                    b = Math.max(b, j);\\n                }\\n        return isRect(num);\\n    }\\n    \\n    private boolean isRect(int num) {  // in the min rect, check if all element is valid, printed, or num;\\n        for (int i = l; i <= r; i++)\\n            for (int j = u; j <= b; j++)\\n                if (g[i][j] != num && !vs.contains(g[i][j])) return false;\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<Integer> vs = new HashSet<>(), pool = new HashSet<>();\\n    int m, n, l, r, u, b, g[][], dir[][] = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public boolean isPrintable(int[][] grid) {\\n        g = grid; m = g.length; n = g[0].length; \\n        for (int i = 0; i < m; i++) \\n            for (int j = 0; j < n; j++) \\n                pool.add(g[i][j]);\\n        while (pool.size() > 0) {\\n            Set<Integer> tr = new HashSet<>();\\n            for (int i : pool) {\\n                if (!vs.contains(i) && canPrint(i)) {\\n                    tr.add(i);\\n                    vs.add(i);\\n                }\\n            }\\n            if (tr.size() == 0) return false;\\n            for (int i : tr) pool.remove(i);\\n        }\\n        return true;\\n    }\\n    \\n    private boolean canPrint(int num) {\\n        l = m; r = 0; b = 0; u = n;\\n        for (int i = 0; i < m; i++)\\n            for (int j = 0; j < n; j++)\\n                if (g[i][j] == num) {\\n                    l = Math.min(l, i);\\n                    r = Math.max(r, i);\\n                    u = Math.min(u, j);\\n                    b = Math.max(b, j);\\n                }\\n        return isRect(num);\\n    }\\n    \\n    private boolean isRect(int num) {  // in the min rect, check if all element is valid, printed, or num;\\n        for (int i = l; i <= r; i++)\\n            for (int j = u; j <= b; j++)\\n                if (g[i][j] != num && !vs.contains(g[i][j])) return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 854172,
                "title": "python-3-same-solution-as-936-stamping-the-sequence",
                "content": "Keep removing all the colors which have valid rectangles and replace each of their elements  with -1.\\n\\nSimilar to [936. Stamping The Sequence](https://leetcode.com/problems/stamping-the-sequence/)\\n```\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        m = len(grid[0])\\n        colors = set()\\n        maxx = {}\\n        maxy = {}\\n        minx = {}\\n        miny = {}\\n        for i in range(n):\\n            for j in range(m):\\n                c = grid[i][j]\\n                minx.setdefault(c, i)\\n                miny.setdefault(c, j)\\n                maxx.setdefault(c, i)\\n                maxy.setdefault(c, j)\\n                minx[c]=min(minx[c],i)\\n                maxx[c]=max(maxx[c],i)\\n                miny[c]=min(miny[c],j)\\n                maxy[c]=max(maxy[c],j)\\n                colors.add(c)\\n\\n        def isrect(c):\\n            for i in range(minx[c], maxx[c]+1):\\n                for j in range(miny[c],maxy[c]+1):\\n                    if not(grid[i][j]==c or grid[i][j]==-1):\\n                        return False\\n            return True\\n        \\n        def change(c):\\n            for i in range(minx[c], maxx[c]+1):\\n                for j in range(miny[c],maxy[c]+1):\\n                    grid[i][j]=-1\\n                    \\n        changed = True\\n        while changed:\\n            removethis = set()\\n            changed = False\\n            for c in colors:\\n                if isrect(c):\\n                    changed = True\\n                    removethis.add(c)\\n                    change(c)\\n            colors-=removethis\\n            \\n        if not colors:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        n = len(grid)\\n        m = len(grid[0])\\n        colors = set()\\n        maxx = {}\\n        maxy = {}\\n        minx = {}\\n        miny = {}\\n        for i in range(n):\\n            for j in range(m):\\n                c = grid[i][j]\\n                minx.setdefault(c, i)\\n                miny.setdefault(c, j)\\n                maxx.setdefault(c, i)\\n                maxy.setdefault(c, j)\\n                minx[c]=min(minx[c],i)\\n                maxx[c]=max(maxx[c],i)\\n                miny[c]=min(miny[c],j)\\n                maxy[c]=max(maxy[c],j)\\n                colors.add(c)\\n\\n        def isrect(c):\\n            for i in range(minx[c], maxx[c]+1):\\n                for j in range(miny[c],maxy[c]+1):\\n                    if not(grid[i][j]==c or grid[i][j]==-1):\\n                        return False\\n            return True\\n        \\n        def change(c):\\n            for i in range(minx[c], maxx[c]+1):\\n                for j in range(miny[c],maxy[c]+1):\\n                    grid[i][j]=-1\\n                    \\n        changed = True\\n        while changed:\\n            removethis = set()\\n            changed = False\\n            for c in colors:\\n                if isrect(c):\\n                    changed = True\\n                    removethis.add(c)\\n                    change(c)\\n            colors-=removethis\\n            \\n        if not colors:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437076,
                "title": "easy-topological-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach color has its dependency, return true if the graph of relationship is a directed acyclic graph. Otherwise return false.\\n# Complexity\\n- Time complexity:$$O(cmn)$$, where $$c$$ is the number of colors (nodes), and $$mn$$ is the number of grids (edges).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity$$O(mn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        unordered_map<int,vector<int>> mp;\\n        unordered_set<int> cs;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++){\\n            int c=g[i][j];\\n            cs.insert(c);\\n            if(c==0) continue;\\n            auto & v=mp[c];\\n            if(v.empty()){\\n                v={i,i,j,j};\\n            }else{\\n                v[0]=min(v[0],i);\\n                v[1]=max(v[1],i);\\n                v[2]=min(v[2],j);\\n                v[3]=max(v[3],j);\\n            }\\n        }\\n        unordered_map<int,unordered_set<int>> e;\\n        unordered_map<int,int> ind;\\n        for(auto& [c,v]:mp){\\n            int minx=v[0],maxx=v[1],miny=v[2],maxy=v[3];\\n            for(int i=minx;i<=maxx;i++) for(int j=miny;j<=maxy;j++){\\n                int d=g[i][j];\\n                if(d==0) return false;\\n                if(d==c or e[d].count(c)) continue;\\n                e[d].insert(c);\\n                ind[c]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(auto c:cs){\\n            if(ind.count(c)) continue;\\n            q.push(c);\\n        }\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:e[u]){\\n                if(--ind[v]) continue;\\n                q.push(v);\\n            }\\n        }\\n        for(auto&[c,v]:ind){\\n            if(v) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& g) {\\n        int n=g.size(),m=g[0].size();\\n        unordered_map<int,vector<int>> mp;\\n        unordered_set<int> cs;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++){\\n            int c=g[i][j];\\n            cs.insert(c);\\n            if(c==0) continue;\\n            auto & v=mp[c];\\n            if(v.empty()){\\n                v={i,i,j,j};\\n            }else{\\n                v[0]=min(v[0],i);\\n                v[1]=max(v[1],i);\\n                v[2]=min(v[2],j);\\n                v[3]=max(v[3],j);\\n            }\\n        }\\n        unordered_map<int,unordered_set<int>> e;\\n        unordered_map<int,int> ind;\\n        for(auto& [c,v]:mp){\\n            int minx=v[0],maxx=v[1],miny=v[2],maxy=v[3];\\n            for(int i=minx;i<=maxx;i++) for(int j=miny;j<=maxy;j++){\\n                int d=g[i][j];\\n                if(d==0) return false;\\n                if(d==c or e[d].count(c)) continue;\\n                e[d].insert(c);\\n                ind[c]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(auto c:cs){\\n            if(ind.count(c)) continue;\\n            q.push(c);\\n        }\\n        while(!q.empty()){\\n            int u=q.front();\\n            q.pop();\\n            for(auto v:e[u]){\\n                if(--ind[v]) continue;\\n                q.push(v);\\n            }\\n        }\\n        for(auto&[c,v]:ind){\\n            if(v) return false;\\n        }\\n        return true;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413210,
                "title": "solid-principles-100-memory-commented-and-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is actually similar to whether or not we have edge collisions in polygon coloring for computer graphics. As such, we take the idea of a color bounding box as a polygon of that color, where we are trying to see if we can get to the back of the painting (aka 0) so we have painted all we need to. To get this as a visual application, simply assign each color to an rgb band. The original will show up, and as you go you can find the polygonal size of the rectangles showing and report on it. It\\'s really quite interesting in this fashion so I\\'ve left as much of it as possible in clear commented code for those interested in setting it up. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe want to track 3 things in our initial set up, so we establish fields for them at init. These are colors yet to reveal, colors not yet revealable, and color boundaries. The colors yet to reveal are those we have yet to process, and initially contains all colors. At each step, we will see if it is a top lying color (meaning we have it on the top of the stack of color boundaries) and if so, we can reveal it to zero and process the boundaries of it. This occurs if we have all values in bounding box of this color, or all values in the bounding box of this color are zero or some mixture of both. If we cannot yet do so, we place it into colors not yet revealable and then will check to see if any change occurred. If no change occurred we have directly conflicting edges and can not process accordingly, and should return False. On change though, we should update colors yet to reveal to the smaller form of those not yet revealable. \\n\\nTo do all this we need a few functions to help out. The first is our set up function, which gets passed the grid we are going to be working on. \\nWe set up our rows and cols of the grid, and get the max dimension as either the max of either of rows or cols or 60 based on problem description. This lets this extend beyond the scope of the problem space. \\n\\nOur color boundaries all start out with the box going from minimal of row and col for the color and maximal of the row and col for the color, found by looping over the grid. \\n\\nWhen done with set up we store the grid in its current form. We do this to not modify the original, and to allow us to report out state changes as we go if we so feel that it is appropriate to do so \\n\\nOur next function is our zero in range function. If a color has been revealed by either all of the cells in the range being that color, or all of the values in that range being that color or zero, we will set all of the cells in that boundary to zero with the zero in range function. It is passed a range of row start, row stop, col start and col stop to work within. \\n\\nWe also have our test color boundary function. This gets passed a color and pulls from our color boundaries the bounding box for that color. We increment the row stop and col stop by one so that python does go over that range in its for loops. We then loop over all cells in the bounding box, and if there is any cell that is not this color or zero, we return False. Otherwise, after processing all succesfully as either this color or zero, we zero this range and return True. \\n\\nTo process our colors finally, we do the following \\n- while our colors yet to reveal is not an empty set \\n    - set our colors not yet revealable to an empty set \\n    - for color in our colors yet to reveal \\n        - if our test of the color boundary is false, add it to not yet revealable. It will be processed otherwise. \\n    - if the size of our colors yet to reveal and our colors not yet revealable match, no change occurred in this loop, return False. \\n    - otherwise, set colors yet to reveal to colors not yet revealable\\nIf all colors processed, return True. \\n\\nTo check if printable, call set up with the target grid, then return the result of processing colors.    \\n\\n# Complexity\\n- Time complexity: O(C^2 * Rows * Cols)\\n    - We loop over colors in process colors \\n        - we build up a color list, which may have us reprocess colors. This makes it a double loop necessarily of the form I in range N -> J in range I, N, which is known to be N^2 at worst. \\n        - On each looping of this we loop over rows, nested with cols \\n        - This is O(C * C * Rows * Cols) where C is colors and rows and cols are the size of the grid    \\n\\n- Space complexity: O(Rows * Cols + Constant) \\n    - We store the grid \\n    - The color space boundary is technically a fixed size of color boundary factors, so can be treated as a constant  \\n\\n# Code\\n```\\nclass Solution:\\n    # initialize with colors that are about to be revealed and those we cannot reveal yet \\n    # initialize alongside this the bounding box of a given color area \\n    def __init__(self) : \\n        self.colors_yet_to_reveal = set()\\n        self.colors_not_yet_revealable = set()\\n        self.color_boundaries = []\\n\\n    def set_up(self, grid) : \\n        # set up according to grid \\n        self.rows = len(grid)\\n        self.cols = len(grid[0])\\n        # based on problem, should stop at dimension 60, but just in case of hooligans, use this \\n        self.max_dimension = max(self.rows, self.cols, 60)\\n        # color boundaries one greater than max dimension for off by one accounding \\n        self.color_boundaries = [[self.rows, self.cols, 0, 0] for _ in range(self.max_dimension + 1)]\\n        # loop in range \\n        for row in range(self.rows) : \\n            for col in range(self.cols) : \\n                # get the color \\n                color = grid[row][col]\\n                # add it if we don\\'t have it yet \\n                self.colors_yet_to_reveal.add(color)\\n                # set the boundary box as the min of the value there now and max of value \\n                # there now compared to the row and col current. This gets the bounding \\n                # box of the color areas like doing polygon bounding in graphical processing \\n                self.color_boundaries[color][0] = min(self.color_boundaries[color][0], row)\\n                self.color_boundaries[color][1] = min(self.color_boundaries[color][1], col)\\n                self.color_boundaries[color][2] = max(self.color_boundaries[color][2], row)\\n                self.color_boundaries[color][3] = max(self.color_boundaries[color][3], col)\\n        # mark the grid as is now for processing \\n        # this makes it so we don\\'t change the original data and can compare on a step by step if needed\\n        self.grid = grid\\n\\n    # set to zero all values in range for current grid \\n    def zero_in_range(self, r0, r1, c0, c1) : \\n        # loop in range \\n        # could include a print statement or export statement of some kind to see grid as it changes \\n        for row in range(r0, r1) : \\n            for col in range(c0, c1) : \\n                # set to default selected value, in this casce 0 \\n                self.grid[row][col] = 0\\n    \\n    # test color is contiguous in boundary \\n    def test_color_boundary(self, color) : \\n        # get stop and start for rows and cols \\n        r_start, c_start, r_stop, c_stop = self.color_boundaries[color]\\n        r_stop += 1 \\n        c_stop += 1 \\n        # loop in range \\n        for row in range(r_start, r_stop) : \\n            for col in range(c_start, c_stop) : \\n                # if it is not zero and not color, that\\'s not good \\n                # return False \\n                if self.grid[row][col] > 0 and self.grid[row][col] != color : \\n                    return False \\n        # otherwise, zero in range and return True \\n        self.zero_in_range(r_start, r_stop, c_start, c_stop)\\n        return True \\n\\n    # process colors in grid \\n    def process_colors(self) :\\n        # while we still have colors to reveal  \\n        while self.colors_yet_to_reveal : \\n            # reset your colors not yet revealable at start of each processing loop \\n            self.colors_not_yet_revealable = set()\\n            # reveal the current colors you have to reveal \\n            for color in self.colors_yet_to_reveal : \\n                # if the color is not yet ready to be revealed \\n                if self.test_color_boundary(color) == False : \\n                    # mark it as such and continue \\n                    self.colors_not_yet_revealable.add(color)\\n            # if we have the same amount to reveal as we started with, nothing changed \\n            # if nothing changed, it\\'s not possible, return False \\n            if len(self.colors_yet_to_reveal) == len(self.colors_not_yet_revealable) : \\n                return False \\n            # otherwise, update accordingly. On the loop where self.colors not yet revealable \\n            # is a set that had nothing added to it, we break \\n            self.colors_yet_to_reveal = self.colors_not_yet_revealable\\n        # return True on all colors revealed \\n        return True \\n\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # set up \\n        self.set_up(targetGrid)\\n        # return results of processing \\n        return self.process_colors()\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    # initialize with colors that are about to be revealed and those we cannot reveal yet \\n    # initialize alongside this the bounding box of a given color area \\n    def __init__(self) : \\n        self.colors_yet_to_reveal = set()\\n        self.colors_not_yet_revealable = set()\\n        self.color_boundaries = []\\n\\n    def set_up(self, grid) : \\n        # set up according to grid \\n        self.rows = len(grid)\\n        self.cols = len(grid[0])\\n        # based on problem, should stop at dimension 60, but just in case of hooligans, use this \\n        self.max_dimension = max(self.rows, self.cols, 60)\\n        # color boundaries one greater than max dimension for off by one accounding \\n        self.color_boundaries = [[self.rows, self.cols, 0, 0] for _ in range(self.max_dimension + 1)]\\n        # loop in range \\n        for row in range(self.rows) : \\n            for col in range(self.cols) : \\n                # get the color \\n                color = grid[row][col]\\n                # add it if we don\\'t have it yet \\n                self.colors_yet_to_reveal.add(color)\\n                # set the boundary box as the min of the value there now and max of value \\n                # there now compared to the row and col current. This gets the bounding \\n                # box of the color areas like doing polygon bounding in graphical processing \\n                self.color_boundaries[color][0] = min(self.color_boundaries[color][0], row)\\n                self.color_boundaries[color][1] = min(self.color_boundaries[color][1], col)\\n                self.color_boundaries[color][2] = max(self.color_boundaries[color][2], row)\\n                self.color_boundaries[color][3] = max(self.color_boundaries[color][3], col)\\n        # mark the grid as is now for processing \\n        # this makes it so we don\\'t change the original data and can compare on a step by step if needed\\n        self.grid = grid\\n\\n    # set to zero all values in range for current grid \\n    def zero_in_range(self, r0, r1, c0, c1) : \\n        # loop in range \\n        # could include a print statement or export statement of some kind to see grid as it changes \\n        for row in range(r0, r1) : \\n            for col in range(c0, c1) : \\n                # set to default selected value, in this casce 0 \\n                self.grid[row][col] = 0\\n    \\n    # test color is contiguous in boundary \\n    def test_color_boundary(self, color) : \\n        # get stop and start for rows and cols \\n        r_start, c_start, r_stop, c_stop = self.color_boundaries[color]\\n        r_stop += 1 \\n        c_stop += 1 \\n        # loop in range \\n        for row in range(r_start, r_stop) : \\n            for col in range(c_start, c_stop) : \\n                # if it is not zero and not color, that\\'s not good \\n                # return False \\n                if self.grid[row][col] > 0 and self.grid[row][col] != color : \\n                    return False \\n        # otherwise, zero in range and return True \\n        self.zero_in_range(r_start, r_stop, c_start, c_stop)\\n        return True \\n\\n    # process colors in grid \\n    def process_colors(self) :\\n        # while we still have colors to reveal  \\n        while self.colors_yet_to_reveal : \\n            # reset your colors not yet revealable at start of each processing loop \\n            self.colors_not_yet_revealable = set()\\n            # reveal the current colors you have to reveal \\n            for color in self.colors_yet_to_reveal : \\n                # if the color is not yet ready to be revealed \\n                if self.test_color_boundary(color) == False : \\n                    # mark it as such and continue \\n                    self.colors_not_yet_revealable.add(color)\\n            # if we have the same amount to reveal as we started with, nothing changed \\n            # if nothing changed, it\\'s not possible, return False \\n            if len(self.colors_yet_to_reveal) == len(self.colors_not_yet_revealable) : \\n                return False \\n            # otherwise, update accordingly. On the loop where self.colors not yet revealable \\n            # is a set that had nothing added to it, we break \\n            self.colors_yet_to_reveal = self.colors_not_yet_revealable\\n        # return True on all colors revealed \\n        return True \\n\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # set up \\n        self.set_up(targetGrid)\\n        # return results of processing \\n        return self.process_colors()\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386215,
                "title": "c-explained-simple-faster-and-space-efficient-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ntopological sort can be applied keeping in mind that if a color is extended in a larger area so that must be printed first then the inner colors can be overpinted in it here DAG can be created from a smaller color value -> larger color value edges where first smaller color value must be printed before higher color values if there is an edge \\nThis can be done by creating coordinates top,right,bottom and left for every color till which it is expanded in the grid all the colors diffrent than this whose atleast one coordinate (t/r/b/l) lies inside this region must be printed first before curr color to be printed.\\nif there is any cycle in this dag then ans is no else true\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![image.png](https://assets.leetcode.com/users/images/5b6e5d8c-c9e7-43bd-9fdf-7a2317310787_1680778622.2249627.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int col,int arr[][4],vector<vector<int>>& grid,int* visited){\\n    visited[col]=1;\\n    int t=arr[col][0];\\n    int r=arr[col][1];\\n    int b=arr[col][2];\\n    int l=arr[col][3];\\n    // cout<<col<<\" \"<<t<<\" \"<<b<<\" \"<<l<<\" \"<<r<<endl;\\n    for(int i=t;i<=b;i++){\\n        for(int j=l;j<=r;j++){\\n            int x=grid[i][j];\\n            if(x==col)  continue;\\n            if(visited[x]==1) return false;\\n            bool ans=1;\\n            if(visited[x]==0){\\n                ans=dfs(x,arr,grid,visited);\\n            }\\n            if(ans==0) return 0;\\n        }\\n    }\\n    visited[col]=2;\\n    return true;\\n}\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int arr[61][4]; // node->a particular color-> 4 cordinates top right bottom left till which that color is expanded in grid\\n        int visited[61];\\n        memset(visited,-1,sizeof(visited));  \\n        // -1 node not present in grid \\n        // 0 node is present but not yet visited\\n        // 1 node is currently being visited\\n        // 2 node has already been visited\\n        // here node is corresponding to ith color\\n        // and visited is corresponding to being printed\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int col=grid[i][j]; // color\\n                if(visited[col]==-1){   // color seen for the first time\\n                    visited[col]=0;\\n                    arr[col][0]=i;\\n                    arr[col][1]=j;\\n                    arr[col][2]=i;\\n                    arr[col][3]=j;\\n                }\\n                else{   //already seen must have some coordinates\\n                    arr[col][0]=min(i,arr[col][0]);\\n                    arr[col][1]=max(j,arr[col][1]);\\n                    arr[col][2]=max(i,arr[col][2]);\\n                    arr[col][3]=min(j,arr[col][3]);\\n                }\\n            }\\n        }\\n        bool ans=1;\\n        for(int i=0;i<61;i++){\\n            if(visited[i]==-1) continue;\\n            if(visited[i]==0){\\n                ans=dfs(i,arr,grid,visited);\\n                if(ans==0) return false;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(int col,int arr[][4],vector<vector<int>>& grid,int* visited){\\n    visited[col]=1;\\n    int t=arr[col][0];\\n    int r=arr[col][1];\\n    int b=arr[col][2];\\n    int l=arr[col][3];\\n    // cout<<col<<\" \"<<t<<\" \"<<b<<\" \"<<l<<\" \"<<r<<endl;\\n    for(int i=t;i<=b;i++){\\n        for(int j=l;j<=r;j++){\\n            int x=grid[i][j];\\n            if(x==col)  continue;\\n            if(visited[x]==1) return false;\\n            bool ans=1;\\n            if(visited[x]==0){\\n                ans=dfs(x,arr,grid,visited);\\n            }\\n            if(ans==0) return 0;\\n        }\\n    }\\n    visited[col]=2;\\n    return true;\\n}\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        int m=grid.size();\\n        int n=grid[0].size();\\n        int arr[61][4]; // node->a particular color-> 4 cordinates top right bottom left till which that color is expanded in grid\\n        int visited[61];\\n        memset(visited,-1,sizeof(visited));  \\n        // -1 node not present in grid \\n        // 0 node is present but not yet visited\\n        // 1 node is currently being visited\\n        // 2 node has already been visited\\n        // here node is corresponding to ith color\\n        // and visited is corresponding to being printed\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int col=grid[i][j]; // color\\n                if(visited[col]==-1){   // color seen for the first time\\n                    visited[col]=0;\\n                    arr[col][0]=i;\\n                    arr[col][1]=j;\\n                    arr[col][2]=i;\\n                    arr[col][3]=j;\\n                }\\n                else{   //already seen must have some coordinates\\n                    arr[col][0]=min(i,arr[col][0]);\\n                    arr[col][1]=max(j,arr[col][1]);\\n                    arr[col][2]=max(i,arr[col][2]);\\n                    arr[col][3]=min(j,arr[col][3]);\\n                }\\n            }\\n        }\\n        bool ans=1;\\n        for(int i=0;i<61;i++){\\n            if(visited[i]==-1) continue;\\n            if(visited[i]==0){\\n                ans=dfs(i,arr,grid,visited);\\n                if(ans==0) return false;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2171580,
                "title": "python-solution-by-building-a-graph-and-topological-sort",
                "content": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        idea: using targetGrid to construct a color region graph\\n        graph nodes are connected by overlapping \\n        nodeA --> nodeB if rangeA covering **pointsB**\\n        Then if the graph can be topological sorted\\n        the printer problem can be solved\\n        \"\"\"\\n        color_set = set()\\n        color_graph = dict()\\n        color_range = dict()\\n        indegrees = dict()\\n        Row, Col = len(targetGrid), len(targetGrid[0])\\n        for i in range(Row):\\n            for j in range(Col):\\n                if targetGrid[i][j] not in color_set:\\n                    color_set.add(targetGrid[i][j])\\n                    color_range[targetGrid[i][j]] = [i, j, i, j] # upper, left, bottom, right\\n                    indegrees[targetGrid[i][j]] = 0\\n                else:\\n                    color_range[targetGrid[i][j]][0] = min(i, color_range[targetGrid[i][j]][0])\\n                    color_range[targetGrid[i][j]][1] = min(j, color_range[targetGrid[i][j]][1])\\n                    color_range[targetGrid[i][j]][2] = max(i, color_range[targetGrid[i][j]][2])\\n                    color_range[targetGrid[i][j]][3] = max(j, color_range[targetGrid[i][j]][3])\\n        # build graph according to color_range coverage (max envelope)\\n        for c in color_set:\\n            color_graph[c] = set()\\n            # connect node c to other nodes\\n            # range of c coverges **points** of other nodes\\n            for i in range(color_range[c][0], color_range[c][2]+1):\\n                for j in range(color_range[c][1], color_range[c][3]+1):\\n                    cur = targetGrid[i][j]\\n                    if cur != c and cur not in color_graph[c]:\\n                        color_graph[c].add(cur)\\n                        # indegrees[c] += 1\\n        # compute indegrees\\n        for c in color_set:\\n            for n in color_graph[c]:\\n                indegrees[n] += 1\\n        # now the graph is built, then can use topological sort \\n        # print(color_graph)\\n        # print(indegrees)\\n        queue = deque()\\n        for c in color_set:\\n            if indegrees[c] == 0:\\n                queue.append(c)\\n        turns = 0\\n        while len(queue)>0:\\n            c = queue.popleft()\\n            turns += 1\\n            for n in color_graph[c]:\\n                indegrees[n] -= 1\\n                if indegrees[n]==0:\\n                    queue.append(n)\\n        # print(turns, len(color_set))         \\n        return turns==len(color_set)\\n```",
                "solutionTags": [
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution(object):\\n    def isPrintable(self, targetGrid):\\n        \"\"\"\\n        :type targetGrid: List[List[int]]\\n        :rtype: bool\\n        idea: using targetGrid to construct a color region graph\\n        graph nodes are connected by overlapping \\n        nodeA --> nodeB if rangeA covering **pointsB**\\n        Then if the graph can be topological sorted\\n        the printer problem can be solved\\n        \"\"\"\\n        color_set = set()\\n        color_graph = dict()\\n        color_range = dict()\\n        indegrees = dict()\\n        Row, Col = len(targetGrid), len(targetGrid[0])\\n        for i in range(Row):\\n            for j in range(Col):\\n                if targetGrid[i][j] not in color_set:\\n                    color_set.add(targetGrid[i][j])\\n                    color_range[targetGrid[i][j]] = [i, j, i, j] # upper, left, bottom, right\\n                    indegrees[targetGrid[i][j]] = 0\\n                else:\\n                    color_range[targetGrid[i][j]][0] = min(i, color_range[targetGrid[i][j]][0])\\n                    color_range[targetGrid[i][j]][1] = min(j, color_range[targetGrid[i][j]][1])\\n                    color_range[targetGrid[i][j]][2] = max(i, color_range[targetGrid[i][j]][2])\\n                    color_range[targetGrid[i][j]][3] = max(j, color_range[targetGrid[i][j]][3])\\n        # build graph according to color_range coverage (max envelope)\\n        for c in color_set:\\n            color_graph[c] = set()\\n            # connect node c to other nodes\\n            # range of c coverges **points** of other nodes\\n            for i in range(color_range[c][0], color_range[c][2]+1):\\n                for j in range(color_range[c][1], color_range[c][3]+1):\\n                    cur = targetGrid[i][j]\\n                    if cur != c and cur not in color_graph[c]:\\n                        color_graph[c].add(cur)\\n                        # indegrees[c] += 1\\n        # compute indegrees\\n        for c in color_set:\\n            for n in color_graph[c]:\\n                indegrees[n] += 1\\n        # now the graph is built, then can use topological sort \\n        # print(color_graph)\\n        # print(indegrees)\\n        queue = deque()\\n        for c in color_set:\\n            if indegrees[c] == 0:\\n                queue.append(c)\\n        turns = 0\\n        while len(queue)>0:\\n            c = queue.popleft()\\n            turns += 1\\n            for n in color_graph[c]:\\n                indegrees[n] -= 1\\n                if indegrees[n]==0:\\n                    queue.append(n)\\n        # print(turns, len(color_set))         \\n        return turns==len(color_set)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977386,
                "title": "easy-to-understand-c-17-build-the-graph-then-topological-sort",
                "content": "### [Easy-to-understand C++17] Build the graph, then Topological Sort\\nIdea:\\nwe can solve this problem in two steps.\\n1. Build a graph to represent the relationships between colors. \\n    *  it\\'s a bit tricky to see how colors depends on each other. \\n\\there an edge from U to V means color U appears in color V\\'s rectangle realm, thus U should be removed earlier than V. \\n\\t* we use an Object-Oriented way to do the statistics for a color. please see the code below.\\n\\t\\n2. Run a standard topological sort algorithm on the graph. \\n    * If the graph is a DAG, then all colors can be removed.\\n\\n```\\nclass Solution {\\n    /// \\\\brief statistics for a color\\n    struct ColorStat{\\n        int _color = 0;\\n        int _count = 0;\\n        int _top = -1;\\n        int _bottom = -1;\\n        int _left = -1;\\n        int _right = -1;\\n        \\n        /// \\\\brief record the color\\'s presence at a cell\\n        void record(int color, int row, int col) {\\n            ++_count;\\n            if (_count == 1) {\\n                _color = color;\\n                _top = row; \\n                _bottom = row;\\n                _left = col;\\n                _right = col;\\n                return;\\n            }\\n            _top = min(_top, row);\\n            _bottom = max(_bottom, row);\\n            _left = min(_left, col);\\n            _right = max(_right, col);\\n        }\\n        \\n        /// \\\\brief check whether the color\\'s rectangle contains only the color itself\\n        bool isTight() const {\\n            return (_bottom - _top + 1) * (_right - _left + 1) == _count;\\n        }\\n        \\n        /// \\\\brief Get the other colors that appear in this color\\'s rectangle realm.\\n        unordered_set<int> otherColorsInMyRealm(const vector<vector<int>>& grid) const {\\n            unordered_set<int> otherColors;\\n            if (isTight()) {\\n                return {};\\n            }\\n            for (int row = _top; row <= _bottom; ++row) {\\n                for (int col = _left; col <= _right; ++col) {\\n                    if (grid[row][col] != _color) {\\n                        otherColors.insert(grid[row][col]);\\n                    }\\n                }\\n            }\\n            return otherColors;\\n        }\\n    };\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        const int nrow = targetGrid.size(), ncol = targetGrid[0].size();\\n        \\n        // map from color to its stats.\\n        // because there can be gaps between color IDs, we\\'d better use a map here.\\n        unordered_map<int, ColorStat> colorToStats;\\n        int maxColor = 0;\\n        for (int r = 0; r < nrow; ++r) {\\n            for (int c = 0; c < ncol; ++c) {\\n                int color = targetGrid[r][c];\\n                colorToStats[color].record(color, r, c);\\n                maxColor = max(maxColor, color);\\n            }\\n        }\\n        // Build the graph.\\n        // adjacency list for the graph.\\n        // an edge from U to V means color U appears in color V\\'s rectangle realm.\\n        vector<vector<int>> adj(maxColor + 1, vector<int>());\\n        vector<int> inDegrees(maxColor + 1);\\n        for (const auto& [color, stats] : colorToStats) {\\n            auto otherColors = stats.otherColorsInMyRealm(targetGrid);\\n            // edge otherColor --> color\\n            inDegrees[color] = otherColors.size();\\n            for (int other : otherColors) {\\n                adj[other].emplace_back(color); \\n            }\\n        }\\n        \\n        // topological sort.\\n        queue<int> q;\\n        int doneColors = 0;\\n        const int occurredColors = colorToStats.size();\\n        // init: enqueue the color nodes with zero in-degrees.\\n        for (int c = 1; c <= maxColor; ++c) {\\n            if (inDegrees[c] == 0 && colorToStats.count(c)) {\\n                q.emplace(c);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int currColor = q.front(); \\n            q.pop();\\n            ++doneColors;\\n            // free up/unleash other colors which depends on currColor\\n            for (int other : adj[currColor]) {\\n                // edge is from currColor --> other\\n                if (--inDegrees[other] == 0) {\\n                    q.emplace(other);\\n                }\\n            }\\n        }\\n        // if there are circular dependencies in the Graph,\\n        // those color nodes involved in the circular deps \\n        // cannot be resolved/printed. In that case, \\n        // doneColors will be smaller. \\n        return doneColors == occurredColors;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    /// \\\\brief statistics for a color\\n    struct ColorStat{\\n        int _color = 0;\\n        int _count = 0;\\n        int _top = -1;\\n        int _bottom = -1;\\n        int _left = -1;\\n        int _right = -1;\\n        \\n        /// \\\\brief record the color\\'s presence at a cell\\n        void record(int color, int row, int col) {\\n            ++_count;\\n            if (_count == 1) {\\n                _color = color;\\n                _top = row; \\n                _bottom = row;\\n                _left = col;\\n                _right = col;\\n                return;\\n            }\\n            _top = min(_top, row);\\n            _bottom = max(_bottom, row);\\n            _left = min(_left, col);\\n            _right = max(_right, col);\\n        }\\n        \\n        /// \\\\brief check whether the color\\'s rectangle contains only the color itself\\n        bool isTight() const {\\n            return (_bottom - _top + 1) * (_right - _left + 1) == _count;\\n        }\\n        \\n        /// \\\\brief Get the other colors that appear in this color\\'s rectangle realm.\\n        unordered_set<int> otherColorsInMyRealm(const vector<vector<int>>& grid) const {\\n            unordered_set<int> otherColors;\\n            if (isTight()) {\\n                return {};\\n            }\\n            for (int row = _top; row <= _bottom; ++row) {\\n                for (int col = _left; col <= _right; ++col) {\\n                    if (grid[row][col] != _color) {\\n                        otherColors.insert(grid[row][col]);\\n                    }\\n                }\\n            }\\n            return otherColors;\\n        }\\n    };\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        const int nrow = targetGrid.size(), ncol = targetGrid[0].size();\\n        \\n        // map from color to its stats.\\n        // because there can be gaps between color IDs, we\\'d better use a map here.\\n        unordered_map<int, ColorStat> colorToStats;\\n        int maxColor = 0;\\n        for (int r = 0; r < nrow; ++r) {\\n            for (int c = 0; c < ncol; ++c) {\\n                int color = targetGrid[r][c];\\n                colorToStats[color].record(color, r, c);\\n                maxColor = max(maxColor, color);\\n            }\\n        }\\n        // Build the graph.\\n        // adjacency list for the graph.\\n        // an edge from U to V means color U appears in color V\\'s rectangle realm.\\n        vector<vector<int>> adj(maxColor + 1, vector<int>());\\n        vector<int> inDegrees(maxColor + 1);\\n        for (const auto& [color, stats] : colorToStats) {\\n            auto otherColors = stats.otherColorsInMyRealm(targetGrid);\\n            // edge otherColor --> color\\n            inDegrees[color] = otherColors.size();\\n            for (int other : otherColors) {\\n                adj[other].emplace_back(color); \\n            }\\n        }\\n        \\n        // topological sort.\\n        queue<int> q;\\n        int doneColors = 0;\\n        const int occurredColors = colorToStats.size();\\n        // init: enqueue the color nodes with zero in-degrees.\\n        for (int c = 1; c <= maxColor; ++c) {\\n            if (inDegrees[c] == 0 && colorToStats.count(c)) {\\n                q.emplace(c);\\n            }\\n        }\\n        while (!q.empty()) {\\n            int currColor = q.front(); \\n            q.pop();\\n            ++doneColors;\\n            // free up/unleash other colors which depends on currColor\\n            for (int other : adj[currColor]) {\\n                // edge is from currColor --> other\\n                if (--inDegrees[other] == 0) {\\n                    q.emplace(other);\\n                }\\n            }\\n        }\\n        // if there are circular dependencies in the Graph,\\n        // those color nodes involved in the circular deps \\n        // cannot be resolved/printed. In that case, \\n        // doneColors will be smaller. \\n        return doneColors == occurredColors;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1560935,
                "title": "python-with-explanations",
                "content": "First consider all cells with some color (value) `v`. From them we can reconstruct supposed boundary of the ractangle of value `v`. Now suppose some two rectangles `rec1, rec2` (with their reconstructed boundary) intersect, if there is color of the first rectangle in the intersection, that means rectangle first must be printed after rectangle second. Thus, we can connect with the directed edge `rec2` to `rec1` meaning `rec2` is printed first. That\\'s how we create our directed graph, and we need to check for it being acyclic which is done by dfs. After acyclicity just print rectangles from top of the graph (all roots) to bottom (leafs). Let\\'s show why this printing is proper below.\\n\\nSo why does acyclicity of the graph implies that there exist proper printing. Consider any cell and say its value is v. Then consider all rectangles (with reconstructed boundary) that cover that cell with value v and pick any, say rec_c. Obviously rectangle corresponding to color v also covers that cell, call it rec_v. So rec_c and rec_v intersect, and since there is color v in the intersection that means there is a link from rec_c to rec_v and rec_v will be printed later than any rec_c, thus initial cell will be eventually colored by color v. Proof is complete.\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid):\\n        n = len(targetGrid)\\n        m = len(targetGrid[0])\\n        di_min, di_max, dj_min, dj_max = {}, {}, {}, {}\\n        vals = set()\\n        val2set = defaultdict(set)\\n        for i in range(n):\\n            for j in range(m):\\n                val = targetGrid[i][j]\\n                val2set[val].add((i, j))\\n                vals.add(val)\\n                di_min[val] = min(di_min.get(val, 10 ** 9), i)\\n                di_max[val] = max(di_max.get(val, 0), i)\\n                dj_min[val] = min(dj_min.get(val, 10 ** 9), j)\\n                dj_max[val] = max(dj_max.get(val, 0), j)\\n\\n        def inside(cell, v):\\n            i, j = cell\\n            return di_min[v] <= i <= di_max[v] and dj_min[v] <= j <= dj_max[v]\\n\\n        gr = defaultdict(list)\\n        for v1 in vals:\\n            for v2 in vals:\\n                if v1 == v2: continue\\n                for c1 in val2set[v1]:\\n                    if inside(c1, v2):\\n                        gr[v2].append(v1)\\n                for c2 in val2set[v2]:\\n                    if inside(c2, v1):\\n                        gr[v1].append(v2)\\n\\n        attended = set()\\n        path = set()\\n        def dfs(node):\\n            attended.add(node)\\n            path.add(node)\\n            boolean = True\\n            for to in gr[node]:\\n                if to in path:\\n                    boolean = False\\n                elif to not in attended:\\n                    boolean &= dfs(to)\\n                if not boolean: break\\n\\n            path.remove(node)\\n            return boolean\\n\\n        for v in vals:\\n            if v not in attended and not dfs(v):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid):\\n        n = len(targetGrid)\\n        m = len(targetGrid[0])\\n        di_min, di_max, dj_min, dj_max = {}, {}, {}, {}\\n        vals = set()\\n        val2set = defaultdict(set)\\n        for i in range(n):\\n            for j in range(m):\\n                val = targetGrid[i][j]\\n                val2set[val].add((i, j))\\n                vals.add(val)\\n                di_min[val] = min(di_min.get(val, 10 ** 9), i)\\n                di_max[val] = max(di_max.get(val, 0), i)\\n                dj_min[val] = min(dj_min.get(val, 10 ** 9), j)\\n                dj_max[val] = max(dj_max.get(val, 0), j)\\n\\n        def inside(cell, v):\\n            i, j = cell\\n            return di_min[v] <= i <= di_max[v] and dj_min[v] <= j <= dj_max[v]\\n\\n        gr = defaultdict(list)\\n        for v1 in vals:\\n            for v2 in vals:\\n                if v1 == v2: continue\\n                for c1 in val2set[v1]:\\n                    if inside(c1, v2):\\n                        gr[v2].append(v1)\\n                for c2 in val2set[v2]:\\n                    if inside(c2, v1):\\n                        gr[v1].append(v2)\\n\\n        attended = set()\\n        path = set()\\n        def dfs(node):\\n            attended.add(node)\\n            path.add(node)\\n            boolean = True\\n            for to in gr[node]:\\n                if to in path:\\n                    boolean = False\\n                elif to not in attended:\\n                    boolean &= dfs(to)\\n                if not boolean: break\\n\\n            path.remove(node)\\n            return boolean\\n\\n        for v in vals:\\n            if v not in attended and not dfs(v):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1321075,
                "title": "java-dfs-with-explanation-clean-code",
                "content": "The idea is to find each color\\'s range with 2 points (min_i, min_j) and (max_i, max_j).\\n\\nThen, DFS each color in its range, if find new color that already printed, then return false, if find new color has not been printed, then DFS the new color in its range. During this, we also skip the points that already be visited, this is important as we rely on the printed color to detect false case, so we do not want to visit the same point multiple times.\\n\\n```\\nclass Solution {\\n    \\n    public boolean isPrintable(int[][] targetGrid) {\\n        int[][] colorBound = new int[61][4];\\n        Set<Integer> colors = new HashSet<>();\\n        \\n        // prepare colorBound with Max and Min integer for later compare\\n        for (int i = 0; i < colorBound.length; i ++) {\\n            for (int j = 0; j < colorBound[0].length; j ++) {\\n                if (j == 0 || j == 1) colorBound[i][j] = Integer.MAX_VALUE;\\n                else colorBound[i][j] = Integer.MIN_VALUE;\\n            }\\n        }\\n            \\n        // find the color range for each color\\n        // each color i has a colorBound[i] with {min_i, min_j, max_i, max_j}\\n        for (int i = 0; i < targetGrid.length; i ++) {\\n            for (int j = 0; j < targetGrid[0].length; j ++) {\\n                colorBound[targetGrid[i][j]][0] = Math.min(colorBound[targetGrid[i][j]][0], i);\\n                colorBound[targetGrid[i][j]][1] = Math.min(colorBound[targetGrid[i][j]][1], j);\\n                colorBound[targetGrid[i][j]][2] = Math.max(colorBound[targetGrid[i][j]][2], i);\\n                colorBound[targetGrid[i][j]][3] = Math.max(colorBound[targetGrid[i][j]][3], j);\\n                colors.add(targetGrid[i][j]);\\n            }\\n        }\\n        \\n        boolean[] printed = new boolean[61];\\n        boolean[][] visited = new boolean[targetGrid.length][targetGrid[0].length];\\n        \\n        //DFS all the colors, skip the color already be printed\\n        for (Integer color : colors) {\\n            if (printed[color]) continue;\\n            if (!dfs(targetGrid, printed, colorBound, visited, color)) return false;;\\n        }\\n        \\n        // if all color has been printed, then return true\\n        return true;\\n    }\\n    \\n    private boolean dfs(int[][] targetGrid, boolean[] printed, int[][] colorBound, boolean[][] visited, int color) {\\n        printed[color] = true;\\n        for (int i = colorBound[color][0]; i <= colorBound[color][2]; i ++) {\\n            for (int j = colorBound[color][1]; j <= colorBound[color][3]; j ++) {\\n                // if i, j is already visited, skip\\n                if (visited[i][j]) continue;\\n                // if we find a different color, then check if the color is already printed, if so, return false\\n                // otherwise, dfs the range of the new color\\n                if (targetGrid[i][j] != color) {\\n                    if (printed[targetGrid[i][j]]) return false;\\n                    if (!dfs(targetGrid, printed, colorBound, visited, targetGrid[i][j])) return false;\\n                }\\n                visited[i][j] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public boolean isPrintable(int[][] targetGrid) {\\n        int[][] colorBound = new int[61][4];\\n        Set<Integer> colors = new HashSet<>();\\n        \\n        // prepare colorBound with Max and Min integer for later compare\\n        for (int i = 0; i < colorBound.length; i ++) {\\n            for (int j = 0; j < colorBound[0].length; j ++) {\\n                if (j == 0 || j == 1) colorBound[i][j] = Integer.MAX_VALUE;\\n                else colorBound[i][j] = Integer.MIN_VALUE;\\n            }\\n        }\\n            \\n        // find the color range for each color\\n        // each color i has a colorBound[i] with {min_i, min_j, max_i, max_j}\\n        for (int i = 0; i < targetGrid.length; i ++) {\\n            for (int j = 0; j < targetGrid[0].length; j ++) {\\n                colorBound[targetGrid[i][j]][0] = Math.min(colorBound[targetGrid[i][j]][0], i);\\n                colorBound[targetGrid[i][j]][1] = Math.min(colorBound[targetGrid[i][j]][1], j);\\n                colorBound[targetGrid[i][j]][2] = Math.max(colorBound[targetGrid[i][j]][2], i);\\n                colorBound[targetGrid[i][j]][3] = Math.max(colorBound[targetGrid[i][j]][3], j);\\n                colors.add(targetGrid[i][j]);\\n            }\\n        }\\n        \\n        boolean[] printed = new boolean[61];\\n        boolean[][] visited = new boolean[targetGrid.length][targetGrid[0].length];\\n        \\n        //DFS all the colors, skip the color already be printed\\n        for (Integer color : colors) {\\n            if (printed[color]) continue;\\n            if (!dfs(targetGrid, printed, colorBound, visited, color)) return false;;\\n        }\\n        \\n        // if all color has been printed, then return true\\n        return true;\\n    }\\n    \\n    private boolean dfs(int[][] targetGrid, boolean[] printed, int[][] colorBound, boolean[][] visited, int color) {\\n        printed[color] = true;\\n        for (int i = colorBound[color][0]; i <= colorBound[color][2]; i ++) {\\n            for (int j = colorBound[color][1]; j <= colorBound[color][3]; j ++) {\\n                // if i, j is already visited, skip\\n                if (visited[i][j]) continue;\\n                // if we find a different color, then check if the color is already printed, if so, return false\\n                // otherwise, dfs the range of the new color\\n                if (targetGrid[i][j] != color) {\\n                    if (printed[targetGrid[i][j]]) return false;\\n                    if (!dfs(targetGrid, printed, colorBound, visited, targetGrid[i][j])) return false;\\n                }\\n                visited[i][j] = true;\\n            }\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888143,
                "title": "straight-solution-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n\\n\\n    map<int, vector<int> > getMinMax(vector<vector<int>>& targetGrid) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();    \\n                \\n        int i, j;\\n        \\n        map<int, vector<int> >  M;\\n        \\n        for(i = 0; i < n; ++i) {\\n            for(j = 0; j < m; ++j) {\\n                int x = targetGrid[i][j];\\n                if(M.count(x) == 0) {\\n                   M[x] = {INT_MAX, INT_MAX, -1, -1};\\n                }\\n                M[x][0] = min(i, M[x][0]);\\n                M[x][1] = min(j, M[x][1]);\\n                M[x][2] = max(i, M[x][2]);\\n                M[x][3] = max(j, M[x][3]);\\n            }\\n        }                \\n        return M;   \\n    }\\n    \\n    bool checkAllSame(int r1, int c1, int r2, int c2, vector<vector<int>>& targetGrid, int l){\\n        int count = 0;\\n        int color = -1;\\n        for(int i=r1; i<=r2; i++){\\n            for(int j=c1; j<=c2; j++){\\n                if(targetGrid[i][j] != -1 && targetGrid[i][j] != l){\\n                   return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void replace(int r1, int c1, int r2, int c2, vector<vector<int>>& targetGrid){\\n       for(int i = r1; i<=r2; i++){\\n         for(int j = c1; j<=c2; j++){\\n            targetGrid[i][j] = -1 ;\\n         }\\n       }\\n    }\\n    \\n    bool checkAll(vector<vector<int>>& targetGrid){\\n         int n = targetGrid.size();\\n         int m = targetGrid[0].size();\\n         for(int i=0; i<n; i++){\\n             for(int j=0; j<m; j++){\\n                 if(targetGrid[i][j]!=-1){\\n                     return false;\\n                 }\\n             }\\n         }\\n        return true;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        \\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        \\n        map<int, vector<int> > M = getMinMax(targetGrid);\\n        while(1) {\\n            int f = 0;\\n            vector<int> proc;\\n            for(auto it : M) {\\n                int l = it.first;\\n                if(checkAllSame(it.second[0], it.second[1], it.second[2], it.second[3], targetGrid, l)) { \\n                    f = 1;\\n                    proc.push_back(l);\\n                    replace(it.second[0], it.second[1], it.second[2], it.second[3], targetGrid);\\n                }\\n            \\n            }\\n            for(int z : proc) {\\n                M.erase(M.find(z));\\n            }\\n            if(f == 0) {\\n               break;\\n            }\\n        }\\n        return checkAll(targetGrid);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n\\n    map<int, vector<int> > getMinMax(vector<vector<int>>& targetGrid) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();    \\n                \\n        int i, j;\\n        \\n        map<int, vector<int> >  M;\\n        \\n        for(i = 0; i < n; ++i) {\\n            for(j = 0; j < m; ++j) {\\n                int x = targetGrid[i][j];\\n                if(M.count(x) == 0) {\\n                   M[x] = {INT_MAX, INT_MAX, -1, -1};\\n                }\\n                M[x][0] = min(i, M[x][0]);\\n                M[x][1] = min(j, M[x][1]);\\n                M[x][2] = max(i, M[x][2]);\\n                M[x][3] = max(j, M[x][3]);\\n            }\\n        }                \\n        return M;   \\n    }\\n    \\n    bool checkAllSame(int r1, int c1, int r2, int c2, vector<vector<int>>& targetGrid, int l){\\n        int count = 0;\\n        int color = -1;\\n        for(int i=r1; i<=r2; i++){\\n            for(int j=c1; j<=c2; j++){\\n                if(targetGrid[i][j] != -1 && targetGrid[i][j] != l){\\n                   return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    void replace(int r1, int c1, int r2, int c2, vector<vector<int>>& targetGrid){\\n       for(int i = r1; i<=r2; i++){\\n         for(int j = c1; j<=c2; j++){\\n            targetGrid[i][j] = -1 ;\\n         }\\n       }\\n    }\\n    \\n    bool checkAll(vector<vector<int>>& targetGrid){\\n         int n = targetGrid.size();\\n         int m = targetGrid[0].size();\\n         for(int i=0; i<n; i++){\\n             for(int j=0; j<m; j++){\\n                 if(targetGrid[i][j]!=-1){\\n                     return false;\\n                 }\\n             }\\n         }\\n        return true;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        \\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        \\n        map<int, vector<int> > M = getMinMax(targetGrid);\\n        while(1) {\\n            int f = 0;\\n            vector<int> proc;\\n            for(auto it : M) {\\n                int l = it.first;\\n                if(checkAllSame(it.second[0], it.second[1], it.second[2], it.second[3], targetGrid, l)) { \\n                    f = 1;\\n                    proc.push_back(l);\\n                    replace(it.second[0], it.second[1], it.second[2], it.second[3], targetGrid);\\n                }\\n            \\n            }\\n            for(int z : proc) {\\n                M.erase(M.find(z));\\n            }\\n            if(f == 0) {\\n               break;\\n            }\\n        }\\n        return checkAll(targetGrid);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856998,
                "title": "c-o-mnc-reverse-printing-by-removing-colours",
                "content": "```csharp\\npublic class Solution \\n{\\n    public bool IsPrintable(int[][] targetGrid)\\n    {\\n        int[,] grid = new int[targetGrid.Length, targetGrid[0].Length];\\n        (int minRow, int minColumn, int maxRow, int maxColumn)[] colorBounds = new (int, int, int, int)[61];\\n        for (int i = 0; i < colorBounds.Length; i++)\\n        {\\n            colorBounds[i] = (61, 61, 0, 0);\\n        }\\n        HashSet<int> colors = new HashSet<int>();\\n\\n        for (int i = 0; i < targetGrid.Length; i++)\\n        {\\n            for (int j = 0; j < targetGrid[i].Length; j++)\\n            {   \\n                int color = targetGrid[i][j];\\n                grid[i, j] = color;\\n                colors.Add(color);\\n\\n                colorBounds[color].minRow = Math.Min(colorBounds[color].minRow, i);                    \\n                colorBounds[color].minColumn = Math.Min(colorBounds[color].minColumn, j);\\n                colorBounds[color].maxRow = Math.Max(colorBounds[color].maxRow, i);\\n                colorBounds[color].maxColumn = Math.Max(colorBounds[color].maxColumn, j);\\n            }\\n        }\\n\\n\\n        while (colors.Count > 0)\\n        {\\n            HashSet<int> newColors = new HashSet<int>();\\n            foreach (int color in colors)\\n            {\\n                if (!CanRemoveColor(color, colorBounds[color], grid))\\n                {\\n                    newColors.Add(color);\\n                }\\n            }\\n\\n            // Not able to remove any color\\n            if (newColors.Count == colors.Count)\\n            {\\n                return false;\\n            }\\n\\n            colors = newColors;\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool CanRemoveColor(int color, (int minRow, int minColumn, int maxRow, int maxColumn) colorBound, int[,] grid)\\n    {\\n        for (int i = colorBound.minRow; i <= colorBound.maxRow; i++)\\n        {\\n            for (int j = colorBound.minColumn; j <= colorBound.maxColumn; j++)\\n            {\\n                if (grid[i, j] > 0 && grid[i, j] != color)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = colorBound.minRow; i <= colorBound.maxRow; i++)\\n        {\\n            for (int j = colorBound.minColumn; j <= colorBound.maxColumn; j++)\\n            {\\n                grid[i, j] = 0;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public bool IsPrintable(int[][] targetGrid)\\n    {\\n        int[,] grid = new int[targetGrid.Length, targetGrid[0].Length];\\n        (int minRow, int minColumn, int maxRow, int maxColumn)[] colorBounds = new (int, int, int, int)[61];\\n        for (int i = 0; i < colorBounds.Length; i++)\\n        {\\n            colorBounds[i] = (61, 61, 0, 0);\\n        }\\n        HashSet<int> colors = new HashSet<int>();\\n\\n        for (int i = 0; i < targetGrid.Length; i++)\\n        {\\n            for (int j = 0; j < targetGrid[i].Length; j++)\\n            {   \\n                int color = targetGrid[i][j];\\n                grid[i, j] = color;\\n                colors.Add(color);\\n\\n                colorBounds[color].minRow = Math.Min(colorBounds[color].minRow, i);                    \\n                colorBounds[color].minColumn = Math.Min(colorBounds[color].minColumn, j);\\n                colorBounds[color].maxRow = Math.Max(colorBounds[color].maxRow, i);\\n                colorBounds[color].maxColumn = Math.Max(colorBounds[color].maxColumn, j);\\n            }\\n        }\\n\\n\\n        while (colors.Count > 0)\\n        {\\n            HashSet<int> newColors = new HashSet<int>();\\n            foreach (int color in colors)\\n            {\\n                if (!CanRemoveColor(color, colorBounds[color], grid))\\n                {\\n                    newColors.Add(color);\\n                }\\n            }\\n\\n            // Not able to remove any color\\n            if (newColors.Count == colors.Count)\\n            {\\n                return false;\\n            }\\n\\n            colors = newColors;\\n        }\\n\\n        return true;\\n    }\\n\\n    private bool CanRemoveColor(int color, (int minRow, int minColumn, int maxRow, int maxColumn) colorBound, int[,] grid)\\n    {\\n        for (int i = colorBound.minRow; i <= colorBound.maxRow; i++)\\n        {\\n            for (int j = colorBound.minColumn; j <= colorBound.maxColumn; j++)\\n            {\\n                if (grid[i, j] > 0 && grid[i, j] != color)\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        for (int i = colorBound.minRow; i <= colorBound.maxRow; i++)\\n        {\\n            for (int j = colorBound.minColumn; j <= colorBound.maxColumn; j++)\\n            {\\n                grid[i, j] = 0;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855857,
                "title": "java-clean-solution-with-explanation-o-nmc-c-time",
                "content": "1. Find all rectangles in the grid (color, topLeft, topRight, width and height) - see `findRectangles` function. It takes O(NM) time\\n2. Construct dependency graph (iterate each rectangle from left to right and from top to bottom, each color that differ should be added as edge in the graph) - see `Graph.construct` function. This stage takes O(NMC)\\n3. Check if dependency graph (which is directed) is DAG (directed acyclic graph). I implemented topological sort, see `Graph.isDag` - it takes O(C\\xB2) time\\nOverall we have O(NM + NMC + C\\xB2) ~ O(NMC + C\\xB2) time complexity\\n\\n```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Map<Integer, Rectangle> rectangles = findRectangles(targetGrid);\\n        Graph graph = Graph.construct(targetGrid, rectangles);\\n        return graph.isDag();\\n    }\\n    \\n    private Map<Integer, Rectangle> findRectangles(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        Map<Integer, Rectangle> rectangles = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int color = grid[i][j];\\n                Rectangle rectangle = rectangles.getOrDefault(color, new Rectangle(j, i, 1, 1));\\n                \\n                rectangle = rectangle.enhance(j, i);\\n                rectangles.put(color, rectangle);\\n            }\\n        }\\n        \\n        return rectangles;\\n    }\\n    \\n    private static class Rectangle {\\n        public int x;\\n        public int y;\\n        public int width;\\n        public int height;\\n        \\n        public Rectangle(int x, int y, int width, int height) {\\n            this.x = x;\\n            this.y = y;\\n            this.width = width;\\n            this.height = height;\\n        }\\n        \\n        public Rectangle enhance(int x, int y) {\\n            if (this.x <= x && x < this.x + width && this.y <= y && y < this.y + this.height)\\n                return new Rectangle(this.x, this.y, this.width, this.height);\\n            \\n            int newX = Math.min(x, this.x);\\n            int newY = Math.min(y, this.y);\\n            int newWidth = Math.max(this.x + this.width, x + 1) - newX;\\n            int newHeight = Math.max(this.y + this.height, y + 1) - newY;\\n            \\n            return new Rectangle(newX, newY, newWidth, newHeight);\\n        }\\n    }\\n    \\n    private static class Graph {\\n        private Map<Integer, Set<Integer>> edges;\\n        \\n        public Graph(Map<Integer, Set<Integer>> edges) {\\n            this.edges = edges;\\n        }\\n        \\n        public static Graph construct(int[][] grid, Map<Integer, Rectangle> rectangles) {\\n            int n = grid.length;\\n            int m = grid[0].length;\\n            Map<Integer, Set<Integer>> edges = new HashMap<>();\\n            \\n            for (int color : rectangles.keySet()) {\\n                Rectangle rectangle = rectangles.get(color);\\n                Set<Integer> paths = new HashSet<>();\\n                \\n                for (int x = rectangle.x; x < rectangle.x + rectangle.width; x++) {\\n                    for (int y = rectangle.y; y < rectangle.y + rectangle.height; y++) {\\n                        if (grid[y][x] != color) {\\n                            paths.add(grid[y][x]);\\n                        }\\n                    }\\n                }\\n                \\n                edges.put(color, paths);\\n            }\\n            \\n            return new Graph(edges);\\n        }\\n        \\n        public boolean isDag() {\\n            Map<Integer, Integer> ingoing = new HashMap<>();\\n            for (int color : edges.keySet()) ingoing.put(color, 0);\\n            \\n            for (int color : edges.keySet()) {\\n                for (int edge : edges.get(color)) {\\n                    ingoing.put(edge, ingoing.get(edge) + 1);\\n                }\\n            }\\n            \\n            Queue<Integer> queue = new LinkedList<>();\\n            for (int color : ingoing.keySet()) if (ingoing.get(color) == 0) queue.add(color);\\n            \\n            while (!queue.isEmpty()) {\\n                int color = queue.poll();\\n                for (int neighbour : edges.get(color)) {\\n                    int previous = ingoing.get(neighbour);\\n                    ingoing.put(neighbour, previous - 1);\\n                    \\n                    if (previous == 1) {\\n                        queue.add(neighbour);\\n                    }\\n                }\\n            }\\n            \\n            for (int value : ingoing.values()) {\\n                if (value != 0) return false;\\n            }\\n            \\n            return true;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Map<Integer, Rectangle> rectangles = findRectangles(targetGrid);\\n        Graph graph = Graph.construct(targetGrid, rectangles);\\n        return graph.isDag();\\n    }\\n    \\n    private Map<Integer, Rectangle> findRectangles(int[][] grid) {\\n        int n = grid.length, m = grid[0].length;\\n        Map<Integer, Rectangle> rectangles = new HashMap<>();\\n        \\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                int color = grid[i][j];\\n                Rectangle rectangle = rectangles.getOrDefault(color, new Rectangle(j, i, 1, 1));\\n                \\n                rectangle = rectangle.enhance(j, i);\\n                rectangles.put(color, rectangle);\\n            }\\n        }\\n        \\n        return rectangles;\\n    }\\n    \\n    private static class Rectangle {\\n        public int x;\\n        public int y;\\n        public int width;\\n        public int height;\\n        \\n        public Rectangle(int x, int y, int width, int height) {\\n            this.x = x;\\n            this.y = y;\\n            this.width = width;\\n            this.height = height;\\n        }\\n        \\n        public Rectangle enhance(int x, int y) {\\n            if (this.x <= x && x < this.x + width && this.y <= y && y < this.y + this.height)\\n                return new Rectangle(this.x, this.y, this.width, this.height);\\n            \\n            int newX = Math.min(x, this.x);\\n            int newY = Math.min(y, this.y);\\n            int newWidth = Math.max(this.x + this.width, x + 1) - newX;\\n            int newHeight = Math.max(this.y + this.height, y + 1) - newY;\\n            \\n            return new Rectangle(newX, newY, newWidth, newHeight);\\n        }\\n    }\\n    \\n    private static class Graph {\\n        private Map<Integer, Set<Integer>> edges;\\n        \\n        public Graph(Map<Integer, Set<Integer>> edges) {\\n            this.edges = edges;\\n        }\\n        \\n        public static Graph construct(int[][] grid, Map<Integer, Rectangle> rectangles) {\\n            int n = grid.length;\\n            int m = grid[0].length;\\n            Map<Integer, Set<Integer>> edges = new HashMap<>();\\n            \\n            for (int color : rectangles.keySet()) {\\n                Rectangle rectangle = rectangles.get(color);\\n                Set<Integer> paths = new HashSet<>();\\n                \\n                for (int x = rectangle.x; x < rectangle.x + rectangle.width; x++) {\\n                    for (int y = rectangle.y; y < rectangle.y + rectangle.height; y++) {\\n                        if (grid[y][x] != color) {\\n                            paths.add(grid[y][x]);\\n                        }\\n                    }\\n                }\\n                \\n                edges.put(color, paths);\\n            }\\n            \\n            return new Graph(edges);\\n        }\\n        \\n        public boolean isDag() {\\n            Map<Integer, Integer> ingoing = new HashMap<>();\\n            for (int color : edges.keySet()) ingoing.put(color, 0);\\n            \\n            for (int color : edges.keySet()) {\\n                for (int edge : edges.get(color)) {\\n                    ingoing.put(edge, ingoing.get(edge) + 1);\\n                }\\n            }\\n            \\n            Queue<Integer> queue = new LinkedList<>();\\n            for (int color : ingoing.keySet()) if (ingoing.get(color) == 0) queue.add(color);\\n            \\n            while (!queue.isEmpty()) {\\n                int color = queue.poll();\\n                for (int neighbour : edges.get(color)) {\\n                    int previous = ingoing.get(neighbour);\\n                    ingoing.put(neighbour, previous - 1);\\n                    \\n                    if (previous == 1) {\\n                        queue.add(neighbour);\\n                    }\\n                }\\n            }\\n            \\n            for (int value : ingoing.values()) {\\n                if (value != 0) return false;\\n            }\\n            \\n            return true;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061745,
                "title": "python-rectangle-overlap-graph",
                "content": "# Intuition\\nKey observation, filling color is on full rectangle only, if one rectangle has other color within its borders, then it has to be painted before that color. This way it can be constructed precedence graph, in another words problem becomes detecting is there cycle or not. More precisely for problem to be solvable it has to be DAG, meaning no cycles, otherwise you got chicken and egg situation. Hard part is to detect overlaps after that cycles can be found with various techniques like indegree counting or dfs with visited flags. \\n\\n\\n# Code\\n```\\nclass Solution:\\n    def get_color_borders(self, g, R, C):\\n        color_border = dict()\\n        for r in range(R):\\n            for c in range(C):\\n                color = g[r][c]\\n                if color in color_border:\\n                    border = color_border[color]\\n                    border[0], border[1] = min(border[0], r), min(border[1], c)\\n                    border[2], border[3] = max(border[2], r), max(border[3], c)\\n                else: color_border[color] = [r, c, r, c]     \\n        return color_border\\n\\n    def get_graph_and_indegree(self, color_border, g):\\n        graph, indeg = defaultdict(set), Counter()\\n        for color in color_border:\\n            cb = color_border[color]\\n            for r, c in product(range(cb[0], cb[2] + 1), range(cb[1], cb[3] + 1)):\\n                if g[r][c] != color:\\n                    if color not in graph[g[r][c]]:\\n                        graph[g[r][c]].add(color)\\n                        indeg[color] += 1        \\n        return graph, indeg\\n\\n    def isPrintable(self, g):\\n        R, C  = len(g), len(g[0])\\n        color_border = self.get_color_borders(g, R, C)\\n        graph, indeg = self.get_graph_and_indegree(color_border, g)\\n\\n        qu = deque()\\n\\n        for color in color_border:\\n            if indeg[color] == 0: qu.append(color)\\n\\n        while qu:\\n            color = qu.popleft()\\n            for to in graph[color]:\\n                indeg[to] -= 1\\n                if indeg[to] == 0: qu.append(to)\\n                \\n        return max(indeg.values()) == 0 if indeg else True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Graph",
                    "Topological Sort",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def get_color_borders(self, g, R, C):\\n        color_border = dict()\\n        for r in range(R):\\n            for c in range(C):\\n                color = g[r][c]\\n                if color in color_border:\\n                    border = color_border[color]\\n                    border[0], border[1] = min(border[0], r), min(border[1], c)\\n                    border[2], border[3] = max(border[2], r), max(border[3], c)\\n                else: color_border[color] = [r, c, r, c]     \\n        return color_border\\n\\n    def get_graph_and_indegree(self, color_border, g):\\n        graph, indeg = defaultdict(set), Counter()\\n        for color in color_border:\\n            cb = color_border[color]\\n            for r, c in product(range(cb[0], cb[2] + 1), range(cb[1], cb[3] + 1)):\\n                if g[r][c] != color:\\n                    if color not in graph[g[r][c]]:\\n                        graph[g[r][c]].add(color)\\n                        indeg[color] += 1        \\n        return graph, indeg\\n\\n    def isPrintable(self, g):\\n        R, C  = len(g), len(g[0])\\n        color_border = self.get_color_borders(g, R, C)\\n        graph, indeg = self.get_graph_and_indegree(color_border, g)\\n\\n        qu = deque()\\n\\n        for color in color_border:\\n            if indeg[color] == 0: qu.append(color)\\n\\n        while qu:\\n            color = qu.popleft()\\n            for to in graph[color]:\\n                indeg[to] -= 1\\n                if indeg[to] == 0: qu.append(to)\\n                \\n        return max(indeg.values()) == 0 if indeg else True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041732,
                "title": "c-solution-explanation-with-intuition-and-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLets look this problem backward. Instead of printing, we will try to remove paints in recantangle fashion.  \\nThe colour painted last will be forming a perfect recantangle, so we can easily remove that rectangle and each time we can repeat this. If we are able to do this, this is possible else its not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Find unique colours in the grid\\n2. For each colour, check if we can remove that or not\\n3. If we can remove atleast one colour each iteration then its possible otherwise its not possible and at max we can have iterations equal to unique colours\\n\\n- How to check if a colour can be removed or not?\\n    1. Find the min and max index in a row where that colour exist, lets say x1 and x2.\\n    2. Find the min and max index in a row where that colour exist, lets say y1 and y2.\\n    3. So, now we have a smaller rectangle starting from x1 to x2 row wise and y1 to y2 column wise\\n    4. In this area check if all cells have the same colour that we want to remove or not (or it will have a default value where some colour that is already removed can come)\\n    5. If we can remove, change it to some default value (lets say 0)\\n# Complexity\\n- Time complexity: O(c * c * m * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nc = unique colours\\n\\n- Space complexity: O(1)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        set<int> s;\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int x1=n-1, x2=0, y1=m-1, y2=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                s.insert(targetGrid[i][j]);\\n            }\\n        }\\n        int sz = s.size();\\n        for(int i=0; i<sz; i++) {\\n            int flag = 0;\\n            for(auto colour: s) {\\n                if(remove(targetGrid, colour)){\\n                    flag = colour;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n                return false;\\n            s.erase(flag);\\n        }\\n        return true;\\n    }\\n    bool remove(vector<vector<int>>& targetGrid, int c) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int x1=n-1, x2=0, y1=m-1, y2=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(targetGrid[i][j]==c) {\\n                    x1 = min(i, x1);\\n                    x2 = max(i, x2);\\n                    y1 = min(j, y1);\\n                    y2 = max(j, y2);\\n                }\\n            }\\n        }\\n        for(int i=x1; i<=x2; i++) {\\n            for(int j=y1; j<=y2; j++) {\\n                if(targetGrid[i][j]!=c && targetGrid[i][j]!=0) \\n                    return false;\\n            }\\n        }\\n        for(int i=x1; i<=x2; i++) {\\n            for(int j=y1; j<=y2; j++) {\\n                targetGrid[i][j]=0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        set<int> s;\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int x1=n-1, x2=0, y1=m-1, y2=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                s.insert(targetGrid[i][j]);\\n            }\\n        }\\n        int sz = s.size();\\n        for(int i=0; i<sz; i++) {\\n            int flag = 0;\\n            for(auto colour: s) {\\n                if(remove(targetGrid, colour)){\\n                    flag = colour;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n                return false;\\n            s.erase(flag);\\n        }\\n        return true;\\n    }\\n    bool remove(vector<vector<int>>& targetGrid, int c) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int x1=n-1, x2=0, y1=m-1, y2=0;\\n        for(int i=0; i<n; i++) {\\n            for(int j=0; j<m; j++) {\\n                if(targetGrid[i][j]==c) {\\n                    x1 = min(i, x1);\\n                    x2 = max(i, x2);\\n                    y1 = min(j, y1);\\n                    y2 = max(j, y2);\\n                }\\n            }\\n        }\\n        for(int i=x1; i<=x2; i++) {\\n            for(int j=y1; j<=y2; j++) {\\n                if(targetGrid[i][j]!=c && targetGrid[i][j]!=0) \\n                    return false;\\n            }\\n        }\\n        for(int i=x1; i<=x2; i++) {\\n            for(int j=y1; j<=y2; j++) {\\n                targetGrid[i][j]=0;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946060,
                "title": "python-clean-and-simple-solution-using-topological-sorting",
                "content": "```\\nfrom collections import defaultdict\\nfrom graphlib import CycleError, TopologicalSorter\\nfrom itertools import product\\n\\nMAX_COLOR = 60\\n\\n\\nclass Solution:\\n    def isPrintable(self, M: list[list[int]]) -> bool:\\n        g = self.create_graph(M)\\n\\n        try:\\n            TopologicalSorter(g).prepare()\\n            return True\\n        except CycleError:\\n            return False\\n\\n    @staticmethod\\n    def create_graph(M: list[list[int]]) -> defaultdict[int, set[int]]:\\n        m, n = len(M), len(M[0])\\n\\n        g = defaultdict(set)\\n\\n        for c in range(1, MAX_COLOR + 1):  # notice that order of traversal, it is from smaller to larger color\\n            # now, finding the rectangle containing the color \"c\"\\n            x1, y1 = m, n  # will represent the top left of the square\\n            x2, y2 = -1, -1  # will represent the bottom right of the square\\n\\n            for i, j in product(range(m), range(n)):\\n                if M[i][j] == c:\\n                    x1, y1 = min(x1, i), min(y1, j)\\n                    x2, y2 = max(x2, i), max(y2, j)\\n\\n            for i, j in product(range(x1, x2 + 1), range(y1, y2 + 1)):\\n                if M[i][j] != c:\\n                    g[c].add(M[i][j])\\n\\n        return g\\n```",
                "solutionTags": [
                    "Python3",
                    "Topological Sort"
                ],
                "code": "```\\nfrom collections import defaultdict\\nfrom graphlib import CycleError, TopologicalSorter\\nfrom itertools import product\\n\\nMAX_COLOR = 60\\n\\n\\nclass Solution:\\n    def isPrintable(self, M: list[list[int]]) -> bool:\\n        g = self.create_graph(M)\\n\\n        try:\\n            TopologicalSorter(g).prepare()\\n            return True\\n        except CycleError:\\n            return False\\n\\n    @staticmethod\\n    def create_graph(M: list[list[int]]) -> defaultdict[int, set[int]]:\\n        m, n = len(M), len(M[0])\\n\\n        g = defaultdict(set)\\n\\n        for c in range(1, MAX_COLOR + 1):  # notice that order of traversal, it is from smaller to larger color\\n            # now, finding the rectangle containing the color \"c\"\\n            x1, y1 = m, n  # will represent the top left of the square\\n            x2, y2 = -1, -1  # will represent the bottom right of the square\\n\\n            for i, j in product(range(m), range(n)):\\n                if M[i][j] == c:\\n                    x1, y1 = min(x1, i), min(y1, j)\\n                    x2, y2 = max(x2, i), max(y2, j)\\n\\n            for i, j in product(range(x1, x2 + 1), range(y1, y2 + 1)):\\n                if M[i][j] != c:\\n                    g[c].add(M[i][j])\\n\\n        return g\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3908091,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool checkCycle(int node,vector<int>&vis,vector<int>&dfsVis,\\n   vector<unordered_set<int>>&adj)\\n   {\\n       vis[node]=1;\\n       dfsVis[node]=1;\\n       for (auto it : adj[node] )\\n       {\\n           if (!vis[it])\\n           {\\n               if (checkCycle(it,vis,dfsVis,adj)) return true;\\n           }\\n           else{\\n               if (dfsVis[it])\\n               {\\n                   return true;\\n               }\\n           }\\n       }\\n       dfsVis[node]=0;\\n       return false;\\n   }\\n    bool isPrintable(vector<vector<int>>& targetGrid) \\n    {\\n        int n=targetGrid.size();\\n        int m=targetGrid[0].size();\\n      vector<unordered_set<int>>adj(61);\\n      for (int i=1;i<=60;i++)\\n      {\\n          int minx=n;\\n          int miny=m;\\n          int maxx=0;\\n          int maxy=0;\\n          for (int x=0;x<n;x++)\\n          {\\n              for (int y=0;y<m;y++)\\n              {\\n                  if (targetGrid[x][y]==i)\\n                  {\\n                     minx=min(x,minx);\\n                     miny=min(y,miny);\\n                     maxx=max(x,maxx);\\n                     maxy=max(y,maxy);\\n                  }\\n              }\\n          }\\n          for (int x=minx;x<=maxx;x++)\\n          {\\n              for (int y=miny;y<=maxy;y++)\\n              {\\n                  if (targetGrid[x][y]!=i)\\n                  {\\n                      adj[i].insert(targetGrid[x][y]);\\n                  }\\n              }\\n          }\\n      }  \\n      vector<int>vis(61,0);\\n      vector<int>dfsVis(61,0);\\n      for (int i=1;i<=60;i++)\\n      {\\n          if (vis[i]==0)\\n          {\\n              if (checkCycle(i,vis,dfsVis,adj)) return false;\\n          }\\n      } \\n      return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool checkCycle(int node,vector<int>&vis,vector<int>&dfsVis,\\n   vector<unordered_set<int>>&adj)\\n   {\\n       vis[node]=1;\\n       dfsVis[node]=1;\\n       for (auto it : adj[node] )\\n       {\\n           if (!vis[it])\\n           {\\n               if (checkCycle(it,vis,dfsVis,adj)) return true;\\n           }\\n           else{\\n               if (dfsVis[it])\\n               {\\n                   return true;\\n               }\\n           }\\n       }\\n       dfsVis[node]=0;\\n       return false;\\n   }\\n    bool isPrintable(vector<vector<int>>& targetGrid) \\n    {\\n        int n=targetGrid.size();\\n        int m=targetGrid[0].size();\\n      vector<unordered_set<int>>adj(61);\\n      for (int i=1;i<=60;i++)\\n      {\\n          int minx=n;\\n          int miny=m;\\n          int maxx=0;\\n          int maxy=0;\\n          for (int x=0;x<n;x++)\\n          {\\n              for (int y=0;y<m;y++)\\n              {\\n                  if (targetGrid[x][y]==i)\\n                  {\\n                     minx=min(x,minx);\\n                     miny=min(y,miny);\\n                     maxx=max(x,maxx);\\n                     maxy=max(y,maxy);\\n                  }\\n              }\\n          }\\n          for (int x=minx;x<=maxx;x++)\\n          {\\n              for (int y=miny;y<=maxy;y++)\\n              {\\n                  if (targetGrid[x][y]!=i)\\n                  {\\n                      adj[i].insert(targetGrid[x][y]);\\n                  }\\n              }\\n          }\\n      }  \\n      vector<int>vis(61,0);\\n      vector<int>dfsVis(61,0);\\n      for (int i=1;i<=60;i++)\\n      {\\n          if (vis[i]==0)\\n          {\\n              if (checkCycle(i,vis,dfsVis,adj)) return false;\\n          }\\n      } \\n      return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886125,
                "title": "c-valid-topological-sort-using-cycle-detection-explanatory-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool dfs(int col,vector<int> adj[],vector<int> &vis,vector<int> &pvis,vector<vector<int>>& grid)\\n{\\n    vis[col]=1;\\n    pvis[col]=1;\\n    int i,j;\\n    for(i=adj[col][0];i<=adj[col][1];i++)\\n    {\\n        for(j=adj[col][2];j<=adj[col][3];j++)\\n        {\\n            int ccol=grid[i][j];\\n            if(ccol==col) continue;\\n            if(vis[ccol]==0)\\n            {\\n                bool b=dfs(ccol,adj,vis,pvis,grid);\\n                if(b==false) return false;\\n            }\\n            else if(pvis[ccol]==1)\\n            return false;\\n        }\\n    }\\n    pvis[col]=0;\\n    return true;\\n}\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        int i,j,n=grid.size(),m=grid[0].size();\\n        vector<int> adj[61];\\n        for(i=0;i<61;i++)\\n        {\\n            adj[i].push_back(n);\\n            adj[i].push_back(-1);\\n            adj[i].push_back(m);\\n            adj[i].push_back(-1);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                int a=grid[i][j];\\n                adj[a][0]=min(adj[a][0],i);\\n                adj[a][1]=max(adj[a][1],i);\\n                adj[a][2]=min(adj[a][2],j);\\n                adj[a][3]=max(adj[a][3],j);\\n            }\\n        }\\n        vector<int> vis(61,0),pvis(61,0);\\n        for(i=0;i<61;i++)\\n        {\\n            if(adj[i][0]!=n)\\n            {\\n                bool b=dfs(i,adj,vis,pvis,grid);\\n                if(b==false)\\n                return false;\\n            }\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool dfs(int col,vector<int> adj[],vector<int> &vis,vector<int> &pvis,vector<vector<int>>& grid)\\n{\\n    vis[col]=1;\\n    pvis[col]=1;\\n    int i,j;\\n    for(i=adj[col][0];i<=adj[col][1];i++)\\n    {\\n        for(j=adj[col][2];j<=adj[col][3];j++)\\n        {\\n            int ccol=grid[i][j];\\n            if(ccol==col) continue;\\n            if(vis[ccol]==0)\\n            {\\n                bool b=dfs(ccol,adj,vis,pvis,grid);\\n                if(b==false) return false;\\n            }\\n            else if(pvis[ccol]==1)\\n            return false;\\n        }\\n    }\\n    pvis[col]=0;\\n    return true;\\n}\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        int i,j,n=grid.size(),m=grid[0].size();\\n        vector<int> adj[61];\\n        for(i=0;i<61;i++)\\n        {\\n            adj[i].push_back(n);\\n            adj[i].push_back(-1);\\n            adj[i].push_back(m);\\n            adj[i].push_back(-1);\\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            for(j=0;j<m;j++)\\n            {\\n                int a=grid[i][j];\\n                adj[a][0]=min(adj[a][0],i);\\n                adj[a][1]=max(adj[a][1],i);\\n                adj[a][2]=min(adj[a][2],j);\\n                adj[a][3]=max(adj[a][3],j);\\n            }\\n        }\\n        vector<int> vis(61,0),pvis(61,0);\\n        for(i=0;i<61;i++)\\n        {\\n            if(adj[i][0]!=n)\\n            {\\n                bool b=dfs(i,adj,vis,pvis,grid);\\n                if(b==false)\\n                return false;\\n            }\\n        }\\n        return true;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749277,
                "title": "my-solutions",
                "content": "**1. Use the topological sort to detect whether there exist cycles in the graph**\\n```\\nclass Solution {\\n private:\\n  class Rectangle {\\n   public:\\n    Rectangle() : min_row_(numeric_limits<int>::max())\\n                , max_row_(numeric_limits<int>::min())\\n                , min_col_(numeric_limits<int>::max())\\n                , max_col_(numeric_limits<int>::min()) {\\n    }\\n    \\n    bool is_valid() const {\\n      return min_row_ != numeric_limits<int>::max();\\n    }\\n    \\n    void update(const int r, const int c) {\\n      min_row_ = min(min_row_, r);\\n      max_row_ = max(max_row_, r);\\n      min_col_ = min(min_col_, c);\\n      max_col_ = max(max_col_, c);\\n    }\\n    \\n    int min_row() const {\\n      return min_row_;\\n    }\\n    \\n    int max_row() const {\\n      return max_row_;\\n    }\\n    \\n    int min_col() const {\\n      return min_col_;\\n    }\\n    \\n    int max_col() const {\\n      return max_col_;\\n    }\\n    \\n   private:\\n    int min_row_;\\n    int max_row_;\\n    int min_col_;\\n    int max_col_;\\n  };\\n  \\n public:\\n  bool isPrintable(const vector<vector<int>> &targetGrid) {\\n    const int rows = static_cast<int>(targetGrid.size());\\n    const int cols = static_cast<int>(targetGrid.front().size());\\n    int max_color = numeric_limits<int>::min();\\n    int min_color = numeric_limits<int>::max();\\n    for (const vector<int> &row : targetGrid) {\\n      for (const int color : row) {\\n        max_color = max(max_color, color);\\n        min_color = min(min_color, color);\\n      }\\n    }\\n    const int color_range = max_color - min_color + 1;\\n    \\n    Rectangle color_to_rectangle[color_range];\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        color_to_rectangle[targetGrid[r][c] - min_color].update(r, c);\\n      }\\n    }\\n    \\n    vector<vector<bool>> graph(color_range, vector<bool>(color_range, false));\\n    int indegrees[color_range];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (int color = 0; color < color_range; ++color) {\\n      const Rectangle &rectangle = color_to_rectangle[color];\\n      if (!rectangle.is_valid()) {\\n        continue;\\n      }\\n      \\n      for (int r = rectangle.min_row(); r < rectangle.max_row() + 1; ++r) {\\n        for (int c = rectangle.min_col(); c < rectangle.max_col() + 1; ++c) {\\n          const int target_color = targetGrid[r][c] - min_color;\\n          if (target_color == color) {\\n            continue;\\n          }\\n\\n          if (!graph[color][target_color]) {\\n            graph[color][target_color] = true;\\n            ++indegrees[target_color];\\n          }\\n        }\\n      }\\n    }\\n    \\n    return !has_cycle(graph, indegrees);\\n  }\\n  \\n private:\\n  bool has_cycle(const vector<vector<bool>> &graph, int *indegrees) {\\n    const int n = static_cast<int>(graph.size());\\n    int visited = 0;\\n    queue<int> q;\\n    for (int i = 0; i < n; ++i) {\\n      if (indegrees[i] == 0) {\\n        q.emplace(i);\\n      }\\n    }\\n    \\n    while (!q.empty()) {\\n      const int node = q.front();\\n      q.pop();\\n      ++visited;\\n      for (int next = 0; next < n; ++next) {\\n        if (graph[node][next] && --indegrees[next] == 0) {\\n          q.emplace(next);\\n        }\\n      }\\n    }\\n    return visited != n;\\n  }\\n};\\n```\\n**2. Use the DFS to detect whether there exist cycles in the graph**\\n```\\nclass Solution {\\n private:\\n  enum class State : uint8_t {\\n    unvisited = 0,\\n    visiting,\\n    visited\\n  };\\n  \\n  class Rectangle {\\n   public:\\n    Rectangle() : min_row_(numeric_limits<int>::max())\\n                , max_row_(numeric_limits<int>::min())\\n                , min_col_(numeric_limits<int>::max())\\n                , max_col_(numeric_limits<int>::min()) {\\n    }\\n    \\n    bool is_valid() const {\\n      return min_row_ != numeric_limits<int>::max();\\n    }\\n    \\n    void update(const int r, const int c) {\\n      min_row_ = min(min_row_, r);\\n      max_row_ = max(max_row_, r);\\n      min_col_ = min(min_col_, c);\\n      max_col_ = max(max_col_, c);\\n    }\\n    \\n    int min_row() const {\\n      return min_row_;\\n    }\\n    \\n    int max_row() const {\\n      return max_row_;\\n    }\\n    \\n    int min_col() const {\\n      return min_col_;\\n    }\\n    \\n    int max_col() const {\\n      return max_col_;\\n    }\\n    \\n   private:\\n    int min_row_;\\n    int max_row_;\\n    int min_col_;\\n    int max_col_;\\n  };\\n  \\n public:\\n  bool isPrintable(const vector<vector<int>> &targetGrid) {\\n    const int rows = static_cast<int>(targetGrid.size());\\n    const int cols = static_cast<int>(targetGrid.front().size());\\n    int max_color = numeric_limits<int>::min();\\n    int min_color = numeric_limits<int>::max();\\n    for (const vector<int> &row : targetGrid) {\\n      for (const int color : row) {\\n        max_color = max(max_color, color);\\n        min_color = min(min_color, color);\\n      }\\n    }\\n    const int color_range = max_color - min_color + 1;\\n    \\n    Rectangle color_to_rectangle[color_range];\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        color_to_rectangle[targetGrid[r][c] - min_color].update(r, c);\\n      }\\n    }\\n    \\n    vector<vector<bool>> graph(color_range, vector<bool>(color_range, false));\\n    for (int color = 0; color < color_range; ++color) {\\n      const Rectangle &rectangle = color_to_rectangle[color];\\n      if (!rectangle.is_valid()) {\\n        continue;\\n      }\\n      \\n      for (int r = rectangle.min_row(); r < rectangle.max_row() + 1; ++r) {\\n        for (int c = rectangle.min_col(); c < rectangle.max_col() + 1; ++c) {\\n          const int target_color = targetGrid[r][c] - min_color;\\n          if (target_color == color) {\\n            continue;\\n          }\\n\\n          if (!graph[color][target_color]) {\\n            graph[color][target_color] = true;\\n          }\\n        }\\n      }\\n    }\\n    \\n    return !has_cycle(graph);\\n  }\\n  \\n private:\\n  bool has_cycle(const vector<vector<bool>> &graph) {\\n    const int n = static_cast<int>(graph.size());\\n    State states[n];\\n    memset(states, 0, sizeof(states));\\n    for (int node = 0; node < n; ++node) {\\n      if (dfs(graph, node, states) != State::visited) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  State dfs(const vector<vector<bool>> &graph, const int node, State *states) {\\n    const int n = static_cast<int>(graph.size());\\n    if (states[node] != State::unvisited) {\\n      return states[node];\\n    }\\n    \\n    states[node] = State::visiting;\\n    for (int next = 0; next < n; ++next) {\\n      if (graph[node][next]) {\\n        if (dfs(graph, next, states) != State::visited) {\\n          return states[node];\\n        }\\n      }\\n    }\\n    states[node] = State::visited;\\n    return states[node];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  class Rectangle {\\n   public:\\n    Rectangle() : min_row_(numeric_limits<int>::max())\\n                , max_row_(numeric_limits<int>::min())\\n                , min_col_(numeric_limits<int>::max())\\n                , max_col_(numeric_limits<int>::min()) {\\n    }\\n    \\n    bool is_valid() const {\\n      return min_row_ != numeric_limits<int>::max();\\n    }\\n    \\n    void update(const int r, const int c) {\\n      min_row_ = min(min_row_, r);\\n      max_row_ = max(max_row_, r);\\n      min_col_ = min(min_col_, c);\\n      max_col_ = max(max_col_, c);\\n    }\\n    \\n    int min_row() const {\\n      return min_row_;\\n    }\\n    \\n    int max_row() const {\\n      return max_row_;\\n    }\\n    \\n    int min_col() const {\\n      return min_col_;\\n    }\\n    \\n    int max_col() const {\\n      return max_col_;\\n    }\\n    \\n   private:\\n    int min_row_;\\n    int max_row_;\\n    int min_col_;\\n    int max_col_;\\n  };\\n  \\n public:\\n  bool isPrintable(const vector<vector<int>> &targetGrid) {\\n    const int rows = static_cast<int>(targetGrid.size());\\n    const int cols = static_cast<int>(targetGrid.front().size());\\n    int max_color = numeric_limits<int>::min();\\n    int min_color = numeric_limits<int>::max();\\n    for (const vector<int> &row : targetGrid) {\\n      for (const int color : row) {\\n        max_color = max(max_color, color);\\n        min_color = min(min_color, color);\\n      }\\n    }\\n    const int color_range = max_color - min_color + 1;\\n    \\n    Rectangle color_to_rectangle[color_range];\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        color_to_rectangle[targetGrid[r][c] - min_color].update(r, c);\\n      }\\n    }\\n    \\n    vector<vector<bool>> graph(color_range, vector<bool>(color_range, false));\\n    int indegrees[color_range];\\n    memset(indegrees, 0, sizeof(indegrees));\\n    for (int color = 0; color < color_range; ++color) {\\n      const Rectangle &rectangle = color_to_rectangle[color];\\n      if (!rectangle.is_valid()) {\\n        continue;\\n      }\\n      \\n      for (int r = rectangle.min_row(); r < rectangle.max_row() + 1; ++r) {\\n        for (int c = rectangle.min_col(); c < rectangle.max_col() + 1; ++c) {\\n          const int target_color = targetGrid[r][c] - min_color;\\n          if (target_color == color) {\\n            continue;\\n          }\\n\\n          if (!graph[color][target_color]) {\\n            graph[color][target_color] = true;\\n            ++indegrees[target_color];\\n          }\\n        }\\n      }\\n    }\\n    \\n    return !has_cycle(graph, indegrees);\\n  }\\n  \\n private:\\n  bool has_cycle(const vector<vector<bool>> &graph, int *indegrees) {\\n    const int n = static_cast<int>(graph.size());\\n    int visited = 0;\\n    queue<int> q;\\n    for (int i = 0; i < n; ++i) {\\n      if (indegrees[i] == 0) {\\n        q.emplace(i);\\n      }\\n    }\\n    \\n    while (!q.empty()) {\\n      const int node = q.front();\\n      q.pop();\\n      ++visited;\\n      for (int next = 0; next < n; ++next) {\\n        if (graph[node][next] && --indegrees[next] == 0) {\\n          q.emplace(next);\\n        }\\n      }\\n    }\\n    return visited != n;\\n  }\\n};\\n```\n```\\nclass Solution {\\n private:\\n  enum class State : uint8_t {\\n    unvisited = 0,\\n    visiting,\\n    visited\\n  };\\n  \\n  class Rectangle {\\n   public:\\n    Rectangle() : min_row_(numeric_limits<int>::max())\\n                , max_row_(numeric_limits<int>::min())\\n                , min_col_(numeric_limits<int>::max())\\n                , max_col_(numeric_limits<int>::min()) {\\n    }\\n    \\n    bool is_valid() const {\\n      return min_row_ != numeric_limits<int>::max();\\n    }\\n    \\n    void update(const int r, const int c) {\\n      min_row_ = min(min_row_, r);\\n      max_row_ = max(max_row_, r);\\n      min_col_ = min(min_col_, c);\\n      max_col_ = max(max_col_, c);\\n    }\\n    \\n    int min_row() const {\\n      return min_row_;\\n    }\\n    \\n    int max_row() const {\\n      return max_row_;\\n    }\\n    \\n    int min_col() const {\\n      return min_col_;\\n    }\\n    \\n    int max_col() const {\\n      return max_col_;\\n    }\\n    \\n   private:\\n    int min_row_;\\n    int max_row_;\\n    int min_col_;\\n    int max_col_;\\n  };\\n  \\n public:\\n  bool isPrintable(const vector<vector<int>> &targetGrid) {\\n    const int rows = static_cast<int>(targetGrid.size());\\n    const int cols = static_cast<int>(targetGrid.front().size());\\n    int max_color = numeric_limits<int>::min();\\n    int min_color = numeric_limits<int>::max();\\n    for (const vector<int> &row : targetGrid) {\\n      for (const int color : row) {\\n        max_color = max(max_color, color);\\n        min_color = min(min_color, color);\\n      }\\n    }\\n    const int color_range = max_color - min_color + 1;\\n    \\n    Rectangle color_to_rectangle[color_range];\\n    for (int r = 0; r < rows; ++r) {\\n      for (int c = 0; c < cols; ++c) {\\n        color_to_rectangle[targetGrid[r][c] - min_color].update(r, c);\\n      }\\n    }\\n    \\n    vector<vector<bool>> graph(color_range, vector<bool>(color_range, false));\\n    for (int color = 0; color < color_range; ++color) {\\n      const Rectangle &rectangle = color_to_rectangle[color];\\n      if (!rectangle.is_valid()) {\\n        continue;\\n      }\\n      \\n      for (int r = rectangle.min_row(); r < rectangle.max_row() + 1; ++r) {\\n        for (int c = rectangle.min_col(); c < rectangle.max_col() + 1; ++c) {\\n          const int target_color = targetGrid[r][c] - min_color;\\n          if (target_color == color) {\\n            continue;\\n          }\\n\\n          if (!graph[color][target_color]) {\\n            graph[color][target_color] = true;\\n          }\\n        }\\n      }\\n    }\\n    \\n    return !has_cycle(graph);\\n  }\\n  \\n private:\\n  bool has_cycle(const vector<vector<bool>> &graph) {\\n    const int n = static_cast<int>(graph.size());\\n    State states[n];\\n    memset(states, 0, sizeof(states));\\n    for (int node = 0; node < n; ++node) {\\n      if (dfs(graph, node, states) != State::visited) {\\n        return true;\\n      }\\n    }\\n    return false;\\n  }\\n  \\n  State dfs(const vector<vector<bool>> &graph, const int node, State *states) {\\n    const int n = static_cast<int>(graph.size());\\n    if (states[node] != State::unvisited) {\\n      return states[node];\\n    }\\n    \\n    states[node] = State::visiting;\\n    for (int next = 0; next < n; ++next) {\\n      if (graph[node][next]) {\\n        if (dfs(graph, next, states) != State::visited) {\\n          return states[node];\\n        }\\n      }\\n    }\\n    states[node] = State::visited;\\n    return states[node];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741066,
                "title": "c-easy-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nif you cannot solve in a given way . try it in a reverse way . \\ntry N times  1 to 60 \\ntry every color 1 to 60 \\n- check using f(color , grid ) ;\\n- find out l , r , u , d of that color in a grid \\n- if color not found return 0\\n- now check in that range can another color present other than 0 and color return 0 . \\n-  now make all numbers in that rectangle matrix to 0 .\\n\\nnow check if in  grid all are 0\\'s . if zeros return 1 ;\\nelse continue checking . \\n\\nif no color is matching in that turen return 0 ( means we cannot move forward )\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N ^ 4)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nconst int N = 60 ; \\nclass Solution {\\npublic:\\n    bool vis[N + 1] ;\\n\\n    bool check( vector<vector<int>> &grid ){\\n        int n = grid.size() , m = grid[0].size() ;\\n        for(int i = 0 ; i < n ; ++i ){\\n            for(int j = 0 ; j< m ; ++j ){\\n                if(grid[i][j] != 0 ) return 0 ; \\n            }\\n        }\\n        return 1 ;    \\n    }\\n    bool f(int color , vector<vector<int>>& grid ){\\n        int n = grid.size() , m = grid[0].size() ;\\n        int l = INT_MAX , r = -1 , u = INT_MAX , d = -1 ;\\n\\n        for(int i = 0 ; i < n ; ++i ){\\n            for(int j = 0 ; j< m ; ++j ){\\n                if( grid[i][j] == color ){\\n                    l = min( l , j ) ;\\n                    r = max( r , j ) ;\\n                    u = min( u , i ) ;\\n                    d = max( d , i ) ;\\n                }\\n            }\\n        }\\n\\n        if( l >= m || r < 0 || u >= n || d < 0 ) return 0 ;\\n\\n        bool found = true ; \\n        for(int i = u ; i <= d ; ++i ){\\n            for(int j = l ; j<= r ; ++j ){\\n                if( grid[i][j] == color || grid[i][j] == 0 ) continue ; \\n                else found = false ; \\n            }\\n        }\\n        if(found == false ) return 0 ; \\n        for(int i = u ; i <= d ; ++i ){\\n            for(int j = l ; j<= r ; ++j ){\\n                grid[i][j] = 0 ; \\n            }\\n        }\\n        vis[color] = 1 ;\\n        return 1 ; \\n    }\\n\\n    bool isPrintable(vector<vector<int>>& grid ) {\\n        memset(vis , 0 , sizeof(vis)) ;\\n\\n        for(int turn = 1 ; turn <= N ; ++turn ){\\n            bool found = false ; \\n            for(int col = 1 ; col<= N ; ++col ){\\n                if(!vis[col] )  found = found | f( col , grid ) ;\\n            }\\n            // cout<<turn<<\" \";\\n            if(check(grid)) return 1 ;\\n            if(found == false ) return 0 ; \\n        }\\n        return 1 ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int N = 60 ; \\nclass Solution {\\npublic:\\n    bool vis[N + 1] ;\\n\\n    bool check( vector<vector<int>> &grid ){\\n        int n = grid.size() , m = grid[0].size() ;\\n        for(int i = 0 ; i < n ; ++i ){\\n            for(int j = 0 ; j< m ; ++j ){\\n                if(grid[i][j] != 0 ) return 0 ; \\n            }\\n        }\\n        return 1 ;    \\n    }\\n    bool f(int color , vector<vector<int>>& grid ){\\n        int n = grid.size() , m = grid[0].size() ;\\n        int l = INT_MAX , r = -1 , u = INT_MAX , d = -1 ;\\n\\n        for(int i = 0 ; i < n ; ++i ){\\n            for(int j = 0 ; j< m ; ++j ){\\n                if( grid[i][j] == color ){\\n                    l = min( l , j ) ;\\n                    r = max( r , j ) ;\\n                    u = min( u , i ) ;\\n                    d = max( d , i ) ;\\n                }\\n            }\\n        }\\n\\n        if( l >= m || r < 0 || u >= n || d < 0 ) return 0 ;\\n\\n        bool found = true ; \\n        for(int i = u ; i <= d ; ++i ){\\n            for(int j = l ; j<= r ; ++j ){\\n                if( grid[i][j] == color || grid[i][j] == 0 ) continue ; \\n                else found = false ; \\n            }\\n        }\\n        if(found == false ) return 0 ; \\n        for(int i = u ; i <= d ; ++i ){\\n            for(int j = l ; j<= r ; ++j ){\\n                grid[i][j] = 0 ; \\n            }\\n        }\\n        vis[color] = 1 ;\\n        return 1 ; \\n    }\\n\\n    bool isPrintable(vector<vector<int>>& grid ) {\\n        memset(vis , 0 , sizeof(vis)) ;\\n\\n        for(int turn = 1 ; turn <= N ; ++turn ){\\n            bool found = false ; \\n            for(int col = 1 ; col<= N ; ++col ){\\n                if(!vis[col] )  found = found | f( col , grid ) ;\\n            }\\n            // cout<<turn<<\" \";\\n            if(check(grid)) return 1 ;\\n            if(found == false ) return 0 ; \\n        }\\n        return 1 ; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3722564,
                "title": "java-solution-55-ms-topological-sort-kahn-algorithm",
                "content": "# Intuition\\nsurrounding color comes before the contained color. if blue box contains red box then blue box surely need to be printed first and then only we can print blue box\\n\\n# Approach\\nthis video builds up the approach\\nLeetcode 1591. Strange Printer II : Elite Code.\\n(not posting link here you can search :) )\\n\\n\\n# Complexity\\n- Time complexity: O(60mn)\\n\\n- Space complexity: O(mn)\\n\\n# Code\\n```\\nclass Solution {\\n    private Set<Integer>[] graph;\\n    private int m, n;\\n    private final int maxColor = 60;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        m = targetGrid.length;\\n        n = targetGrid[0].length;\\n        graph = new HashSet[maxColor + 1];\\n        for(int color = 1; color <= maxColor; ++color) {\\n            int minI = m, minJ = n;\\n            int maxI = -1, maxJ = -1;\\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(targetGrid[i][j] == color) {\\n                        minI = Math.min(minI, i);\\n                        minJ = Math.min(minJ, j);\\n                        maxI = Math.max(maxI, i);\\n                        maxJ = Math.max(maxJ, j);\\n                    }\\n                }\\n            }\\n            graph[color] = new HashSet<>();\\n            for(int i = minI; i <= maxI; ++i) {\\n                for(int j = minJ; j <= maxJ; ++j) {\\n                    if(targetGrid[i][j] != color) {\\n                        graph[color].add(targetGrid[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        int[] indegree = new int[maxColor + 1];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for(int color = 1; color <= maxColor; ++color) {\\n            for(Integer containedColor : graph[color]) indegree[containedColor]++;\\n        }\\n        for(int color = 1; color <= maxColor; ++color) {\\n            if(indegree[color] == 0) {\\n                q.offer(color);\\n            }\\n        }\\n        int topoLength = 0;\\n        while(!q.isEmpty()) {\\n            Integer color = q.poll();\\n            topoLength++;\\n            for(Integer containedColor : graph[color]) {\\n                if(--indegree[containedColor] == 0) {\\n                    q.offer(containedColor);\\n                }\\n            }\\n        }\\n        return topoLength == maxColor;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    private Set<Integer>[] graph;\\n    private int m, n;\\n    private final int maxColor = 60;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        m = targetGrid.length;\\n        n = targetGrid[0].length;\\n        graph = new HashSet[maxColor + 1];\\n        for(int color = 1; color <= maxColor; ++color) {\\n            int minI = m, minJ = n;\\n            int maxI = -1, maxJ = -1;\\n            for(int i = 0; i < m; i++) {\\n                for(int j = 0; j < n; j++) {\\n                    if(targetGrid[i][j] == color) {\\n                        minI = Math.min(minI, i);\\n                        minJ = Math.min(minJ, j);\\n                        maxI = Math.max(maxI, i);\\n                        maxJ = Math.max(maxJ, j);\\n                    }\\n                }\\n            }\\n            graph[color] = new HashSet<>();\\n            for(int i = minI; i <= maxI; ++i) {\\n                for(int j = minJ; j <= maxJ; ++j) {\\n                    if(targetGrid[i][j] != color) {\\n                        graph[color].add(targetGrid[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        int[] indegree = new int[maxColor + 1];\\n        Queue<Integer> q = new ArrayDeque<>();\\n        for(int color = 1; color <= maxColor; ++color) {\\n            for(Integer containedColor : graph[color]) indegree[containedColor]++;\\n        }\\n        for(int color = 1; color <= maxColor; ++color) {\\n            if(indegree[color] == 0) {\\n                q.offer(color);\\n            }\\n        }\\n        int topoLength = 0;\\n        while(!q.isEmpty()) {\\n            Integer color = q.poll();\\n            topoLength++;\\n            for(Integer containedColor : graph[color]) {\\n                if(--indegree[containedColor] == 0) {\\n                    q.offer(containedColor);\\n                }\\n            }\\n        }\\n        return topoLength == maxColor;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3562158,
                "title": "brute-force-straight-forward",
                "content": "# Intuition\\nWe can only print rectangles. So in order to print a non-rectangle shape, we need to print a rectangle first, and cover this rectangles with another rectangle with same color. Therefore, the last color we printed, has to be a rectangle (since we cannot cover it with other colors). Therefore, we check if the pattern contains a rectangle, if so, this is the rectangle we color in the end. Then we un-color it, finding what color could we color before coloring the last one. We repeat this process until, we could not find any rectangle (return false), or we could un-color the entire board (return true).\\n\\n# Process\\nWe just check if any rectangle exist. That is, take a color\\'s top left most x and y, and bottom right most x and y, and see if the entire rectangle is the same color. Then, we check if all grids inside this could form any other rectangle.\\n\\n# Complexity\\n- Time complexity:\\nO(CCMN), C is the number of colors, MN is the size of the board.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        map<int, set<pair<int,int>>> all_colors;\\n        for(int i = 0; i < targetGrid.size(); ++i){\\n            for(int j = 0; j < targetGrid[0].size(); ++j){\\n                all_colors[targetGrid[i][j]].insert(make_pair(i, j));\\n            }\\n        }\\n        while(true){\\n            bool could_break = true;\\n            for(auto itr = all_colors.begin(); itr != all_colors.end(); ++itr){\\n                int left_x =  61, left_y = 61;\\n                int right_x = 0, right_y = 0;\\n                for(auto jtr = itr->second.begin(); jtr != itr->second.end(); ++jtr){\\n                    left_x = min(left_x, jtr->first);\\n                    left_y = min(left_y, jtr->second);\\n                    right_x = max(right_x, jtr->first);\\n                    right_y = max(right_y, jtr->second);\\n                }\\n                cout << itr->first << \"color with \" << left_x <<\",\" << left_y << \"  \" << right_x << \",\" << right_y << endl;\\n                // we check if it forms a square\\n                bool satisfy = true;\\n                for(int i = left_x; i <= right_x; ++i){\\n                    for(int j = left_y; j <= right_y; ++j){\\n                        if(targetGrid[i][j] != itr->first && targetGrid[i][j] != -1){\\n                            satisfy = false;\\n                        }\\n                    }\\n                }\\n                if(satisfy){\\n                    could_break = false;\\n                    for(int i = left_x; i <= right_x; ++i){\\n                        for(int j = left_y; j <= right_y; ++j){\\n                            targetGrid[i][j] = -1;\\n                        }\\n                    }\\n                    all_colors.erase(itr->first);\\n                    break;\\n                }\\n            }\\n            if(could_break){\\n                break;\\n            }\\n        }\\n\\n        return all_colors.size() == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        map<int, set<pair<int,int>>> all_colors;\\n        for(int i = 0; i < targetGrid.size(); ++i){\\n            for(int j = 0; j < targetGrid[0].size(); ++j){\\n                all_colors[targetGrid[i][j]].insert(make_pair(i, j));\\n            }\\n        }\\n        while(true){\\n            bool could_break = true;\\n            for(auto itr = all_colors.begin(); itr != all_colors.end(); ++itr){\\n                int left_x =  61, left_y = 61;\\n                int right_x = 0, right_y = 0;\\n                for(auto jtr = itr->second.begin(); jtr != itr->second.end(); ++jtr){\\n                    left_x = min(left_x, jtr->first);\\n                    left_y = min(left_y, jtr->second);\\n                    right_x = max(right_x, jtr->first);\\n                    right_y = max(right_y, jtr->second);\\n                }\\n                cout << itr->first << \"color with \" << left_x <<\",\" << left_y << \"  \" << right_x << \",\" << right_y << endl;\\n                // we check if it forms a square\\n                bool satisfy = true;\\n                for(int i = left_x; i <= right_x; ++i){\\n                    for(int j = left_y; j <= right_y; ++j){\\n                        if(targetGrid[i][j] != itr->first && targetGrid[i][j] != -1){\\n                            satisfy = false;\\n                        }\\n                    }\\n                }\\n                if(satisfy){\\n                    could_break = false;\\n                    for(int i = left_x; i <= right_x; ++i){\\n                        for(int j = left_y; j <= right_y; ++j){\\n                            targetGrid[i][j] = -1;\\n                        }\\n                    }\\n                    all_colors.erase(itr->first);\\n                    break;\\n                }\\n            }\\n            if(could_break){\\n                break;\\n            }\\n        }\\n\\n        return all_colors.size() == 0;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3547757,
                "title": "clean-c-solution-topological-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n\\n        //---------Creating the dependence graph-------------\\n        vector<int> inDegree(61,0);\\n        vector<vector<int>> graph(61);\\n\\n        for(int colr=1; colr<=60; colr++){\\n            // Determine the rectangle of the current color \\'colr\\'\\n            int minx = m, miny = n, maxx = -1, maxy = -1;\\n            for (int x = 0; x < m; ++x) {\\n                for (int y = 0; y < n; ++y) {\\n                    if (targetGrid[x][y] == colr) {\\n                        minx = min(x, minx);\\n                        miny = min(y, miny);\\n                        maxx = max(x, maxx);\\n                        maxy = max(y, maxy);\\n                    }\\n                }\\n            }\\n            // Add any color covering the current color as dependence\\n            for (int tx = minx; tx <= maxx; ++tx) {\\n                for (int ty = miny; ty <= maxy; ++ty) {\\n                    if (targetGrid[tx][ty] != colr){\\n                        graph[colr].push_back(targetGrid[tx][ty]);\\n                        inDegree[targetGrid[tx][ty]]++;\\n                    } \\n                }\\n            }\\n        }\\n\\n        //-------------Kahns Algo------------\\n        int visited = 0;\\n        queue<int> q;\\n        for (int colr = 1; colr <= 60; colr++) {\\n            if (inDegree[colr] == 0)\\n                q.push(colr);\\n        }\\n        \\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            visited++;\\n            for (auto& child : graph[node]) {\\n                if (!(--inDegree[child]))\\n                    q.push(child);\\n            }\\n        }\\n        return visited==60;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n\\n        //---------Creating the dependence graph-------------\\n        vector<int> inDegree(61,0);\\n        vector<vector<int>> graph(61);\\n\\n        for(int colr=1; colr<=60; colr++){\\n            // Determine the rectangle of the current color \\'colr\\'\\n            int minx = m, miny = n, maxx = -1, maxy = -1;\\n            for (int x = 0; x < m; ++x) {\\n                for (int y = 0; y < n; ++y) {\\n                    if (targetGrid[x][y] == colr) {\\n                        minx = min(x, minx);\\n                        miny = min(y, miny);\\n                        maxx = max(x, maxx);\\n                        maxy = max(y, maxy);\\n                    }\\n                }\\n            }\\n            // Add any color covering the current color as dependence\\n            for (int tx = minx; tx <= maxx; ++tx) {\\n                for (int ty = miny; ty <= maxy; ++ty) {\\n                    if (targetGrid[tx][ty] != colr){\\n                        graph[colr].push_back(targetGrid[tx][ty]);\\n                        inDegree[targetGrid[tx][ty]]++;\\n                    } \\n                }\\n            }\\n        }\\n\\n        //-------------Kahns Algo------------\\n        int visited = 0;\\n        queue<int> q;\\n        for (int colr = 1; colr <= 60; colr++) {\\n            if (inDegree[colr] == 0)\\n                q.push(colr);\\n        }\\n        \\n        while (!q.empty()) {\\n            int node = q.front();\\n            q.pop();\\n            visited++;\\n            for (auto& child : graph[node]) {\\n                if (!(--inDegree[child]))\\n                    q.push(child);\\n            }\\n        }\\n        return visited==60;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367936,
                "title": "python-simple-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid):\\n        m, n, dict1 = len(targetGrid), len(targetGrid[0]), defaultdict(set)\\n\\n        for c in range(1,61):\\n            i_mn = j_mn = 60\\n            i_mx = j_mx = 0\\n\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j] == c:\\n                        i_mn = min(i_mn,i)\\n                        i_mx = max(i_mx,i)\\n                        j_mn = min(j_mn,j)\\n                        j_mx = max(j_mx,j)\\n\\n            for i in range(i_mn,i_mx+1):\\n                for j in range(j_mn,j_mx+1):\\n                    if targetGrid[i][j] != c:\\n                        dict1[c].add(targetGrid[i][j])\\n\\n        def dfs(n):\\n            if visited[n]: return visited[n] == 1\\n            visited[n] = 1\\n            if any(dfs(j) for j in dict1[n]): return True\\n            visited[n] = 2\\n            return False \\n\\n        visited = [0]*61\\n\\n        return not any(dfs(i) for i in range(61))\\n\\n\\n\\n            \\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid):\\n        m, n, dict1 = len(targetGrid), len(targetGrid[0]), defaultdict(set)\\n\\n        for c in range(1,61):\\n            i_mn = j_mn = 60\\n            i_mx = j_mx = 0\\n\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j] == c:\\n                        i_mn = min(i_mn,i)\\n                        i_mx = max(i_mx,i)\\n                        j_mn = min(j_mn,j)\\n                        j_mx = max(j_mx,j)\\n\\n            for i in range(i_mn,i_mx+1):\\n                for j in range(j_mn,j_mx+1):\\n                    if targetGrid[i][j] != c:\\n                        dict1[c].add(targetGrid[i][j])\\n\\n        def dfs(n):\\n            if visited[n]: return visited[n] == 1\\n            visited[n] = 1\\n            if any(dfs(j) for j in dict1[n]): return True\\n            visited[n] = 2\\n            return False \\n\\n        visited = [0]*61\\n\\n        return not any(dfs(i) for i in range(61))\\n\\n\\n\\n            \\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357689,
                "title": "c-code-with-simple-explanation-using-dfs",
                "content": "# Intuition\\nOur aim is to determine the sequence for printing colors in sub-matrices that will result in the target matrix. If such a sequence is found, return **true** otherwise, return **false**.\\n\\n# Approach\\nTo establish the order in which colors should be printed to obtain the target matrix, we must identify the top-left and bottom-right corners for each color. Colors within these sub-matrices must be printed after the sub-matrix itself.\\n\\nThis process helps us identify dependencies between colors, which can be represented as a directed graph. If this graph contains a cycle, it is impossible to find an order of colors that will result in the target matrix. However, if the graph is acyclic, we can perform a topological sort to obtain an appropriate color printing order. In this context, our main concern is to determine if a valid color printing order exists or not. \\n\\n# Complexity\\n- Time complexity: $$(n^3)$$\\n\\n- Space complexity: $$(n^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isCycle(int node,bool G[61][61],vector<int> &vis)\\n    {\\n        vis[node] = 2;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(G[node][i] == true && vis[i] == 2)\\n            {\\n                return true;\\n            }\\n            else if(G[node][i] == true && vis[i] == -1)\\n            {\\n                if(isCycle(i,G,vis))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[node] = 1;\\n        return false;\\n    }\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        bool G[61][61]= {0};\\n        for(int color=1;color<=60;color++)\\n        {\\n            int minX = 61,minY = 61,maxX = -1,maxY = -1;\\n            for(int i=0;i<targetGrid.size();i++)\\n            {\\n                for(int j=0;j<targetGrid[0].size();j++)\\n                {\\n                    if(targetGrid[i][j] == color)\\n                    {\\n                        minX = min(minX,i);\\n                        minY = min(minY,j);\\n                        maxX = max(maxX,i);\\n                        maxY = max(maxY,j);\\n                    }\\n                }\\n            }\\n            for(int i=minX;i<=maxX;i++)\\n            {\\n                for(int j=minY;j<=maxY;j++)\\n                {\\n                    if(targetGrid[i][j] != color)\\n                    {\\n                        G[color][targetGrid[i][j]] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> vis(61,-1);\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(vis[i] == -1)\\n            {\\n                if(isCycle(i,G,vis))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isCycle(int node,bool G[61][61],vector<int> &vis)\\n    {\\n        vis[node] = 2;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(G[node][i] == true && vis[i] == 2)\\n            {\\n                return true;\\n            }\\n            else if(G[node][i] == true && vis[i] == -1)\\n            {\\n                if(isCycle(i,G,vis))\\n                {\\n                    return true;\\n                }\\n            }\\n        }\\n        vis[node] = 1;\\n        return false;\\n    }\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        bool G[61][61]= {0};\\n        for(int color=1;color<=60;color++)\\n        {\\n            int minX = 61,minY = 61,maxX = -1,maxY = -1;\\n            for(int i=0;i<targetGrid.size();i++)\\n            {\\n                for(int j=0;j<targetGrid[0].size();j++)\\n                {\\n                    if(targetGrid[i][j] == color)\\n                    {\\n                        minX = min(minX,i);\\n                        minY = min(minY,j);\\n                        maxX = max(maxX,i);\\n                        maxY = max(maxY,j);\\n                    }\\n                }\\n            }\\n            for(int i=minX;i<=maxX;i++)\\n            {\\n                for(int j=minY;j<=maxY;j++)\\n                {\\n                    if(targetGrid[i][j] != color)\\n                    {\\n                        G[color][targetGrid[i][j]] = true;\\n                    }\\n                }\\n            }\\n        }\\n\\n        vector<int> vis(61,-1);\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(vis[i] == -1)\\n            {\\n                if(isCycle(i,G,vis))\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3354966,
                "title": "find-continuous-rectangles-iterative-approach-c",
                "content": "# Intuition\\nThe prerequisite that every color is printed not more than once leads to the central idea of this solution:\\n- The color that is printed last must form a continuous rectangle\\n\\nTherefore we can iteratively solve the problem:\\n- Find continuous rectangle in `targetGrid` with properties:\\n    - All fields are either of color `c` or `dont care`\\n    - No fields outside that rectangle are of color `c`\\n- That rectangle will be printed in color `c`: Replace all `c` with `dont care`\\n- Repeat until all colors have been eliminated or no more suchg rectangles can be found\\n- If no color remains on `targetGrid`, it can be printed by the strange printer\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(mnk^2)$$, with $$m, n$$ dimensions of grid, $$k$$ number of colors\\n\\n- Space complexity:\\n$$O(k)$$ space additional to $$O(mn)$$ for `targetGrid`\\n\\n# Code\\n```\\npublic class Solution {\\n    public bool IsPrintable(int[][] targetGrid) {\\n        int m = targetGrid.Length, n = targetGrid[0].Length;\\n\\n        //this array will contain information of the smallest and \\n        //largest row, col where to find a certain color\\n        int[,] minMax = new int[61, 4];\\n\\n        //colorExists[c] indicates color c exists \\n        bool[] colorExists = new bool[61];\\n\\n        //find smallest and largest row, col where to find a certain color\\n        for(int c = 0; c < 61; c++)\\n        {\\n            minMax[c, 0] = 60;\\n            minMax[c, 2] = 60;\\n        }\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int c = targetGrid[i][j];\\n                colorExists[c] = true;\\n                minMax[c, 0] = Math.Min(minMax[c, 0], i);\\n                minMax[c, 1] = Math.Max(minMax[c, 1], i);\\n                minMax[c, 2] = Math.Min(minMax[c, 2], j);\\n                minMax[c, 3] = Math.Max(minMax[c, 3], j);\\n            }\\n        }\\n\\n        \\n        bool change = true;\\n        while(change)\\n        {\\n            change = false;\\n            //Iterate over all colors, if they exist, check that a \\n            //continuous rectangle containing all occurences exists.\\n            //Then mark that rectangle as printed\\n            for(int c = 1; c < 61; c++)\\n            {\\n                if(!colorExists[c])\\n                    continue;\\n                //is rectangle only this color?\\n                bool isPrintable = true;\\n                for(int i = minMax[c, 0]; isPrintable && i <= minMax[c, 1]; i++)\\n                    for(int j = minMax[c, 2]; isPrintable && j <= minMax[c, 3]; j++)\\n                        if(targetGrid[i][j] != c && targetGrid[i][j] != 0)\\n                            isPrintable = false;\\n                if(!isPrintable)\\n                    continue;\\n                change = true;\\n                //Fill printable rectangle with 0 = dont care\\n                for(int i = minMax[c, 0]; i <= minMax[c, 1]; i++)\\n                    for(int j = minMax[c, 2]; j <= minMax[c, 3]; j++)\\n                        targetGrid[i][j] = 0; \\n                colorExists[c] = false;\\n            }\\n        }\\n        //return true if all colors have been eliminated\\n        return (from x in colorExists where x select x).Count() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array"
                ],
                "code": "```\\npublic class Solution {\\n    public bool IsPrintable(int[][] targetGrid) {\\n        int m = targetGrid.Length, n = targetGrid[0].Length;\\n\\n        //this array will contain information of the smallest and \\n        //largest row, col where to find a certain color\\n        int[,] minMax = new int[61, 4];\\n\\n        //colorExists[c] indicates color c exists \\n        bool[] colorExists = new bool[61];\\n\\n        //find smallest and largest row, col where to find a certain color\\n        for(int c = 0; c < 61; c++)\\n        {\\n            minMax[c, 0] = 60;\\n            minMax[c, 2] = 60;\\n        }\\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                int c = targetGrid[i][j];\\n                colorExists[c] = true;\\n                minMax[c, 0] = Math.Min(minMax[c, 0], i);\\n                minMax[c, 1] = Math.Max(minMax[c, 1], i);\\n                minMax[c, 2] = Math.Min(minMax[c, 2], j);\\n                minMax[c, 3] = Math.Max(minMax[c, 3], j);\\n            }\\n        }\\n\\n        \\n        bool change = true;\\n        while(change)\\n        {\\n            change = false;\\n            //Iterate over all colors, if they exist, check that a \\n            //continuous rectangle containing all occurences exists.\\n            //Then mark that rectangle as printed\\n            for(int c = 1; c < 61; c++)\\n            {\\n                if(!colorExists[c])\\n                    continue;\\n                //is rectangle only this color?\\n                bool isPrintable = true;\\n                for(int i = minMax[c, 0]; isPrintable && i <= minMax[c, 1]; i++)\\n                    for(int j = minMax[c, 2]; isPrintable && j <= minMax[c, 3]; j++)\\n                        if(targetGrid[i][j] != c && targetGrid[i][j] != 0)\\n                            isPrintable = false;\\n                if(!isPrintable)\\n                    continue;\\n                change = true;\\n                //Fill printable rectangle with 0 = dont care\\n                for(int i = minMax[c, 0]; i <= minMax[c, 1]; i++)\\n                    for(int j = minMax[c, 2]; j <= minMax[c, 3]; j++)\\n                        targetGrid[i][j] = 0; \\n                colorExists[c] = false;\\n            }\\n        }\\n        //return true if all colors have been eliminated\\n        return (from x in colorExists where x select x).Count() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343962,
                "title": "python-3-very-fast-beats-100-implicit-directed-graph-search-cycle-with-dfs",
                "content": "![Capture d\\u2019\\xE9cran 2023-03-26 134650.png](https://assets.leetcode.com/users/images/b5c4690d-6d2b-41c0-998e-19ed432ebb1c_1679834845.1809278.png)\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*m)$$ to find limits of rectangle of each color.\\n$$O(n*m*c)$$ to construct the graph ; $$c$$ is the number of colors.\\n$$O(c)$$ to check if there is a cycle in the graph of $$c$$ nodes\\n\\n-> $$O(n*m*c)$$\\n\\n- Space complexity:\\nrectangle is a dictionnary with $$c$$ keys and its values are lists of 4 integers.\\nto_do_after is a dictionnary with $$c$$ keys and values are sets of at most $$c$$ values.\\nstatus is a dictionnary (values are integers) of length $$c$$.\\n\\n-> $$O(c\\xB2)$$\\n\\n# Code\\n```\\nclass Solution:\\n\\n    def isPrintable(self, grid: List[List[int]]) -> bool:      \\n        # You search limits of each color\\'s rectangle  \\n        rectangle = {}\\n        for i, row in enumerate(grid):\\n            for j, color in enumerate(row):\\n                curr = rectangle.get(color, None)\\n                if not curr:\\n                    rectangle[color] = [i, i + 1, j, j + 1]\\n                else:\\n                    if i < curr[0]:\\n                        curr[0] = i\\n                    elif i >= curr[1]:\\n                        curr[1] = i + 1\\n                    if j < curr[2]:\\n                        curr[2] = j\\n                    elif j >= curr[3]:\\n                        curr[3] = j + 1\\n                    rectangle[color] = curr\\n        \\n        # You construct the dependecies graph\\n        to_do_after = {}\\n        for c1 in rectangle.keys():\\n            x, X, y, Y = rectangle[c1]\\n            to_do_after[c1] = set()\\n            for row in grid[x: X]:\\n                for c2 in row[y: Y]:\\n                    if c2 != c1:                        \\n                        if c1 in to_do_after.get(c2, []):\\n                            return False\\n                        to_do_after[c1].add(c2)\\n        \\n        # You check if there is no cycle in the dependencies graph\\n\\n        def cycle(node):\\n            status[node] = IN_PROGRESS\\n            for nn in to_do_after[node]:\\n                if status[nn] is IN_PROGRESS:\\n                    return True\\n                elif status[nn] is NOT_VISITED:\\n                    if cycle(nn):\\n                        return True\\n            status[node] = VISITED\\n            return False\\n        \\n        NOT_VISITED, IN_PROGRESS, VISITED = 1, 2, 3\\n        status = {c: NOT_VISITED for c in to_do_after.keys()}\\n        for c in to_do_after.keys():\\n            if status[c] == NOT_VISITED and cycle(c):\\n                return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n\\n    def isPrintable(self, grid: List[List[int]]) -> bool:      \\n        # You search limits of each color\\'s rectangle  \\n        rectangle = {}\\n        for i, row in enumerate(grid):\\n            for j, color in enumerate(row):\\n                curr = rectangle.get(color, None)\\n                if not curr:\\n                    rectangle[color] = [i, i + 1, j, j + 1]\\n                else:\\n                    if i < curr[0]:\\n                        curr[0] = i\\n                    elif i >= curr[1]:\\n                        curr[1] = i + 1\\n                    if j < curr[2]:\\n                        curr[2] = j\\n                    elif j >= curr[3]:\\n                        curr[3] = j + 1\\n                    rectangle[color] = curr\\n        \\n        # You construct the dependecies graph\\n        to_do_after = {}\\n        for c1 in rectangle.keys():\\n            x, X, y, Y = rectangle[c1]\\n            to_do_after[c1] = set()\\n            for row in grid[x: X]:\\n                for c2 in row[y: Y]:\\n                    if c2 != c1:                        \\n                        if c1 in to_do_after.get(c2, []):\\n                            return False\\n                        to_do_after[c1].add(c2)\\n        \\n        # You check if there is no cycle in the dependencies graph\\n\\n        def cycle(node):\\n            status[node] = IN_PROGRESS\\n            for nn in to_do_after[node]:\\n                if status[nn] is IN_PROGRESS:\\n                    return True\\n                elif status[nn] is NOT_VISITED:\\n                    if cycle(nn):\\n                        return True\\n            status[node] = VISITED\\n            return False\\n        \\n        NOT_VISITED, IN_PROGRESS, VISITED = 1, 2, 3\\n        status = {c: NOT_VISITED for c in to_do_after.keys()}\\n        for c in to_do_after.keys():\\n            if status[c] == NOT_VISITED and cycle(c):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3308965,
                "title": "c-straight-forward-toposort",
                "content": "### Upvote if you Find my solution Helpful!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInstead of filling a solid rectangle with color, we can begin solving the problem by removing the color from the rectangle.\\n\\nTo do this, we should keep track of the starting and ending coordinates of the colored area.\\nWe can only remove the color from the rectangle if it is entirely filled with the same color or if all other colors in the rectangle have already been removed.\\nThis process is similar to a topological ordering of the colors, where a specific color can only be removed once all of the colors it depends on have already been removed.\\n\\n\\n# Complexity\\n- Time complexity :   O ( n x m x 3600)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        vector<vector<int>>adj(61);\\n\\n             // 61 stuff because total number of colors can be 60\\n        vector<int>row_min(61,n),row_max(61,-1),col_min(61,m),col_max(61,-1);\\n\\n            //Getting the Corners of every colors\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                \\n                int x = targetGrid[i][j];       \\n\\n                row_min[x] = min(row_min[x],i);\\n                row_max[x] = max(row_max[x],i);\\n                col_min[x] = min(col_min[x],j);\\n                col_max[x] = max(col_max[x],j);\\n            }\\n        }\\n        \\n            // Generating my Indegree array for Toposort\\n        vector<int>inDegree(61);\\n        for(int color = 1 ; color < 61 ; color++){\\n            for(int i = row_min[color] ; i <= row_max[color] ; i++){\\n                for(int j = col_min[color] ; j <= col_max[color] ; j++){\\n                    int x = targetGrid[i][j];\\n                    if(x != color){\\n                        adj[color].push_back(x);\\n                        inDegree[x]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n            // Simple TopoSort Algorithm\\n        queue<int>q;\\n        for(int color = 1 ; color < 61 ; color++){\\n            if(inDegree[color]==0) q.push(color);\\n        }\\n\\n        int cnt =0;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto it :adj[node]){\\n                inDegree[it]--;\\n                if(inDegree[it]==0) q.push(it);\\n            }\\n        }\\n        if(cnt!=60) return false;\\n    \\n        return true;\\n    }\\n};\\n```\\n\\n.\\n\\n.\\n\\n# Here are some Topological Sort Problems :\\n\\n\\n\\n\\n- Course Schedule : https://leetcode.com/problems/course-schedule/\\n- Course Schedule II: https://leetcode.com/problems/course-schedule-ii/\\n- Sequence Reconstruction: https://leetcode.com/problems/sequence-reconstruction/\\n- Alien Dictionary: https://leetcode.com/problems/alien-dictionary/solution/\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        vector<vector<int>>adj(61);\\n\\n             // 61 stuff because total number of colors can be 60\\n        vector<int>row_min(61,n),row_max(61,-1),col_min(61,m),col_max(61,-1);\\n\\n            //Getting the Corners of every colors\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                \\n                int x = targetGrid[i][j];       \\n\\n                row_min[x] = min(row_min[x],i);\\n                row_max[x] = max(row_max[x],i);\\n                col_min[x] = min(col_min[x],j);\\n                col_max[x] = max(col_max[x],j);\\n            }\\n        }\\n        \\n            // Generating my Indegree array for Toposort\\n        vector<int>inDegree(61);\\n        for(int color = 1 ; color < 61 ; color++){\\n            for(int i = row_min[color] ; i <= row_max[color] ; i++){\\n                for(int j = col_min[color] ; j <= col_max[color] ; j++){\\n                    int x = targetGrid[i][j];\\n                    if(x != color){\\n                        adj[color].push_back(x);\\n                        inDegree[x]++;\\n                    }\\n                }\\n            }\\n        }\\n\\n            // Simple TopoSort Algorithm\\n        queue<int>q;\\n        for(int color = 1 ; color < 61 ; color++){\\n            if(inDegree[color]==0) q.push(color);\\n        }\\n\\n        int cnt =0;\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            cnt++;\\n            for(auto it :adj[node]){\\n                inDegree[it]--;\\n                if(inDegree[it]==0) q.push(it);\\n            }\\n        }\\n        if(cnt!=60) return false;\\n    \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3175080,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n        use std::collections::HashSet;\\n\\n        fn has_circle(curr: usize, dep: &Vec<HashSet<i32>>, vis: &mut Vec<i32>) -> bool {\\n            vis[curr] = 1;\\n            for &d in dep[curr].iter() {\\n                let d = d as usize;\\n                if vis[d] == 2 {\\n                    continue;\\n                }\\n                if vis[d] == 1 {\\n                    return true;\\n                }\\n                if has_circle(d, dep, vis) {\\n                    return true;\\n                }\\n            }\\n            vis[curr] = 2;\\n            false\\n        }\\n\\n        let (m, n) = (target_grid.len() as i32, target_grid[0].len() as i32);\\n        let mut dep = vec![HashSet::new(); 61];\\n        for i in 1..=60 {\\n            let (mut minx, mut miny, mut maxx, mut maxy) = (m, n, -1, -1);\\n            for x in 0..m {\\n                for y in 0..n {\\n                    if target_grid[x as usize][y as usize] == i {\\n                        minx = minx.min(x);\\n                        miny = miny.min(y);\\n                        maxx = maxx.max(x);\\n                        maxy = maxy.max(y);\\n                    }\\n                }\\n            }\\n            for tx in minx..=maxx {\\n                for ty in miny..=maxy {\\n                    if target_grid[tx as usize][ty as usize] != i {\\n                        dep[i as usize].insert(target_grid[tx as usize][ty as usize]);\\n                    }\\n                }\\n            }\\n        }\\n        let mut vis = vec![0; 61];\\n        for i in 1..=60 {\\n            if vis[i] == 0 && has_circle(i, &dep, &mut vis) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n        use std::collections::HashSet;\\n\\n        fn has_circle(curr: usize, dep: &Vec<HashSet<i32>>, vis: &mut Vec<i32>) -> bool {\\n            vis[curr] = 1;\\n            for &d in dep[curr].iter() {\\n                let d = d as usize;\\n                if vis[d] == 2 {\\n                    continue;\\n                }\\n                if vis[d] == 1 {\\n                    return true;\\n                }\\n                if has_circle(d, dep, vis) {\\n                    return true;\\n                }\\n            }\\n            vis[curr] = 2;\\n            false\\n        }\\n\\n        let (m, n) = (target_grid.len() as i32, target_grid[0].len() as i32);\\n        let mut dep = vec![HashSet::new(); 61];\\n        for i in 1..=60 {\\n            let (mut minx, mut miny, mut maxx, mut maxy) = (m, n, -1, -1);\\n            for x in 0..m {\\n                for y in 0..n {\\n                    if target_grid[x as usize][y as usize] == i {\\n                        minx = minx.min(x);\\n                        miny = miny.min(y);\\n                        maxx = maxx.max(x);\\n                        maxy = maxy.max(y);\\n                    }\\n                }\\n            }\\n            for tx in minx..=maxx {\\n                for ty in miny..=maxy {\\n                    if target_grid[tx as usize][ty as usize] != i {\\n                        dep[i as usize].insert(target_grid[tx as usize][ty as usize]);\\n                    }\\n                }\\n            }\\n        }\\n        let mut vis = vec![0; 61];\\n        for i in 1..=60 {\\n            if vis[i] == 0 && has_circle(i, &dep, &mut vis) {\\n                return false;\\n            }\\n        }\\n        true\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3128315,
                "title": "c-toposort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& g) {\\n      map<int ,int >col ;\\n        int n=0 ; \\n        for(auto it : g)\\n        {\\n            for(auto itr : it)\\n            {\\n                col[itr]++ ; \\n                n = max(n , itr) ; \\n            }\\n        }\\n    int c = col.size()  ; \\n        vector<int> maxx(n+1, -1 ) , maxy(n+1 , -1 ) , minx(n+1 , 1e9) , miny(n+1 , 1e9 ) ; \\n    \\n     for(int i =0 ; i<g.size(); i++)\\n     {\\n         for(int j= 0; j<g[0].size(); j++ )\\n         {\\n            \\n             maxx[g[i][j]] = max( maxx[g[i][j]] , i ) ; \\n             maxy[g[i][j]] = max( maxy[g[i][j]] , j ) ; \\n             minx[g[i][j]] = min( minx[g[i][j]] , i ) ; \\n             miny[g[i][j]] = min(miny[g[i][j]] , j ) ;\\n         }\\n     } \\n        map<int ,vector<int>> adj ;\\n        map<int ,int > indegree; \\n        for(int k =1; k<=n; k++ )\\n        {\\n            if(col[k])\\n            for(int i = minx[k]; i<=maxx[k]; i++ )\\n            {\\n                for(int j = miny[k]; j<=maxy[k] ;j++ )\\n                {\\n                    if(g[i][j]!=k)\\n                    {\\n                        adj[k].push_back(g[i][j]) ; \\n                        indegree[g[i][j]]++; \\n                    }\\n                }\\n            }\\n        }\\n        queue<int> q; \\n        \\n        for(int i =1; i<=n; i++ )\\n        {\\n            if(indegree[i]==0 && col[i])\\n            {\\n                q.push(i); \\n                cout << i << endl; \\n            }\\n        }\\n        int sum= 0; \\n        while(!q.empty())\\n        {\\n            int node = q.front() ; \\n            q.pop() ; \\n            sum++; \\n            for(auto it : adj[node])\\n            {\\n                indegree[it]-- ; \\n                if(indegree[it]==0)\\n                {\\n                    q.push(it) ; \\n                }\\n            }\\n        }\\n        \\n        // cout << sum << endl ;\\n        return sum==c; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& g) {\\n      map<int ,int >col ;\\n        int n=0 ; \\n        for(auto it : g)\\n        {\\n            for(auto itr : it)\\n            {\\n                col[itr]++ ; \\n                n = max(n , itr) ; \\n            }\\n        }\\n    int c = col.size()  ; \\n        vector<int> maxx(n+1, -1 ) , maxy(n+1 , -1 ) , minx(n+1 , 1e9) , miny(n+1 , 1e9 ) ; \\n    \\n     for(int i =0 ; i<g.size(); i++)\\n     {\\n         for(int j= 0; j<g[0].size(); j++ )\\n         {\\n            \\n             maxx[g[i][j]] = max( maxx[g[i][j]] , i ) ; \\n             maxy[g[i][j]] = max( maxy[g[i][j]] , j ) ; \\n             minx[g[i][j]] = min( minx[g[i][j]] , i ) ; \\n             miny[g[i][j]] = min(miny[g[i][j]] , j ) ;\\n         }\\n     } \\n        map<int ,vector<int>> adj ;\\n        map<int ,int > indegree; \\n        for(int k =1; k<=n; k++ )\\n        {\\n            if(col[k])\\n            for(int i = minx[k]; i<=maxx[k]; i++ )\\n            {\\n                for(int j = miny[k]; j<=maxy[k] ;j++ )\\n                {\\n                    if(g[i][j]!=k)\\n                    {\\n                        adj[k].push_back(g[i][j]) ; \\n                        indegree[g[i][j]]++; \\n                    }\\n                }\\n            }\\n        }\\n        queue<int> q; \\n        \\n        for(int i =1; i<=n; i++ )\\n        {\\n            if(indegree[i]==0 && col[i])\\n            {\\n                q.push(i); \\n                cout << i << endl; \\n            }\\n        }\\n        int sum= 0; \\n        while(!q.empty())\\n        {\\n            int node = q.front() ; \\n            q.pop() ; \\n            sum++; \\n            for(auto it : adj[node])\\n            {\\n                indegree[it]-- ; \\n                if(indegree[it]==0)\\n                {\\n                    q.push(it) ; \\n                }\\n            }\\n        }\\n        \\n        // cout << sum << endl ;\\n        return sum==c; \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3085815,
                "title": "golang-topological-sorting-easy-understanding",
                "content": "```go\\nfunc isPrintable(targetGrid [][]int) bool {\\n  // Let\\'s find the top-left and bottom-right coordinates for each color\\n  colors := make(map[int][]int)\\n  m, n := len(targetGrid), len(targetGrid[0])\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      c := targetGrid[i][j]\\n      if _, ok := colors[c]; !ok {\\n        colors[c] = []int{math.MaxInt32, math.MaxInt32, math.MinInt32, math.MinInt32}\\n      }\\n      colors[c][0] = min(colors[c][0], i)\\n      colors[c][1] = min(colors[c][1], j)\\n      colors[c][2] = max(colors[c][2], i)\\n      colors[c][3] = max(colors[c][3], j)\\n    }\\n  }\\n  // Now we\\'re going to build a graph on colors based on overlaps.\\n  overlaps := make(map[int]map[int]struct{})\\n  indegrees := make(map[int]int)\\n  for c, coords := range colors {\\n    overlaps[c] = make(map[int]struct{})\\n    for i := coords[0]; i <= coords[2]; i++ {\\n      for j := coords[1]; j <= coords[3]; j++ {\\n        c2 := targetGrid[i][j]\\n        if c != c2 {\\n          if _, ok := overlaps[c][c2]; !ok {\\n            indegrees[c2]++\\n            overlaps[c][c2] = struct{}{}\\n          }\\n        }\\n      }\\n    }\\n  }\\n  // We\\'ll do a topological sorting based on the overlaps. We start by processing\\n  // all nodes that aren\\'t overlapping with anything else. \\n  var queue []int\\n  var handled int\\n  for c := range colors {\\n    if indegrees[c] == 0 {\\n      queue = append(queue, c)\\n    }\\n  }\\n  for len(queue) > 0 {\\n    var newQueue []int\\n    for _, c := range queue {\\n      handled++\\n      for c2 := range overlaps[c] {\\n        indegrees[c2]--\\n        if indegrees[c2] == 0 {\\n          newQueue = append(newQueue, c2)\\n        }\\n      }\\n    }\\n    queue = newQueue\\n  }\\n  // Return whether we can paint all colors\\n  return handled == len(colors)\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Topological Sort"
                ],
                "code": "```go\\nfunc isPrintable(targetGrid [][]int) bool {\\n  // Let\\'s find the top-left and bottom-right coordinates for each color\\n  colors := make(map[int][]int)\\n  m, n := len(targetGrid), len(targetGrid[0])\\n  for i := 0; i < m; i++ {\\n    for j := 0; j < n; j++ {\\n      c := targetGrid[i][j]\\n      if _, ok := colors[c]; !ok {\\n        colors[c] = []int{math.MaxInt32, math.MaxInt32, math.MinInt32, math.MinInt32}\\n      }\\n      colors[c][0] = min(colors[c][0], i)\\n      colors[c][1] = min(colors[c][1], j)\\n      colors[c][2] = max(colors[c][2], i)\\n      colors[c][3] = max(colors[c][3], j)\\n    }\\n  }\\n  // Now we\\'re going to build a graph on colors based on overlaps.\\n  overlaps := make(map[int]map[int]struct{})\\n  indegrees := make(map[int]int)\\n  for c, coords := range colors {\\n    overlaps[c] = make(map[int]struct{})\\n    for i := coords[0]; i <= coords[2]; i++ {\\n      for j := coords[1]; j <= coords[3]; j++ {\\n        c2 := targetGrid[i][j]\\n        if c != c2 {\\n          if _, ok := overlaps[c][c2]; !ok {\\n            indegrees[c2]++\\n            overlaps[c][c2] = struct{}{}\\n          }\\n        }\\n      }\\n    }\\n  }\\n  // We\\'ll do a topological sorting based on the overlaps. We start by processing\\n  // all nodes that aren\\'t overlapping with anything else. \\n  var queue []int\\n  var handled int\\n  for c := range colors {\\n    if indegrees[c] == 0 {\\n      queue = append(queue, c)\\n    }\\n  }\\n  for len(queue) > 0 {\\n    var newQueue []int\\n    for _, c := range queue {\\n      handled++\\n      for c2 := range overlaps[c] {\\n        indegrees[c2]--\\n        if indegrees[c2] == 0 {\\n          newQueue = append(newQueue, c2)\\n        }\\n      }\\n    }\\n    queue = newQueue\\n  }\\n  // Return whether we can paint all colors\\n  return handled == len(colors)\\n}\\n\\nfunc min(a, b int) int {\\n  if a < b {\\n    return a\\n  }\\n  return b\\n}\\n\\nfunc max(a, b int) int {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3043147,
                "title": "python-construct-graph-and-detect-cycle-in-the-directed-graph-easy-implementation",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        minRow, maxRow = defaultdict(lambda: math.inf), defaultdict(lambda:-math.inf)\\n        minCol, maxCol = defaultdict(lambda: math.inf), defaultdict(lambda:-math.inf)\\n\\n        # Part 1 - Finding left/right/top/bottom boundaries of a rectangular color block\\n        M, N = len(targetGrid), len(targetGrid[0])\\n        for i in range(M):\\n            for j in range(N):\\n                color = targetGrid[i][j]\\n                minRow[color], maxRow[color] = min(minRow[color], i), max(maxRow[color], i)\\n                minCol[color], maxCol[color] = min(minCol[color], j), max(maxCol[color], j)\\n        \\n        # Part 2 - Creation of Graph\\n        G = defaultdict(list)\\n        for color in minRow.keys():\\n            for i in range(minRow[color], maxRow[color] + 1):\\n                for j in range(minCol[color], maxCol[color] + 1):\\n                    if targetGrid[i][j] != color:\\n                        G[targetGrid[i][j]].append(color)\\n        \\n        # Part 3 - Cycle Detection Helper Function\\n        def dfs_cycle(node):\\n            visited.add(node)\\n            dfs_visited.add(node)\\n            for nei in G[node]:\\n                if nei in visited and nei in dfs_visited: return True\\n                if nei not in visited:\\n                    if dfs_cycle(nei): return True\\n            dfs_visited.remove(node)\\n            return False\\n\\n        # Part 4 - Cycle Detection in a Directed Graph\\n        visited, dfs_visited = set(), set()\\n        for color in minRow.keys():\\n            if color not in visited:\\n                if dfs_cycle(color):\\n                    return False  \\n        return True\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        minRow, maxRow = defaultdict(lambda: math.inf), defaultdict(lambda:-math.inf)\\n        minCol, maxCol = defaultdict(lambda: math.inf), defaultdict(lambda:-math.inf)\\n\\n        # Part 1 - Finding left/right/top/bottom boundaries of a rectangular color block\\n        M, N = len(targetGrid), len(targetGrid[0])\\n        for i in range(M):\\n            for j in range(N):\\n                color = targetGrid[i][j]\\n                minRow[color], maxRow[color] = min(minRow[color], i), max(maxRow[color], i)\\n                minCol[color], maxCol[color] = min(minCol[color], j), max(maxCol[color], j)\\n        \\n        # Part 2 - Creation of Graph\\n        G = defaultdict(list)\\n        for color in minRow.keys():\\n            for i in range(minRow[color], maxRow[color] + 1):\\n                for j in range(minCol[color], maxCol[color] + 1):\\n                    if targetGrid[i][j] != color:\\n                        G[targetGrid[i][j]].append(color)\\n        \\n        # Part 3 - Cycle Detection Helper Function\\n        def dfs_cycle(node):\\n            visited.add(node)\\n            dfs_visited.add(node)\\n            for nei in G[node]:\\n                if nei in visited and nei in dfs_visited: return True\\n                if nei not in visited:\\n                    if dfs_cycle(nei): return True\\n            dfs_visited.remove(node)\\n            return False\\n\\n        # Part 4 - Cycle Detection in a Directed Graph\\n        visited, dfs_visited = set(), set()\\n        for color in minRow.keys():\\n            if color not in visited:\\n                if dfs_cycle(color):\\n                    return False  \\n        return True\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010297,
                "title": "c-topology-sort-o-n-2-k",
                "content": "# Intuition\\n\\nEach priting rectangle is a layer on the paper. If we treat each layer as a node in a graph, the overlapping relation is an edge from the back layer to the front layer. If the layers could be sorted topologically, the print is valid.\\n\\n![strange-printer-ii.excalidraw.png](https://assets.leetcode.com/users/images/6554a929-79ae-4ecc-b75f-0b38b94be240_1673030311.190599.png)\\n\\n\\n\\n# Code\\n```c++\\nclass Solution {\\npublic:\\n\\n    vector<int> colors;\\n    vector<int> nodes;\\n    vector<vector<int>> layers;\\n    vector<unordered_set<int>> adj;\\n    vector<int> in_degree;\\n    vector<vector<int>> * _grid;\\n\\n    void init_size(int k)\\n    {\\n        colors.resize(k);\\n        layers.resize(k);\\n        adj.resize(k);\\n        in_degree.resize(k, 0);\\n        nodes.resize(61);\\n    }\\n\\n    void build(int u)\\n    {\\n        const auto & r = layers[u];\\n        int self_color = colors[u];\\n        vector<vector<int>> & grid = *_grid;\\n        for (int i = r[0]; i <= r[1]; i++)\\n        {\\n            for (int j = r[2]; j <= r[3]; j++)\\n            {\\n                if (grid[i][j] != self_color)\\n                {\\n                    int v = nodes[grid[i][j]];\\n                    adj[u].insert(v);\\n                }\\n            }\\n        }\\n\\n        for (auto v : adj[u])\\n        {\\n            in_degree[v] ++;\\n        }\\n    }\\n\\n    void topology_sort(int k)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (in_degree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<bool> visited(k, false);\\n        while (!q.empty())\\n        {\\n            int u = q.front();\\n            q.pop();\\n            if (visited[u]) {continue;}\\n            visited[u] = true;\\n\\n            for (auto v : adj[u])\\n            {\\n                in_degree[v] --;\\n                if (in_degree[v] == 0)\\n                {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        unordered_map<int, vector<int>> rect;\\n        int m = grid.size(), n = grid[0].size();\\n        _grid = &grid;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int color = grid[i][j];\\n                if (rect.find(color) == rect.end())\\n                {\\n                    // {top, bottom, left, right}\\n                    rect[color] = {m, -1, n, -1};\\n                }\\n                vector<int> & r = rect[color];\\n                r[0] = std::min(r[0], i);\\n                r[1] = std::max(r[1], i);\\n                r[2] = std::min(r[2], j);\\n                r[3] = std::max(r[3], j);\\n            }\\n        }\\n\\n        int k = rect.size();\\n        init_size(k);\\n        int i = 0;\\n        for (const auto & [color, r] : rect)\\n        {\\n            colors[i] = color;\\n            layers[i] = r;\\n            nodes[color] = i;\\n            i++;\\n        }\\n\\n        for (int u = 0; u < k; u++)\\n        {\\n            build(u);\\n        }\\n\\n        topology_sort(k);\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (in_degree[i] > 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n\\n    vector<int> colors;\\n    vector<int> nodes;\\n    vector<vector<int>> layers;\\n    vector<unordered_set<int>> adj;\\n    vector<int> in_degree;\\n    vector<vector<int>> * _grid;\\n\\n    void init_size(int k)\\n    {\\n        colors.resize(k);\\n        layers.resize(k);\\n        adj.resize(k);\\n        in_degree.resize(k, 0);\\n        nodes.resize(61);\\n    }\\n\\n    void build(int u)\\n    {\\n        const auto & r = layers[u];\\n        int self_color = colors[u];\\n        vector<vector<int>> & grid = *_grid;\\n        for (int i = r[0]; i <= r[1]; i++)\\n        {\\n            for (int j = r[2]; j <= r[3]; j++)\\n            {\\n                if (grid[i][j] != self_color)\\n                {\\n                    int v = nodes[grid[i][j]];\\n                    adj[u].insert(v);\\n                }\\n            }\\n        }\\n\\n        for (auto v : adj[u])\\n        {\\n            in_degree[v] ++;\\n        }\\n    }\\n\\n    void topology_sort(int k)\\n    {\\n        queue<int> q;\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (in_degree[i] == 0)\\n            {\\n                q.push(i);\\n            }\\n        }\\n\\n        vector<bool> visited(k, false);\\n        while (!q.empty())\\n        {\\n            int u = q.front();\\n            q.pop();\\n            if (visited[u]) {continue;}\\n            visited[u] = true;\\n\\n            for (auto v : adj[u])\\n            {\\n                in_degree[v] --;\\n                if (in_degree[v] == 0)\\n                {\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        unordered_map<int, vector<int>> rect;\\n        int m = grid.size(), n = grid[0].size();\\n        _grid = &grid;\\n\\n        for (int i = 0; i < m; i++)\\n        {\\n            for (int j = 0; j < n; j++)\\n            {\\n                int color = grid[i][j];\\n                if (rect.find(color) == rect.end())\\n                {\\n                    // {top, bottom, left, right}\\n                    rect[color] = {m, -1, n, -1};\\n                }\\n                vector<int> & r = rect[color];\\n                r[0] = std::min(r[0], i);\\n                r[1] = std::max(r[1], i);\\n                r[2] = std::min(r[2], j);\\n                r[3] = std::max(r[3], j);\\n            }\\n        }\\n\\n        int k = rect.size();\\n        init_size(k);\\n        int i = 0;\\n        for (const auto & [color, r] : rect)\\n        {\\n            colors[i] = color;\\n            layers[i] = r;\\n            nodes[color] = i;\\n            i++;\\n        }\\n\\n        for (int u = 0; u < k; u++)\\n        {\\n            build(u);\\n        }\\n\\n        topology_sort(k);\\n\\n        for (int i = 0; i < k; i++)\\n        {\\n            if (in_degree[i] > 0)\\n            {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005109,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[][]} targetGrid\\n * @return {boolean}\\n */\\nvar isPrintable = function (targetGrid) {\\n  const n = targetGrid.length;\\n  const m = targetGrid[0].length;\\n  let map = {};\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      const color = targetGrid[i][j];\\n      if (!(color in map)) {\\n        map[color] = {\\n          top: i,\\n          left: j,\\n          down: i,\\n          right: j,\\n        };\\n      } else {\\n        map[color].top = Math.min(map[color].top, i);\\n        map[color].left = Math.min(map[color].left, j);\\n        map[color].down = Math.max(map[color].down, i);\\n        map[color].right = Math.max(map[color].right, j);\\n      }\\n    }\\n  }\\n\\n  while (Object.keys(map).length > 0) {\\n    const next = {};\\n    for (const color in map) {\\n      if (!canPrint(map[color], color, targetGrid)) {\\n        next[color] = map[color];\\n      }\\n    }\\n    if (Object.keys(next).length === Object.keys(map).length) {\\n      return false;\\n    }\\n    map = next;\\n  }\\n  return true;\\n};\\n\\nfunction canPrint(position, color, targetGrid) {\\n  const { top, left, down, right } = position;\\n  for (let i = top; i <= down; i++) {\\n    for (let j = left; j <= right; j++) {\\n      if (targetGrid[i][j] > 0 && targetGrid[i][j] !== Number(color)) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  for (let i = top; i <= down; i++) {\\n    for (let j = left; j <= right; j++) {\\n      targetGrid[i][j] = 0;\\n    }\\n  }\\n  return true;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} targetGrid\\n * @return {boolean}\\n */\\nvar isPrintable = function (targetGrid) {\\n  const n = targetGrid.length;\\n  const m = targetGrid[0].length;\\n  let map = {};\\n\\n  for (let i = 0; i < n; i++) {\\n    for (let j = 0; j < m; j++) {\\n      const color = targetGrid[i][j];\\n      if (!(color in map)) {\\n        map[color] = {\\n          top: i,\\n          left: j,\\n          down: i,\\n          right: j,\\n        };\\n      } else {\\n        map[color].top = Math.min(map[color].top, i);\\n        map[color].left = Math.min(map[color].left, j);\\n        map[color].down = Math.max(map[color].down, i);\\n        map[color].right = Math.max(map[color].right, j);\\n      }\\n    }\\n  }\\n\\n  while (Object.keys(map).length > 0) {\\n    const next = {};\\n    for (const color in map) {\\n      if (!canPrint(map[color], color, targetGrid)) {\\n        next[color] = map[color];\\n      }\\n    }\\n    if (Object.keys(next).length === Object.keys(map).length) {\\n      return false;\\n    }\\n    map = next;\\n  }\\n  return true;\\n};\\n\\nfunction canPrint(position, color, targetGrid) {\\n  const { top, left, down, right } = position;\\n  for (let i = top; i <= down; i++) {\\n    for (let j = left; j <= right; j++) {\\n      if (targetGrid[i][j] > 0 && targetGrid[i][j] !== Number(color)) {\\n        return false;\\n      }\\n    }\\n  }\\n\\n  for (let i = top; i <= down; i++) {\\n    for (let j = left; j <= right; j++) {\\n      targetGrid[i][j] = 0;\\n    }\\n  }\\n  return true;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2990155,
                "title": "python-keep-unpaint-untill-canvas-is-blank",
                "content": "# Code\\r\\n``` python\\r\\nclass Solution:\\r\\n    def isPrintable(self, targetGrid):\\r\\n        R, C, limits = len(mat), len(mat[0]), dict()\\r\\n\\r\\n        for i in range(R):  # using corners of color dict as color\\'s set as well\\r\\n            for j in range(C):\\r\\n                color = mat[i][j]\\r\\n                if color not in limits: limits[color] = [R, C, 0, 0]\\r\\n                limits[color][0] = min(limits[color][0], i)  # min row\\r\\n                limits[color][1] = min(limits[color][1], j)  # max col\\r\\n                limits[color][2] = max(limits[color][2], i)  # min row\\r\\n                limits[color][3] = max(limits[color][3], j)  # max col\\r\\n\\r\\n        def unpaint(color) -> bool:\\r\\n            # test range of color\\r\\n            r, c, R, C = limits[color]\\r\\n            for i in range(r, R + 1):\\r\\n                for j in range(c, C + 1):\\r\\n                    if mat[i][j] not in [0, color]: return False\\r\\n            # unpaint\\r\\n            for i in range(r, R + 1):\\r\\n                for j in range(c, C + 1):\\r\\n                    mat[i][j] = 0\\r\\n\\r\\n            return True\\r\\n\\r\\n        while limits.keys():\\r\\n            unpainted = list(filter(unpaint, limits.keys()))\\r\\n            if not unpainted: return False\\r\\n            for color in unpainted:\\r\\n                del limits[color]\\r\\n\\r\\n        return True\\r\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` python\\r\\nclass Solution:\\r\\n    def isPrintable(self, targetGrid):\\r\\n        R, C, limits = len(mat), len(mat[0]), dict()\\r\\n\\r\\n        for i in range(R):  # using corners of color dict as color\\'s set as well\\r\\n            for j in range(C):\\r\\n                color = mat[i][j]\\r\\n                if color not in limits: limits[color] = [R, C, 0, 0]\\r\\n                limits[color][0] = min(limits[color][0], i)  # min row\\r\\n                limits[color][1] = min(limits[color][1], j)  # max col\\r\\n                limits[color][2] = max(limits[color][2], i)  # min row\\r\\n                limits[color][3] = max(limits[color][3], j)  # max col\\r\\n\\r\\n        def unpaint(color) -> bool:\\r\\n            # test range of color\\r\\n            r, c, R, C = limits[color]\\r\\n            for i in range(r, R + 1):\\r\\n                for j in range(c, C + 1):\\r\\n                    if mat[i][j] not in [0, color]: return False\\r\\n            # unpaint\\r\\n            for i in range(r, R + 1):\\r\\n                for j in range(c, C + 1):\\r\\n                    mat[i][j] = 0\\r\\n\\r\\n            return True\\r\\n\\r\\n        while limits.keys():\\r\\n            unpainted = list(filter(unpaint, limits.keys()))\\r\\n            if not unpainted: return False\\r\\n            for color in unpainted:\\r\\n                del limits[color]\\r\\n\\r\\n        return True\\r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2922174,
                "title": "spend-whole-day-on-this-question-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    void dfs(set<ll>adj[],vector<vector<ll>>&cord,ll current,vector<vector<int>>& targetGrid){\\n        ll up_row=cord[current][0],down_row=cord[current][1],left_col=cord[current][2],right_col=cord[current][3];\\n        for(ll i=up_row;i<=down_row;i++){\\n            for(ll j=left_col;j<=right_col;j++){\\n                if(targetGrid[i][j]!=current){\\n                    adj[current].insert(targetGrid[i][j]);\\n                }\\n            }\\n        }\\n        return;\\n    }\\n\\n    bool checkcycle(set<ll>adj[],ll current,vector<bool>&visited){\\n        visited[current]=true;\\n        for(auto &x:adj[current]){\\n            if(visited[x]==true){\\n                return true;\\n            }\\n            else{\\n                if(checkcycle(adj,x,visited)){\\n                    return true;\\n                }\\n            }\\n        }\\n        visited[current]=false;\\n        return false;\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        ll n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<ll>mp(61,0);\\n        vector<vector<ll>>cord(61,vector<ll>(4));\\n        set<ll>adj[61];\\n        for(ll i=1;i<=60;i++){\\n            for(ll j=0;j<=3;j++){\\n                if(j==0 || j==2){\\n                    cord[i][j]=INT_MAX;\\n                }\\n                else{\\n                    cord[i][j]=INT_MIN;\\n                }\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                mp[targetGrid[i][j]]++;\\n                cord[targetGrid[i][j]][0]=min(cord[targetGrid[i][j]][0],(ll)i);\\n                cord[targetGrid[i][j]][1]=max(cord[targetGrid[i][j]][1],(ll)i);\\n                cord[targetGrid[i][j]][2]=min(cord[targetGrid[i][j]][2],(ll)j);\\n                cord[targetGrid[i][j]][3]=max(cord[targetGrid[i][j]][3],(ll)j);\\n            }\\n        }\\n        for(ll i=1;i<=60;i++){\\n            if(mp[i]>0){\\n                dfs(adj,cord,i,targetGrid);\\n            }\\n        }\\n        vector<bool>visited(61,false);\\n        for(ll i=1;i<=60;i++){\\n            if(mp[i]>0){\\n                if(checkcycle(adj,i,visited)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    void dfs(set<ll>adj[],vector<vector<ll>>&cord,ll current,vector<vector<int>>& targetGrid){\\n        ll up_row=cord[current][0],down_row=cord[current][1],left_col=cord[current][2],right_col=cord[current][3];\\n        for(ll i=up_row;i<=down_row;i++){\\n            for(ll j=left_col;j<=right_col;j++){\\n                if(targetGrid[i][j]!=current){\\n                    adj[current].insert(targetGrid[i][j]);\\n                }\\n            }\\n        }\\n        return;\\n    }\\n\\n    bool checkcycle(set<ll>adj[],ll current,vector<bool>&visited){\\n        visited[current]=true;\\n        for(auto &x:adj[current]){\\n            if(visited[x]==true){\\n                return true;\\n            }\\n            else{\\n                if(checkcycle(adj,x,visited)){\\n                    return true;\\n                }\\n            }\\n        }\\n        visited[current]=false;\\n        return false;\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        ll n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<ll>mp(61,0);\\n        vector<vector<ll>>cord(61,vector<ll>(4));\\n        set<ll>adj[61];\\n        for(ll i=1;i<=60;i++){\\n            for(ll j=0;j<=3;j++){\\n                if(j==0 || j==2){\\n                    cord[i][j]=INT_MAX;\\n                }\\n                else{\\n                    cord[i][j]=INT_MIN;\\n                }\\n            }\\n        }\\n        for(ll i=0;i<n;i++){\\n            for(ll j=0;j<m;j++){\\n                mp[targetGrid[i][j]]++;\\n                cord[targetGrid[i][j]][0]=min(cord[targetGrid[i][j]][0],(ll)i);\\n                cord[targetGrid[i][j]][1]=max(cord[targetGrid[i][j]][1],(ll)i);\\n                cord[targetGrid[i][j]][2]=min(cord[targetGrid[i][j]][2],(ll)j);\\n                cord[targetGrid[i][j]][3]=max(cord[targetGrid[i][j]][3],(ll)j);\\n            }\\n        }\\n        for(ll i=1;i<=60;i++){\\n            if(mp[i]>0){\\n                dfs(adj,cord,i,targetGrid);\\n            }\\n        }\\n        vector<bool>visited(61,false);\\n        for(ll i=1;i<=60;i++){\\n            if(mp[i]>0){\\n                if(checkcycle(adj,i,visited)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2914080,
                "title": "c-47ms-greedy",
                "content": "# Intuition\\nFirst try to find the $$(start-cord, end-cord)$$ fr each color. Now the last color say $$k$$ which was used by printer must have all cells in $$(start-cord(k), end-cord(k))$$ of color $$k$$. So just greedily remove color one by one. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst find the $$start$$ and $$end$$ co-ordinates for all the colors. This can be done in $$O(nm)$$. Then greedily check for every color wheter it have valid cell. Then remove it greedily. \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nlet the total colors be $$k$$. Then time complexit is $$O(nmk^2)$$ but if we assume that $$k = O(n)$$ then it becomes $$O(n^3m)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    bool check_color(vector<vector<int>>& t, pair<int,int> s, pair<int,int> e, int c){\\n\\n        for(int i = s.first; i <= e.first; i++){\\n            for(int j = s.second; j <= e.second; j++){\\n                //cout << c <<\" \"<<t[i][j]<<\" \"<<i <<\" \"<<j << endl;\\n                if(t[i][j] != c && t[i][j] != -1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    void fill(vector<vector<int>>& t, pair<int,int> s, pair<int,int> e){\\n\\n        for(int i = s.first; i <= e.first; i++){\\n            for(int j = s.second; j <= e.second; j++){\\n                t[i][j] = -1;\\n            }\\n        }\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& t) {\\n        \\n        //the start and end locations for colours\\n        unordered_map<int, pair<int,int>> start;\\n        unordered_map<int, pair<int,int>> end;\\n\\n        //now just iterate\\n        int n = t.size();\\n        int m = t[0].size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int c = t[i][j];\\n                \\n                //find the start\\n                auto start_it = start.find(c);\\n                auto end_it = end.find(c);\\n\\n                //start pair and end pair\\n                pair<int,int> start_c;\\n                pair<int,int> end_c;\\n                \\n                if(start_it == start.end()){\\n                    start_c = make_pair(INT_MAX, INT_MAX);\\n                }\\n                else{\\n                    start_c = start_it->second;\\n                }\\n\\n                if(end_it == end.end()){\\n                    end_c = make_pair(INT_MIN, INT_MIN);\\n                }\\n                else{\\n                    end_c = end_it->second;\\n                }\\n\\n                start_c = make_pair(min(i, start_c.first), min(j, start_c.second));\\n                end_c = make_pair(max(i, end_c.first), max(j, end_c.second));\\n\\n                start[c] = start_c;\\n                end[c] = end_c;\\n            }\\n        }\\n\\n        //  for(auto it = start.begin(); it != start.end(); it++){\\n        //     int c = it->first;\\n        //     pair<int, int> t = it->second;\\n        //     cout << c <<\": \"<<t.first <<\",\"<<t.second;\\n        //     t = end[c];\\n        //     cout <<\" - \"<<t.first <<\",\"<<t.second<<endl;\\n        // }\\n\\n        while(true){\\n            bool changed = false;\\n            for(auto it = start.begin(); it != start.end(); it++){\\n                int c = it->first;\\n                pair<int,int> s = it->second;\\n                pair<int,int> e = end[c];\\n\\n                if(check_color(t, s, e, c)){\\n                    fill(t,s,e);\\n                    changed = true;\\n                    start.erase(it);\\n                    end.erase(c);\\n                    break;\\n                }\\n            }\\n            if(!changed){\\n                return false;\\n            }\\n            if(start.size() == 0){\\n                return true;\\n            }\\n        }\\n\\n        return false;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    bool check_color(vector<vector<int>>& t, pair<int,int> s, pair<int,int> e, int c){\\n\\n        for(int i = s.first; i <= e.first; i++){\\n            for(int j = s.second; j <= e.second; j++){\\n                //cout << c <<\" \"<<t[i][j]<<\" \"<<i <<\" \"<<j << endl;\\n                if(t[i][j] != c && t[i][j] != -1){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n\\n    void fill(vector<vector<int>>& t, pair<int,int> s, pair<int,int> e){\\n\\n        for(int i = s.first; i <= e.first; i++){\\n            for(int j = s.second; j <= e.second; j++){\\n                t[i][j] = -1;\\n            }\\n        }\\n    }\\n\\n    bool isPrintable(vector<vector<int>>& t) {\\n        \\n        //the start and end locations for colours\\n        unordered_map<int, pair<int,int>> start;\\n        unordered_map<int, pair<int,int>> end;\\n\\n        //now just iterate\\n        int n = t.size();\\n        int m = t[0].size();\\n        for(int i = 0; i < n; i++){\\n            for(int j = 0; j < m; j++){\\n                int c = t[i][j];\\n                \\n                //find the start\\n                auto start_it = start.find(c);\\n                auto end_it = end.find(c);\\n\\n                //start pair and end pair\\n                pair<int,int> start_c;\\n                pair<int,int> end_c;\\n                \\n                if(start_it == start.end()){\\n                    start_c = make_pair(INT_MAX, INT_MAX);\\n                }\\n                else{\\n                    start_c = start_it->second;\\n                }\\n\\n                if(end_it == end.end()){\\n                    end_c = make_pair(INT_MIN, INT_MIN);\\n                }\\n                else{\\n                    end_c = end_it->second;\\n                }\\n\\n                start_c = make_pair(min(i, start_c.first), min(j, start_c.second));\\n                end_c = make_pair(max(i, end_c.first), max(j, end_c.second));\\n\\n                start[c] = start_c;\\n                end[c] = end_c;\\n            }\\n        }\\n\\n        //  for(auto it = start.begin(); it != start.end(); it++){\\n        //     int c = it->first;\\n        //     pair<int, int> t = it->second;\\n        //     cout << c <<\": \"<<t.first <<\",\"<<t.second;\\n        //     t = end[c];\\n        //     cout <<\" - \"<<t.first <<\",\"<<t.second<<endl;\\n        // }\\n\\n        while(true){\\n            bool changed = false;\\n            for(auto it = start.begin(); it != start.end(); it++){\\n                int c = it->first;\\n                pair<int,int> s = it->second;\\n                pair<int,int> e = end[c];\\n\\n                if(check_color(t, s, e, c)){\\n                    fill(t,s,e);\\n                    changed = true;\\n                    start.erase(it);\\n                    end.erase(c);\\n                    break;\\n                }\\n            }\\n            if(!changed){\\n                return false;\\n            }\\n            if(start.size() == 0){\\n                return true;\\n            }\\n        }\\n\\n        return false;   \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2873114,
                "title": "python-simple-topological-sort-o-c-m-n",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, tg: List[List[int]]) -> bool:\\n        n = len(tg);\\n        m = len(tg[0]);\\n        cr = dict()\\n        for i in range(n):\\n            for j in range(m):\\n                c = tg[i][j];\\n                if(c not in cr):\\n                    cr[c] = [[i,j],[i,j]] # start y,x and end y,x\\n                else:\\n                    cr[c][0][0] = min(i,cr[c][0][0])\\n                    cr[c][0][1] = min(j,cr[c][0][1])\\n                    cr[c][1][0] = max(i,cr[c][1][0])\\n                    cr[c][1][1] = max(j,cr[c][1][1])\\n        colors = {c:i for i,c in enumerate(cr.keys())};\\n        adj = [[False]*len(colors) for i in range(len(colors))]\\n        for c in colors:\\n            u = colors[c]\\n            for i in range(cr[c][0][0],cr[c][1][0]+1):\\n                for j in range(cr[c][0][1],cr[c][1][1]+1):\\n                    v = colors[tg[i][j]]\\n                    if(u!=v):\\n                        adj[u][v] = True;\\n        \\n        visited = 0\\n        hasCycle = False\\n        target = (1<<len(colors))-1\\n        def dfs(u,vis):\\n            nonlocal hasCycle, visited\\n            visited |= (1<<u)\\n            for v in range(len(colors)):\\n                if(adj[u][v]):\\n                    if((vis&(1<<v))>0):\\n                        hasCycle = True\\n                    if(not hasCycle and (visited&(1<<v))==0):\\n                        dfs(v,vis | (1<<v))\\n        for u in range(len(colors)):\\n            if((visited&(1<<u))==0):\\n                dfs(u,1<<u);\\n                if(hasCycle): return False\\n                if(visited==target): return True\\n        return False\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, tg: List[List[int]]) -> bool:\\n        n = len(tg);\\n        m = len(tg[0]);\\n        cr = dict()\\n        for i in range(n):\\n            for j in range(m):\\n                c = tg[i][j];\\n                if(c not in cr):\\n                    cr[c] = [[i,j],[i,j]] # start y,x and end y,x\\n                else:\\n                    cr[c][0][0] = min(i,cr[c][0][0])\\n                    cr[c][0][1] = min(j,cr[c][0][1])\\n                    cr[c][1][0] = max(i,cr[c][1][0])\\n                    cr[c][1][1] = max(j,cr[c][1][1])\\n        colors = {c:i for i,c in enumerate(cr.keys())};\\n        adj = [[False]*len(colors) for i in range(len(colors))]\\n        for c in colors:\\n            u = colors[c]\\n            for i in range(cr[c][0][0],cr[c][1][0]+1):\\n                for j in range(cr[c][0][1],cr[c][1][1]+1):\\n                    v = colors[tg[i][j]]\\n                    if(u!=v):\\n                        adj[u][v] = True;\\n        \\n        visited = 0\\n        hasCycle = False\\n        target = (1<<len(colors))-1\\n        def dfs(u,vis):\\n            nonlocal hasCycle, visited\\n            visited |= (1<<u)\\n            for v in range(len(colors)):\\n                if(adj[u][v]):\\n                    if((vis&(1<<v))>0):\\n                        hasCycle = True\\n                    if(not hasCycle and (visited&(1<<v))==0):\\n                        dfs(v,vis | (1<<v))\\n        for u in range(len(colors)):\\n            if((visited&(1<<u))==0):\\n                dfs(u,1<<u);\\n                if(hasCycle): return False\\n                if(visited==target): return True\\n        return False\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851318,
                "title": "c-cycle-detect",
                "content": "```\\nbool hasCircle(int curr, vector<int>& vis, unordered_map<int, unordered_set<int>>& adj_list){\\n        vis[curr] = 1;\\n        for (const int d : adj_list[curr]) {\\n            if (vis[d] == 2) continue;\\n            if (vis[d] == 1) return true;\\n            if (hasCircle(d, vis, adj_list)) return true;\\n        }\\n        vis[curr] = 2;\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_set<int> set_of_nums;\\n        int max_num = INT_MIN;\\n        using pos = pair<int, int>; //row, col\\n        unordered_map<int, pair<pos, pos>> M;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (M.find(targetGrid[i][j]) != M.end()) {\\n                    pair<pos,pos> p = M[targetGrid[i][j]];\\n                    M.erase(targetGrid[i][j]);\\n                    if (p.second.second > j) \\n                        M.insert(make_pair(targetGrid[i][j], make_pair(make_pair(p.first.first, j), make_pair(i, p.second.second))));\\n                    else \\n                        M.insert(make_pair(targetGrid[i][j], make_pair(p.first, make_pair(i, j))));\\n                }\\n                else {\\n                    M[targetGrid[i][j]] = {{i,j}, {i, j}};\\n                    set_of_nums.insert(targetGrid[i][j]);\\n                    max_num = std::max(max_num, targetGrid[i][j]);\\n                }\\n            }\\n        }\\n                \\n        unordered_map<int, unordered_set<int>> adj_list;\\n        for (auto& elem: M) {\\n            int curr = elem.first;\\n            pos start_pos = elem.second.first;\\n            pos end_pos = elem.second.second;\\n            for (int i = start_pos.first; i <= end_pos.first; i++) {\\n                for (int j = start_pos.second; j <= end_pos.second; j++) {\\n                    if (targetGrid[i][j] != curr) \\n                            adj_list[curr].insert(targetGrid[i][j]);\\n                }\\n            }\\n        }\\n        vector<int> visited(max_num  + 1, 0);\\n        for (int num : set_of_nums) {\\n            if (!visited[num] && hasCircle(num, visited, adj_list)) {\\n                 return false;\\n            }\\n        } \\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nbool hasCircle(int curr, vector<int>& vis, unordered_map<int, unordered_set<int>>& adj_list){\\n        vis[curr] = 1;\\n        for (const int d : adj_list[curr]) {\\n            if (vis[d] == 2) continue;\\n            if (vis[d] == 1) return true;\\n            if (hasCircle(d, vis, adj_list)) return true;\\n        }\\n        vis[curr] = 2;\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_set<int> set_of_nums;\\n        int max_num = INT_MIN;\\n        using pos = pair<int, int>; //row, col\\n        unordered_map<int, pair<pos, pos>> M;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (M.find(targetGrid[i][j]) != M.end()) {\\n                    pair<pos,pos> p = M[targetGrid[i][j]];\\n                    M.erase(targetGrid[i][j]);\\n                    if (p.second.second > j) \\n                        M.insert(make_pair(targetGrid[i][j], make_pair(make_pair(p.first.first, j), make_pair(i, p.second.second))));\\n                    else \\n                        M.insert(make_pair(targetGrid[i][j], make_pair(p.first, make_pair(i, j))));\\n                }\\n                else {\\n                    M[targetGrid[i][j]] = {{i,j}, {i, j}};\\n                    set_of_nums.insert(targetGrid[i][j]);\\n                    max_num = std::max(max_num, targetGrid[i][j]);\\n                }\\n            }\\n        }\\n                \\n        unordered_map<int, unordered_set<int>> adj_list;\\n        for (auto& elem: M) {\\n            int curr = elem.first;\\n            pos start_pos = elem.second.first;\\n            pos end_pos = elem.second.second;\\n            for (int i = start_pos.first; i <= end_pos.first; i++) {\\n                for (int j = start_pos.second; j <= end_pos.second; j++) {\\n                    if (targetGrid[i][j] != curr) \\n                            adj_list[curr].insert(targetGrid[i][j]);\\n                }\\n            }\\n        }\\n        vector<int> visited(max_num  + 1, 0);\\n        for (int num : set_of_nums) {\\n            if (!visited[num] && hasCircle(num, visited, adj_list)) {\\n                 return false;\\n            }\\n        } \\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2799454,
                "title": "topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<int> v[61];\\n        vector<int> present(61,false);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val=targetGrid[i][j];\\n                present[val]=true;\\n                if(v[val].size()==0){\\n                    vector<int> temp={i,i,j,j};\\n                    v[val]=temp;\\n                }\\n                else{\\n                    if(v[val][0]>i){v[val][0]=i;}\\n                    if(v[val][1]<i){v[val][1]=i;}\\n                    if(v[val][2]>j){v[val][2]=j;}\\n                    if(v[val][3]<j){v[val][3]=j;}\\n                }\\n            }\\n        }\\n        unordered_set<int> adj[61];\\n        for(int k=1;k<=60;k++){\\n            if(v[k].size()==0){continue;}\\n            int rs=v[k][0],re=v[k][1],cs=v[k][2],ce=v[k][3];\\n            for(int i=rs;i<=re;i++){\\n                for(int j=cs;j<=ce;j++){\\n                    int val=targetGrid[i][j];\\n                    if(val!=k){\\n                        adj[val].insert(k);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> indeg(61,0);\\n        for(int i=1;i<=60;i++){\\n            for(int u:adj[i]){\\n                indeg[u]++;\\n            }\\n        }\\n        queue<int> q;\\n        int count1=0;\\n        for(int i=1;i<=60;i++){\\n            if(present[i]){count1++;}\\n            if(indeg[i]==0 && present[i]){\\n                q.push(i);\\n            }\\n        }\\n        int count=0;\\n        while(!q.empty()){\\n            int u=q.front();q.pop();\\n            count++;\\n            for(int v:adj[u]){\\n                indeg[v]--;\\n                if(indeg[v]==0){\\n                    q.push(v);\\n                }\\n            }\\n        }\\n        return count==count1;\\n    }\\n};",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<int> v[61];\\n        vector<int> present(61,false);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                int val=targetGrid[i][j];\\n                present[val]=true;\\n                if(v[val].size()==0){\\n                    vector<int> temp={i,i,j,j}",
                "codeTag": "Java"
            },
            {
                "id": 2717470,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    vi(ll)vis;\\n    bool func(const vi(vi(ll))&g, ll nd){ // detect cycle\\n        if(vis[nd]==1){\\n            return 1;\\n        }\\n        if(vis[nd]==2){\\n            return 0;\\n        }\\n        vis[nd]=1;\\n        for(ll child:g[nd]){\\n            if(func(g, child)){\\n                return 1;\\n            }\\n        }\\n        vis[nd]=2;\\n        return 0;\\n    }\\n    bool isPrintable(vector<vector<int>>&v) {\\n        vi(vi(ll))g(61);\\n        ll m=v.size(), n=v[0].size();\\n        for(ll i=1;i<=60;++i){\\n            ll mnx=m, mny=n, mxx=-1, mxy=-1; //  min, max, x, y, blah blah...\\n            for(ll j=0;j<m;++j){\\n                for(ll k=0;k<n;++k){\\n                    if(v[j][k]==i){\\n                        mnx=min(mnx, j), mny=min(mny, k), mxx=max(mxx, j), mxy=max(mxy, k);\\n                    }\\n                }\\n            }\\n            for(ll r=mnx;r<=mxx;++r){\\n                for(ll c=mny;c<=mxy;++c){\\n                    if(v[r][c]!=i){\\n                        g[i].pb(v[r][c]);\\n                    }\\n                }\\n            }\\n        }\\n        vis.assign(61, 0);\\n        for(ll nd=1;nd<=60;++nd){\\n            if(!vis[nd] && func(g, nd)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\ntypedef long long ll;\\n#define vi(x) vector<x>\\n#define pb push_back\\npublic:\\n    vi(ll)vis;\\n    bool func(const vi(vi(ll))&g, ll nd){ // detect cycle\\n        if(vis[nd]==1){\\n            return 1;\\n        }\\n        if(vis[nd]==2){\\n            return 0;\\n        }\\n        vis[nd]=1;\\n        for(ll child:g[nd]){\\n            if(func(g, child)){\\n                return 1;\\n            }\\n        }\\n        vis[nd]=2;\\n        return 0;\\n    }\\n    bool isPrintable(vector<vector<int>>&v) {\\n        vi(vi(ll))g(61);\\n        ll m=v.size(), n=v[0].size();\\n        for(ll i=1;i<=60;++i){\\n            ll mnx=m, mny=n, mxx=-1, mxy=-1; //  min, max, x, y, blah blah...\\n            for(ll j=0;j<m;++j){\\n                for(ll k=0;k<n;++k){\\n                    if(v[j][k]==i){\\n                        mnx=min(mnx, j), mny=min(mny, k), mxx=max(mxx, j), mxy=max(mxy, k);\\n                    }\\n                }\\n            }\\n            for(ll r=mnx;r<=mxx;++r){\\n                for(ll c=mny;c<=mxy;++c){\\n                    if(v[r][c]!=i){\\n                        g[i].pb(v[r][c]);\\n                    }\\n                }\\n            }\\n        }\\n        vis.assign(61, 0);\\n        for(ll nd=1;nd<=60;++nd){\\n            if(!vis[nd] && func(g, nd)){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700331,
                "title": "o-mn-c-no-need-to-actually-repaint-grid-topological-sort-is-trying-too-hard",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, G: List[List[int]]) -> bool:\\n        m = len(G)\\n        n = len(G[0])\\n        # 1) Find \"bounding box\" of each color. Boxes might overlap.\\n        box = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                color = G[i][j]\\n                if color not in box:\\n                    box[color] = [i,j,i,j]\\n                else:\\n                    p = box[color]\\n                    p[:] = min(p[0],i), min(p[1],j), max(p[2],i), max(p[3],j)\\n        # 2) For each cell (i,j), any neighbor that has a different color\\n        #    but is in my color\\'s bounding box must be painted after me.\\n        over = 61*[0]\\n        under = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                c = G[i][j]\\n                p = box[c]\\n                for a,b in [ (i-1,j), (i+1,j), (i,j-1), (i,j+1) ]:\\n                    if p[0] <= a <= p[2] and p[1] <= b <= p[3] and G[a][b] != c and c not in under[G[a][b]]:\\n                        over[c] += 1\\n                        under[G[a][b]].add(c)\\n        # 3) Repeatedly unpaint each color that has no other color over its box.\\n        q = [c for c in range(1,len(over)) if not over[c]]\\n        while q:\\n            top = q.pop()\\n            for c in under[top]:\\n                over[c] -= 1\\n                if over[c] == 0:\\n                    q.append(c)\\n        return not any(over)\\n```",
                "solutionTags": [
                    "Python",
                    "Queue"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, G: List[List[int]]) -> bool:\\n        m = len(G)\\n        n = len(G[0])\\n        # 1) Find \"bounding box\" of each color. Boxes might overlap.\\n        box = dict()\\n        for i in range(m):\\n            for j in range(n):\\n                color = G[i][j]\\n                if color not in box:\\n                    box[color] = [i,j,i,j]\\n                else:\\n                    p = box[color]\\n                    p[:] = min(p[0],i), min(p[1],j), max(p[2],i), max(p[3],j)\\n        # 2) For each cell (i,j), any neighbor that has a different color\\n        #    but is in my color\\'s bounding box must be painted after me.\\n        over = 61*[0]\\n        under = defaultdict(set)\\n        for i in range(m):\\n            for j in range(n):\\n                c = G[i][j]\\n                p = box[c]\\n                for a,b in [ (i-1,j), (i+1,j), (i,j-1), (i,j+1) ]:\\n                    if p[0] <= a <= p[2] and p[1] <= b <= p[3] and G[a][b] != c and c not in under[G[a][b]]:\\n                        over[c] += 1\\n                        under[G[a][b]].add(c)\\n        # 3) Repeatedly unpaint each color that has no other color over its box.\\n        q = [c for c in range(1,len(over)) if not over[c]]\\n        while q:\\n            top = q.pop()\\n            for c in under[top]:\\n                over[c] -= 1\\n                if over[c] == 0:\\n                    q.append(c)\\n        return not any(over)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661798,
                "title": "java-t-o-mn-c-only-check-neighbors-in-4-dirctions",
                "content": "```\\nprivate boolean sln5(int[][] t){\\n        int m = t.length;\\n        int n = t[0].length;\\n        int colorSize = 61;\\n        Set<Integer>[] es = new Set[colorSize];\\n        int[][] cs = new int[colorSize][4];\\n        int[] deg = new int[colorSize];\\n        int[][] dirs = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int i = 0;i<colorSize;i++){\\n            cs[i][0] = m;\\n            cs[i][1] = n;\\n            cs[i][2] = -1;\\n            cs[i][3] = -1;\\n            es[i] = new HashSet<>();\\n        }\\n        for(int i =0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                cs[t[i][j]][0] = Math.min(i, cs[t[i][j]][0]);\\n                cs[t[i][j]][1] = Math.min(j, cs[t[i][j]][1]);\\n                cs[t[i][j]][2] = Math.max(i, cs[t[i][j]][2]);\\n                cs[t[i][j]][3] = Math.max(j, cs[t[i][j]][3]);\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                int c1 = t[i][j];\\n                for(int[] d: dirs){\\n                    int ni = i+d[0];\\n                    int nj = j+d[1];\\n                    if(ni<0 || nj<0 || ni==m || nj==n || t[i][j] == t[ni][nj]) continue;\\n                    int c2 = t[ni][nj];\\n                    if(cs[c1][0] <= ni && cs[c1][1] <= nj && cs[c1][2] >= ni && cs[c1][3] >= nj){\\n                        if(!es[c1].contains(c2)){\\n                            es[c1].add(c2);\\n                            deg[c2]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        Deque<Integer> que = new ArrayDeque<>();\\n        for(int i = 0;i<colorSize;i++){\\n            if(deg[i]==0) que.addLast(i);\\n        }\\n        while(que.size()>0){\\n            int curr = que.removeFirst();\\n            colorSize--;\\n            for(int next: es[curr]){\\n                deg[next]--;\\n                if(deg[next]==0) que.addLast(next);\\n            }\\n        }\\n        return colorSize==0;\\n    }",
                "solutionTags": [],
                "code": "```\\nprivate boolean sln5(int[][] t){\\n        int m = t.length;\\n        int n = t[0].length;\\n        int colorSize = 61;\\n        Set<Integer>[] es = new Set[colorSize];\\n        int[][] cs = new int[colorSize][4];\\n        int[] deg = new int[colorSize];\\n        int[][] dirs = new int[][]{{0,1},{1,0},{0,-1},{-1,0}};\\n        for(int i = 0;i<colorSize;i++){\\n            cs[i][0] = m;\\n            cs[i][1] = n;\\n            cs[i][2] = -1;\\n            cs[i][3] = -1;\\n            es[i] = new HashSet<>();\\n        }\\n        for(int i =0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                cs[t[i][j]][0] = Math.min(i, cs[t[i][j]][0]);\\n                cs[t[i][j]][1] = Math.min(j, cs[t[i][j]][1]);\\n                cs[t[i][j]][2] = Math.max(i, cs[t[i][j]][2]);\\n                cs[t[i][j]][3] = Math.max(j, cs[t[i][j]][3]);\\n            }\\n        }\\n        for(int i = 0;i<m;i++){\\n            for(int j = 0;j<n;j++){\\n                int c1 = t[i][j];\\n                for(int[] d: dirs){\\n                    int ni = i+d[0];\\n                    int nj = j+d[1];\\n                    if(ni<0 || nj<0 || ni==m || nj==n || t[i][j] == t[ni][nj]) continue;\\n                    int c2 = t[ni][nj];\\n                    if(cs[c1][0] <= ni && cs[c1][1] <= nj && cs[c1][2] >= ni && cs[c1][3] >= nj){\\n                        if(!es[c1].contains(c2)){\\n                            es[c1].add(c2);\\n                            deg[c2]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        Deque<Integer> que = new ArrayDeque<>();\\n        for(int i = 0;i<colorSize;i++){\\n            if(deg[i]==0) que.addLast(i);\\n        }\\n        while(que.size()>0){\\n            int curr = que.removeFirst();\\n            colorSize--;\\n            for(int next: es[curr]){\\n                deg[next]--;\\n                if(deg[next]==0) que.addLast(next);\\n            }\\n        }\\n        return colorSize==0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2648045,
                "title": "simple-greedy-approach-no-graphs-explained-python",
                "content": "```\\n   def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        #Greedy Approach:\\n        #instead of figuring out correct color order to paint from first to last\\n        #figure out the order from last to first by removing most recent painted layer\\n        #if u think about it most_recent_painted layer should not interact with any other layers\\n        #since it doesnt interact with other colors, u can remove it move on to different color without any consequence\\n        #if you can strip all the colors, then its possible to paint the matrix\\n        \\n        m = len(targetGrid); n = len(targetGrid[0])\\n        #we need to know the bounds of each color\\n        bounds = [[m, -1, n, -1] for _ in range(61)]#there are 60 colors (1 to 60)\\n        for i in range(m):\\n            for j in range(n):\\n                color = targetGrid[i][j]\\n                bounds[color][0] = min(bounds[color][0], i)\\n                bounds[color][1] = max(bounds[color][1], i)\\n                bounds[color][2] = min(bounds[color][2], j)\\n                bounds[color][3] = max(bounds[color][3], j)\\n        \\n        def canRemove(color):\\n            for i in range(bounds[color][0], bounds[color][1] + 1):\\n                for j in range(bounds[color][2], bounds[color][3] + 1):\\n                    #u cant remove this color, because there is another color sitting on it\\n                    if targetGrid[i][j] and targetGrid[i][j] != color:\\n                        return False\\n            #you can remove this color layer, because there is no another color on it\\n            for i in range(bounds[color][0], bounds[color][1] + 1):\\n                for j in range(bounds[color][2], bounds[color][3] + 1):\\n                    #u cant remove this color, because there is another color sitting on it\\n                    targetGrid[i][j] = 0\\n            return True\\n        \\n        colors = list(range(1, 61))\\n        \\n        #if we assume only one color is removed at a time\\n        #so size of colors goes from 60->59->58->......->2->1->0\\n        #so Time->O(m*n* (60 + 59 + .... + 1)) = O(m*n*colors^2)\\n        #space is O(colors)\\n        while colors:\\n            toDo = []\\n            for color in colors:\\n                if not canRemove(color):\\n                    toDo.append(color)\\n            \\n            #we havnt been able to remove a single color, so its not possible to paint the matrix\\n            if len(toDo) == len(colors):\\n                return False\\n            \\n            colors = toDo #if there is nothing in toDo that means all color layers were removed\\n        \\n        return True\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy",
                    "Depth-First Search",
                    "Topological Sort"
                ],
                "code": "```\\n   def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        #Greedy Approach:\\n        #instead of figuring out correct color order to paint from first to last\\n        #figure out the order from last to first by removing most recent painted layer\\n        #if u think about it most_recent_painted layer should not interact with any other layers\\n        #since it doesnt interact with other colors, u can remove it move on to different color without any consequence\\n        #if you can strip all the colors, then its possible to paint the matrix\\n        \\n        m = len(targetGrid); n = len(targetGrid[0])\\n        #we need to know the bounds of each color\\n        bounds = [[m, -1, n, -1] for _ in range(61)]#there are 60 colors (1 to 60)\\n        for i in range(m):\\n            for j in range(n):\\n                color = targetGrid[i][j]\\n                bounds[color][0] = min(bounds[color][0], i)\\n                bounds[color][1] = max(bounds[color][1], i)\\n                bounds[color][2] = min(bounds[color][2], j)\\n                bounds[color][3] = max(bounds[color][3], j)\\n        \\n        def canRemove(color):\\n            for i in range(bounds[color][0], bounds[color][1] + 1):\\n                for j in range(bounds[color][2], bounds[color][3] + 1):\\n                    #u cant remove this color, because there is another color sitting on it\\n                    if targetGrid[i][j] and targetGrid[i][j] != color:\\n                        return False\\n            #you can remove this color layer, because there is no another color on it\\n            for i in range(bounds[color][0], bounds[color][1] + 1):\\n                for j in range(bounds[color][2], bounds[color][3] + 1):\\n                    #u cant remove this color, because there is another color sitting on it\\n                    targetGrid[i][j] = 0\\n            return True\\n        \\n        colors = list(range(1, 61))\\n        \\n        #if we assume only one color is removed at a time\\n        #so size of colors goes from 60->59->58->......->2->1->0\\n        #so Time->O(m*n* (60 + 59 + .... + 1)) = O(m*n*colors^2)\\n        #space is O(colors)\\n        while colors:\\n            toDo = []\\n            for color in colors:\\n                if not canRemove(color):\\n                    toDo.append(color)\\n            \\n            #we havnt been able to remove a single color, so its not possible to paint the matrix\\n            if len(toDo) == len(colors):\\n                return False\\n            \\n            colors = toDo #if there is nothing in toDo that means all color layers were removed\\n        \\n        return True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2640520,
                "title": "my-first-intuitive-c-recursive-solution-removing-layers-backwards-33ms",
                "content": "```\\nclass Solution {\\n    struct GridBounds {\\n        int left = -1;\\n        int right = -1;\\n        int upper = -1;\\n        int lower = -1;\\n        int color = -1;        \\n    };\\n\\npublic:\\n    bool isPrintable(std::vector<std::vector<int>>& targetGrid) {\\n        bool ret = true;\\n        std::unordered_set<int> underlying_colors;\\n        for (int i = 0; i < targetGrid.size(); ++i) {\\n            if (ret == false) {\\n                return false;\\n            }\\n            auto it = std::find_if_not(targetGrid[i].begin(), targetGrid[i].end(), [](int color) {\\n                return color == -1;\\n                                       });\\n            if (it == targetGrid[i].end()) {\\n                if (i == targetGrid.size() - 1) {\\n                    break;\\n                }\\n                continue;\\n            }            \\n            ret = isSolid(targetGrid, GetBounds(targetGrid, *it), underlying_colors);\\n            i = 0;\\n        }\\n        return ret;\\n    }\\n\\nprivate:\\n    GridBounds GetBounds(std::vector<std::vector<int>>& t, int color) {\\n        GridBounds bounds;\\n        bounds.color = color;\\n        auto Checker = [color](int col) {\\n            return col == color;\\n        };\\n        for (auto v_it = t.begin(); v_it != t.end(); ++v_it) {\\n            auto it = std::find_if(v_it->begin(), v_it->end(), Checker);\\n            if (it == v_it->end()) {\\n                continue;\\n            }\\n            if (bounds.upper == -1) {\\n                bounds.upper = v_it - t.begin();\\n            }\\n            bounds.lower = v_it - t.begin();\\n            bounds.left = bounds.left == -1 ? std::distance(v_it->begin(), it) : std::min(bounds.left, static_cast<int>(std::distance(v_it->begin(), it)));\\n            auto r_it = std::find_if(v_it->rbegin(), v_it->rend(), Checker);\\n            bounds.right = bounds.right == -1 ? std::distance(v_it->begin(), r_it.base() - 1) : std::max(bounds.right, static_cast<int>(std::distance(v_it->begin(), r_it.base() - 1)));\\n        }\\n        return bounds;\\n    }\\n\\n    bool isSolid(std::vector<std::vector<int>>& t, GridBounds grid, std::unordered_set<int>& underlying_colors) {\\n        int this_color = grid.color;\\n        for (int y = grid.upper; y <= grid.lower; ++y) {\\n            for (int x = grid.left; x <= grid.right; ++x) {\\n                if (underlying_colors.count(t[y][x]) != 0) {\\n                    return false;\\n                }\\n                if (t[y][x] == -1) {\\n                    continue;\\n                }\\n                if (t[y][x] != this_color) {\\n                    underlying_colors.insert(this_color);\\n                    if (isSolid(t, GetBounds(t, t[y][x]), underlying_colors)) {                        \\n                        underlying_colors.erase(this_color);\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        MarkDeleted(t, grid);\\n        return true;\\n    }\\n\\n    void MarkDeleted(std::vector<std::vector<int>>& t, GridBounds grid) {\\n        for (int y = grid.upper; y <= grid.lower; ++y) {\\n            for (int x = grid.left; x <= grid.right; ++x) {\\n                t[y][x] = -1;\\n            }\\n        }\\n    }\\n};\\n```\\n\\nMy first try without looking into common solution with Graphs. Anyway going to study and understand other ways))",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    struct GridBounds {\\n        int left = -1;\\n        int right = -1;\\n        int upper = -1;\\n        int lower = -1;\\n        int color = -1;        \\n    };\\n\\npublic:\\n    bool isPrintable(std::vector<std::vector<int>>& targetGrid) {\\n        bool ret = true;\\n        std::unordered_set<int> underlying_colors;\\n        for (int i = 0; i < targetGrid.size(); ++i) {\\n            if (ret == false) {\\n                return false;\\n            }\\n            auto it = std::find_if_not(targetGrid[i].begin(), targetGrid[i].end(), [](int color) {\\n                return color == -1;\\n                                       });\\n            if (it == targetGrid[i].end()) {\\n                if (i == targetGrid.size() - 1) {\\n                    break;\\n                }\\n                continue;\\n            }            \\n            ret = isSolid(targetGrid, GetBounds(targetGrid, *it), underlying_colors);\\n            i = 0;\\n        }\\n        return ret;\\n    }\\n\\nprivate:\\n    GridBounds GetBounds(std::vector<std::vector<int>>& t, int color) {\\n        GridBounds bounds;\\n        bounds.color = color;\\n        auto Checker = [color](int col) {\\n            return col == color;\\n        };\\n        for (auto v_it = t.begin(); v_it != t.end(); ++v_it) {\\n            auto it = std::find_if(v_it->begin(), v_it->end(), Checker);\\n            if (it == v_it->end()) {\\n                continue;\\n            }\\n            if (bounds.upper == -1) {\\n                bounds.upper = v_it - t.begin();\\n            }\\n            bounds.lower = v_it - t.begin();\\n            bounds.left = bounds.left == -1 ? std::distance(v_it->begin(), it) : std::min(bounds.left, static_cast<int>(std::distance(v_it->begin(), it)));\\n            auto r_it = std::find_if(v_it->rbegin(), v_it->rend(), Checker);\\n            bounds.right = bounds.right == -1 ? std::distance(v_it->begin(), r_it.base() - 1) : std::max(bounds.right, static_cast<int>(std::distance(v_it->begin(), r_it.base() - 1)));\\n        }\\n        return bounds;\\n    }\\n\\n    bool isSolid(std::vector<std::vector<int>>& t, GridBounds grid, std::unordered_set<int>& underlying_colors) {\\n        int this_color = grid.color;\\n        for (int y = grid.upper; y <= grid.lower; ++y) {\\n            for (int x = grid.left; x <= grid.right; ++x) {\\n                if (underlying_colors.count(t[y][x]) != 0) {\\n                    return false;\\n                }\\n                if (t[y][x] == -1) {\\n                    continue;\\n                }\\n                if (t[y][x] != this_color) {\\n                    underlying_colors.insert(this_color);\\n                    if (isSolid(t, GetBounds(t, t[y][x]), underlying_colors)) {                        \\n                        underlying_colors.erase(this_color);\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n            }\\n        }\\n        MarkDeleted(t, grid);\\n        return true;\\n    }\\n\\n    void MarkDeleted(std::vector<std::vector<int>>& t, GridBounds grid) {\\n        for (int y = grid.upper; y <= grid.lower; ++y) {\\n            for (int x = grid.left; x <= grid.right; ++x) {\\n                t[y][x] = -1;\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632686,
                "title": "c-straight-forward-less-space",
                "content": "Here below is my solution (without topological sort; it\\'s still a bit hard for me :D)\\n```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        vector<vector<int>>& tg = targetGrid;\\n        map<int, pair<pair<int, int>, pair<int, int>>> color;\\n        const int m = tg.size(), n = tg[0].size();\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if(color.count(tg[i][j])){\\n                    auto &range = color[tg[i][j]];\\n                    auto &p1 = range.first, &p2 = range.second;\\n                    int &x1 = p1.first, &y1 = p1.second;\\n                    int &x2 = p2.first, &y2 = p2.second;\\n                    if(i < x1) x1 = i;\\n                    else if(i > x2)  x2 = i;\\n                    if(j < y1) y1 = j;\\n                    else if(j > y2)  y2 = j;\\n                }else\\n                    color[tg[i][j]] = {{i, j}, {i, j}};\\n            }\\n        }\\n        bool running = true;\\n        while(running && !color.empty()){\\n            running = false;\\n            for(auto [c, p]: color){\\n                auto p1 = p.first, p2 = p.second;\\n                int x1 = p1.first, y1 = p1.second;\\n                int x2 = p2.first, y2 = p2.second;\\n                bool valid = true;\\n                for(int i = 0; valid && i < m; ++i){\\n                    for(int j = 0; valid && j < n; ++j){\\n                        bool inRange = i >= x1 && i <= x2 && j >= y1 && j <= y2;\\n                        bool isColor = tg[i][j] == c;\\n                        bool isZero = tg[i][j] == 0;\\n                        if((inRange && !isColor && !isZero) || (!inRange && isColor))\\n                            valid = false;\\n                    }\\n                }\\n                if(valid){\\n                    color.erase(c);\\n                    for(int i = x1; i <= x2; ++i)\\n                        for(int j = y1; j <= y2; ++j)\\n                            tg[i][j] = 0;\\n                    running = true;\\n\\t\\t\\t\\t\\tbreak;\\n                }\\n            }\\n            if(!running)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        vector<vector<int>>& tg = targetGrid;\\n        map<int, pair<pair<int, int>, pair<int, int>>> color;\\n        const int m = tg.size(), n = tg[0].size();\\n        for(int i = 0; i < m; ++i){\\n            for(int j = 0; j < n; ++j){\\n                if(color.count(tg[i][j])){\\n                    auto &range = color[tg[i][j]];\\n                    auto &p1 = range.first, &p2 = range.second;\\n                    int &x1 = p1.first, &y1 = p1.second;\\n                    int &x2 = p2.first, &y2 = p2.second;\\n                    if(i < x1) x1 = i;\\n                    else if(i > x2)  x2 = i;\\n                    if(j < y1) y1 = j;\\n                    else if(j > y2)  y2 = j;\\n                }else\\n                    color[tg[i][j]] = {{i, j}, {i, j}};\\n            }\\n        }\\n        bool running = true;\\n        while(running && !color.empty()){\\n            running = false;\\n            for(auto [c, p]: color){\\n                auto p1 = p.first, p2 = p.second;\\n                int x1 = p1.first, y1 = p1.second;\\n                int x2 = p2.first, y2 = p2.second;\\n                bool valid = true;\\n                for(int i = 0; valid && i < m; ++i){\\n                    for(int j = 0; valid && j < n; ++j){\\n                        bool inRange = i >= x1 && i <= x2 && j >= y1 && j <= y2;\\n                        bool isColor = tg[i][j] == c;\\n                        bool isZero = tg[i][j] == 0;\\n                        if((inRange && !isColor && !isZero) || (!inRange && isColor))\\n                            valid = false;\\n                    }\\n                }\\n                if(valid){\\n                    color.erase(c);\\n                    for(int i = x1; i <= x2; ++i)\\n                        for(int j = y1; j <= y2; ++j)\\n                            tg[i][j] = 0;\\n                    running = true;\\n\\t\\t\\t\\t\\tbreak;\\n                }\\n            }\\n            if(!running)\\n                return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602857,
                "title": "straightforward-python-solution",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        V = 60\\n        adj = [[] for v in range(V)]\\n        d = collections.defaultdict(lambda: [[R, C], [-1, -1], set()])  # color: [start, end, set of all points of this color]\\n        \\n        # make the hashmap `d`\\n        for color in range(60):\\n            for r in range(R):\\n                for c in range(C):\\n                    cur = d[color]\\n                    start, end, pts = cur\\n                    if grid[r][c] - 1 == color:\\n                        start[0] = min(start[0], r)\\n                        start[1] = min(start[1], c)\\n                        end[0] = max(end[0], r)\\n                        end[1] = max(end[1], c)\\n                        pts.add((r, c))\\n        \\n        # make the dependencies i.e. the order in which colors must occur to be able to satisfy printer\\'s requirements\\n        for color1 in range(60):\\n            for color2 in range(60):\\n                if color1 == color2: continue\\n                color1_pts = d[color1][2]\\n                color2_start, color2_end, color2_pts = d[color2]\\n                for pt in color1_pts:\\n                    r, c = pt\\n                    r1, c1 = color2_start\\n                    r2, c2 = color2_end\\n                    if r1 <= r <= r2 and c1 <= c <= c2:\\n                        adj[color2].append(color1)\\n                        break\\n        \\n        # Check if there is an inconsistant order of colors i.e., if there is a cycle in our directed graph, return False\\n        def isCycle(s, visited1, visited2):\\n            visited1[s] = True\\n            visited2[s] = True\\n            for v in adj[s]:\\n                if visited2[v]:\\n                    return True\\n                if not visited1[v]:\\n                    if isCycle(v, visited1, visited2):\\n                        return True\\n            visited2[s] = False\\n            return False\\n        \\n        visited1 = [False] * V\\n        visited2 = [False] * V\\n        for v in range(V):\\n            if not visited1[v]:\\n                if isCycle(v, visited1, visited2):\\n                    return False\\n        \\n        return True\\n```\\n        \\n                    \\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        R, C = len(grid), len(grid[0])\\n        V = 60\\n        adj = [[] for v in range(V)]\\n        d = collections.defaultdict(lambda: [[R, C], [-1, -1], set()])  # color: [start, end, set of all points of this color]\\n        \\n        # make the hashmap `d`\\n        for color in range(60):\\n            for r in range(R):\\n                for c in range(C):\\n                    cur = d[color]\\n                    start, end, pts = cur\\n                    if grid[r][c] - 1 == color:\\n                        start[0] = min(start[0], r)\\n                        start[1] = min(start[1], c)\\n                        end[0] = max(end[0], r)\\n                        end[1] = max(end[1], c)\\n                        pts.add((r, c))\\n        \\n        # make the dependencies i.e. the order in which colors must occur to be able to satisfy printer\\'s requirements\\n        for color1 in range(60):\\n            for color2 in range(60):\\n                if color1 == color2: continue\\n                color1_pts = d[color1][2]\\n                color2_start, color2_end, color2_pts = d[color2]\\n                for pt in color1_pts:\\n                    r, c = pt\\n                    r1, c1 = color2_start\\n                    r2, c2 = color2_end\\n                    if r1 <= r <= r2 and c1 <= c <= c2:\\n                        adj[color2].append(color1)\\n                        break\\n        \\n        # Check if there is an inconsistant order of colors i.e., if there is a cycle in our directed graph, return False\\n        def isCycle(s, visited1, visited2):\\n            visited1[s] = True\\n            visited2[s] = True\\n            for v in adj[s]:\\n                if visited2[v]:\\n                    return True\\n                if not visited1[v]:\\n                    if isCycle(v, visited1, visited2):\\n                        return True\\n            visited2[s] = False\\n            return False\\n        \\n        visited1 = [False] * V\\n        visited2 = [False] * V\\n        for v in range(V):\\n            if not visited1[v]:\\n                if isCycle(v, visited1, visited2):\\n                    return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568783,
                "title": "java-70-faster-o-m-n-k-k-number-of-times-printer-used",
                "content": "\\tMap<Integer, int[]> idxMap =new HashMap<>();\\n    int[][] grid;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int m = targetGrid.length;\\n        int n = targetGrid[0].length;\\n        grid = targetGrid;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int val = targetGrid[i][j];\\n                if(idxMap.containsKey(val)) {\\n                    int[] co_or = idxMap.get(val);\\n                    co_or[0] = Math.min(co_or[0], i); // min I\\n                    co_or[1] = Math.max(co_or[1], i); // max I\\n                    co_or[2] = Math.min(co_or[2], j); // min J\\n                    co_or[3] = Math.max(co_or[3], j); // max J\\n                } else {\\n                    idxMap.put(val, new int[]{i, i, j, j});\\n                }\\n            }\\n        }\\n        \\n        Set<Integer> finished = new HashSet<>();\\n        boolean validated = true;\\n        while(!allDone(targetGrid) && validated) {\\n            validated = false;\\n            for(Integer key : idxMap.keySet()) {\\n                if(!finished.contains(key)) {\\n                    if(isRectangle(key, idxMap.get(key))) {\\n                        finished.add(key);\\n                        validated = true;\\n                    }\\n                }\\n            }\\n        }\\n        return allDone(targetGrid);\\n    }\\n                   \\n    public boolean isRectangle(Integer key, int[] limits) {\\n        boolean validRectangle = true;\\n        for(int i=limits[0]; i<=limits[1]; i++) {\\n            for(int j=limits[2]; j<=limits[3]; j++) {\\n                if(grid[i][j] != -1 && grid[i][j] != key) {\\n                    validRectangle = false;\\n                }\\n            }\\n        }\\n        if(validRectangle) {\\n            for(int i=limits[0]; i<=limits[1]; i++) {\\n                for(int j=limits[2]; j<=limits[3]; j++) {\\n                    grid[i][j] = -1;\\n                }\\n            }\\n        }\\n        return validRectangle;\\n    }\\n    \\n    public boolean allDone(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] != -1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "\\tMap<Integer, int[]> idxMap =new HashMap<>();\\n    int[][] grid;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int m = targetGrid.length;\\n        int n = targetGrid[0].length;\\n        grid = targetGrid;\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int val = targetGrid[i][j];\\n                if(idxMap.containsKey(val)) {\\n                    int[] co_or = idxMap.get(val);\\n                    co_or[0] = Math.min(co_or[0], i); // min I\\n                    co_or[1] = Math.max(co_or[1], i); // max I\\n                    co_or[2] = Math.min(co_or[2], j); // min J\\n                    co_or[3] = Math.max(co_or[3], j); // max J\\n                } else {\\n                    idxMap.put(val, new int[]{i, i, j, j});\\n                }\\n            }\\n        }\\n        \\n        Set<Integer> finished = new HashSet<>();\\n        boolean validated = true;\\n        while(!allDone(targetGrid) && validated) {\\n            validated = false;\\n            for(Integer key : idxMap.keySet()) {\\n                if(!finished.contains(key)) {\\n                    if(isRectangle(key, idxMap.get(key))) {\\n                        finished.add(key);\\n                        validated = true;\\n                    }\\n                }\\n            }\\n        }\\n        return allDone(targetGrid);\\n    }\\n                   \\n    public boolean isRectangle(Integer key, int[] limits) {\\n        boolean validRectangle = true;\\n        for(int i=limits[0]; i<=limits[1]; i++) {\\n            for(int j=limits[2]; j<=limits[3]; j++) {\\n                if(grid[i][j] != -1 && grid[i][j] != key) {\\n                    validRectangle = false;\\n                }\\n            }\\n        }\\n        if(validRectangle) {\\n            for(int i=limits[0]; i<=limits[1]; i++) {\\n                for(int j=limits[2]; j<=limits[3]; j++) {\\n                    grid[i][j] = -1;\\n                }\\n            }\\n        }\\n        return validRectangle;\\n    }\\n    \\n    public boolean allDone(int[][] grid) {\\n        int m = grid.length;\\n        int n = grid[0].length;\\n        \\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                if(grid[i][j] != -1) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2552969,
                "title": "python-topological-sort-with-brief-explanations",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        \\n        # store maximum possible range of borders\\n        rects = defaultdict(lambda: {\\'l\\': 60, \\'r\\': -1, \\'t\\': 60, \\'d\\': -1})\\n        for i in range(m):\\n            for j in range(n):\\n                rects[targetGrid[i][j]][\\'l\\'] = min(rects[targetGrid[i][j]][\\'l\\'], j)\\n                rects[targetGrid[i][j]][\\'r\\'] = max(rects[targetGrid[i][j]][\\'r\\'], j)\\n                rects[targetGrid[i][j]][\\'t\\'] = min(rects[targetGrid[i][j]][\\'t\\'], i)\\n                rects[targetGrid[i][j]][\\'d\\'] = max(rects[targetGrid[i][j]][\\'d\\'], i)\\n                \\n        # indegree counts the number of rects covering the rect numbered i\\n        # outgoing memos the graph (top rect to the rects below)\\n        indegree, outgoing = {}, defaultdict(set)\\n        for i, d in rects.items():\\n            indegree.setdefault(i, 0)\\n            for r in range(d[\\'t\\'], d[\\'d\\'] + 1):\\n                for c in range(d[\\'l\\'], d[\\'r\\'] + 1):\\n                    num = targetGrid[r][c]\\n                    if num != i and i not in outgoing[num]:\\n                        outgoing[num].add(i)\\n                        indegree[i] += 1\\n                        \\n        # dump the rects with 0 indegrees (uncovered ones) into the queue\\n        uncovered = deque()\\n        for i, count in indegree.items():\\n            if not count: uncovered.append(i)\\n        \\n        # loop to uncover rects and add the new uncovered into queue\\n        while uncovered:\\n            i = uncovered.popleft()\\n            for j in outgoing[i]:\\n                indegree[j] -= 1\\n                if not indegree[j]:\\n                    uncovered.append(j)\\n                    \\n        # return True if there is no covered rects (all indegrees are 0)\\n        return not any(indegree.values())\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        \\n        # store maximum possible range of borders\\n        rects = defaultdict(lambda: {\\'l\\': 60, \\'r\\': -1, \\'t\\': 60, \\'d\\': -1})\\n        for i in range(m):\\n            for j in range(n):\\n                rects[targetGrid[i][j]][\\'l\\'] = min(rects[targetGrid[i][j]][\\'l\\'], j)\\n                rects[targetGrid[i][j]][\\'r\\'] = max(rects[targetGrid[i][j]][\\'r\\'], j)\\n                rects[targetGrid[i][j]][\\'t\\'] = min(rects[targetGrid[i][j]][\\'t\\'], i)\\n                rects[targetGrid[i][j]][\\'d\\'] = max(rects[targetGrid[i][j]][\\'d\\'], i)\\n                \\n        # indegree counts the number of rects covering the rect numbered i\\n        # outgoing memos the graph (top rect to the rects below)\\n        indegree, outgoing = {}, defaultdict(set)\\n        for i, d in rects.items():\\n            indegree.setdefault(i, 0)\\n            for r in range(d[\\'t\\'], d[\\'d\\'] + 1):\\n                for c in range(d[\\'l\\'], d[\\'r\\'] + 1):\\n                    num = targetGrid[r][c]\\n                    if num != i and i not in outgoing[num]:\\n                        outgoing[num].add(i)\\n                        indegree[i] += 1\\n                        \\n        # dump the rects with 0 indegrees (uncovered ones) into the queue\\n        uncovered = deque()\\n        for i, count in indegree.items():\\n            if not count: uncovered.append(i)\\n        \\n        # loop to uncover rects and add the new uncovered into queue\\n        while uncovered:\\n            i = uncovered.popleft()\\n            for j in outgoing[i]:\\n                indegree[j] -= 1\\n                if not indegree[j]:\\n                    uncovered.append(j)\\n                    \\n        # return True if there is no covered rects (all indegrees are 0)\\n        return not any(indegree.values())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2548347,
                "title": "c-cycle-detection",
                "content": "struct Node{\\n    int minx,miny,maxx,maxy;  \\n    Node()\\n    {\\n        minx = INT_MAX;\\n        miny = INT_MAX;\\n        maxx = INT_MIN;\\n        maxy = INT_MIN;\\n    }\\n};\\nclass Solution {\\npublic:\\n\\n        unordered_map<int,Node> mp;\\n        bool cycle(int src,vector<bool>&rec,vector<bool>&vis,vector<int>adj[]){\\n        if(vis[src]== false){\\n        vis[src]=true;\\n        rec[src]=true;\\n        for(auto node : adj[src]){\\n            if(!vis[node] && cycle(node,rec,vis,adj)){\\n                    return true;\\n            }\\n            else if(rec[node] == true)\\n            return true;\\n        }\\n        }\\n        rec[src]=false;\\n        return false;\\n        \\n    }\\n    bool isPrintable(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        int sz=0;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++)\\n                sz=max(sz,a[i][j]);\\n        }\\n        vector<int>adj[sz+1];\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                mp[a[i][j]].minx = min(mp[a[i][j]].minx,i);\\n                mp[a[i][j]].maxx = max(mp[a[i][j]].maxx,i);\\n                mp[a[i][j]].miny = min(mp[a[i][j]].miny,j);\\n                mp[a[i][j]].maxy = max(mp[a[i][j]].maxy,j);\\n            }\\n        }\\n        \\n        for(auto it:mp)\\n        { \\n            for(int i = it.second.minx;i<=it.second.maxx;i++)\\n            {\\n                for(int j = it.second.miny;j<=it.second.maxy;j++)\\n                {\\n                    if(a[i][j]!=it.first){\\n                       adj[it.first].push_back(a[i][j]);\\n                    }\\n                }\\n            }\\n            //cout<<endl;\\n        }\\n        // for(int i=1;i<=sz;i++){\\n        //     cout<<i<<\"->\";\\n        //     for(auto it : adj[i])\\n        //         cout<<it<<\" \";\\n        //     cout<<endl;\\n        // }\\n        vector<bool>vis(sz+1,false);\\n        vector<bool>rec(sz+1,false);\\n        for(int i=1;i<=sz;i++){\\n            if(vis[i]==false && cycle(i,rec,vis,adj))\\n                return false;\\n        }\\n        return true;\\n        \\n    }   \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n        unordered_map<int,Node> mp;\\n        bool cycle(int src,vector<bool>&rec,vector<bool>&vis,vector<int>adj[]){\\n        if(vis[src]== false){\\n        vis[src]=true;\\n        rec[src]=true;\\n        for(auto node : adj[src]){\\n            if(!vis[node] && cycle(node,rec,vis,adj)){\\n                    return true;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2518836,
                "title": "java-adjacency-map-topological-sort",
                "content": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int LEFT=0,RIGHT=1,TOP=2,BOTTOM=3;\\n        Map<Integer, int[]> coordinates = new HashMap();\\n        Map<Integer, Set<Integer>> adj = new HashMap();\\n        int rows = targetGrid.length, cols = targetGrid[0].length;\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                int color = targetGrid[i][j];\\n                if (coordinates.containsKey(color)){\\n                    int[] coordinate = coordinates.get(color);\\n                    coordinate[LEFT]=Math.min(j, coordinate[LEFT]);\\n                    coordinate[RIGHT]=Math.max(j, coordinate[RIGHT]);\\n                    coordinate[TOP]=Math.min(i, coordinate[TOP]);\\n                    coordinate[BOTTOM]=Math.max(i, coordinate[BOTTOM]);\\n                }else{\\n                    coordinates.put(color, new int[]{j, j, i, i});\\n                    adj.put(color, new HashSet());\\n                }\\n            }\\n        }\\n        Map<Integer, Integer> indegree = new HashMap();\\n        for(Map.Entry<Integer, int[]> entry: coordinates.entrySet()){\\n            int currColor = entry.getKey();\\n            int[] coordinate=entry.getValue();\\n            for(int i = coordinate[TOP]; i <= coordinate[BOTTOM]; i++){\\n                for(int j = coordinate[LEFT]; j <= coordinate[RIGHT]; j++){\\n                    int color = targetGrid[i][j];\\n                    if (currColor!=color)\\n                        adj.get(currColor).add(color);\\n                }\\n            }\\n            indegree.put(currColor, 0);\\n        }\\n        for(Integer key: adj.keySet()){\\n            for (int color: adj.get(key))\\n                indegree.put(color, indegree.get(color)+1);\\n        }\\n        Queue<Integer> queue = new LinkedList();\\n        for(Integer key: indegree.keySet())\\n            if (indegree.get(key)==0)\\n                queue.offer(key);\\n        int size = 0;\\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            size++;\\n            for(int neighbor: adj.get(node)){\\n                indegree.put(neighbor, indegree.get(neighbor)-1);\\n                if (indegree.get(neighbor) == 0)\\n                    queue.offer(neighbor);\\n            }\\n        }\\n        return size == adj.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int LEFT=0,RIGHT=1,TOP=2,BOTTOM=3;\\n        Map<Integer, int[]> coordinates = new HashMap();\\n        Map<Integer, Set<Integer>> adj = new HashMap();\\n        int rows = targetGrid.length, cols = targetGrid[0].length;\\n        for(int i = 0; i < rows; i++){\\n            for(int j = 0; j < cols; j++){\\n                int color = targetGrid[i][j];\\n                if (coordinates.containsKey(color)){\\n                    int[] coordinate = coordinates.get(color);\\n                    coordinate[LEFT]=Math.min(j, coordinate[LEFT]);\\n                    coordinate[RIGHT]=Math.max(j, coordinate[RIGHT]);\\n                    coordinate[TOP]=Math.min(i, coordinate[TOP]);\\n                    coordinate[BOTTOM]=Math.max(i, coordinate[BOTTOM]);\\n                }else{\\n                    coordinates.put(color, new int[]{j, j, i, i});\\n                    adj.put(color, new HashSet());\\n                }\\n            }\\n        }\\n        Map<Integer, Integer> indegree = new HashMap();\\n        for(Map.Entry<Integer, int[]> entry: coordinates.entrySet()){\\n            int currColor = entry.getKey();\\n            int[] coordinate=entry.getValue();\\n            for(int i = coordinate[TOP]; i <= coordinate[BOTTOM]; i++){\\n                for(int j = coordinate[LEFT]; j <= coordinate[RIGHT]; j++){\\n                    int color = targetGrid[i][j];\\n                    if (currColor!=color)\\n                        adj.get(currColor).add(color);\\n                }\\n            }\\n            indegree.put(currColor, 0);\\n        }\\n        for(Integer key: adj.keySet()){\\n            for (int color: adj.get(key))\\n                indegree.put(color, indegree.get(color)+1);\\n        }\\n        Queue<Integer> queue = new LinkedList();\\n        for(Integer key: indegree.keySet())\\n            if (indegree.get(key)==0)\\n                queue.offer(key);\\n        int size = 0;\\n        while(!queue.isEmpty()){\\n            int node = queue.poll();\\n            size++;\\n            for(int neighbor: adj.get(node)){\\n                indegree.put(neighbor, indegree.get(neighbor)-1);\\n                if (indegree.get(neighbor) == 0)\\n                    queue.offer(neighbor);\\n            }\\n        }\\n        return size == adj.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501527,
                "title": "python",
                "content": "\\tclass Solution:\\n\\t\\tdef isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n\\t\\t\\tcoords = defaultdict(lambda:[(math.inf,math.inf),(-1,-1)])\\n\\n\\t\\t\\tm = len(targetGrid)\\n\\t\\t\\tn = len(targetGrid[0])\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tcord = coords[targetGrid[i][j]]\\n\\t\\t\\t\\t\\tlx = cord[0][0]\\n\\t\\t\\t\\t\\tly = cord[0][1]\\n\\t\\t\\t\\t\\trx = cord[1][0]\\n\\t\\t\\t\\t\\try = cord[1][1]\\n\\n\\t\\t\\t\\t\\tcoords[targetGrid[i][j]] = [(min(lx,i),min(ly,j)),(max(rx,i),max(ry,j))]\\n\\n\\t\\t\\tused = defaultdict(lambda:None)\\n\\t\\t\\tdef dfs(color):\\n\\n\\t\\t\\t\\tif used[color] == False:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telif used[color] == True:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tused[color] = False\\n\\n\\t\\t\\t\\tc = coords[color]\\n\\t\\t\\t\\tlxp, rxp, lyp, ryp = c[0][0],c[1][0],c[0][1],c[1][1]\\n\\t\\t\\t\\tfor i in range(lxp, rxp + 1):\\n\\t\\t\\t\\t\\tfor j in range(lyp, ryp + 1):\\n\\t\\t\\t\\t\\t\\tnxt = targetGrid[i][j]\\n\\t\\t\\t\\t\\t\\tif  nxt != color and not dfs(nxt):\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tused[color] = True\\n\\t\\t\\t\\treturn True\\n\\n\\n\\t\\t\\tfor key in coords:\\n\\t\\t\\t\\tif not dfs(key):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n\\t\\t\\tcoords = defaultdict(lambda:[(math.inf,math.inf),(-1,-1)])\\n\\n\\t\\t\\tm = len(targetGrid)\\n\\t\\t\\tn = len(targetGrid[0])\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tcord = coords[targetGrid[i][j]]\\n\\t\\t\\t\\t\\tlx = cord[0][0]\\n\\t\\t\\t\\t\\tly = cord[0][1]\\n\\t\\t\\t\\t\\trx = cord[1][0]\\n\\t\\t\\t\\t\\try = cord[1][1]\\n\\n\\t\\t\\t\\t\\tcoords[targetGrid[i][j]] = [(min(lx,i),min(ly,j)),(max(rx,i),max(ry,j))]\\n\\n\\t\\t\\tused = defaultdict(lambda:None)\\n\\t\\t\\tdef dfs(color):\\n\\n\\t\\t\\t\\tif used[color] == False:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\telif used[color] == True:\\n\\t\\t\\t\\t\\treturn True\\n\\n\\t\\t\\t\\tused[color] = False\\n\\n\\t\\t\\t\\tc = coords[color]\\n\\t\\t\\t\\tlxp, rxp, lyp, ryp = c[0][0],c[1][0],c[0][1],c[1][1]\\n\\t\\t\\t\\tfor i in range(lxp, rxp + 1):\\n\\t\\t\\t\\t\\tfor j in range(lyp, ryp + 1):\\n\\t\\t\\t\\t\\t\\tnxt = targetGrid[i][j]\\n\\t\\t\\t\\t\\t\\tif  nxt != color and not dfs(nxt):\\n\\t\\t\\t\\t\\t\\t\\treturn False\\n\\n\\t\\t\\t\\tused[color] = True\\n\\t\\t\\t\\treturn True\\n\\n\\n\\t\\t\\tfor key in coords:\\n\\t\\t\\t\\tif not dfs(key):\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\treturn True\\n",
                "codeTag": "Java"
            },
            {
                "id": 2418475,
                "title": "clean-java-topological-sort-solution",
                "content": "The gist of this problem is to identify the fact that there would always be a color that have a rectangular shape. As a result we could:\\n\\n[1] Put the first colors that have rectangular shape in the queue first\\n\\n[2] Mark all those colors as CUSTOM_COLOR that could be used by any other color to form their rectangular shape.\\n\\n[3] Then find any other color that could use these CUSTOM_COLOR to form rectangular shape and repeat [1]\\n\\nIf at some point during [2] to [3], there are colors left but no rectangular shape has found, we know we could not use this printer to print this shape.\\n\\nCode:\\n\\n```\\nclass Solution {\\n    private static final int CUSTOM_COLOR = 0;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Set<Integer> colors = getColors(targetGrid);\\n        Map<Integer, int[]> minMaxXY = getMinMaxXY(colors, targetGrid);\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int color : colors) {\\n            if (isColorRectangular(color, targetGrid, minMaxXY.get(color))) {\\n                queue.offer(color);\\n            }\\n        }\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i < size; ++i) {\\n                int color = queue.poll();\\n                mark(color, targetGrid, minMaxXY.get(color));\\n                colors.remove(color);\\n            }\\n            for (int color : colors) {\\n                if (isColorRectangular(color, targetGrid, minMaxXY.get(color))) {\\n                    queue.offer(color);\\n                }\\n            }\\n        }\\n        \\n        return colors.isEmpty();\\n    }\\n    \\n    private void mark(int color, int[][] targetGrid, int[] minMaxXY) {\\n        int minX = minMaxXY[0], maxX = minMaxXY[1];\\n        int minY = minMaxXY[2], maxY = minMaxXY[3];\\n        for(int x=minX; x <= maxX; ++x) {\\n            for (int y = minY; y <= maxY; ++y) {\\n                targetGrid[x][y] = CUSTOM_COLOR;\\n            }\\n        }\\n    }\\n    \\n    private boolean isColorRectangular(int targetColor, int[][] targetGrid, int[] minMaxXY) {\\n        int minX = minMaxXY[0], maxX = minMaxXY[1];\\n        int minY = minMaxXY[2], maxY = minMaxXY[3];\\n        for(int x=minX; x <= maxX; ++x) {\\n            for (int y = minY; y <= maxY; ++y) {\\n                int color = targetGrid[x][y];\\n                if (color != targetColor && color != CUSTOM_COLOR) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private Map<Integer, int[]> getMinMaxXY(Set<Integer> colors, int[][] targetGrid) {\\n        // minX, maxX, minY, maxY\\n        Map<Integer, int[]> minMaxes = new HashMap<>();\\n        for(int color : colors) {\\n            minMaxes.put(color, new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE});\\n        }\\n        \\n        for (int x=0; x < targetGrid.length; ++x) {\\n            for (int y=0; y < targetGrid[0].length; ++y) {\\n                int color = targetGrid[x][y];\\n                int[] minMax = minMaxes.get(color);\\n                minMax[0] = Math.min(x, minMax[0]);\\n                minMax[1] = Math.max(x, minMax[1]);\\n                minMax[2] = Math.min(y, minMax[2]);\\n                minMax[3] = Math.max(y, minMax[3]);\\n            }\\n        }\\n        return minMaxes;\\n    }\\n    \\n    private Set<Integer> getColors(int[][] targetGrid) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int[] row : targetGrid) {\\n            for (int val : row) {\\n                set.add(val);\\n            }\\n        }\\n        return set;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    private static final int CUSTOM_COLOR = 0;\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Set<Integer> colors = getColors(targetGrid);\\n        Map<Integer, int[]> minMaxXY = getMinMaxXY(colors, targetGrid);\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int color : colors) {\\n            if (isColorRectangular(color, targetGrid, minMaxXY.get(color))) {\\n                queue.offer(color);\\n            }\\n        }\\n        while(!queue.isEmpty()) {\\n            int size = queue.size();\\n            for (int i=0; i < size; ++i) {\\n                int color = queue.poll();\\n                mark(color, targetGrid, minMaxXY.get(color));\\n                colors.remove(color);\\n            }\\n            for (int color : colors) {\\n                if (isColorRectangular(color, targetGrid, minMaxXY.get(color))) {\\n                    queue.offer(color);\\n                }\\n            }\\n        }\\n        \\n        return colors.isEmpty();\\n    }\\n    \\n    private void mark(int color, int[][] targetGrid, int[] minMaxXY) {\\n        int minX = minMaxXY[0], maxX = minMaxXY[1];\\n        int minY = minMaxXY[2], maxY = minMaxXY[3];\\n        for(int x=minX; x <= maxX; ++x) {\\n            for (int y = minY; y <= maxY; ++y) {\\n                targetGrid[x][y] = CUSTOM_COLOR;\\n            }\\n        }\\n    }\\n    \\n    private boolean isColorRectangular(int targetColor, int[][] targetGrid, int[] minMaxXY) {\\n        int minX = minMaxXY[0], maxX = minMaxXY[1];\\n        int minY = minMaxXY[2], maxY = minMaxXY[3];\\n        for(int x=minX; x <= maxX; ++x) {\\n            for (int y = minY; y <= maxY; ++y) {\\n                int color = targetGrid[x][y];\\n                if (color != targetColor && color != CUSTOM_COLOR) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    private Map<Integer, int[]> getMinMaxXY(Set<Integer> colors, int[][] targetGrid) {\\n        // minX, maxX, minY, maxY\\n        Map<Integer, int[]> minMaxes = new HashMap<>();\\n        for(int color : colors) {\\n            minMaxes.put(color, new int[]{Integer.MAX_VALUE, Integer.MIN_VALUE, Integer.MAX_VALUE, Integer.MIN_VALUE});\\n        }\\n        \\n        for (int x=0; x < targetGrid.length; ++x) {\\n            for (int y=0; y < targetGrid[0].length; ++y) {\\n                int color = targetGrid[x][y];\\n                int[] minMax = minMaxes.get(color);\\n                minMax[0] = Math.min(x, minMax[0]);\\n                minMax[1] = Math.max(x, minMax[1]);\\n                minMax[2] = Math.min(y, minMax[2]);\\n                minMax[3] = Math.max(y, minMax[3]);\\n            }\\n        }\\n        return minMaxes;\\n    }\\n    \\n    private Set<Integer> getColors(int[][] targetGrid) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int[] row : targetGrid) {\\n            for (int val : row) {\\n                set.add(val);\\n            }\\n        }\\n        return set;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2410597,
                "title": "clean-c-solution-cycle-detection",
                "content": "```\\nstruct Node{\\n    int minx,miny,maxx,maxy;  \\n    Node()\\n    {\\n        minx = INT_MAX;\\n        miny = INT_MAX;\\n        maxx = INT_MIN;\\n        maxy = INT_MIN;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_set<int>> mpIn;\\n    unordered_map<int,Node> mp;\\n    unordered_set<int> vis;\\n    \\n    bool hasCycle(int sv,int parent)\\n    {\\n        vis.insert(sv);\\n        for(auto it:mpIn[sv])\\n        {\\n            if(vis.find(it)==vis.end())\\n            {\\n                if(hasCycle(it,sv))return true;\\n            }\\n            else\\n            {\\n                // cout<<\"yaha se \"<<it<<endl;\\n                return true;\\n            }\\n        }\\n        vis.erase(sv);\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                mp[a[i][j]].minx = min(mp[a[i][j]].minx,i);\\n                mp[a[i][j]].maxx = max(mp[a[i][j]].maxx,i);\\n                mp[a[i][j]].miny = min(mp[a[i][j]].miny,j);\\n                mp[a[i][j]].maxy = max(mp[a[i][j]].maxy,j);\\n            }\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            for(int i = it.second.minx;i<=it.second.maxx;i++)\\n            {\\n                for(int j = it.second.miny;j<=it.second.maxy;j++)\\n                {\\n                    if(a[i][j]!=it.first)\\n                        mpIn[it.first].insert(a[i][j]);\\n                }\\n            }\\n        }\\n            \\n        \\n        for(auto it:mpIn)\\n        {\\n            if(hasCycle(it.first,-1))return false;\\n        }\\n        return true;\\n        \\n    }   \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct Node{\\n    int minx,miny,maxx,maxy;  \\n    Node()\\n    {\\n        minx = INT_MAX;\\n        miny = INT_MAX;\\n        maxx = INT_MIN;\\n        maxy = INT_MIN;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_set<int>> mpIn;\\n    unordered_map<int,Node> mp;\\n    unordered_set<int> vis;\\n    \\n    bool hasCycle(int sv,int parent)\\n    {\\n        vis.insert(sv);\\n        for(auto it:mpIn[sv])\\n        {\\n            if(vis.find(it)==vis.end())\\n            {\\n                if(hasCycle(it,sv))return true;\\n            }\\n            else\\n            {\\n                // cout<<\"yaha se \"<<it<<endl;\\n                return true;\\n            }\\n        }\\n        vis.erase(sv);\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        for(int i = 0;i<n;i++)\\n        {\\n            for(int j = 0;j<m;j++)\\n            {\\n                mp[a[i][j]].minx = min(mp[a[i][j]].minx,i);\\n                mp[a[i][j]].maxx = max(mp[a[i][j]].maxx,i);\\n                mp[a[i][j]].miny = min(mp[a[i][j]].miny,j);\\n                mp[a[i][j]].maxy = max(mp[a[i][j]].maxy,j);\\n            }\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            for(int i = it.second.minx;i<=it.second.maxx;i++)\\n            {\\n                for(int j = it.second.miny;j<=it.second.maxy;j++)\\n                {\\n                    if(a[i][j]!=it.first)\\n                        mpIn[it.first].insert(a[i][j]);\\n                }\\n            }\\n        }\\n            \\n        \\n        for(auto it:mpIn)\\n        {\\n            if(hasCycle(it.first,-1))return false;\\n        }\\n        return true;\\n        \\n    }   \\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2356777,
                "title": "c-solution-with-i-hope-it-is-an-easy-explanation",
                "content": "The idea is that we identify the boundaries of each color (minimum/maximum row and column for each color), and then one color, for instance, color 1, will relate to others using a graph in which the nodes are the colors that represent on the supplied target grid (for example, color 2). When color1 also has color2, add the direct edge of the border. Because particular color1 cells can turn into specific color2 cells, it suggests that there is a link between the nodes.\\n\\nThe issue arises if a cycle occurs, meaning some cells will change from their current color to an older one, violating the constraint ( the same color cannot be used again)\\n\\n```\\nclass Solution {\\npublic:\\n//this will be called 3rd order\\nbool is_dag(vector<vector<short>>& g, vector<short>&status,short node) {\\n\\t// this will be called recursively, so put the satus 0 to identify that it will \\n\\t// after vistied the child it will comes to this node\\n\\tstatus[node] = 0;\\n\\tfor (short v : g[node]) {\\n\\t\\tif (status[v] == 0)  // we visit parent twice this means it has a cycle\\n\\t\\t\\treturn false;\\n\\t\\tif (status[v] == -1) // we not visit this node yet then visit\\n\\t\\t\\tif (!is_dag(g, status, v)) // if the child has a cycle, just return false\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\tstatus[node] = 1; // after visited, change the status to 1\\n\\treturn true;\\n}\\n\\n//This will be call 2nd order\\nbool is_cycle(vector<vector<short>>& graph) {\\n\\tvector<short> status(graph.size(), -1);\\n\\tfor (short node = 0; node < graph.size(); ++node)\\n\\t\\tif (status[node] == -1) \\n\\t\\t\\tif (!is_dag(graph,status, node)) \\n\\t\\t\\t\\treturn true;\\n\\n\\treturn false;\\n}\\n\\nbool isPrintable(vector<vector<int>>& targetGrid) {\\n\\tshort mxcolor = 1;\\n\\tconst short R = targetGrid.size();\\n\\tconst short C = targetGrid[0].size();\\n\\n\\t// find out that what is the maximum nodes to use (use colors as nodes)\\n\\tfor (short r = 0; r < R; ++r)\\n\\t\\tfor (short c = 0; c < C; ++c)\\n\\t\\t\\tmxcolor = max(mxcolor, (short)targetGrid[r][c]);\\n\\t\\t\\t\\n\\tvector<short> mxcolor_row(mxcolor + 1, -1); // base 0 -> base 1;\\n\\tvector<short> mncolor_row(mxcolor + 1, R);  // put default high number for min\\n\\tvector<short> mxcolor_col(mxcolor + 1, -1); // put default low number for max\\n\\tvector<short> mncolor_col(mxcolor + 1, C);\\n\\n\\t// find the max/min (boundary) for each color(node) that appear on grid;\\n\\tfor (short r = 0; r < R; ++r) {\\n\\t\\tfor (short c = 0; c < C; ++c) {\\n\\t\\t\\tshort cur = targetGrid[r][c];\\n\\t\\t\\tmxcolor_row[cur] = max(mxcolor_row[cur], r);\\n\\t\\t\\tmxcolor_col[cur] = max(mxcolor_col[cur], c);\\n\\t\\t\\tmncolor_col[cur] = min(mncolor_col[cur], c);\\n\\t\\t\\tmncolor_row[cur] = min(mncolor_row[cur], r);\\n\\t\\t}\\n\\t}\\n\\n\\t// Create the graph which the relation is define as if the boundary of some color\\n\\t// eg. color1 has different color eg color 2, then add direct edge \\n\\t//from color1 to color2, So let\\'s build the graph\\n\\t\\n\\t// This is graph with no edges yet (just a nodes) base 1\\n\\tvector<vector<short>> graph(mxcolor + 1); \\n\\n\\tfor (short c = 1; c <= mxcolor; ++c) \\n\\t\\t//iterate to each color boundary (some color will have no boundary)\\n\\t\\tfor (short crow = mncolor_row[c]; crow <= mxcolor_row[c]; ++crow)\\n\\t\\t\\tfor (short ccol = mncolor_col[c]; ccol <= mxcolor_col[c]; ++ccol)\\n\\t\\t\\t\\t// if there are some color that not in current color boundary so add the relation.\\n\\t\\t\\t\\tif (targetGrid[crow][ccol] != c) \\n\\t\\t\\t\\t\\tgraph[c].push_back(targetGrid[crow][ccol]);\\n\\n// The graph that have a cycle will not be able to put the different color\\n// since the edge from color1 to color2 mean color1 will be transform to color2\\n// so if there are a cycle it means color2 will convert to color1 which violate the\\n// constraint (each color will use once)\\n\\treturn !is_cycle(graph);\\t\\t\\t\\n}\\n\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//this will be called 3rd order\\nbool is_dag(vector<vector<short>>& g, vector<short>&status,short node) {\\n\\t// this will be called recursively, so put the satus 0 to identify that it will \\n\\t// after vistied the child it will comes to this node\\n\\tstatus[node] = 0;\\n\\tfor (short v : g[node]) {\\n\\t\\tif (status[v] == 0)  // we visit parent twice this means it has a cycle\\n\\t\\t\\treturn false;\\n\\t\\tif (status[v] == -1) // we not visit this node yet then visit\\n\\t\\t\\tif (!is_dag(g, status, v)) // if the child has a cycle, just return false\\n\\t\\t\\t\\treturn false;\\n\\t}\\n\\tstatus[node] = 1; // after visited, change the status to 1\\n\\treturn true;\\n}\\n\\n//This will be call 2nd order\\nbool is_cycle(vector<vector<short>>& graph) {\\n\\tvector<short> status(graph.size(), -1);\\n\\tfor (short node = 0; node < graph.size(); ++node)\\n\\t\\tif (status[node] == -1) \\n\\t\\t\\tif (!is_dag(graph,status, node)) \\n\\t\\t\\t\\treturn true;\\n\\n\\treturn false;\\n}\\n\\nbool isPrintable(vector<vector<int>>& targetGrid) {\\n\\tshort mxcolor = 1;\\n\\tconst short R = targetGrid.size();\\n\\tconst short C = targetGrid[0].size();\\n\\n\\t// find out that what is the maximum nodes to use (use colors as nodes)\\n\\tfor (short r = 0; r < R; ++r)\\n\\t\\tfor (short c = 0; c < C; ++c)\\n\\t\\t\\tmxcolor = max(mxcolor, (short)targetGrid[r][c]);\\n\\t\\t\\t\\n\\tvector<short> mxcolor_row(mxcolor + 1, -1); // base 0 -> base 1;\\n\\tvector<short> mncolor_row(mxcolor + 1, R);  // put default high number for min\\n\\tvector<short> mxcolor_col(mxcolor + 1, -1); // put default low number for max\\n\\tvector<short> mncolor_col(mxcolor + 1, C);\\n\\n\\t// find the max/min (boundary) for each color(node) that appear on grid;\\n\\tfor (short r = 0; r < R; ++r) {\\n\\t\\tfor (short c = 0; c < C; ++c) {\\n\\t\\t\\tshort cur = targetGrid[r][c];\\n\\t\\t\\tmxcolor_row[cur] = max(mxcolor_row[cur], r);\\n\\t\\t\\tmxcolor_col[cur] = max(mxcolor_col[cur], c);\\n\\t\\t\\tmncolor_col[cur] = min(mncolor_col[cur], c);\\n\\t\\t\\tmncolor_row[cur] = min(mncolor_row[cur], r);\\n\\t\\t}\\n\\t}\\n\\n\\t// Create the graph which the relation is define as if the boundary of some color\\n\\t// eg. color1 has different color eg color 2, then add direct edge \\n\\t//from color1 to color2, So let\\'s build the graph\\n\\t\\n\\t// This is graph with no edges yet (just a nodes) base 1\\n\\tvector<vector<short>> graph(mxcolor + 1); \\n\\n\\tfor (short c = 1; c <= mxcolor; ++c) \\n\\t\\t//iterate to each color boundary (some color will have no boundary)\\n\\t\\tfor (short crow = mncolor_row[c]; crow <= mxcolor_row[c]; ++crow)\\n\\t\\t\\tfor (short ccol = mncolor_col[c]; ccol <= mxcolor_col[c]; ++ccol)\\n\\t\\t\\t\\t// if there are some color that not in current color boundary so add the relation.\\n\\t\\t\\t\\tif (targetGrid[crow][ccol] != c) \\n\\t\\t\\t\\t\\tgraph[c].push_back(targetGrid[crow][ccol]);\\n\\n// The graph that have a cycle will not be able to put the different color\\n// since the edge from color1 to color2 mean color1 will be transform to color2\\n// so if there are a cycle it means color2 will convert to color1 which violate the\\n// constraint (each color will use once)\\n\\treturn !is_cycle(graph);\\t\\t\\t\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2354583,
                "title": "c-o-60-n-m-time-kahn-s-algorithm-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>> &a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector<int> adj[61];\\n        for(int c=1 ; c<=60 ; c++) {\\n            int minx = max(n , m) , miny = max(n , m) , maxx = -1 , maxy = -1;\\n            for(int i=0 ; i<n ; i++) {\\n                for(int j=0 ; j<m ; j++) {\\n                    if(a[i][j] == c) {\\n                        minx = min(minx , i);\\n                        miny = min(miny , j);\\n                        maxx = max(maxx , i);\\n                        maxy = max(maxy , j);\\n                    }\\n                }\\n            }\\n            for(int i=minx ; i<=maxx ; i++) {\\n                for(int j=miny ; j<=maxy ; j++) {\\n                    if(a[i][j] != c) {\\n                        adj[c].push_back(a[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> indegree(61 , 0);\\n        for(int i=1 ; i<=60 ; i++) {\\n            for(int j=0 ; j<adj[i].size() ; j++) {\\n                indegree[adj[i][j]]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=1 ; i<=60 ; i++) {\\n            if(!indegree[i]) q.push(i); \\n        }\\n        int cnt = 0;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(int v : adj[u]) {\\n                indegree[v]--;\\n                if(!indegree[v]) q.push(v);\\n            }\\n            cnt++;\\n        }\\n        if(cnt != 60) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>> &a) {\\n        int n = a.size();\\n        int m = a[0].size();\\n        vector<int> adj[61];\\n        for(int c=1 ; c<=60 ; c++) {\\n            int minx = max(n , m) , miny = max(n , m) , maxx = -1 , maxy = -1;\\n            for(int i=0 ; i<n ; i++) {\\n                for(int j=0 ; j<m ; j++) {\\n                    if(a[i][j] == c) {\\n                        minx = min(minx , i);\\n                        miny = min(miny , j);\\n                        maxx = max(maxx , i);\\n                        maxy = max(maxy , j);\\n                    }\\n                }\\n            }\\n            for(int i=minx ; i<=maxx ; i++) {\\n                for(int j=miny ; j<=maxy ; j++) {\\n                    if(a[i][j] != c) {\\n                        adj[c].push_back(a[i][j]);\\n                    }\\n                }\\n            }\\n        }\\n        vector<int> indegree(61 , 0);\\n        for(int i=1 ; i<=60 ; i++) {\\n            for(int j=0 ; j<adj[i].size() ; j++) {\\n                indegree[adj[i][j]]++;\\n            }\\n        }\\n        queue<int> q;\\n        for(int i=1 ; i<=60 ; i++) {\\n            if(!indegree[i]) q.push(i); \\n        }\\n        int cnt = 0;\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(int v : adj[u]) {\\n                indegree[v]--;\\n                if(!indegree[v]) q.push(v);\\n            }\\n            cnt++;\\n        }\\n        if(cnt != 60) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283505,
                "title": "python-with-detailed-comments",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        \\n        # White/Gray/Black DFS tree traversal to detect cycles \\n        def dfs(u):           \\n            # mark the node as a visited in the current dfs path\\n            seen[u] = 1 # 1 - Gray, seen in this dfs path\\n            for v in graph[u]:\\n                # if already seen in this dfs path, we got a cycle, return failure                \\n                if seen[v] == 1: # 1- Gray\\n                    return False  \\n                # already seen this node in a previous dfs path, the rest has been already checked for cycles\\n                if seen[v] == 2: # 2- Black\\n                    continue\\n                # check for cycles along the way, if at least one failure, return all way to the top\\n                if not dfs(v):\\n                    return False\\n            # mark this node as processed and checked no cycles down the way\\n            seen[u] = 2  # 2- Black\\n            return True                \\n        \\n        graph = defaultdict(set)\\n        rects = {}\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        # 1. get max rectangle for all found colors per color\\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                if c not in rects:\\n                    rects[c] = [1, (i,j), (i,j)]\\n                else:\\n                    r = rects[c]\\n                    r[0] += 1\\n                    r[1] = (min(r[1][0], i), min(r[1][1], j))\\n                    r[2] = (max(r[2][0], i), max(r[2][1], j))\\n        # 2. for every max color rectange, link to a graph with all other overlapping colors as children\\n        for c, (cnt, (x0, y0), (x1, y1)) in rects.items():\\n            # the rectangle is completely filled with a single color, no other color children\\n            if (x1 - x0 + 1) * (y1 - y0 + 1) == cnt:\\n                continue\\n            # for every cell in the color box\\n            for i in range(x0, x1 + 1):\\n                for j in range(y0, y1 + 1):\\n                    if targetGrid[i][j] != c:\\n                        # add another color as this node\\'s child\\n                        graph[c].add(targetGrid[i][j])                \\n\\n        # 3. we just need to enure no cycles - two colors don\\'t depend on each other\\n        seen = defaultdict(str)\\n        # detect cycles using White/Grey/Black DFS, graph may be disjoint and we start from random nodes\\n        for c in list(graph.keys()):\\n            if not dfs(c):\\n                return False\\n        \\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        \\n        # White/Gray/Black DFS tree traversal to detect cycles \\n        def dfs(u):           \\n            # mark the node as a visited in the current dfs path\\n            seen[u] = 1 # 1 - Gray, seen in this dfs path\\n            for v in graph[u]:\\n                # if already seen in this dfs path, we got a cycle, return failure                \\n                if seen[v] == 1: # 1- Gray\\n                    return False  \\n                # already seen this node in a previous dfs path, the rest has been already checked for cycles\\n                if seen[v] == 2: # 2- Black\\n                    continue\\n                # check for cycles along the way, if at least one failure, return all way to the top\\n                if not dfs(v):\\n                    return False\\n            # mark this node as processed and checked no cycles down the way\\n            seen[u] = 2  # 2- Black\\n            return True                \\n        \\n        graph = defaultdict(set)\\n        rects = {}\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        # 1. get max rectangle for all found colors per color\\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                if c not in rects:\\n                    rects[c] = [1, (i,j), (i,j)]\\n                else:\\n                    r = rects[c]\\n                    r[0] += 1\\n                    r[1] = (min(r[1][0], i), min(r[1][1], j))\\n                    r[2] = (max(r[2][0], i), max(r[2][1], j))\\n        # 2. for every max color rectange, link to a graph with all other overlapping colors as children\\n        for c, (cnt, (x0, y0), (x1, y1)) in rects.items():\\n            # the rectangle is completely filled with a single color, no other color children\\n            if (x1 - x0 + 1) * (y1 - y0 + 1) == cnt:\\n                continue\\n            # for every cell in the color box\\n            for i in range(x0, x1 + 1):\\n                for j in range(y0, y1 + 1):\\n                    if targetGrid[i][j] != c:\\n                        # add another color as this node\\'s child\\n                        graph[c].add(targetGrid[i][j])                \\n\\n        # 3. we just need to enure no cycles - two colors don\\'t depend on each other\\n        seen = defaultdict(str)\\n        # detect cycles using White/Grey/Black DFS, graph may be disjoint and we start from random nodes\\n        for c in list(graph.keys()):\\n            if not dfs(c):\\n                return False\\n        \\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2265577,
                "title": "python-projection-non-dfs-with-thought-process-when-being-asked-during-interviews",
                "content": "### Projection\\nMy first intuition is to calculate the topological sort and find if there is cycle. However, it\\'s constructed as undirected graph by taking overlapping colors as dependency without knowing which color goes first.\\nBut it gives the basic idea that the last printed color is with complete rectangle and absolutely able to print. With this printed color, we can reset all of cells with the color to be `0` meaning any color which can be used to construct the incomplete rectangle with the different color. Then repeat this process until there is no more incomplete rectangle left. \\n\\n**So the first problem is how can we know if there is a complete rectangle for a given color `c`?**\\n\\nBecause of rectangle, we can know the size of rectangle once we know the left top corner and the right bottom corner which can be simpley gotten by iterating the target grid, and then compare it with the number of cells with the color `c`.\\n\\n**Then the next question is how can we reset the cells with the color `c` to make up the incomplete rectangle?**\\nWe can only update those incomplete rectangles with overlapping cells with color `c`. Then this question can be converted to find out the overlapping cells. If you are familiar with intersection interval, then you know how to find overlapping cells. We use the same idea but with a 2D array by projecting the coordinate to `rows` and `cols` axis respectively. Then we can simply detect if there is overlapping.\\n\\nOnce the number of cells after update is equals to the size of rectangle, the rectangle is complete, and can be put to the next queue to construct futher more rectangles.\\n\\n**Can we stop here, it looks a working solution?**\\nNo, I made this mistake by stopping here and just comparing the number without looking at the exactly overlapping coordinates. The solution failed on the last second test case. \\nThe reason is that it\\'s possible to add up the same cell mutliple times because of overlapped with multiple colors.\\nWe have to generate the actual coordinate for each cells that are overlapping and update to corresponding colors.\\n\\nSo let\\'s put all together\\n1. Iterate target grid to record cells for each color.\\n2. Find the colors with complete rectrangles, put to printed color set.\\n3. For each color `c`, iterate all the other incomplete color `d`, cacluate the overlapping cells, update to cells for color `d`.\\n4. As long as the number of cells equals to size of rectangle for color `d`, put `d` to the next printed color set.\\n5. Repeat step 2 - 4, until no more colors left to print, return True. Otherwise false when next printed set is empty.\\n\\n```python\\ndef isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n\\trows = defaultdict(lambda:[float(\\'inf\\'), float(\\'-inf\\')])\\n\\tcols = defaultdict(lambda:[float(\\'inf\\'), float(\\'-inf\\')])\\n\\tcolors = defaultdict(set)\\n        \\n\\tm, n = len(targetGrid), len(targetGrid[0])\\n        \\n\\tdef index(i, j):\\n\\t\\treturn i * n + j\\n        \\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcolor = targetGrid[i][j]\\n\\t\\t\\trows[color] = [min(rows[color][0], i), max(rows[color][1], i)]\\n\\t\\t\\tcols[color] = [min(cols[color][0], j), max(cols[color][1], j)]\\n\\t\\t\\tcolors[color].add(index(i, j))\\n                \\n\\tdef get_size(color): \\n\\t\\trow = rows[color]\\n\\t\\tcol = cols[color]\\n\\t\\treturn (row[1] - row[0] + 1) * (col[1] - col[0] + 1)\\n        \\n\\tdef overlap_size(this, that):\\n\\t\\trow_this = rows[this]\\n\\t\\trow_that = rows[that]\\n\\t\\tcol_this = cols[this]\\n\\t\\tcol_that = cols[that]\\n\\t\\treturn {index(i, j) for i in range(max(row_this[0], row_that[0]), min(row_this[1], row_that[1]) + 1) for j in range(max(col_this[0], col_that[0]), min(col_this[1], col_that[1]) + 1)}\\n            \\n\\tprinted = {color for color in colors if get_size(color) == len(colors[color])}\\n\\tleft =  set(colors.keys()) - printed\\n        \\n    while left:\\n\\t\\tif not printed:\\n\\t\\t\\treturn False\\n\\t\\tnext_printed = set()\\n\\t\\tfor color in printed:\\n\\t\\t\\tfor remain in left:\\n\\t\\t\\t\\tif remain in next_printed:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcolors[remain] |= overlap_size(color, remain)\\n\\t\\t\\t\\tif len(colors[remain]) == get_size(remain):\\n\\t\\t\\t\\t\\tnext_printed.add(remain)\\n\\t\\tprinted = next_printed\\n\\t\\tleft = left - printed \\n\\treturn True\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```python\\ndef isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n\\trows = defaultdict(lambda:[float(\\'inf\\'), float(\\'-inf\\')])\\n\\tcols = defaultdict(lambda:[float(\\'inf\\'), float(\\'-inf\\')])\\n\\tcolors = defaultdict(set)\\n        \\n\\tm, n = len(targetGrid), len(targetGrid[0])\\n        \\n\\tdef index(i, j):\\n\\t\\treturn i * n + j\\n        \\n\\tfor i in range(m):\\n\\t\\tfor j in range(n):\\n\\t\\t\\tcolor = targetGrid[i][j]\\n\\t\\t\\trows[color] = [min(rows[color][0], i), max(rows[color][1], i)]\\n\\t\\t\\tcols[color] = [min(cols[color][0], j), max(cols[color][1], j)]\\n\\t\\t\\tcolors[color].add(index(i, j))\\n                \\n\\tdef get_size(color): \\n\\t\\trow = rows[color]\\n\\t\\tcol = cols[color]\\n\\t\\treturn (row[1] - row[0] + 1) * (col[1] - col[0] + 1)\\n        \\n\\tdef overlap_size(this, that):\\n\\t\\trow_this = rows[this]\\n\\t\\trow_that = rows[that]\\n\\t\\tcol_this = cols[this]\\n\\t\\tcol_that = cols[that]\\n\\t\\treturn {index(i, j) for i in range(max(row_this[0], row_that[0]), min(row_this[1], row_that[1]) + 1) for j in range(max(col_this[0], col_that[0]), min(col_this[1], col_that[1]) + 1)}\\n            \\n\\tprinted = {color for color in colors if get_size(color) == len(colors[color])}\\n\\tleft =  set(colors.keys()) - printed\\n        \\n    while left:\\n\\t\\tif not printed:\\n\\t\\t\\treturn False\\n\\t\\tnext_printed = set()\\n\\t\\tfor color in printed:\\n\\t\\t\\tfor remain in left:\\n\\t\\t\\t\\tif remain in next_printed:\\n\\t\\t\\t\\t\\tcontinue\\n\\t\\t\\t\\tcolors[remain] |= overlap_size(color, remain)\\n\\t\\t\\t\\tif len(colors[remain]) == get_size(remain):\\n\\t\\t\\t\\t\\tnext_printed.add(remain)\\n\\t\\tprinted = next_printed\\n\\t\\tleft = left - printed \\n\\treturn True\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2255333,
                "title": "c-find-most-recently-painted-blocks",
                "content": "The key to this problem is to think in reverse. It\\'s difficult to find out which color is printed first but it\\'s easier to find out which color is printed last.\\n```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& nums,int a,int b,int x,int y,int k){\\n        for(int i = a; i<=x;++i){\\n            for(int j = b; j<=y;++j){\\n                if(nums[i][j]==k || nums[i][j]==0) continue;\\n                else return 0;\\n            }\\n        }\\n        for(int i = a; i<=x;++i){\\n            for(int j = b; j<=y;++j) nums[i][j] = 0;\\n        }\\n        return 1;\\n    }\\n    bool isPrintable(vector<vector<int>>& nums) {\\n        unordered_map<int,pair<int,int>> max_;\\n        unordered_map<int,pair<int,int>> min_;\\n        unordered_set<int> mp;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0; j<nums[0].size();++j){\\n                if(mp.find(nums[i][j])==mp.end()){\\n                    max_[nums[i][j]] = {i,j};\\n                    min_[nums[i][j]] = {i,j};\\n                }\\n                else{\\n                    max_[nums[i][j]].first = max(max_[nums[i][j]].first,i);\\n                    max_[nums[i][j]].second = max(max_[nums[i][j]].second,j);\\n                    min_[nums[i][j]].first = min(min_[nums[i][j]].first,i);\\n                    min_[nums[i][j]].second = min(min_[nums[i][j]].second,j);\\n                }\\n                mp.insert(nums[i][j]);\\n            }\\n        }\\n        while(mp.size()){\\n            bool st = 0;\\n            for(auto&it:mp){\\n                bool k = \\n                    find(nums,min_[it].first,min_[it].second,max_[it].first,max_[it].second,it);\\n                if(k==1){\\n                    st = 1; mp.erase(it);\\n                    break;\\n                }\\n            }\\n            if(st == 0) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int find(vector<vector<int>>& nums,int a,int b,int x,int y,int k){\\n        for(int i = a; i<=x;++i){\\n            for(int j = b; j<=y;++j){\\n                if(nums[i][j]==k || nums[i][j]==0) continue;\\n                else return 0;\\n            }\\n        }\\n        for(int i = a; i<=x;++i){\\n            for(int j = b; j<=y;++j) nums[i][j] = 0;\\n        }\\n        return 1;\\n    }\\n    bool isPrintable(vector<vector<int>>& nums) {\\n        unordered_map<int,pair<int,int>> max_;\\n        unordered_map<int,pair<int,int>> min_;\\n        unordered_set<int> mp;\\n        for(int i = 0; i<nums.size();++i){\\n            for(int j = 0; j<nums[0].size();++j){\\n                if(mp.find(nums[i][j])==mp.end()){\\n                    max_[nums[i][j]] = {i,j};\\n                    min_[nums[i][j]] = {i,j};\\n                }\\n                else{\\n                    max_[nums[i][j]].first = max(max_[nums[i][j]].first,i);\\n                    max_[nums[i][j]].second = max(max_[nums[i][j]].second,j);\\n                    min_[nums[i][j]].first = min(min_[nums[i][j]].first,i);\\n                    min_[nums[i][j]].second = min(min_[nums[i][j]].second,j);\\n                }\\n                mp.insert(nums[i][j]);\\n            }\\n        }\\n        while(mp.size()){\\n            bool st = 0;\\n            for(auto&it:mp){\\n                bool k = \\n                    find(nums,min_[it].first,min_[it].second,max_[it].first,max_[it].second,it);\\n                if(k==1){\\n                    st = 1; mp.erase(it);\\n                    break;\\n                }\\n            }\\n            if(st == 0) return 0;\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186860,
                "title": "c-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        unordered_map<int, vector<int>> myMap;\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_map<int, unordered_set<int>> edge;\\n        unordered_map<int, int> indegree;\\n        int num_color = 0;\\n        for (int i=0; i<targetGrid.size(); ++i) {\\n            for (int j=0; j<targetGrid[0].size(); ++j) {\\n                int color = targetGrid[i][j];\\n                if (myMap.find(color) == myMap.end()) {\\n                    myMap[color] = {{INT_MAX, INT_MIN, INT_MAX, INT_MIN}};\\n                    indegree[color] = 0;\\n                    num_color ++;\\n                }\\n                myMap[color][0] = min(myMap[color][0], i);\\n                myMap[color][1] = max(myMap[color][1], i);\\n                myMap[color][2] = min(myMap[color][2], j);\\n                myMap[color][3] = max(myMap[color][3], j);\\n            }\\n        }\\n        \\n        for (auto it = myMap.begin(); it != myMap.end(); ++it) {\\n            for (int i=it->second[0]; i<=it->second[1]; ++i) {\\n                for (int j=it->second[2]; j <= it->second[3]; ++j) {\\n                    if (targetGrid[i][j] != it->first) {\\n                        if (edge[it->first].count(targetGrid[i][j]) == 0){\\n                            edge[it->first].insert(targetGrid[i][j]);\\n                            indegree[targetGrid[i][j]] ++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        queue<int> myQueue;\\n        for (auto it = indegree.begin(); it != indegree.end(); ++it) {\\n            if (it->second == 0) {\\n                myQueue.push(it->first);\\n            }\\n        }\\n        int color_count = 0;\\n        while (!myQueue.empty()) {\\n            int front = myQueue.front();\\n            myQueue.pop();\\n            color_count ++;\\n            for (auto it = edge[front].begin(); it!= edge[front].end(); ++it) {\\n                indegree[*it] --;\\n                if (indegree[*it] == 0) {\\n                    myQueue.push(*it);\\n                }\\n            }\\n        }\\n        return color_count == num_color;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Topological Sort"
                ],
                "code": "class Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        unordered_map<int, vector<int>> myMap;\\n        int m = targetGrid.size();\\n        int n = targetGrid[0].size();\\n        unordered_map<int, unordered_set<int>> edge;\\n        unordered_map<int, int> indegree;\\n        int num_color = 0;\\n        for (int i=0; i<targetGrid.size(); ++i) {\\n            for (int j=0; j<targetGrid[0].size(); ++j) {\\n                int color = targetGrid[i][j];\\n                if (myMap.find(color) == myMap.end()) {\\n                    myMap[color] = {{INT_MAX, INT_MIN, INT_MAX, INT_MIN}",
                "codeTag": "Java"
            },
            {
                "id": 2126926,
                "title": "javascript-topological-sort",
                "content": "The key to solving this is finding the colors that are mixed into a single colored rectangle. For example if there is a rectangle of 1s, and we can see that some segments of that rectangle are occupied by 2s and 3s, we should bind these into an adjacent set where we say the value 1 is adjacent to 2 and 3. And likewise the value of 1 is also within 2 and 3 within an opposite set.\\n\\nSorting backwards, any rectangle that is not sharing its space is easy to place and so we know we can paint those last. Afterwards we look for any rectangles that was sharing its space with the ones we just put into the back of the list. By checking to see if there\\'s no longer any shared colors in the adjacency map we can keep adding them to the list in this sorted order until the final sorted color is placed at the front of the list. This front color will be the color that shares most of its space with other colors and thus should be painted first so that the others can be painted on top.\\n\\n```\\nvar isPrintable = function (targetGrid) {\\n\\tconst n = targetGrid.length;\\n\\tconst m = targetGrid[0].length;\\n\\n\\tconst pointData = [];\\n\\n\\tlet list = new Set();\\n\\tconst outputCheck = [];\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\toutputCheck[y] = new Array(m).fill(0);\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tconst val = targetGrid[y][x];\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tif (pointData[val] === undefined) {\\n\\t\\t\\t\\tpointData[val] = {\\n\\t\\t\\t\\t\\tminX: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tminY: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tmaxX: -1,\\n\\t\\t\\t\\t\\tmaxY: -1,\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\tconst data = pointData[val];\\n\\t\\t\\tdata.minX = Math.min(data.minX, x);\\n\\t\\t\\tdata.minY = Math.min(data.minY, y);\\n\\t\\t\\tdata.maxX = Math.max(data.maxX, x);\\n\\t\\t\\tdata.maxY = Math.max(data.maxY, y);\\n\\t\\t}\\n\\t}\\n\\n\\t//this list is for storing all the colours inside the target color rectangle\\n\\t//example: box of 1s, has 2 and 3s inside it then this adj[1].has(2) && adj[1].has(3)\\n\\tconst adj = [];\\n\\n\\t//this list is the opposite to the adj list where this color exists in other colored rectangle spaces\\n\\t//example: if you have a rectangle of 2s and rectangle of 3s, the color 1 might exist in both of them so opp[1].has(2) && opp[1].has(3)\\n\\tconst opp = [];\\n\\n\\tfor (const val of list) {\\n\\t\\tconst { minX, minY, maxX, maxY } = pointData[val];\\n\\t\\tfor (let y = minY; y <= maxY; ++y) {\\n\\t\\t\\tfor (let x = minX; x <= maxX; ++x) {\\n\\t\\t\\t\\tconst cval = targetGrid[y][x];\\n\\t\\t\\t\\t//find colors that don\\'t belong to this space and bind them\\n\\t\\t\\t\\tif (cval !== val) {\\n\\t\\t\\t\\t\\tif (adj[val] === undefined) adj[val] = new Set();\\n\\t\\t\\t\\t\\tif (opp[cval] === undefined) opp[cval] = new Set();\\n\\t\\t\\t\\t\\tadj[val].add(cval);\\n\\t\\t\\t\\t\\topp[cval].add(val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tconst sortedList = getTopoSortedList(list);\\n\\n\\tfunction getTopoSortedList(list) {\\n\\t\\tlet output = new Set();\\n\\t\\tlet q = [];\\n\\t\\tfor (const val of list) {\\n\\t\\t\\tif (adj[val] === undefined) q.push(val);\\n\\t\\t}\\n\\t\\twhile (q.length) {\\n\\t\\t\\tconst value = q.shift();\\n\\t\\t\\tif (output.has(value)) continue;\\n\\t\\t\\toutput.add(value);\\n            if (opp[value]) {\\n                for (const node of opp[value]) {\\n                    adj[node].delete(value);\\n                    if (adj[node].size === 0) {\\n                        q.push(node);\\n                    }\\n                }   \\n            }\\n\\t\\t}\\n\\t\\treturn Array.from(output).reverse();\\n\\t}\\n\\n\\tfor (const val of sortedList) {\\n\\t\\tconst { minX, minY, maxX, maxY } = pointData[val];\\n\\t\\tfor (let y = minY; y <= maxY; ++y) {\\n\\t\\t\\tfor (let x = minX; x <= maxX; ++x) {\\n\\t\\t\\t\\toutputCheck[y][x] = val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tif (targetGrid[y][x] !== outputCheck[y][x]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Topological Sort"
                ],
                "code": "```\\nvar isPrintable = function (targetGrid) {\\n\\tconst n = targetGrid.length;\\n\\tconst m = targetGrid[0].length;\\n\\n\\tconst pointData = [];\\n\\n\\tlet list = new Set();\\n\\tconst outputCheck = [];\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\toutputCheck[y] = new Array(m).fill(0);\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tconst val = targetGrid[y][x];\\n\\t\\t\\tlist.add(val);\\n\\t\\t\\tif (pointData[val] === undefined) {\\n\\t\\t\\t\\tpointData[val] = {\\n\\t\\t\\t\\t\\tminX: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tminY: Number.MAX_VALUE,\\n\\t\\t\\t\\t\\tmaxX: -1,\\n\\t\\t\\t\\t\\tmaxY: -1,\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\tconst data = pointData[val];\\n\\t\\t\\tdata.minX = Math.min(data.minX, x);\\n\\t\\t\\tdata.minY = Math.min(data.minY, y);\\n\\t\\t\\tdata.maxX = Math.max(data.maxX, x);\\n\\t\\t\\tdata.maxY = Math.max(data.maxY, y);\\n\\t\\t}\\n\\t}\\n\\n\\t//this list is for storing all the colours inside the target color rectangle\\n\\t//example: box of 1s, has 2 and 3s inside it then this adj[1].has(2) && adj[1].has(3)\\n\\tconst adj = [];\\n\\n\\t//this list is the opposite to the adj list where this color exists in other colored rectangle spaces\\n\\t//example: if you have a rectangle of 2s and rectangle of 3s, the color 1 might exist in both of them so opp[1].has(2) && opp[1].has(3)\\n\\tconst opp = [];\\n\\n\\tfor (const val of list) {\\n\\t\\tconst { minX, minY, maxX, maxY } = pointData[val];\\n\\t\\tfor (let y = minY; y <= maxY; ++y) {\\n\\t\\t\\tfor (let x = minX; x <= maxX; ++x) {\\n\\t\\t\\t\\tconst cval = targetGrid[y][x];\\n\\t\\t\\t\\t//find colors that don\\'t belong to this space and bind them\\n\\t\\t\\t\\tif (cval !== val) {\\n\\t\\t\\t\\t\\tif (adj[val] === undefined) adj[val] = new Set();\\n\\t\\t\\t\\t\\tif (opp[cval] === undefined) opp[cval] = new Set();\\n\\t\\t\\t\\t\\tadj[val].add(cval);\\n\\t\\t\\t\\t\\topp[cval].add(val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tconst sortedList = getTopoSortedList(list);\\n\\n\\tfunction getTopoSortedList(list) {\\n\\t\\tlet output = new Set();\\n\\t\\tlet q = [];\\n\\t\\tfor (const val of list) {\\n\\t\\t\\tif (adj[val] === undefined) q.push(val);\\n\\t\\t}\\n\\t\\twhile (q.length) {\\n\\t\\t\\tconst value = q.shift();\\n\\t\\t\\tif (output.has(value)) continue;\\n\\t\\t\\toutput.add(value);\\n            if (opp[value]) {\\n                for (const node of opp[value]) {\\n                    adj[node].delete(value);\\n                    if (adj[node].size === 0) {\\n                        q.push(node);\\n                    }\\n                }   \\n            }\\n\\t\\t}\\n\\t\\treturn Array.from(output).reverse();\\n\\t}\\n\\n\\tfor (const val of sortedList) {\\n\\t\\tconst { minX, minY, maxX, maxY } = pointData[val];\\n\\t\\tfor (let y = minY; y <= maxY; ++y) {\\n\\t\\t\\tfor (let x = minX; x <= maxX; ++x) {\\n\\t\\t\\t\\toutputCheck[y][x] = val;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let y = 0; y < n; ++y) {\\n\\t\\tfor (let x = 0; x < m; ++x) {\\n\\t\\t\\tif (targetGrid[y][x] !== outputCheck[y][x]) {\\n\\t\\t\\t\\treturn false;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2110826,
                "title": "c-brute-force",
                "content": "Let\\'s introduce *joker* `color == 0` - color which is overpainted by some other colors.\\nWe can draw `color` if and only if all cells of this color make a *rectangle* which has `color` and joker color only.\\nWhen we find `color` which can be painted we change all cells of this color into joker color:\\n\\n```\\ninitial       1st       2nd          3d\\n1111         1111       1111        0000\\n1133         1133       1100        0000\\n1134         1130       1100        0000\\n5514         0010       0010        0000\\n```\\n\\n**Code:**\\n\\n```\\npublic class Solution {\\n    \\n    private static bool TryColor(int[][] grid, \\n                                 int color, \\n                                 (int left, int top, int right, int bottom) rect) {\\n        bool result = true;\\n        \\n        for (int r = rect.top; r <= rect.bottom; ++r)\\n            for (int c = rect.left; c <= rect.right; ++c)\\n                if (grid[r][c] > 0 && grid[r][c] != color)\\n                    return false;\\n        \\n        for (int r = rect.top; r <= rect.bottom; ++r)\\n            for (int c = rect.left; c <= rect.right; ++c)\\n                grid[r][c] = 0;\\n        \\n        return true;\\n    }\\n    \\n    public bool IsPrintable(int[][] targetGrid) {\\n      Dictionary<int, (int left, int top, int right, int bottom)> patches = new();\\n\\n      HashSet<int> colors = new();\\n\\n      for (int r = 0; r < targetGrid.Length; ++r)\\n        for (int c = 0; c < targetGrid[r].Length; ++c) {\\n          int color = targetGrid[r][c];\\n\\n          colors.Add(color);\\n\\n          if (patches.TryGetValue(color, out var rect)) {\\n            patches[color] = (\\n                Math.Min(c, rect.left),\\n                Math.Min(r, rect.top),\\n                Math.Max(c, rect.right),\\n                Math.Max(r, rect.bottom)\\n            );\\n          }\\n          else\\n            patches.Add(color, (c, r, c, r));\\n        }\\n\\n      for (bool agenda = true; agenda;) {\\n        agenda = false;\\n\\n        foreach (var color in colors.ToList()) {\\n          if (TryColor(targetGrid, color, patches[color])) {\\n            agenda = true;\\n\\n            colors.Remove(color);\\n          }\\n        }\\n      }\\n\\n      return colors.Count <= 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\ninitial       1st       2nd          3d\\n1111         1111       1111        0000\\n1133         1133       1100        0000\\n1134         1130       1100        0000\\n5514         0010       0010        0000\\n```\n```\\npublic class Solution {\\n    \\n    private static bool TryColor(int[][] grid, \\n                                 int color, \\n                                 (int left, int top, int right, int bottom) rect) {\\n        bool result = true;\\n        \\n        for (int r = rect.top; r <= rect.bottom; ++r)\\n            for (int c = rect.left; c <= rect.right; ++c)\\n                if (grid[r][c] > 0 && grid[r][c] != color)\\n                    return false;\\n        \\n        for (int r = rect.top; r <= rect.bottom; ++r)\\n            for (int c = rect.left; c <= rect.right; ++c)\\n                grid[r][c] = 0;\\n        \\n        return true;\\n    }\\n    \\n    public bool IsPrintable(int[][] targetGrid) {\\n      Dictionary<int, (int left, int top, int right, int bottom)> patches = new();\\n\\n      HashSet<int> colors = new();\\n\\n      for (int r = 0; r < targetGrid.Length; ++r)\\n        for (int c = 0; c < targetGrid[r].Length; ++c) {\\n          int color = targetGrid[r][c];\\n\\n          colors.Add(color);\\n\\n          if (patches.TryGetValue(color, out var rect)) {\\n            patches[color] = (\\n                Math.Min(c, rect.left),\\n                Math.Min(r, rect.top),\\n                Math.Max(c, rect.right),\\n                Math.Max(r, rect.bottom)\\n            );\\n          }\\n          else\\n            patches.Add(color, (c, r, c, r));\\n        }\\n\\n      for (bool agenda = true; agenda;) {\\n        agenda = false;\\n\\n        foreach (var color in colors.ToList()) {\\n          if (TryColor(targetGrid, color, patches[color])) {\\n            agenda = true;\\n\\n            colors.Remove(color);\\n          }\\n        }\\n      }\\n\\n      return colors.Count <= 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105309,
                "title": "hard-brute-force",
                "content": "```\\n#define pll pair<int,int>\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<pair<int,pair<pll,pll>>> v;\\n    vector<vector<int>> a;\\n    \\n    bool update()\\n    {\\n        vector<pair<pll,pll>> ans;\\n        for(int k=0;k<v.size();k++)\\n        {\\n            if(v[k].ff==-1) continue;\\n            int x=v[k].ss.ff.ff,y=v[k].ss.ff.ss;\\n            int p=v[k].ss.ss.ff,q=v[k].ss.ss.ss;\\n            int yes=1;\\n            for(int i=x;i<=p;i++)\\n                for(int j=y;j<=q;j++)\\n                    if(a[i][j]!=\\'0\\' && v[k].ff!=a[i][j]) \\n                        yes=0;\\n            if(yes)\\n            {\\n                v[k].ff=-1;\\n                for(int i=x;i<=p;i++)\\n                    for(int j=y;j<=q;j++)\\n                        a[i][j]=\\'0\\';\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) \\n    {\\n        a=targetGrid;\\n        n=a.size(); m=a[0].size();\\n       \\n        map<int,pll> mn,mx;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                int cl=a[i][j];\\n                if(mn.count(cl))\\n                {\\n                    pll p=mn[cl],q=mx[cl];\\n                    p.ff=min(p.ff,i); p.ss=min(p.ss,j);\\n                    q.ff=max(q.ff,i); q.ss=max(q.ss,j);\\n                    mn[cl]=p; mx[cl]=q;\\n                }\\n                else mn[cl]=mx[cl]={i,j};\\n            }\\n        \\n        for(auto i:mn)\\n            v.push_back({i.ff,{i.ss,mx[i.ff]}});\\n       \\n        while(update());\\n        \\n        int yes=1;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i].ff!=-1) yes=0;\\n        return yes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define pll pair<int,int>\\n#define ff first\\n#define ss second\\n\\nclass Solution {\\npublic:\\n    int n,m;\\n    vector<pair<int,pair<pll,pll>>> v;\\n    vector<vector<int>> a;\\n    \\n    bool update()\\n    {\\n        vector<pair<pll,pll>> ans;\\n        for(int k=0;k<v.size();k++)\\n        {\\n            if(v[k].ff==-1) continue;\\n            int x=v[k].ss.ff.ff,y=v[k].ss.ff.ss;\\n            int p=v[k].ss.ss.ff,q=v[k].ss.ss.ss;\\n            int yes=1;\\n            for(int i=x;i<=p;i++)\\n                for(int j=y;j<=q;j++)\\n                    if(a[i][j]!=\\'0\\' && v[k].ff!=a[i][j]) \\n                        yes=0;\\n            if(yes)\\n            {\\n                v[k].ff=-1;\\n                for(int i=x;i<=p;i++)\\n                    for(int j=y;j<=q;j++)\\n                        a[i][j]=\\'0\\';\\n                return 1;\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    \\n    bool isPrintable(vector<vector<int>>& targetGrid) \\n    {\\n        a=targetGrid;\\n        n=a.size(); m=a[0].size();\\n       \\n        map<int,pll> mn,mx;\\n        for(int i=0;i<n;i++)\\n            for(int j=0;j<m;j++)\\n            {\\n                int cl=a[i][j];\\n                if(mn.count(cl))\\n                {\\n                    pll p=mn[cl],q=mx[cl];\\n                    p.ff=min(p.ff,i); p.ss=min(p.ss,j);\\n                    q.ff=max(q.ff,i); q.ss=max(q.ss,j);\\n                    mn[cl]=p; mx[cl]=q;\\n                }\\n                else mn[cl]=mx[cl]={i,j};\\n            }\\n        \\n        for(auto i:mn)\\n            v.push_back({i.ff,{i.ss,mx[i.ff]}});\\n       \\n        while(update());\\n        \\n        int yes=1;\\n        for(int i=0;i<v.size();i++)\\n            if(v[i].ff!=-1) yes=0;\\n        return yes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2091631,
                "title": "java-topological-sort-tc-o-n-3-sc-o-n-2",
                "content": "```\\nclass Solution {\\n    // store each color\\'s left, top, right, bottom\\n    private Set<Integer>[] graph;\\n    private int[] indegrees;\\n    private int[][] ranges; \\n    private boolean[] exists;\\n    private int m;\\n    private int n;\\n    private int maxColor = 60; \\n    public boolean isPrintable(int[][] targetGrid) {\\n        this.m = targetGrid.length;\\n        this.n = targetGrid[0].length;\\n        buildRanges(targetGrid);\\n        buildGraph(targetGrid);\\n        int count = 0;\\n        int totalCount = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 1; i <= maxColor; i++) {\\n            if (exists[i]) {\\n                if (indegrees[i] == 0) {\\n                    queue.offer(i);\\n                }\\n                totalCount++;\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            count++;\\n            Integer current = queue.poll();\\n            for (Integer neighbor: graph[current]) {\\n                if (--indegrees[neighbor] == 0) {\\n                    queue.offer(neighbor);\\n                }\\n            }\\n        }\\n        return count == totalCount;\\n    }\\n    private void buildRanges(int[][] targetGrid) {\\n        this.ranges = new int[maxColor + 1][4];\\n        for (int i = 1; i <= maxColor; i++) {\\n            ranges[i][0] = ranges[i][1] = Integer.MAX_VALUE;\\n            ranges[i][2] = ranges[i][3] = Integer.MIN_VALUE;\\n        }\\n        exists = new boolean[maxColor + 1];\\n        int max = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int color = targetGrid[i][j];\\n                exists[color] = true;\\n                max = Math.max(max, color);\\n                ranges[color][0] = Math.min(ranges[color][0], j);\\n                ranges[color][1] = Math.min(ranges[color][1], i);\\n                ranges[color][2] = Math.max(ranges[color][2], j);\\n                ranges[color][3] = Math.max(ranges[color][3], i);\\n            }\\n        }\\n        maxColor = max;\\n    }\\n\\t// TC O(n^3) to build graph\\n    private void buildGraph(int[][] targetGrid) {\\n        graph = new Set[maxColor + 1];\\n        indegrees = new int[maxColor + 1];\\n        for (int c = 1; c <= maxColor; c++) {\\n            if (exists[c]) {\\n                graph[c] = new HashSet<>();\\n                for (int i = ranges[c][1]; i <= ranges[c][3]; i++) {\\n                    for (int j = ranges[c][0]; j <= ranges[c][2]; j++) {\\n                        int other = targetGrid[i][j];\\n                        if (other != c && !graph[c].contains(other)) {\\n                            graph[c].add(other);\\n                            indegrees[other]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    // store each color\\'s left, top, right, bottom\\n    private Set<Integer>[] graph;\\n    private int[] indegrees;\\n    private int[][] ranges; \\n    private boolean[] exists;\\n    private int m;\\n    private int n;\\n    private int maxColor = 60; \\n    public boolean isPrintable(int[][] targetGrid) {\\n        this.m = targetGrid.length;\\n        this.n = targetGrid[0].length;\\n        buildRanges(targetGrid);\\n        buildGraph(targetGrid);\\n        int count = 0;\\n        int totalCount = 0;\\n        Queue<Integer> queue = new LinkedList<>();\\n        for (int i = 1; i <= maxColor; i++) {\\n            if (exists[i]) {\\n                if (indegrees[i] == 0) {\\n                    queue.offer(i);\\n                }\\n                totalCount++;\\n            }\\n        }\\n        while (!queue.isEmpty()) {\\n            count++;\\n            Integer current = queue.poll();\\n            for (Integer neighbor: graph[current]) {\\n                if (--indegrees[neighbor] == 0) {\\n                    queue.offer(neighbor);\\n                }\\n            }\\n        }\\n        return count == totalCount;\\n    }\\n    private void buildRanges(int[][] targetGrid) {\\n        this.ranges = new int[maxColor + 1][4];\\n        for (int i = 1; i <= maxColor; i++) {\\n            ranges[i][0] = ranges[i][1] = Integer.MAX_VALUE;\\n            ranges[i][2] = ranges[i][3] = Integer.MIN_VALUE;\\n        }\\n        exists = new boolean[maxColor + 1];\\n        int max = 0;\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int color = targetGrid[i][j];\\n                exists[color] = true;\\n                max = Math.max(max, color);\\n                ranges[color][0] = Math.min(ranges[color][0], j);\\n                ranges[color][1] = Math.min(ranges[color][1], i);\\n                ranges[color][2] = Math.max(ranges[color][2], j);\\n                ranges[color][3] = Math.max(ranges[color][3], i);\\n            }\\n        }\\n        maxColor = max;\\n    }\\n\\t// TC O(n^3) to build graph\\n    private void buildGraph(int[][] targetGrid) {\\n        graph = new Set[maxColor + 1];\\n        indegrees = new int[maxColor + 1];\\n        for (int c = 1; c <= maxColor; c++) {\\n            if (exists[c]) {\\n                graph[c] = new HashSet<>();\\n                for (int i = ranges[c][1]; i <= ranges[c][3]; i++) {\\n                    for (int j = ranges[c][0]; j <= ranges[c][2]; j++) {\\n                        int other = targetGrid[i][j];\\n                        if (other != c && !graph[c].contains(other)) {\\n                            graph[c].add(other);\\n                            indegrees[other]++;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2073544,
                "title": "java-kahn-s-algorithm",
                "content": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int LEFT = 0, RIGHT = 1, TOP = 2, BOTTOM = 3;\\n        Map<Integer, int[]> coordinates = new HashMap<>();  // {left, right, top, bottom}\\n        Map<Integer, Set<Integer>> adj = new HashMap<>();   // adjacency list for colors\\n        Map<Integer, Integer> indegree = new HashMap<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        int m = targetGrid.length, n = targetGrid[0].length;\\n        \\n        // Finding the stretch of each color\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int color = targetGrid[i][j];\\n                if (coordinates.containsKey(color)) {\\n                    int[] coordinate = coordinates.get(color);\\n                    coordinate[LEFT] = Math.min(coordinate[LEFT], j);\\n                    coordinate[RIGHT] = Math.max(coordinate[RIGHT], j);\\n                    coordinate[TOP] = Math.min(coordinate[TOP], i);\\n                    coordinate[BOTTOM] = Math.max(coordinate[BOTTOM], i);\\n                } else {\\n                    coordinates.put(color, new int[]{j, j, i, i});\\n                    adj.put(color, new HashSet<>());\\n                }\\n            }\\n        }\\n        \\n        // Building an adjacency list\\n        for (Map.Entry<Integer, int[]> entry : coordinates.entrySet()) {\\n            Integer currentColor = entry.getKey();\\n            int[] coordinate = entry.getValue();\\n            for (int i = coordinate[TOP]; i <= coordinate[BOTTOM]; ++i) {\\n                for (int j = coordinate[LEFT]; j <= coordinate[RIGHT]; ++j) {\\n                    int color = targetGrid[i][j];\\n                    if (currentColor != color) {\\n                        adj.get(currentColor).add(color);\\n                    }\\n                }\\n            }\\n            indegree.put(currentColor, 0);\\n        }\\n        \\n        // Update indegrees of each color\\n        for (Set<Integer> entry : adj.values()) {\\n            for (int color : entry) {\\n                indegree.put(color, indegree.get(color) + 1);\\n            }\\n        }\\n        \\n        // Add nodes with zero indegree to the queue\\n        for (Map.Entry<Integer, Integer> entry : indegree.entrySet()) {\\n            if (entry.getValue() == 0)\\n                q.add(entry.getKey());\\n        }\\n        \\n\\t\\t// Kahn\\'s algorithm in action\\n        int size = 0;\\n        while (!q.isEmpty()) {\\n            int currentColor = q.remove();\\n            size++;\\n            for (int color : adj.get(currentColor)) {\\n                indegree.put(color, indegree.get(color) - 1);\\n                if (indegree.get(color) == 0)\\n                    q.add(color);\\n            }\\n        }\\n        \\n\\t\\t// If there was a cycle, all the nodes wouldn\\'t have been processed, \\n\\t\\t// since there is no valid topological order.\\n        return size == adj.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Topological Sort"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        int LEFT = 0, RIGHT = 1, TOP = 2, BOTTOM = 3;\\n        Map<Integer, int[]> coordinates = new HashMap<>();  // {left, right, top, bottom}\\n        Map<Integer, Set<Integer>> adj = new HashMap<>();   // adjacency list for colors\\n        Map<Integer, Integer> indegree = new HashMap<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        \\n        int m = targetGrid.length, n = targetGrid[0].length;\\n        \\n        // Finding the stretch of each color\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                int color = targetGrid[i][j];\\n                if (coordinates.containsKey(color)) {\\n                    int[] coordinate = coordinates.get(color);\\n                    coordinate[LEFT] = Math.min(coordinate[LEFT], j);\\n                    coordinate[RIGHT] = Math.max(coordinate[RIGHT], j);\\n                    coordinate[TOP] = Math.min(coordinate[TOP], i);\\n                    coordinate[BOTTOM] = Math.max(coordinate[BOTTOM], i);\\n                } else {\\n                    coordinates.put(color, new int[]{j, j, i, i});\\n                    adj.put(color, new HashSet<>());\\n                }\\n            }\\n        }\\n        \\n        // Building an adjacency list\\n        for (Map.Entry<Integer, int[]> entry : coordinates.entrySet()) {\\n            Integer currentColor = entry.getKey();\\n            int[] coordinate = entry.getValue();\\n            for (int i = coordinate[TOP]; i <= coordinate[BOTTOM]; ++i) {\\n                for (int j = coordinate[LEFT]; j <= coordinate[RIGHT]; ++j) {\\n                    int color = targetGrid[i][j];\\n                    if (currentColor != color) {\\n                        adj.get(currentColor).add(color);\\n                    }\\n                }\\n            }\\n            indegree.put(currentColor, 0);\\n        }\\n        \\n        // Update indegrees of each color\\n        for (Set<Integer> entry : adj.values()) {\\n            for (int color : entry) {\\n                indegree.put(color, indegree.get(color) + 1);\\n            }\\n        }\\n        \\n        // Add nodes with zero indegree to the queue\\n        for (Map.Entry<Integer, Integer> entry : indegree.entrySet()) {\\n            if (entry.getValue() == 0)\\n                q.add(entry.getKey());\\n        }\\n        \\n\\t\\t// Kahn\\'s algorithm in action\\n        int size = 0;\\n        while (!q.isEmpty()) {\\n            int currentColor = q.remove();\\n            size++;\\n            for (int color : adj.get(currentColor)) {\\n                indegree.put(color, indegree.get(color) - 1);\\n                if (indegree.get(color) == 0)\\n                    q.add(color);\\n            }\\n        }\\n        \\n\\t\\t// If there was a cycle, all the nodes wouldn\\'t have been processed, \\n\\t\\t// since there is no valid topological order.\\n        return size == adj.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1989601,
                "title": "c-with-comment",
                "content": "class Solution {\\npublic:\\n    /* 1. First find the (left/right/up/down) most grid index of one specific color\\n       It is documented in the map ma: ma[color index]={ box.l(min j), box.r(max j),  box.u(min i), box.d(max i)}\\n       this determines the rectangle(of this color) used for coloring.\\n       \\n       2. Determine the order of coloring from the overlap part of the grid. The order of coloring is documented\\n       in col_order vector, start coloring an empty grid with col_order[i] from i=0 to col_order.size()-1.\\n       \\n       3. col_order vector needed to be sort according to the overlap region coloring.\\n          function order : bubble sort the col_order.\\n          function flip  : if two color region overlaps, determine the color and decide whether exchange\\n          c1=col_order[i] &\\n          c2=col_order[j]\\n          .The top most part must be colored later.\\n       4. Color dummy grid t with color according to col_order in region ma[color index].\\n          Check if dummy t is the targetGrid.\\n          \\n        * print is for printing col_order. uncomment line 70 to observe bubble sort\\n    \\n    \\n    */\\n    map<int,vector<int>> ma;  //(color index)->{ box.l(min j), box.r(max j),  box.u(min i), box.d(max i)}\\n    map<int,vector<int>>::iterator it;\\n    vector<vector<int>> grid;\\n    bool flip(int c1,int c2){\\n        int i,j,l1,l2,r1,r2,d1,d2,u1,u2,m,n;\\n        m=grid.size();\\n        n=grid[0].size();\\n        l1=ma[c1][0];\\n        l2=ma[c2][0];\\n        r1=ma[c1][1];\\n        r2=ma[c2][1];\\n        d1=ma[c1][3];\\n        d2=ma[c2][3];\\n        u1=ma[c1][2];\\n        u2=ma[c2][2];\\n        if(r1<l2 or r2<l1 or u1>d2 or u2>d1) return false;\\n        //if(r1>l2 and u1<d2) return (grid[u1][r1]==c1);//upper right covered\\n        for(i=0;i<m;i++){\\n        for(j=0;j<n;j++){\\n            //cout<<d1<<d2<<u1<<u2<<endl;\\n            if(i>=u1 and i>=u2 and i<=d1 and i<=d2 and j>=l1 and j>=l2 and j<=r1 and j<=r2){\\n                //cout<<(grid[i][j])<<\" \"<<c1<<\" \"<<c2<<endl;\\n                return (grid[i][j] ==c1);\\n            }\\n        }\\n        }\\n        return false;\\n        \\n    }\\n    void print(vector<int>& col_order) {\\n        int i,j,n,tmp;\\n        n=col_order.size();\\n        for(i=0;i<n;i++){cout<<col_order[i]<<\" \";}\\n        cout<<endl;\\n        return;\\n    }\\n    void order(vector<int>& col_order) {\\n        int i,j,n,tmp;\\n        n=col_order.size();\\n        //col_order={5,4,3,1};\\n        //print(col_order);\\n        for(i=0;i<n;i++){\\n        for(j=i+1;j<n;j++){\\n            if(flip(col_order[i],col_order[j]) == true) {//col_order[j] is colored later than col_order[i]\\n            tmp=col_order[i];\\n            col_order[i]=col_order[j];\\n            col_order[j]=tmp;\\n            //print(col_order);\\n            }\\n        }    \\n        }\\n        return;\\n    }\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n    grid=targetGrid;  \\n    vector<vector<int>> t;\\n    vector<int> col_order;\\n    int i,j,k,n,m;\\n    //begin constructing map ma\\n    m=targetGrid.size();\\n    n=targetGrid[0].size();\\n    for(i=0;i<m;i++){\\n    for(j=0;j<n;j++){\\n        if(ma.find(targetGrid[i][j])==ma.end()){\\n            ma[targetGrid[i][j]]={j,j,i,i};\\n             \\n        }\\n        if(j<ma[targetGrid[i][j]][0]) ma[targetGrid[i][j]][0]=j;\\n        if(j>ma[targetGrid[i][j]][1]) ma[targetGrid[i][j]][1]=j;\\n        if(i<ma[targetGrid[i][j]][2]) ma[targetGrid[i][j]][2]=i;\\n        if(i>ma[targetGrid[i][j]][3]) ma[targetGrid[i][j]][3]=i;\\n    }   \\n    }\\n    //end constructing map ma\\n        \\n    //begin constructing coloring order col_order\\n    for(it=ma.begin();it!=ma.end();it++){\\n        col_order.push_back(it->first);\\n    }\\n    //print(col_order);\\n    order(col_order);   //bubble sort\\n    //print(col_order);\\n    //end constructing coloring order col_order\\n    \\n    //use dummy grid t to check if the grid can be reconstructed.\\n    t=vector(m,vector<int> (n,0));\\n    for(k=0;k<col_order.size();k++)  {\\n    for(i=ma[col_order[k]][2];i<=ma[col_order[k]][3];i++){\\n        for(j=ma[col_order[k]][0];j<=ma[col_order[k]][1];j++){\\n            t[i][j]=col_order[k];\\n        }\\n    }\\n    }\\n    //dummy grid t is constructed and colored\\n    //check\\n    for(i=0;i<m;i++){\\n    for(j=0;j<n;j++){\\n        if( targetGrid[i][j] !=t[i][j]) return false;\\n        \\n    }\\n    }\\n    return true;\\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    /* 1. First find the (left/right/up/down) most grid index of one specific color\\n       It is documented in the map ma: ma[color index]={ box.l(min j), box.r(max j),  box.u(min i), box.d(max i)}",
                "codeTag": "Java"
            },
            {
                "id": 1949381,
                "title": "c-99-34-faster-but-i-can-t-find-time-complexity",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstruct Color {\\n\\t\\t\\tint xmin, ymin, xmax, ymax, visited;\\n\\t\\t\\tColor () {\\n\\t\\t\\t\\txmin = 100; ymin = 100; xmax = -1; ymax = -1;\\n\\t\\t\\t\\tvisited = false;\\n\\t\\t\\t}\\n\\t\\t\\tvoid push(int i, int j) {\\n\\t\\t\\t\\txmin = min(i, xmin);\\n\\t\\t\\t\\tymin = min(j, ymin);\\n\\t\\t\\t\\txmax = max(i, xmax);\\n\\t\\t\\t\\tymax = max(j, ymax);\\n\\t\\t\\t}\\n\\t\\t\\tvoid change(vector<vector<int>>& grid) {\\n\\t\\t\\t\\tfor(int i = xmin; i <= xmax; i++) \\n\\t\\t\\t\\t\\tfor(int j = ymin; j <= ymax; j++) \\n\\t\\t\\t\\t\\t\\tgrid[i][j] = 100;\\n\\t\\t\\t\\tvisited = true;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tbool isPrintable(vector<vector<int>>& targetGrid) {\\n\\t\\t\\tint m = targetGrid.size(), n = targetGrid[0].size();\\n\\t\\t\\tvector<Color> color(70);\\n\\t\\t\\tunordered_set<int> colorInGrid;\\n\\t\\t\\tfor(int i = 0; i < m; i++) \\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) \\n\\t\\t\\t\\t   color[targetGrid[i][j]].push(i, j), colorInGrid.insert(targetGrid[i][j]);       \\n\\n\\t\\t\\tbool ok = true;\\n\\t\\t\\twhile(ok) {\\n\\t\\t\\t\\tok = false;\\n\\t\\t\\t\\tfor(auto& c : colorInGrid) {\\n\\t\\t\\t\\t\\tif(color[c].visited) continue;\\n\\t\\t\\t\\t\\tbool findRec = true;\\n\\t\\t\\t\\t\\tfor(int i = color[c].xmin; i <= color[c].xmax && !findRec ; i++) \\n\\t\\t\\t\\t\\t\\tfor(int j = color[c].ymin; j <= color[c].ymax && !findRec ; j++) \\n\\t\\t\\t\\t\\t\\t\\tif(targetGrid[i][j] != 100 && targetGrid[i][j] != c) findRec  = true;\\n\\t\\t\\t\\t\\tif(findRec == true) {\\n\\t\\t\\t\\t\\t\\tok = true;\\n\\t\\t\\t\\t\\t\\tcolor[c].change(targetGrid);\\n\\t\\t\\t\\t\\t}    \\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i = 0; i < m; i++) \\n\\t\\t\\t\\tfor(int j = 0; j < n; j++) \\n\\t\\t\\t\\t\\tif(targetGrid[i][j] != 100) return false;\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstruct Color {\\n\\t\\t\\tint xmin, ymin, xmax, ymax, visited;\\n\\t\\t\\tColor () {\\n\\t\\t\\t\\txmin = 100; ymin = 100; xmax = -1; ymax = -1;\\n\\t\\t\\t\\tvisited = false;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1831740,
                "title": "c-solution-using-topological-sort",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int maxColors=60;\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m=targetGrid.size();\\n        int n=targetGrid[0].size();\\n        unordered_map<int,vector<int>> umap;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int color = targetGrid[i][j];\\n                if(umap.find(color) == umap.end()){\\n                    umap[color]={i,i,j,j};\\n                }\\n                else{\\n                    umap[color][0]=min(umap[color][0],i);\\n                    umap[color][1]=max(umap[color][1],i);\\n                    umap[color][2]=min(umap[color][2],j);\\n                    umap[color][3]=max(umap[color][3],j);\\n                }\\n            }\\n        }\\n        vector<vector<int>> graph(maxColors+1,vector<int>());\\n        vector<int> inDegree(maxColors+1,-1);\\n        for(auto itr : umap){\\n            int color=itr.first;\\n            int rowStart=itr.second[0];\\n            int rowEnd=itr.second[1];\\n            int columnStart=itr.second[2];\\n            int columnEnd=itr.second[3];\\n            vector<int> visited(maxColors+1,false);\\n            if(inDegree[color] == -1){\\n                inDegree[color]=0;\\n            }\\n            for(int i=rowStart;i<=rowEnd;i++){\\n                for(int j=columnStart;j<=columnEnd;j++){\\n                    if(color != targetGrid[i][j]){\\n                        if(visited[targetGrid[i][j]] == false){\\n                            graph[color].push_back(targetGrid[i][j]);\\n                            if(inDegree[targetGrid[i][j]] == -1){\\n                                inDegree[targetGrid[i][j]]=0;\\n                            }\\n                            inDegree[targetGrid[i][j]]++;\\n                            visited[targetGrid[i][j]]=true;\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        queue<int> bfsQueue;\\n        int totalColors=0;\\n        for(int i=0;i<=maxColors;i++){\\n            if(inDegree[i] != -1){\\n                totalColors++;\\n            }\\n            if(inDegree[i] == 0){\\n                bfsQueue.push(i);\\n            }\\n        }\\n        while(!bfsQueue.empty()){\\n            int front=bfsQueue.front();\\n            bfsQueue.pop();\\n            totalColors--;\\n            for(int i=0;i<graph[front].size();i++){\\n                int p=graph[front][i];\\n                inDegree[p]--;\\n                if(inDegree[p] == 0){\\n                    bfsQueue.push(p);\\n                }\\n            }\\n        }\\n        return totalColors == 0;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    int maxColors=60;\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m=targetGrid.size();\\n        int n=targetGrid[0].size();\\n        unordered_map<int,vector<int>> umap;\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                int color = targetGrid[i][j];\\n                if(umap.find(color) == umap.end()){\\n                    umap[color]={i,i,j,j}",
                "codeTag": "Java"
            },
            {
                "id": 1793267,
                "title": "c-topo-sort",
                "content": "```\\n//Find prerequisites for each color and then use toposort\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>>adj;\\n    vector<int>indeg;\\n    set<int>colors;\\n    void find(int col,vector<vector<int>>&grid)\\n    {\\n        //Find extreme points for the color \\'col\\'\\n        int r1=-1,r2=-1,c1=-1,c2=-1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==col)\\n                {\\n                    if(r1==-1)\\n                    {\\n                        r1=r2=i;\\n                        c1=c2=j;\\n                    }\\n                    else\\n                    {\\n                        r2=i;\\n                        c1=min(c1,j);\\n                        c2=max(c2,j);\\n                    }\\n                }\\n            }\\n        }\\n        if(r1==-1)\\n            return;\\n        colors.insert(col);\\n        // No. of different colors in this boundary are prerequisite for \\'col\\'\\n        for(int i=r1;i<=r2;i++)\\n        {\\n            for(int j=c1;j<=c2;j++)\\n            {\\n                if(grid[i][j]!=col)\\n                {\\n                    adj[grid[i][j]].push_back(col);\\n                    indeg[col]++;\\n                }\\n            }\\n        }\\n    }\\n    bool isPrintable(vector<vector<int>>&grid) \\n    {\\n        m=grid.size(),n=grid[0].size();\\n        adj.resize(61);\\n        indeg.resize(61);\\n        for(int i=1;i<=60;i++)\\n            find(i,grid);\\n        queue<int>q;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(indeg[i]==0 && colors.find(i)!=colors.end())\\n                q.push(i);\\n        }\\n        int count=0;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            count++;\\n            q.pop();\\n            for(auto &v:adj[u])\\n            {\\n                indeg[v]--;\\n                if(indeg[v]==0)\\n                    q.push(v);\\n            }\\n        }\\n        return count==colors.size();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Find prerequisites for each color and then use toposort\\nclass Solution {\\npublic:\\n    int m,n;\\n    vector<vector<int>>adj;\\n    vector<int>indeg;\\n    set<int>colors;\\n    void find(int col,vector<vector<int>>&grid)\\n    {\\n        //Find extreme points for the color \\'col\\'\\n        int r1=-1,r2=-1,c1=-1,c2=-1;\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(grid[i][j]==col)\\n                {\\n                    if(r1==-1)\\n                    {\\n                        r1=r2=i;\\n                        c1=c2=j;\\n                    }\\n                    else\\n                    {\\n                        r2=i;\\n                        c1=min(c1,j);\\n                        c2=max(c2,j);\\n                    }\\n                }\\n            }\\n        }\\n        if(r1==-1)\\n            return;\\n        colors.insert(col);\\n        // No. of different colors in this boundary are prerequisite for \\'col\\'\\n        for(int i=r1;i<=r2;i++)\\n        {\\n            for(int j=c1;j<=c2;j++)\\n            {\\n                if(grid[i][j]!=col)\\n                {\\n                    adj[grid[i][j]].push_back(col);\\n                    indeg[col]++;\\n                }\\n            }\\n        }\\n    }\\n    bool isPrintable(vector<vector<int>>&grid) \\n    {\\n        m=grid.size(),n=grid[0].size();\\n        adj.resize(61);\\n        indeg.resize(61);\\n        for(int i=1;i<=60;i++)\\n            find(i,grid);\\n        queue<int>q;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(indeg[i]==0 && colors.find(i)!=colors.end())\\n                q.push(i);\\n        }\\n        int count=0;\\n        while(!q.empty())\\n        {\\n            int u=q.front();\\n            count++;\\n            q.pop();\\n            for(auto &v:adj[u])\\n            {\\n                indeg[v]--;\\n                if(indeg[v]==0)\\n                    q.push(v);\\n            }\\n        }\\n        return count==colors.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1678639,
                "title": "very-interesting-problem-java-dfs",
                "content": "```\\nclass Solution {\\n    Set<Integer> allColors = new HashSet<>();\\n    List<int[]> list = new ArrayList<>();\\n    int maxR = -1, minR = 1000, maxC = -1, minC = 1000;\\n    int times = 0;\\n\\n    public boolean isPrintable(int[][] grid) {\\n        populateColors(grid);\\n        boolean removed = false;\\n        while (times <= 50) {\\n            int validColor = -1;\\n            if (allColors.size() == 0) {\\n                return true;\\n            }\\n            for (int color : allColors) {\\n                list.clear();\\n                maxR = -1;\\n                minR = 1000;\\n                maxC = -1;\\n                minC = 1000;\\n                boolean valid = true;\\n                boolean[][] vis = new boolean[grid.length][grid[0].length];\\n                for (boolean[] r : vis) Arrays.fill(r, false);\\n                for (int i = 0; i < grid.length; i++) {\\n                    for (int j = 0; j < grid[i].length; j++) {\\n                        if (grid[i][j] == color && !vis[i][j]) {\\n                            dfs(i, j, color, grid, vis);\\n                        }\\n                    }\\n                }\\n//                System.out.println(color + \" \" + list.size());\\n                // {maxR,minC},{maxR,maxC},{minR,maxC},{minR,minC}\\n                int numPoints = 0;\\n                //potentially valid color\\n                for (int i = minR; i <= maxR; i++) {\\n                    for (int j = minC; j <= maxC; j++) {\\n                        numPoints++;\\n                        if (!vis[i][j]) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid && numPoints <= list.size()) {\\n                    validColor = color;\\n                    break;\\n                }\\n\\n            }\\n            if (validColor != -1) {\\n                //System.out.println(\"Removing Color = \" + validColor);\\n                for (int[] point : list) {\\n                    grid[point[0]][point[1]] = -1;\\n                }\\n                allColors.remove(validColor);\\n                removed =true;\\n            }\\n            if(!removed){\\n                break;\\n            }\\n            times++;\\n        }\\n        return false;\\n    }\\n\\n    void dfs(int row, int col, int color, int[][] grid, boolean[][] vis) {\\n        if (row < 0 || col < 0 || row >= grid.length || col >= grid[row].length) {\\n            return;\\n        }\\n        if (grid[row][col] == color || grid[row][col] < 0) {\\n            if (!vis[row][col]) {\\n                vis[row][col] = true;\\n                list.add(new int[]{row, col});\\n                if (grid[row][col] == color) {\\n                    maxR = Math.max(row, maxR);\\n                    maxC = Math.max(col, maxC);\\n                    minR = Math.min(row, minR);\\n                    minC = Math.min(col, minC);\\n                }\\n                int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n                for (int[] dir : dirs) {\\n                    dfs(row + dir[0], col + dir[1], color, grid, vis);\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    void populateColors(int[][] grid) {\\n        for (int[] arr : grid) {\\n            for (int color : arr) {\\n                allColors.add(color);\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Set<Integer> allColors = new HashSet<>();\\n    List<int[]> list = new ArrayList<>();\\n    int maxR = -1, minR = 1000, maxC = -1, minC = 1000;\\n    int times = 0;\\n\\n    public boolean isPrintable(int[][] grid) {\\n        populateColors(grid);\\n        boolean removed = false;\\n        while (times <= 50) {\\n            int validColor = -1;\\n            if (allColors.size() == 0) {\\n                return true;\\n            }\\n            for (int color : allColors) {\\n                list.clear();\\n                maxR = -1;\\n                minR = 1000;\\n                maxC = -1;\\n                minC = 1000;\\n                boolean valid = true;\\n                boolean[][] vis = new boolean[grid.length][grid[0].length];\\n                for (boolean[] r : vis) Arrays.fill(r, false);\\n                for (int i = 0; i < grid.length; i++) {\\n                    for (int j = 0; j < grid[i].length; j++) {\\n                        if (grid[i][j] == color && !vis[i][j]) {\\n                            dfs(i, j, color, grid, vis);\\n                        }\\n                    }\\n                }\\n//                System.out.println(color + \" \" + list.size());\\n                // {maxR,minC},{maxR,maxC},{minR,maxC},{minR,minC}\\n                int numPoints = 0;\\n                //potentially valid color\\n                for (int i = minR; i <= maxR; i++) {\\n                    for (int j = minC; j <= maxC; j++) {\\n                        numPoints++;\\n                        if (!vis[i][j]) {\\n                            valid = false;\\n                            break;\\n                        }\\n                    }\\n                }\\n                if (valid && numPoints <= list.size()) {\\n                    validColor = color;\\n                    break;\\n                }\\n\\n            }\\n            if (validColor != -1) {\\n                //System.out.println(\"Removing Color = \" + validColor);\\n                for (int[] point : list) {\\n                    grid[point[0]][point[1]] = -1;\\n                }\\n                allColors.remove(validColor);\\n                removed =true;\\n            }\\n            if(!removed){\\n                break;\\n            }\\n            times++;\\n        }\\n        return false;\\n    }\\n\\n    void dfs(int row, int col, int color, int[][] grid, boolean[][] vis) {\\n        if (row < 0 || col < 0 || row >= grid.length || col >= grid[row].length) {\\n            return;\\n        }\\n        if (grid[row][col] == color || grid[row][col] < 0) {\\n            if (!vis[row][col]) {\\n                vis[row][col] = true;\\n                list.add(new int[]{row, col});\\n                if (grid[row][col] == color) {\\n                    maxR = Math.max(row, maxR);\\n                    maxC = Math.max(col, maxC);\\n                    minR = Math.min(row, minR);\\n                    minC = Math.min(col, minC);\\n                }\\n                int[][] dirs = new int[][]{{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\\n                for (int[] dir : dirs) {\\n                    dfs(row + dir[0], col + dir[1], color, grid, vis);\\n                }\\n            }\\n        }\\n    }\\n\\n\\n    void populateColors(int[][] grid) {\\n        for (int[] arr : grid) {\\n            for (int color : arr) {\\n                allColors.add(color);\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1507261,
                "title": "python-o-cmn-time-o-c-space-very-fast",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        #record min and max rows or columns for each color\\n        colorToRange = {}\\n        for row in range(m):\\n            for col in range(n):\\n                color = targetGrid[row][col]\\n                if color not in colorToRange:\\n                    colorToRange[color] = [row, row, col, col]\\n                else:\\n                    colorToRange[color][0] = min(colorToRange[color][0], row)\\n                    colorToRange[color][1] = max(colorToRange[color][1], row)\\n                    colorToRange[color][2] = min(colorToRange[color][2], col)\\n                    colorToRange[color][3] = max(colorToRange[color][3], col)\\n        \\n        #DFS for topological sort\\n        def topologicalSort(color: int):\\n            nonlocal colorStatus\\n            \\n            if colorStatus[color] == \"visited\":\\n                return False\\n            elif colorStatus[color] == \"resolved\":\\n                return True\\n            \\n            colorStatus[color] = \"visited\"\\n                \\n            row_min, row_max, col_min, col_max = colorToRange[color]\\n            for row in range(row_min, row_max + 1):\\n                for col in range(col_min, col_max + 1):\\n                    nextColor = targetGrid[row][col]\\n                    if  nextColor != color and not topologicalSort(nextColor):\\n                        return False\\n            \\n            colorStatus[color] = \\'resolved\\'\\n            return True\\n            \\n        colorStatus = dict.fromkeys(colorToRange)\\n        for color in colorToRange:\\n            if not topologicalSort(color):\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        #record min and max rows or columns for each color\\n        colorToRange = {}\\n        for row in range(m):\\n            for col in range(n):\\n                color = targetGrid[row][col]\\n                if color not in colorToRange:\\n                    colorToRange[color] = [row, row, col, col]\\n                else:\\n                    colorToRange[color][0] = min(colorToRange[color][0], row)\\n                    colorToRange[color][1] = max(colorToRange[color][1], row)\\n                    colorToRange[color][2] = min(colorToRange[color][2], col)\\n                    colorToRange[color][3] = max(colorToRange[color][3], col)\\n        \\n        #DFS for topological sort\\n        def topologicalSort(color: int):\\n            nonlocal colorStatus\\n            \\n            if colorStatus[color] == \"visited\":\\n                return False\\n            elif colorStatus[color] == \"resolved\":\\n                return True\\n            \\n            colorStatus[color] = \"visited\"\\n                \\n            row_min, row_max, col_min, col_max = colorToRange[color]\\n            for row in range(row_min, row_max + 1):\\n                for col in range(col_min, col_max + 1):\\n                    nextColor = targetGrid[row][col]\\n                    if  nextColor != color and not topologicalSort(nextColor):\\n                        return False\\n            \\n            colorStatus[color] = \\'resolved\\'\\n            return True\\n            \\n        colorStatus = dict.fromkeys(colorToRange)\\n        for color in colorToRange:\\n            if not topologicalSort(color):\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434080,
                "title": "scala",
                "content": "```\\nimport math._\\n\\nobject Solution {\\n  def isPrintable(target: Array[Array[Int]]): Boolean = {\\n    val m = target.length\\n    val n = target.headOption.map(_.length).getOrElse(0)\\n\\n    val colors = (0 until m)\\n      .flatMap { i =>\\n        (0 until n).collect {\\n          case j if target(i)(j) > 0 => target(i)(j) -> ((i, i), (j, j))\\n        }\\n      }\\n      .groupMapReduce(_._1)(_._2) {\\n        case (((minRow1, maxRow1), (minCol1, maxCol1)), ((minRow2, maxRow2), (minCol2, maxCol2))) =>\\n          ((min(minRow1, minRow2), max(maxRow1, maxRow2)), (min(minCol1, minCol2), max(maxCol1, maxCol2)))\\n      }\\n    \\n    if (colors.nonEmpty) {\\n      def isColorPrintable(color: Int) = colors(color) match {\\n        case ((minRow, maxRow), (minCol, maxCol)) => (minRow to maxRow).forall { i =>\\n          (minCol to maxCol).forall(j => target(i)(j) == 0 || target(i)(j) == color)\\n        }\\n      }\\n\\n      val printableColors = colors.keySet.filter(isColorPrintable)\\n\\n      if (printableColors.nonEmpty) {\\n        for (i <- 0 until m; j <- 0 until n if printableColors.contains(target(i)(j))) {\\n          target(i)(j) = 0\\n        }\\n        isPrintable(target)\\n      } else {\\n        false\\n      }\\n    } else {\\n      true\\n    }\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport math._\\n\\nobject Solution {\\n  def isPrintable(target: Array[Array[Int]]): Boolean = {\\n    val m = target.length\\n    val n = target.headOption.map(_.length).getOrElse(0)\\n\\n    val colors = (0 until m)\\n      .flatMap { i =>\\n        (0 until n).collect {\\n          case j if target(i)(j) > 0 => target(i)(j) -> ((i, i), (j, j))\\n        }\\n      }\\n      .groupMapReduce(_._1)(_._2) {\\n        case (((minRow1, maxRow1), (minCol1, maxCol1)), ((minRow2, maxRow2), (minCol2, maxCol2))) =>\\n          ((min(minRow1, minRow2), max(maxRow1, maxRow2)), (min(minCol1, minCol2), max(maxCol1, maxCol2)))\\n      }\\n    \\n    if (colors.nonEmpty) {\\n      def isColorPrintable(color: Int) = colors(color) match {\\n        case ((minRow, maxRow), (minCol, maxCol)) => (minRow to maxRow).forall { i =>\\n          (minCol to maxCol).forall(j => target(i)(j) == 0 || target(i)(j) == color)\\n        }\\n      }\\n\\n      val printableColors = colors.keySet.filter(isColorPrintable)\\n\\n      if (printableColors.nonEmpty) {\\n        for (i <- 0 until m; j <- 0 until n if printableColors.contains(target(i)(j))) {\\n          target(i)(j) = 0\\n        }\\n        isPrintable(target)\\n      } else {\\n        false\\n      }\\n    } else {\\n      true\\n    }\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1421039,
                "title": "c-topological-sorting",
                "content": "```\\nclass Solution {\\n#define pb push_back\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<vector<int>>g(61);\\n        vector<int>xmax(61,-1),xmin(61,n),ymax(61,-1),ymin(61,m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                xmax[targetGrid[i][j]]=max(xmax[targetGrid[i][j]],i);\\n                xmin[targetGrid[i][j]]=min(xmin[targetGrid[i][j]],i);\\n                ymax[targetGrid[i][j]]=max(ymax[targetGrid[i][j]],j);\\n                ymin[targetGrid[i][j]]=min(ymin[targetGrid[i][j]],j);\\n            }\\n        }\\n        vector<int>indeg(61);\\n        for(int col=1;col<=60;col++){\\n            for(int i=xmin[col];i<=xmax[col];i++){\\n                for(int j=ymin[col];j<=ymax[col];j++){\\n                    if(targetGrid[i][j]!=col){\\n                        g[col].pb(targetGrid[i][j]);\\n                        indeg[targetGrid[i][j]]++;\\n                    }\\n                }\\n            }\\n        }\\n        int visited=0;\\n        queue<int>q;\\n        for(int col=1;col<=60;col++){\\n            if(!indeg[col]){\\n                q.push(col);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            visited++;\\n            for(auto &child:g[node]){\\n                if(!(--indeg[child])){\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return visited==60;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n#define pb push_back\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n=targetGrid.size(),m=targetGrid[0].size();\\n        vector<vector<int>>g(61);\\n        vector<int>xmax(61,-1),xmin(61,n),ymax(61,-1),ymin(61,m);\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                xmax[targetGrid[i][j]]=max(xmax[targetGrid[i][j]],i);\\n                xmin[targetGrid[i][j]]=min(xmin[targetGrid[i][j]],i);\\n                ymax[targetGrid[i][j]]=max(ymax[targetGrid[i][j]],j);\\n                ymin[targetGrid[i][j]]=min(ymin[targetGrid[i][j]],j);\\n            }\\n        }\\n        vector<int>indeg(61);\\n        for(int col=1;col<=60;col++){\\n            for(int i=xmin[col];i<=xmax[col];i++){\\n                for(int j=ymin[col];j<=ymax[col];j++){\\n                    if(targetGrid[i][j]!=col){\\n                        g[col].pb(targetGrid[i][j]);\\n                        indeg[targetGrid[i][j]]++;\\n                    }\\n                }\\n            }\\n        }\\n        int visited=0;\\n        queue<int>q;\\n        for(int col=1;col<=60;col++){\\n            if(!indeg[col]){\\n                q.push(col);\\n            }\\n        }\\n        while(!q.empty()){\\n            int node=q.front();\\n            q.pop();\\n            visited++;\\n            for(auto &child:g[node]){\\n                if(!(--indeg[child])){\\n                    q.push(child);\\n                }\\n            }\\n        }\\n        return visited==60;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407449,
                "title": "topological-sorting-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> g[65];\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n  = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int in[65];\\n        memset(in,0,sizeof in);\\n        for(int i=1;i<=60;i++)g[i].clear();\\n        for(int color=1;color<=60;color++)\\n        {\\n            int ur=1000,uc=1000;\\n            int lr=-1,lc=-1;\\n            int flag = 0;\\n            for(int i=1;i<=n;i++)\\n            {\\n                for(int j=1;j<=m;j++)\\n                {\\n                    if(targetGrid[i-1][j-1] == color)\\n                    {\\n                        flag = 1;\\n                        ur = min(ur,i);\\n                        uc = min(uc,j);\\n                        lr = max(lr,i);\\n                        lc = max(lc,j);\\n                    }\\n                }\\n            }\\n\\n            if(!flag)continue;\\n            for(int i=ur;i<=lr;i++)\\n            {\\n                for(int j=uc;j<=lc;j++)\\n                {\\n                    if(targetGrid[i-1][j-1] != color)\\n                    {\\n                        in[targetGrid[i-1][j-1]]++;\\n                        g[color].push_back(targetGrid[i-1][j-1]);\\n                    }\\n                }\\n            }\\n\\n        }\\n\\n        queue<int> q;\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(in[i] == 0)q.push(i);\\n        }\\n\\n        while(!q.empty())\\n        {\\n            int f = q.front();q.pop();\\n            for(auto v:g[f])\\n            {\\n                in[v]--;\\n                if(in[v] == 0)q.push(v);\\n            }\\n        }\\n\\n        for(int i=1;i<=60;i++)\\n        {\\n            if(in[i]!=0)return 0;\\n        }\\n        return 1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> g[65];\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int n  = targetGrid.size();\\n        int m = targetGrid[0].size();\\n        int in[65];\\n        memset(in,0,sizeof in);\\n        for(int i=1;i<=60;i++)g[i].clear();\\n        for(int color=1;color<=60;color++)\\n        {\\n            int ur=1000,uc=1000;\\n            int lr=-1,lc=-1;\\n            int flag = 0;\\n            for(int i=1;i<=n;i++)\\n            {\\n                for(int j=1;j<=m;j++)\\n                {\\n                    if(targetGrid[i-1][j-1] == color)\\n                    {\\n                        flag = 1;\\n                        ur = min(ur,i);\\n                        uc = min(uc,j);\\n                        lr = max(lr,i);\\n                        lc = max(lc,j);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1347194,
                "title": "use-overlapping-rectangles-and-topological-sort-to-recreate-the-grid-explanation-in-comments",
                "content": "```\\nfrom graphlib import TopologicalSorter, CycleError\\n\\nColor = int\\nCorner = Tuple[int, int]\\nRect = Tuple[Corner, Corner]  # [upper-left, lower-right (non-inclusive)]\\nLayer = Tuple[Color, Rect]\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # Runtime is the summation of several steps but is dominated by the second step\\n        # O(M*N + C*C*M*N + (O(C*C) + O(M*N)) + M*N) -> O(C*C*M*N)\\n        def compare(a:Layer, b:Layer) -> int:\\n            \"\"\"\\n            Determine if two rectangles overlap.\\n\\n            Return:\\n                -1 if b is over a\\n                0 if there is no overlap or an order cannot be determined (the overlap contains no elements of a or b)\\n                1 if a is over b\\n            \"\"\"\\n            val_a, (a_ul, a_lr) = a\\n            val_b, (b_ul, b_lr) = b\\n\\n            # Get overlap rectangle\\n            ul, lr = (\\n                (max(a_ul[0], b_ul[0]), max(a_ul[1], b_ul[1])),\\n                (min(a_lr[0], b_lr[0]), min(a_lr[1], b_lr[1])),\\n            )\\n\\n            # If either dimension is non-positive, there is no overlap\\n            if lr[0] - ul[0] <= 0 or lr[1] - ul[1] <= 0:\\n                return 0\\n\\n            # Find the first element matching a or b in the overlap rectangle.\\n            # We\\'ll consider that the \"over\" value.\\n            for r in range(ul[0], lr[0]):\\n                for c in range(ul[1], lr[1]):\\n                    if targetGrid[r][c] == val_b:\\n                        return -1\\n                    elif targetGrid[r][c] == val_a:\\n                        return 1\\n            # We could find no values from a or b in the overlap.\\n            # The result is indeterminate.\\n            return 0\\n\\n        # Generate the enclosing rectangles for each visible color (ie. layers).\\n        # O(M*N)\\n        rects:Dict[Color, Rect] = defaultdict(lambda: ([100, 100], [0, 0]))\\n        for r, row in enumerate(targetGrid):\\n            for c, val in enumerate(row):\\n                ul, lr = rects[val]\\n                rects[val] = (\\n                    (min(ul[0], r), min(ul[1], c)),\\n                    (max(lr[0], r + 1), max(lr[1], c + 1))\\n                )\\n\\n        # Compare every pair of layers.\\n        # If overlap is detected, record that the \"upper\" rectangle depends on the \"lower\" one.\\n        # O(C*C*M*N)  # Number of colors\\n        layers:List[Layer] = list(rects.items())\\n        graph:Dict[Layer, Set[Layer]] = {layer: set() for layer in layers}\\n        for i, a in enumerate(layers):\\n            for b in layers[i + 1 :]:\\n                if (cmp := compare(a, b)) < 0:\\n                    graph[b].add(a)\\n                elif cmp > 0:\\n                    graph[a].add(b)\\n\\n        # Use topological sort on the graph to reproduce the printing order (in the absence\\n        # of cycles) and print our own grid.\\n        # O(C*C) + O(M*N)  // O(C*C) is derived from topological sort O(V+E)\\n        try:\\n            grid = [[0] * len(targetGrid[0]) for _ in targetGrid]\\n            for color, (ul, lr) in TopologicalSorter(graph).static_order():\\n                for r in range(ul[0], lr[0]):\\n                    for c in range(ul[1], lr[1]):\\n                        grid[r][c] = color\\n        except CycleError:\\n            return False\\n\\n        # Compare the grids\\n        # O(M*N)\\n        return grid == targetGrid\\n```",
                "solutionTags": [
                    "Python",
                    "Topological Sort"
                ],
                "code": "```\\nfrom graphlib import TopologicalSorter, CycleError\\n\\nColor = int\\nCorner = Tuple[int, int]\\nRect = Tuple[Corner, Corner]  # [upper-left, lower-right (non-inclusive)]\\nLayer = Tuple[Color, Rect]\\n\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        # Runtime is the summation of several steps but is dominated by the second step\\n        # O(M*N + C*C*M*N + (O(C*C) + O(M*N)) + M*N) -> O(C*C*M*N)\\n        def compare(a:Layer, b:Layer) -> int:\\n            \"\"\"\\n            Determine if two rectangles overlap.\\n\\n            Return:\\n                -1 if b is over a\\n                0 if there is no overlap or an order cannot be determined (the overlap contains no elements of a or b)\\n                1 if a is over b\\n            \"\"\"\\n            val_a, (a_ul, a_lr) = a\\n            val_b, (b_ul, b_lr) = b\\n\\n            # Get overlap rectangle\\n            ul, lr = (\\n                (max(a_ul[0], b_ul[0]), max(a_ul[1], b_ul[1])),\\n                (min(a_lr[0], b_lr[0]), min(a_lr[1], b_lr[1])),\\n            )\\n\\n            # If either dimension is non-positive, there is no overlap\\n            if lr[0] - ul[0] <= 0 or lr[1] - ul[1] <= 0:\\n                return 0\\n\\n            # Find the first element matching a or b in the overlap rectangle.\\n            # We\\'ll consider that the \"over\" value.\\n            for r in range(ul[0], lr[0]):\\n                for c in range(ul[1], lr[1]):\\n                    if targetGrid[r][c] == val_b:\\n                        return -1\\n                    elif targetGrid[r][c] == val_a:\\n                        return 1\\n            # We could find no values from a or b in the overlap.\\n            # The result is indeterminate.\\n            return 0\\n\\n        # Generate the enclosing rectangles for each visible color (ie. layers).\\n        # O(M*N)\\n        rects:Dict[Color, Rect] = defaultdict(lambda: ([100, 100], [0, 0]))\\n        for r, row in enumerate(targetGrid):\\n            for c, val in enumerate(row):\\n                ul, lr = rects[val]\\n                rects[val] = (\\n                    (min(ul[0], r), min(ul[1], c)),\\n                    (max(lr[0], r + 1), max(lr[1], c + 1))\\n                )\\n\\n        # Compare every pair of layers.\\n        # If overlap is detected, record that the \"upper\" rectangle depends on the \"lower\" one.\\n        # O(C*C*M*N)  # Number of colors\\n        layers:List[Layer] = list(rects.items())\\n        graph:Dict[Layer, Set[Layer]] = {layer: set() for layer in layers}\\n        for i, a in enumerate(layers):\\n            for b in layers[i + 1 :]:\\n                if (cmp := compare(a, b)) < 0:\\n                    graph[b].add(a)\\n                elif cmp > 0:\\n                    graph[a].add(b)\\n\\n        # Use topological sort on the graph to reproduce the printing order (in the absence\\n        # of cycles) and print our own grid.\\n        # O(C*C) + O(M*N)  // O(C*C) is derived from topological sort O(V+E)\\n        try:\\n            grid = [[0] * len(targetGrid[0]) for _ in targetGrid]\\n            for color, (ul, lr) in TopologicalSorter(graph).static_order():\\n                for r in range(ul[0], lr[0]):\\n                    for c in range(ul[1], lr[1]):\\n                        grid[r][c] = color\\n        except CycleError:\\n            return False\\n\\n        # Compare the grids\\n        # O(M*N)\\n        return grid == targetGrid\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1312786,
                "title": "c-easy-solution",
                "content": "```c++\\nclass Solution {\\npublic:\\n    struct Color{\\n        int minh;\\n        int maxh;\\n        int minw;\\n        int maxw;\\n    };\\n    int n,m;\\n    unordered_map<int,Color>color;\\n    vector<vector<int>>grid;\\n    //function to check if it is valid or not\\n    bool isrect(int c){\\n        int a = color[c].minh;\\n        int b = color[c].minw;\\n        int cn = color[c].maxh;\\n        int cm = color[c].maxw;\\n        for(int i = a;i<=cn;i++){\\n            for(int j = b;j<=cm;j++){\\n                if(grid[i][j]==c||grid[i][j]==0) continue;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    //function to set zero\\n    void setzero(int c){\\n        int a = color[c].minh;\\n        int b = color[c].minw;\\n        int cn = color[c].maxh;\\n        int cm = color[c].maxw;\\n        for(int i = a;i<=cn;i++){\\n            for(int j = b;j<=cm;j++){\\n                grid[i][j] = 0;\\n            }\\n        }\\n    }\\n    //function to set all the colors\\n    void getcolor(){\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(color.find(grid[i][j])==color.end()){\\n                    Color t;\\n                    t.minh = i;\\n                    t.maxh = i;\\n                    t.minw = j;\\n                    t.maxw = j;\\n                    color[grid[i][j]] = t;\\n                }\\n                else{\\n                    color[grid[i][j]].minw = min(color[grid[i][j]].minw,j);\\n                    color[grid[i][j]].maxw = max(color[grid[i][j]].maxw,j);\\n                    color[grid[i][j]].minh = min(color[grid[i][j]].minh,i);\\n                    color[grid[i][j]].maxh = max(color[grid[i][j]].maxh,i);\\n                }\\n            }\\n        }\\n    }   \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        grid = targetGrid;\\n        n = grid.size();\\n        m = grid[0].size();\\n        getcolor();\\n        queue<int>q;\\n        for(auto &i : color){\\n            if(isrect(i.first)){\\n                q.push(i.first);\\n            }\\n        }\\n        vector<bool>visited(61,false);\\n        while(q.size()){\\n            int curr = q.front();\\n            q.pop();\\n            if(visited[curr]) continue;\\n            setzero(curr);\\n            \\n            visited[curr] = true;\\n            for(auto &i : color){\\n                if(isrect(i.first)) q.push(i.first);\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\npublic:\\n    struct Color{\\n        int minh;\\n        int maxh;\\n        int minw;\\n        int maxw;\\n    };\\n    int n,m;\\n    unordered_map<int,Color>color;\\n    vector<vector<int>>grid;\\n    //function to check if it is valid or not\\n    bool isrect(int c){\\n        int a = color[c].minh;\\n        int b = color[c].minw;\\n        int cn = color[c].maxh;\\n        int cm = color[c].maxw;\\n        for(int i = a;i<=cn;i++){\\n            for(int j = b;j<=cm;j++){\\n                if(grid[i][j]==c||grid[i][j]==0) continue;\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    //function to set zero\\n    void setzero(int c){\\n        int a = color[c].minh;\\n        int b = color[c].minw;\\n        int cn = color[c].maxh;\\n        int cm = color[c].maxw;\\n        for(int i = a;i<=cn;i++){\\n            for(int j = b;j<=cm;j++){\\n                grid[i][j] = 0;\\n            }\\n        }\\n    }\\n    //function to set all the colors\\n    void getcolor(){\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(color.find(grid[i][j])==color.end()){\\n                    Color t;\\n                    t.minh = i;\\n                    t.maxh = i;\\n                    t.minw = j;\\n                    t.maxw = j;\\n                    color[grid[i][j]] = t;\\n                }\\n                else{\\n                    color[grid[i][j]].minw = min(color[grid[i][j]].minw,j);\\n                    color[grid[i][j]].maxw = max(color[grid[i][j]].maxw,j);\\n                    color[grid[i][j]].minh = min(color[grid[i][j]].minh,i);\\n                    color[grid[i][j]].maxh = max(color[grid[i][j]].maxh,i);\\n                }\\n            }\\n        }\\n    }   \\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        grid = targetGrid;\\n        n = grid.size();\\n        m = grid[0].size();\\n        getcolor();\\n        queue<int>q;\\n        for(auto &i : color){\\n            if(isrect(i.first)){\\n                q.push(i.first);\\n            }\\n        }\\n        vector<bool>visited(61,false);\\n        while(q.size()){\\n            int curr = q.front();\\n            q.pop();\\n            if(visited[curr]) continue;\\n            setzero(curr);\\n            \\n            visited[curr] = true;\\n            for(auto &i : color){\\n                if(isrect(i.first)) q.push(i.first);\\n            }\\n        }\\n        for(int i = 0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(grid[i][j]!=0) return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1295212,
                "title": "java-rectange-flip-solution",
                "content": "```\\n// Rectange Flip Solution\\n// 1. Find the up, bottom, most-left, most-right idx for each color, and store in HashMap\\n// 2. Flip a flippable color. If flippable, remove that color. If no color can be flipped, return false.\\n// Time complexity: O(M * N * C * C)\\n// Space complexity: O(C)\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        if (targetGrid == null || targetGrid.length == 0 || targetGrid[0].length == 0) return false;\\n        final int M = targetGrid.length, N = targetGrid[0].length;\\n        // HashMap to store the <color, Grid with {up, bottom, most-left, most-right idx}> \\n        Map<Integer, Grid> map = new HashMap<>();\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int color = targetGrid[i][j];\\n                Grid grid = map.get(color);\\n                if (grid == null) {\\n                    grid = new Grid(M, -1, N, -1);\\n                    map.put(color, grid);\\n                }\\n                grid.up = Math.min(grid.up, i);\\n                grid.bottom = Math.max(grid.bottom, i);\\n                grid.left = Math.min(grid.left, j);\\n                grid.right = Math.max(grid.right, j);\\n            }\\n        }\\n        return isPrintable(targetGrid, map);\\n    }\\n    \\n    private boolean isPrintable(int[][] targetGrid, Map<Integer, Grid> map) {\\n        Set<Integer> colorSet = new HashSet<>(map.keySet());\\n        while (!colorSet.isEmpty()) {\\n            Set<Integer> nextSet = new HashSet<>(colorSet);\\n            for (int color : colorSet) {\\n                // If flippable, remove that color. \\n                if (flipRect(targetGrid, map.get(color), color)) {\\n                    nextSet.remove(color);\\n                }\\n            }\\n            // If no color can be flipped, return false.\\n            if (colorSet.size() == nextSet.size()) {\\n                return false;\\n            }\\n            colorSet = nextSet;\\n        }\\n        return true;\\n    }\\n    \\n    // Check whether a color can be flipped at this time.\\n    // If the rectangle contains other unflipped color, then the rectangle is not flippable.\\n    private boolean flipRect(int[][] targetGrid, Grid grid, int color) {\\n        for (int i = grid.up; i <= grid.bottom; i++) {\\n            for (int j = grid.left; j <= grid.right; j++) {\\n                if (targetGrid[i][j] > 0 && targetGrid[i][j] != color) {\\n                    return false;  // rectangle contains other unflipped color, return false. \\n                }\\n            }\\n        }\\n        // Flip the flippable rectangle.\\n        for (int i = grid.up; i <= grid.bottom; i++) {\\n            for (int j = grid.left; j <= grid.right; j++) {\\n                if (targetGrid[i][j] > 0) {\\n                    targetGrid[i][j] = -color;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class Grid {\\n        int up, bottom, left, right;\\n        Grid(int up, int bottom, int left, int right) {\\n            this.up = up;\\n            this.bottom = bottom;\\n            this.left = left;\\n            this.right = right;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Rectange Flip Solution\\n// 1. Find the up, bottom, most-left, most-right idx for each color, and store in HashMap\\n// 2. Flip a flippable color. If flippable, remove that color. If no color can be flipped, return false.\\n// Time complexity: O(M * N * C * C)\\n// Space complexity: O(C)\\nclass Solution {\\n    public boolean isPrintable(int[][] targetGrid) {\\n        if (targetGrid == null || targetGrid.length == 0 || targetGrid[0].length == 0) return false;\\n        final int M = targetGrid.length, N = targetGrid[0].length;\\n        // HashMap to store the <color, Grid with {up, bottom, most-left, most-right idx}> \\n        Map<Integer, Grid> map = new HashMap<>();\\n        for (int i = 0; i < M; i++) {\\n            for (int j = 0; j < N; j++) {\\n                int color = targetGrid[i][j];\\n                Grid grid = map.get(color);\\n                if (grid == null) {\\n                    grid = new Grid(M, -1, N, -1);\\n                    map.put(color, grid);\\n                }\\n                grid.up = Math.min(grid.up, i);\\n                grid.bottom = Math.max(grid.bottom, i);\\n                grid.left = Math.min(grid.left, j);\\n                grid.right = Math.max(grid.right, j);\\n            }\\n        }\\n        return isPrintable(targetGrid, map);\\n    }\\n    \\n    private boolean isPrintable(int[][] targetGrid, Map<Integer, Grid> map) {\\n        Set<Integer> colorSet = new HashSet<>(map.keySet());\\n        while (!colorSet.isEmpty()) {\\n            Set<Integer> nextSet = new HashSet<>(colorSet);\\n            for (int color : colorSet) {\\n                // If flippable, remove that color. \\n                if (flipRect(targetGrid, map.get(color), color)) {\\n                    nextSet.remove(color);\\n                }\\n            }\\n            // If no color can be flipped, return false.\\n            if (colorSet.size() == nextSet.size()) {\\n                return false;\\n            }\\n            colorSet = nextSet;\\n        }\\n        return true;\\n    }\\n    \\n    // Check whether a color can be flipped at this time.\\n    // If the rectangle contains other unflipped color, then the rectangle is not flippable.\\n    private boolean flipRect(int[][] targetGrid, Grid grid, int color) {\\n        for (int i = grid.up; i <= grid.bottom; i++) {\\n            for (int j = grid.left; j <= grid.right; j++) {\\n                if (targetGrid[i][j] > 0 && targetGrid[i][j] != color) {\\n                    return false;  // rectangle contains other unflipped color, return false. \\n                }\\n            }\\n        }\\n        // Flip the flippable rectangle.\\n        for (int i = grid.up; i <= grid.bottom; i++) {\\n            for (int j = grid.left; j <= grid.right; j++) {\\n                if (targetGrid[i][j] > 0) {\\n                    targetGrid[i][j] = -color;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    class Grid {\\n        int up, bottom, left, right;\\n        Grid(int up, int bottom, int left, int right) {\\n            this.up = up;\\n            this.bottom = bottom;\\n            this.left = left;\\n            this.right = right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1244402,
                "title": "golang-brute-force-24ms-6-6mb-clean-code",
                "content": "use 0 for any color\\n```\\nfunc isPrintable(targetGrid [][]int) bool {\\n    list := make([]*clrRange, 61)\\n    \\n    for i := 0; i < len(targetGrid); i++ {\\n        for j := 0; j < len(targetGrid[i]); j++ {\\n            clr := targetGrid[i][j]\\n            \\n            if list[clr] == nil {\\n                list[clr] = &clrRange{clr:clr, x1:61, y1:61}\\n            }\\n            list[clr].setRange(i, j)\\n        }\\n    }\\n    \\n    for {\\n        state := 1\\n        for i := 0; i < len(list); i++ {\\n            if list[i] == nil || list[i].handle {\\n                continue\\n            }\\n            \\n            if state == 1 {\\n                state = 2\\n            }\\n            if list[i].can(targetGrid) {\\n                state = 3\\n                list[i].setGrid(targetGrid)\\n            }\\n        }\\n        \\n        if state == 2 {\\n            return false\\n        } else if state == 1 {\\n            return true\\n        }\\n    }\\n    return true\\n}\\n\\ntype clrRange struct {\\n    clr int\\n    x1, x2, y1, y2 int\\n    handle bool\\n}\\n\\nfunc (c *clrRange) setRange(x, y int) {\\n    if c.x1 > x {\\n        c.x1 = x\\n    }\\n    if c.x2 < x {\\n        c.x2 = x\\n    }\\n    if c.y1 > y {\\n        c.y1 = y\\n    }\\n    if c.y2 < y {\\n        c.y2 = y\\n    }\\n}\\n\\nfunc (c *clrRange) can (grid [][]int) bool {\\n    for x := c.x1; x <= c.x2; x++ {\\n        for y := c.y1; y <= c.y2; y++ {\\n            if grid[x][y] == 0 || grid[x][y] == c.clr {\\n                continue\\n            }\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc (c *clrRange) setGrid(grid [][]int) {\\n    for x := c.x1; x <= c.x2; x++ {\\n        for y := c.y1; y <= c.y2; y++ {\\n            grid[x][y] = 0\\n        }\\n    }\\n    c.handle = true\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc isPrintable(targetGrid [][]int) bool {\\n    list := make([]*clrRange, 61)\\n    \\n    for i := 0; i < len(targetGrid); i++ {\\n        for j := 0; j < len(targetGrid[i]); j++ {\\n            clr := targetGrid[i][j]\\n            \\n            if list[clr] == nil {\\n                list[clr] = &clrRange{clr:clr, x1:61, y1:61}\\n            }\\n            list[clr].setRange(i, j)\\n        }\\n    }\\n    \\n    for {\\n        state := 1\\n        for i := 0; i < len(list); i++ {\\n            if list[i] == nil || list[i].handle {\\n                continue\\n            }\\n            \\n            if state == 1 {\\n                state = 2\\n            }\\n            if list[i].can(targetGrid) {\\n                state = 3\\n                list[i].setGrid(targetGrid)\\n            }\\n        }\\n        \\n        if state == 2 {\\n            return false\\n        } else if state == 1 {\\n            return true\\n        }\\n    }\\n    return true\\n}\\n\\ntype clrRange struct {\\n    clr int\\n    x1, x2, y1, y2 int\\n    handle bool\\n}\\n\\nfunc (c *clrRange) setRange(x, y int) {\\n    if c.x1 > x {\\n        c.x1 = x\\n    }\\n    if c.x2 < x {\\n        c.x2 = x\\n    }\\n    if c.y1 > y {\\n        c.y1 = y\\n    }\\n    if c.y2 < y {\\n        c.y2 = y\\n    }\\n}\\n\\nfunc (c *clrRange) can (grid [][]int) bool {\\n    for x := c.x1; x <= c.x2; x++ {\\n        for y := c.y1; y <= c.y2; y++ {\\n            if grid[x][y] == 0 || grid[x][y] == c.clr {\\n                continue\\n            }\\n            return false\\n        }\\n    }\\n    return true\\n}\\n\\nfunc (c *clrRange) setGrid(grid [][]int) {\\n    for x := c.x1; x <= c.x2; x++ {\\n        for y := c.y1; y <= c.y2; y++ {\\n            grid[x][y] = 0\\n        }\\n    }\\n    c.handle = true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1169839,
                "title": "python3-bfs-to-check-dependencies",
                "content": "First identify the boundaries of all the rectangles. For each area bounded for rectangle i, if there is an overlap of another rectangle j, it means j must be printed after i. We use `nxt[i]` to record what rectangles have to be printed after rectangle i.\\n\\nThen we just use normal BFS to check if there is a cycle in the graph.\\n\\n```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        rect = defaultdict(lambda: [n, -1, m, -1])\\n        colors = set()\\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                colors.add(c)\\n                l, r, t, b = rect[c]\\n                l = min(l, j)\\n                r = max(r, j)\\n                t = min(t, i)\\n                b = max(b, i)\\n                rect[c] = [l, r, t, b]\\n\\n        nxt = defaultdict(set)\\n        for c in rect:\\n            l, r, t, b = rect[c]\\n            for i in range(t, b + 1):\\n                for j in range(l, r + 1):\\n                    if targetGrid[i][j] != c:\\n                        nxt[c].add(targetGrid[i][j])\\n\\n        degree = defaultdict(int)\\n        for i in nxt:\\n            for j in nxt[i]:\\n                degree[j] += 1\\n        queue = deque([])\\n        for i in colors:\\n            queue.append(i)\\n        while queue:\\n            found, size = False, len(queue)\\n            for _ in range(size):\\n                i = queue.popleft()\\n                if degree[i] == 0:\\n                    for j in nxt[i]:\\n                        degree[j] -= 1\\n                    found = True\\n                else:\\n                    queue.append(i)\\n            if not found:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0])\\n        rect = defaultdict(lambda: [n, -1, m, -1])\\n        colors = set()\\n        for i in range(m):\\n            for j in range(n):\\n                c = targetGrid[i][j]\\n                colors.add(c)\\n                l, r, t, b = rect[c]\\n                l = min(l, j)\\n                r = max(r, j)\\n                t = min(t, i)\\n                b = max(b, i)\\n                rect[c] = [l, r, t, b]\\n\\n        nxt = defaultdict(set)\\n        for c in rect:\\n            l, r, t, b = rect[c]\\n            for i in range(t, b + 1):\\n                for j in range(l, r + 1):\\n                    if targetGrid[i][j] != c:\\n                        nxt[c].add(targetGrid[i][j])\\n\\n        degree = defaultdict(int)\\n        for i in nxt:\\n            for j in nxt[i]:\\n                degree[j] += 1\\n        queue = deque([])\\n        for i in colors:\\n            queue.append(i)\\n        while queue:\\n            found, size = False, len(queue)\\n            for _ in range(size):\\n                i = queue.popleft()\\n                if degree[i] == 0:\\n                    for j in nxt[i]:\\n                        degree[j] -= 1\\n                    found = True\\n                else:\\n                    queue.append(i)\\n            if not found:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1090604,
                "title": "c",
                "content": "```\\nclass Solution {\\n    unordered_map<int, int> left, right, top, buttom;\\n    \\n    // For any 2 colors, their boundaries might overlap. If the overlap area contain 2 colors. Then this is invalid. \\n    // Otherwise, the only color in the overlap area is the color printed later. Now we have a directed graph relative order of painting between 2 colors.\\n    bool valid(vector<vector<int>>& grid, int x, int y, unordered_map<int, vector<int>>& g) {\\n\\n        int t = max(top[x], top[y]);\\n        int b = min(buttom[x], buttom[y]);\\n        int l = max(left[x], left[y]);\\n        int r = min(right[x], right[y]);\\n\\n        bool findX = false, findY = false;\\n        for(int i=t; i<=b; ++i) {\\n            for(int j=l; j<=r; ++j) {\\n                if(grid[i][j] == x) findX = true;\\n                if(grid[i][j] == y) findY = true;\\n            }\\n        }\\n        \\n        if(findX && findY) return false;\\n        if(findX) g[x].push_back(y);\\n        if(findY) g[y].push_back(x);    \\n        return true;\\n    }\\npublic:\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        left.clear();\\n        right.clear();\\n        top.clear();\\n        buttom.clear();\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        \\n        // Get the boundaries of each color. {left, right, top, buttom}. The boundaries means for that color, we need to print at least the area from [left, top] to [right, buttom].\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int val = grid[i][j];\\n                if(left.find(val) != left.end()) left[val] = min(left[val], j);\\n                else left[val] = j;\\n                if(right.find(val) != right.end()) right[val] = max(right[val], j);\\n                else right[val] = j;\\n                if(top.find(val) != top.end()) top[val] = min(top[val], i);\\n                else top[val] = i;\\n                if(buttom.find(val) != buttom.end()) buttom[val] = max(buttom[val], i);\\n                else buttom[val] = i;\\n            }\\n        }\\n        \\n        unordered_map<int, vector<int>> g;\\n        vector<int> colors;\\n        for(auto it1 = left.begin(); it1 != left.end(); ++it1) {\\n            colors.push_back(it1->first);\\n            for(auto it2 = left.begin(); it2 != left.end(); ++it2) {\\n                if(it1->first >= it2->first) continue;\\n                if(!valid(grid, it1->first, it2->first, g)) return false;\\n            }\\n        }\\n        \\n        // Check if the graph has cycle. If it does, then there is no valid order to paint colors.\\n        unordered_set<int> visited;\\n        for(auto c : colors) {\\n            visited.clear();\\n            if(hasCycle(c, g, visited)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    bool hasCycle(int cur, unordered_map<int, vector<int>>& g, unordered_set<int>& visited) {\\n        if(visited.count(cur)) return true;\\n        \\n        if(g.find(cur) == g.end()) {\\n            return false;\\n        }\\n        \\n        visited.insert(cur);\\n        for(auto nxt : g[cur]) {\\n            if(hasCycle(nxt, g, visited)) return true;\\n        }\\n        visited.erase(cur);\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<int, int> left, right, top, buttom;\\n    \\n    // For any 2 colors, their boundaries might overlap. If the overlap area contain 2 colors. Then this is invalid. \\n    // Otherwise, the only color in the overlap area is the color printed later. Now we have a directed graph relative order of painting between 2 colors.\\n    bool valid(vector<vector<int>>& grid, int x, int y, unordered_map<int, vector<int>>& g) {\\n\\n        int t = max(top[x], top[y]);\\n        int b = min(buttom[x], buttom[y]);\\n        int l = max(left[x], left[y]);\\n        int r = min(right[x], right[y]);\\n\\n        bool findX = false, findY = false;\\n        for(int i=t; i<=b; ++i) {\\n            for(int j=l; j<=r; ++j) {\\n                if(grid[i][j] == x) findX = true;\\n                if(grid[i][j] == y) findY = true;\\n            }\\n        }\\n        \\n        if(findX && findY) return false;\\n        if(findX) g[x].push_back(y);\\n        if(findY) g[y].push_back(x);    \\n        return true;\\n    }\\npublic:\\n    bool isPrintable(vector<vector<int>>& grid) {\\n        left.clear();\\n        right.clear();\\n        top.clear();\\n        buttom.clear();\\n        \\n        int m = grid.size(), n = grid[0].size();\\n        \\n        // Get the boundaries of each color. {left, right, top, buttom}. The boundaries means for that color, we need to print at least the area from [left, top] to [right, buttom].\\n        for(int i=0; i<m; i++) {\\n            for(int j=0; j<n; j++) {\\n                int val = grid[i][j];\\n                if(left.find(val) != left.end()) left[val] = min(left[val], j);\\n                else left[val] = j;\\n                if(right.find(val) != right.end()) right[val] = max(right[val], j);\\n                else right[val] = j;\\n                if(top.find(val) != top.end()) top[val] = min(top[val], i);\\n                else top[val] = i;\\n                if(buttom.find(val) != buttom.end()) buttom[val] = max(buttom[val], i);\\n                else buttom[val] = i;\\n            }\\n        }\\n        \\n        unordered_map<int, vector<int>> g;\\n        vector<int> colors;\\n        for(auto it1 = left.begin(); it1 != left.end(); ++it1) {\\n            colors.push_back(it1->first);\\n            for(auto it2 = left.begin(); it2 != left.end(); ++it2) {\\n                if(it1->first >= it2->first) continue;\\n                if(!valid(grid, it1->first, it2->first, g)) return false;\\n            }\\n        }\\n        \\n        // Check if the graph has cycle. If it does, then there is no valid order to paint colors.\\n        unordered_set<int> visited;\\n        for(auto c : colors) {\\n            visited.clear();\\n            if(hasCycle(c, g, visited)) return false;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    \\n    bool hasCycle(int cur, unordered_map<int, vector<int>>& g, unordered_set<int>& visited) {\\n        if(visited.count(cur)) return true;\\n        \\n        if(g.find(cur) == g.end()) {\\n            return false;\\n        }\\n        \\n        visited.insert(cur);\\n        for(auto nxt : g[cur]) {\\n            if(hasCycle(nxt, g, visited)) return true;\\n        }\\n        visited.erase(cur);\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1038318,
                "title": "why-this-matrix-is-returning-true",
                "content": "I submit my application but it didn\\'t work because of the below test case. why this should be true??? \"Trace number 60 to know what I mean\"\\n\\n[[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,36,36,36,36,36,36,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,29,29,29,36,36,36,36,36,36,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,29,29,29,36,36,36,36,36,36,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,29,29,29,36,36,36,36,36,36,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,60,29,29,29,36,36,36,36,36,36,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,29,60,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,60,60,60,60,60,60,60,60,60,60,60,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,60,60,60,60,60,60,60,23,23,23,23,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,60,60,60,60,60,60,60,23,23,23,23,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,60,60,60,60,60,60,60,23,23,23,23,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,18,18,18,18,18,23,23,23,23,45,45,45,45,45,45,36,36,36,36,36,36,29,29,29,29,29,29,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,18,18,18,18,18,23,23,23,23,23,23,23,29,29,29,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,18,18,32,32,32,32,32,32,32,32,32,32,32,32,36,36,46,46,46,46,46,46,46,46,46,46,48,48,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,18,34,34,34,34,34,34,34,34,34,34,34,34,34,32,36,36,46,46,46,46,46,46,46,46,46,46,48,48,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,46,46,46,46,46,46,46,46,46,46,48,48,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,46,46,46,46,46,46,46,46,46,46,48,48,46,46,46,46,46,46,46,46,46,46,46,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,48,48,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,37,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,40,40,40,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,37,44,44,49,49,49,49,49,44,44,44,44,44,44,44]\\n,[60,60,18,18,37,37,40,40,40,37,37,37,37,37,37,37,37,37,37,37,37,38,38,38,38,38,38,38,38,38,37,44,44,49,49,49,49,49,44,44,44,44,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,34,34,34,34,34,31,36,36,38,47,47,47,47,47,47,47,47,47,47,47,49,49,49,49,49,47,47,47,47,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,34,34,34,34,34,31,36,36,38,47,47,47,47,47,47,47,47,47,47,47,49,49,49,49,49,47,47,47,47,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,34,34,34,34,34,28,36,36,36,47,47,47,47,47,47,47,47,47,47,47,49,49,49,49,49,47,47,47,47,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,34,34,34,34,34,28,36,36,36,36,36,36,30,30,26,26,41,41,44,44,44,44,44,44,44,44,44,44,44,44,44,44]\\n,[60,60,18,18,18,34,40,40,40,34,34,34,34,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,44,44,44,44]\\n,[60,60,60,60,60,34,40,40,40,34,34,34,34,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,50,22,22,60,60]\\n,[60,60,60,60,60,34,40,40,40,34,34,34,34,34,34,34,34,34,22,22,30,30,30,30,30,30,30,43,43,43,43,43,43,43,43,43,43,43,43,43,43,43,22,60,60]\\n,[60,60,60,60,60,60,60,60,60,60,60,22,22,22,22,22,22,22,22,22,30,30,30,30,30,30,30,26,26,41,41,41,41,41,22,22,22,22,22,22,42,22,22,60,60]\\n,[60,60,60,60,60, 3, 3, 3 ,3, 3, 3,22,22,22,22,22,22,22,22,22,22,22,22,22,22,26,26,26,26,41,41,41,41,41,22,22,25,25,25,25,42,22,22,60,60]\\n,[60,60,60,60,60, 3, 3, 3, 3, 3, 3,22,22,22,22,22,22,22,22,22,22,22,22,22,22,26,26,26,26,26,26,26,26,22,22,22,25,25,25,25,42,22,22,60,60]\\n,[60,60,12,12,12,12,12, 3, 3, 3, 3,22,22,22,22,22,22,22,22,22,22,22,22,22,22,26,26,26,26,26,26,26,26,22,22,22,22,22,22,22,22,24,24,24,24]]",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1026798,
                "title": "c-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        initGraph(targetGrid);\\n        const int n = g.size();\\n        vector<int> indegree(n);\\n        for(auto st:g) for(auto i:st) indegree[i]++;\\n        queue<int> q;\\n        for(int i=0;i<n;i++) if(indegree[i] == 0 && !g[i].empty()) q.push(i);\\n        while(!q.empty()){\\n            auto i = q.front(); q.pop();\\n            cout<<i<<endl;\\n            for(auto j:g[i]){\\n                if(--indegree[j] == 0) q.push(j);\\n            }\\n        }\\n        return count(indegree.begin(), indegree.end(), 0) == n;\\n    }\\n    \\n    void initGraph(vector<vector<int>>& vv){\\n        const int n = vv.size(), m = vv[0].size(); \\n        g.resize(61);  \\n        unordered_map<int, Boundry> mp;\\n        for(int i=0;i<n;i++) for(int j=0;j<m;j++){\\n            mp[vv[i][j]].update(i, j);\\n        }\\n        for(const auto& [color, bond] : mp){\\n            auto [x1, x2, y1, y2] = bond;\\n            for(int i=x1;i<=x2;i++) for(int j=y1;j<=y2;j++){\\n                if(vv[i][j] != color) g[color].insert(vv[i][j]);\\n            }\\n        }\\n    }\\n    \\n    struct Boundry{\\n        void update(int x, int y){\\n            x1 = min(x, x1);\\n            x2 = max(x, x2);\\n            y1 = min(y, y1);\\n            y2 = max(y, y2);\\n        }\\n        \\n        bool include(int x, int y) const{\\n            return x>=x1 && x<=x2 && y>=y1 && y<=y2;\\n        }\\n        \\n        int x1 = 100;\\n        int x2 = -1;\\n        int y1 = 100;\\n        int y2 = -1;\\n    };\\n    \\n    vector<unordered_set<int>> g; \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        initGraph(targetGrid);\\n        const int n = g.size();\\n        vector<int> indegree(n);\\n        for(auto st:g) for(auto i:st) indegree[i]++;\\n        queue<int> q;\\n        for(int i=0;i<n;i++) if(indegree[i] == 0 && !g[i].empty()) q.push(i);\\n        while(!q.empty()){\\n            auto i = q.front(); q.pop();\\n            cout<<i<<endl;\\n            for(auto j:g[i]){\\n                if(--indegree[j] == 0) q.push(j);\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 1018414,
                "title": "p23-5",
                "content": "Topo sort\\nTopo sort\\nTopo sort",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1012458,
                "title": "python-3-steps",
                "content": "**Key Insights:**\\n\\n1. Because each stamp is a rectangle, for each color, the stamp\\nmust span across [min(x<sub>i</sub>), max(x<sub>i</sub>)] and [min(y<sub>i</sub>), max(y<sub>i</sub>)] (inclusive).\\nWhere min(x<sub>i</sub>) is the left most cell of that color.\\n\\n\\n2. Because each color can only be used once, the colors that\\nform a perfect rectangle (without any other stamps overlapping\\nthem) must be the last stamps made. \\n\\n**Approach:** *step numbers match code comments*\\n\\n1. Find the left-most, top-most, right-most and bottom-most cell of each color.\\nThe points (left-most, top-most) and (right-most, bottom-most) will be the\\ntop-left and bottom-right corners of the stamp.\\n```rect[color] = [left-most, top-most, right-most, bottom-most]```\\n\\n2. Determine which stamps must come **before** other stamps.  If colors A\\nand B are in the rectangle for stamp of color C, then color C must be stamped\\nbefore color A and color B.  \\n\\n3. Work backwards to find an order of colors that agrees with the order from\\nstep 2.  Since we are working backwards, start with any stamps that do not\\nhave any other stamps on top of them.  Then use DFS to try all possible combinations\\nof next stamps.  <br>\\nThe exit condition is once all stamps have been placed, return True.  Otherwise\\ntry stamping all colors that 1. have not been stamped yet and 2. have all the prerequisite\\ncolors already stamped.  \\n\\n**Optimizations:**\\n\\nThe stamps that have been placed and the requirements for stamps that must be placed\\ncan be bitmasked such that 22 = \\'0b10110\\' represents stamps 1, 2, and 4.\\n\\n<br>\\n\\n```python\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        \\n        # 1. Find the rectangle that each color is stamped over\\n        m, n = len(grid), len(grid[0])\\n        rect = collections.defaultdict(lambda: [m-1, n-1, 0, 0])\\n        for i in range(m):\\n            for j in range(n):\\n                color = grid[i][j]\\n                a, b, c, d = rect[color]\\n                rect[color] = [min(a, i), min(b, j), max(c, i), max(d, j)]\\n        \\n        # 2. Find which colors must come before each color\\n        before = collections.defaultdict(int)\\n        for color in rect:\\n            y1, x1, y2, x2 = rect[color]\\n            for i in range(y1, y2+1):\\n                for j in range(x1, x2+1):\\n                    if grid[i][j] != color:\\n                        before[color] |= (1 << grid[i][j])\\n        \\n        # 3. Can all stamps be placed without violating the order in before\\n        @functools.lru_cache(None)\\n        def helper(stamped):\\n            if stamped == target:\\n                return True\\n            for i in rect:\\n                if not (stamped & bitmask[i]) and (before[i] & stamped == before[i]):\\n                    if helper(stamped | bitmask[i]):\\n                        return True\\n            return False\\n        \\n        bitmask = [1 << i for i in range(max(rect)+1)]\\n        target = functools.reduce(lambda x, y: x|(bitmask[y]), rect, 0)\\n        start = functools.reduce(lambda x, y: x if before[y] else x|(bitmask[y]), rect, 0)\\n        return helper(start)\\n```",
                "solutionTags": [],
                "code": "```rect[color] = [left-most, top-most, right-most, bottom-most]```\n```python\\nclass Solution:\\n    def isPrintable(self, grid: List[List[int]]) -> bool:\\n        \\n        # 1. Find the rectangle that each color is stamped over\\n        m, n = len(grid), len(grid[0])\\n        rect = collections.defaultdict(lambda: [m-1, n-1, 0, 0])\\n        for i in range(m):\\n            for j in range(n):\\n                color = grid[i][j]\\n                a, b, c, d = rect[color]\\n                rect[color] = [min(a, i), min(b, j), max(c, i), max(d, j)]\\n        \\n        # 2. Find which colors must come before each color\\n        before = collections.defaultdict(int)\\n        for color in rect:\\n            y1, x1, y2, x2 = rect[color]\\n            for i in range(y1, y2+1):\\n                for j in range(x1, x2+1):\\n                    if grid[i][j] != color:\\n                        before[color] |= (1 << grid[i][j])\\n        \\n        # 3. Can all stamps be placed without violating the order in before\\n        @functools.lru_cache(None)\\n        def helper(stamped):\\n            if stamped == target:\\n                return True\\n            for i in rect:\\n                if not (stamped & bitmask[i]) and (before[i] & stamped == before[i]):\\n                    if helper(stamped | bitmask[i]):\\n                        return True\\n            return False\\n        \\n        bitmask = [1 << i for i in range(max(rect)+1)]\\n        target = functools.reduce(lambda x, y: x|(bitmask[y]), rect, 0)\\n        start = functools.reduce(lambda x, y: x if before[y] else x|(bitmask[y]), rect, 0)\\n        return helper(start)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 907077,
                "title": "c-o-n-3-solution",
                "content": "1. Consider each color as node of a directed graph. \\n2. There is an edge from color **i** to color **j** if color **j** appears anywhere inside the maximum rectangle of color **i**.\\n3. Now if there is no cycle in this directed graph then there exisits a topological ordering of operations of the strange printer.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<unordered_set<int> > adj;\\n    vector<int> color;\\n    \\n    bool cycle_exists(int v){\\n        color[v]=1;\\n        for(int to: adj[v]){\\n            if(color[to]==1){\\n                return true;\\n            }\\n            else if(color[to]==0){\\n                if(cycle_exists(to)){\\n                    return true;\\n                }\\n            }\\n        }\\n        color[v]=2;\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& g) {\\n        vector<int> left(61, 10000), right(61, -1), top(61, 10000), bottom(61, -1);\\n        int n=g.size(), m=g[0].size();\\n        adj=vector<unordered_set<int> >(61);\\n        color=vector<int>(61, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                left[g[i][j]]=min(left[g[i][j]], j);\\n                right[g[i][j]]=max(right[g[i][j]], j);\\n                top[g[i][j]]=min(top[g[i][j]], i);\\n                bottom[g[i][j]]=max(bottom[g[i][j]], i);\\n            }\\n        }\\n        for(int i=1; i<=60; i++){\\n            if(top[i]==10000) continue;\\n            for(int x=top[i]; x<=bottom[i]; x++){\\n                for(int y=left[i]; y<=right[i]; y++){\\n                    if(g[x][y]!=i){\\n                        adj[i].insert(g[x][y]);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=1; i<=60; i++){\\n            if(top[i]==10000) continue;\\n            if(color[i]==0){\\n                if(cycle_exists(i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<unordered_set<int> > adj;\\n    vector<int> color;\\n    \\n    bool cycle_exists(int v){\\n        color[v]=1;\\n        for(int to: adj[v]){\\n            if(color[to]==1){\\n                return true;\\n            }\\n            else if(color[to]==0){\\n                if(cycle_exists(to)){\\n                    return true;\\n                }\\n            }\\n        }\\n        color[v]=2;\\n        return false;\\n    }\\n    \\n    bool isPrintable(vector<vector<int>>& g) {\\n        vector<int> left(61, 10000), right(61, -1), top(61, 10000), bottom(61, -1);\\n        int n=g.size(), m=g[0].size();\\n        adj=vector<unordered_set<int> >(61);\\n        color=vector<int>(61, 0);\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                left[g[i][j]]=min(left[g[i][j]], j);\\n                right[g[i][j]]=max(right[g[i][j]], j);\\n                top[g[i][j]]=min(top[g[i][j]], i);\\n                bottom[g[i][j]]=max(bottom[g[i][j]], i);\\n            }\\n        }\\n        for(int i=1; i<=60; i++){\\n            if(top[i]==10000) continue;\\n            for(int x=top[i]; x<=bottom[i]; x++){\\n                for(int y=left[i]; y<=right[i]; y++){\\n                    if(g[x][y]!=i){\\n                        adj[i].insert(g[x][y]);\\n                    }\\n                }\\n            }\\n        }\\n        for(int i=1; i<=60; i++){\\n            if(top[i]==10000) continue;\\n            if(color[i]==0){\\n                if(cycle_exists(i)){\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906886,
                "title": "java-o-mnc-beats97-with-explaintion-clean-code-but-a-little-long",
                "content": "1\\u3001Try to clean a rectangle of same number to 0 each time. Then Try to clean all numbers to 0. \\n2\\u3001If we meet different number , push the previos number to Stack and Try to clean the new number.\\n3\\u3001The cleaning will fail if the number to be cleaned has been in Stack , and the result is false. \\n4\\u3001After all numbers are cleaned ,return true.\\n\\n```\\nclass Solution {\\n    int[][] Range = new int[4][61];  //left,up,right,down;\\n    int[][] main;\\n    List<Integer> numToBeCleaned = new ArrayList<>();\\n    HashSet<Integer> cleanStack = new HashSet<>();\\n\\n    public boolean isPrintable(int[][] targetGrid) {\\n        initialize(targetGrid);\\n        while (!numToBeCleaned.isEmpty()){\\n            cleanStack.clear();\\n            if(!clean(numToBeCleaned.get(0)))return false;\\n        }\\n        return true;\\n    }\\n\\n    private boolean clean(int target){\\n        if(!cleanStack.add(target)) return false;\\n        for (int i = Range[1][target]; i <= Range[3][target]; i++)\\n            for (int j = Range[0][target]; j <= Range[2][target]; j++) {\\n                if(main[i][j]==0)continue;\\n                if(main[i][j]==target){main[i][j] = 0;continue;}\\n                if(!clean(main[i][j])){return false;}\\n            }\\n        numToBeCleaned.remove(numToBeCleaned.indexOf(target));\\n        return true;\\n    }\\n\\n    private void initialize(int[][] t){\\n        main = t;\\n        Arrays.fill(Range[0],Integer.MAX_VALUE);\\n        Arrays.fill(Range[1],Integer.MAX_VALUE);\\n        Arrays.fill(Range[2],-1);\\n        Arrays.fill(Range[3],-1);\\n\\n        int v = 0;\\n        for(int i = 0; i < main.length;i++)\\n            for (int j = 0; j < main[0].length; j++) {\\n                v = main[i][j];\\n                Range[0][v] = Math.min(j, Range[0][v]);\\n                Range[1][v] = Math.min(i, Range[1][v]);\\n                Range[2][v] = Math.max(j, Range[2][v]);\\n                Range[3][v] = Math.max(i, Range[3][v]);\\n            }\\n\\n\\n        for (int i = 0; i < 61; i++)\\n            if(Range[2][i] != -1)\\n                numToBeCleaned.add(i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] Range = new int[4][61];  //left,up,right,down;\\n    int[][] main;\\n    List<Integer> numToBeCleaned = new ArrayList<>();\\n    HashSet<Integer> cleanStack = new HashSet<>();\\n\\n    public boolean isPrintable(int[][] targetGrid) {\\n        initialize(targetGrid);\\n        while (!numToBeCleaned.isEmpty()){\\n            cleanStack.clear();\\n            if(!clean(numToBeCleaned.get(0)))return false;\\n        }\\n        return true;\\n    }\\n\\n    private boolean clean(int target){\\n        if(!cleanStack.add(target)) return false;\\n        for (int i = Range[1][target]; i <= Range[3][target]; i++)\\n            for (int j = Range[0][target]; j <= Range[2][target]; j++) {\\n                if(main[i][j]==0)continue;\\n                if(main[i][j]==target){main[i][j] = 0;continue;}\\n                if(!clean(main[i][j])){return false;}\\n            }\\n        numToBeCleaned.remove(numToBeCleaned.indexOf(target));\\n        return true;\\n    }\\n\\n    private void initialize(int[][] t){\\n        main = t;\\n        Arrays.fill(Range[0],Integer.MAX_VALUE);\\n        Arrays.fill(Range[1],Integer.MAX_VALUE);\\n        Arrays.fill(Range[2],-1);\\n        Arrays.fill(Range[3],-1);\\n\\n        int v = 0;\\n        for(int i = 0; i < main.length;i++)\\n            for (int j = 0; j < main[0].length; j++) {\\n                v = main[i][j];\\n                Range[0][v] = Math.min(j, Range[0][v]);\\n                Range[1][v] = Math.min(i, Range[1][v]);\\n                Range[2][v] = Math.max(j, Range[2][v]);\\n                Range[3][v] = Math.max(i, Range[3][v]);\\n            }\\n\\n\\n        for (int i = 0; i < 61; i++)\\n            if(Range[2][i] != -1)\\n                numToBeCleaned.add(i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 906641,
                "title": "python3-time-o-n-m-c-space-o-c-beats-98",
                "content": "Record the boundry of each color in the grid so we can constraint the search area, in which should we encounter a different color, we\\'ll try to resolve (revert the painting) that color first.\\n\\nA painting can\\'t be reverted successfully, `cleanRectangle => true`, if it relies on reverting some colors beforehand while they rely on reverting this color first. Which means, a circular dependency is detected. We mark a grid with `-1` if this grid is not resolved yet, and if in the recursive process we encounter such a value, we can abort the process because a circle exists.\\n\\nTime complexity: O(NMC)\\nThe first call to `cleanRectangle` for each color might take up to NM traverse to visit and update the targetGrid. The second call might happen and in that case, we detect the circle and abort early.\\n\\nSpace: O(C)\\nThe space for `boundry` is O(C), and the depth of recursive call is O(C).\\n\\n\\n\\n```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        N, M, colors = len(targetGrid), len(targetGrid[0]) if len(targetGrid) else 0, max( max(r) for r in targetGrid )\\n        boundry = [(N, 0, M, 0)]*(colors+1) # boundry[i] = (a, b, c, d) if the color shows in rows [a:b+1] and colums [c:d+1]\\n        resolved = set()\\n        for x in range(N):\\n            for y in range(M):\\n                c = targetGrid[x][y]\\n                boundry[c] = min(x, boundry[c][0]), max(x, boundry[c][1]), min(y, boundry[c][2]), max(y, boundry[c][3])\\n        \\n        def cleanRectangle(color: int) -> bool: # if we can form a rectangle, remove this color (label 0)\\n            frX, toX, frY, toY = boundry[color]\\n            if color in resolved:\\n                return True\\n            for i in range(frX, toX+1):\\n                for j in range(frY, toY+1):\\n                    if targetGrid[i][j] == color:\\n                        targetGrid[i][j] = -1\\n                    elif targetGrid[i][j] == -1: # circle back to a unsolved color, detect a deadlock (circular dependency)\\n                        return False\\n                    elif targetGrid[i][j] > 0 and not cleanRectangle(targetGrid[i][j]):\\n                        return False\\n            for i in range(frX, toX+1):\\n                for j in range(frY, toY+1):\\n                    targetGrid[i][j] = 0\\n            resolved.add(color)\\n            return True\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if targetGrid[i][j] and not cleanRectangle(targetGrid[i][j]):\\n                    return False\\n        return True\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        N, M, colors = len(targetGrid), len(targetGrid[0]) if len(targetGrid) else 0, max( max(r) for r in targetGrid )\\n        boundry = [(N, 0, M, 0)]*(colors+1) # boundry[i] = (a, b, c, d) if the color shows in rows [a:b+1] and colums [c:d+1]\\n        resolved = set()\\n        for x in range(N):\\n            for y in range(M):\\n                c = targetGrid[x][y]\\n                boundry[c] = min(x, boundry[c][0]), max(x, boundry[c][1]), min(y, boundry[c][2]), max(y, boundry[c][3])\\n        \\n        def cleanRectangle(color: int) -> bool: # if we can form a rectangle, remove this color (label 0)\\n            frX, toX, frY, toY = boundry[color]\\n            if color in resolved:\\n                return True\\n            for i in range(frX, toX+1):\\n                for j in range(frY, toY+1):\\n                    if targetGrid[i][j] == color:\\n                        targetGrid[i][j] = -1\\n                    elif targetGrid[i][j] == -1: # circle back to a unsolved color, detect a deadlock (circular dependency)\\n                        return False\\n                    elif targetGrid[i][j] > 0 and not cleanRectangle(targetGrid[i][j]):\\n                        return False\\n            for i in range(frX, toX+1):\\n                for j in range(frY, toY+1):\\n                    targetGrid[i][j] = 0\\n            resolved.add(color)\\n            return True\\n        \\n        for i in range(N):\\n            for j in range(M):\\n                if targetGrid[i][j] and not cleanRectangle(targetGrid[i][j]):\\n                    return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 880691,
                "title": "c-cycle-detecion-dfs-coloring-clean-code-with-comments",
                "content": "```\\nclass Solution {\\n    struct Bounds {\\n        int left, right, top, bottom;\\n        Bounds() : left(INT_MAX), \\n                   right(INT_MIN),\\n                   top(INT_MAX), \\n                   bottom(INT_MIN)\\n                   {}\\n    };\\n    unordered_map<int, Bounds> colors;\\n    \\n    bool cycle(vector<vector<int>>& grid, int col){\\n        for (int i = colors[col].top; i <= colors[col].bottom; ++i){\\n            for (int j = colors[col].left; j <= colors[col].right; ++j){\\n                if (grid[i][j] == -1) return true; // already visited and unresolved!\\n                else if (grid[i][j] == col) grid[i][j] = -1; // mark visiting\\n                else if (grid[i][j] && cycle(grid, grid[i][j])) return true;\\n            }\\n        }\\n        \\n        for (int i = colors[col].top; i <= colors[col].bottom; ++i){\\n            for (int j = colors[col].left; j <= colors[col].right; ++j){\\n                grid[i][j] = 0; // resolved\\n            }\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        for (int i = 0; i < targetGrid.size(); ++i){\\n            for (int j = 0; j < targetGrid[0].size(); ++j){\\n                colors[targetGrid[i][j]].left = min(colors[targetGrid[i][j]].left, j);\\n                colors[targetGrid[i][j]].top = min(colors[targetGrid[i][j]].top, i);\\n                colors[targetGrid[i][j]].right = max(colors[targetGrid[i][j]].right, j);\\n                colors[targetGrid[i][j]].bottom = max(colors[targetGrid[i][j]].bottom, i);\\n            }\\n        }\\n        \\n        for (int i = 0; i < targetGrid.size(); ++i){\\n            for (int j = 0; j < targetGrid[0].size(); ++j){\\n                if (targetGrid[i][j] && cycle(targetGrid, targetGrid[i][j])) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    struct Bounds {\\n        int left, right, top, bottom;\\n        Bounds() : left(INT_MAX), \\n                   right(INT_MIN),\\n                   top(INT_MAX), \\n                   bottom(INT_MIN)\\n                   {}\\n    };\\n    unordered_map<int, Bounds> colors;\\n    \\n    bool cycle(vector<vector<int>>& grid, int col){\\n        for (int i = colors[col].top; i <= colors[col].bottom; ++i){\\n            for (int j = colors[col].left; j <= colors[col].right; ++j){\\n                if (grid[i][j] == -1) return true; // already visited and unresolved!\\n                else if (grid[i][j] == col) grid[i][j] = -1; // mark visiting\\n                else if (grid[i][j] && cycle(grid, grid[i][j])) return true;\\n            }\\n        }\\n        \\n        for (int i = colors[col].top; i <= colors[col].bottom; ++i){\\n            for (int j = colors[col].left; j <= colors[col].right; ++j){\\n                grid[i][j] = 0; // resolved\\n            }\\n        }\\n        \\n        return false;\\n    }\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        for (int i = 0; i < targetGrid.size(); ++i){\\n            for (int j = 0; j < targetGrid[0].size(); ++j){\\n                colors[targetGrid[i][j]].left = min(colors[targetGrid[i][j]].left, j);\\n                colors[targetGrid[i][j]].top = min(colors[targetGrid[i][j]].top, i);\\n                colors[targetGrid[i][j]].right = max(colors[targetGrid[i][j]].right, j);\\n                colors[targetGrid[i][j]].bottom = max(colors[targetGrid[i][j]].bottom, i);\\n            }\\n        }\\n        \\n        for (int i = 0; i < targetGrid.size(); ++i){\\n            for (int j = 0; j < targetGrid[0].size(); ++j){\\n                if (targetGrid[i][j] && cycle(targetGrid, targetGrid[i][j])) return false;\\n            }\\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 874875,
                "title": "o-c-mn-c-solution-with-2d-prefix-sum-array",
                "content": "Think of the reverse process, i.e. remove colors according to some order and finally leaves nothing. A color is removable if there is no other color in its bounding box.\\n\\nWe do C rounds, at each round, we check all remaining colors one by one and see if it\\'s fine to remove it. If it\\'s fine, we go to next round; otherwise, we return false.\\n\\nOnce a color is removed, we mark these cells as free. A color is removable iff the bounding box of this color contains only this color or free cells.\\n\\nDuring each round, we iterate all possible colors, and just need to check if this color\\'s bounding box contains only itself or free cells. We can know the bounding box and count of this color in advance easily. The key challenge is to get # free cells efficiently.\\n\\nBefore each round, we store the count of free cells in first r rows and first c columns in `dp[r][c]`, which can be computed using O(mn) time with dynamic programming. To query the count of free cells in a bounding box, we can use `dp[bottom][right] + dp[top - 1][left - 1] - dp[bottom][left - 1] - dp[top - 1][right]` which takes constant time. So it takes constant time to check for each color. Each round takes O(mn+c) time.\\n\\n```C++\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        left = [n] * 65\\n        right = [0] * 65\\n        top = [m] * 65\\n        bottom = [0] * 65\\n        cnt = [0] * 65\\n        colors = set([])\\n        for i in range(m):\\n            for j in range(n):\\n                colors.add(targetGrid[i][j])\\n                left[targetGrid[i][j]] = min(left[targetGrid[i][j]],j)\\n                right[targetGrid[i][j]] = max(right[targetGrid[i][j]],j)\\n                top[targetGrid[i][j]]=min(top[targetGrid[i][j]],i)\\n                bottom[targetGrid[i][j]]=max(bottom[targetGrid[i][j]],i)\\n                cnt[targetGrid[i][j]]+=1\\n        while colors:\\n            to_delete = None\\n            # Update unknown.\\n            unknown = [[0 for _ in range(n)] for _ in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if i==0 and j==0:\\n                        unknown[i][j]=1 if targetGrid[i][j]==0 else 0\\n                    elif i==0:\\n                        unknown[i][j]=unknown[i][j-1]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n                    elif j==0:\\n                        unknown[i][j]=unknown[i-1][j]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n                    else:\\n                        unknown[i][j]=unknown[i][j-1]+unknown[i-1][j]-unknown[i-1][j-1]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n            for color in colors:\\n                # Check if possible to remove color.\\n                l, r, t, b = left[color], right[color], top[color], bottom[color]\\n                unknown_cnt = unknown[b][r]\\n                if l and t:\\n                    unknown_cnt +=unknown[t-1][l-1]\\n                if l:\\n                    unknown_cnt -= unknown[b][l-1]\\n                if t:\\n                    unknown_cnt-=unknown[t-1][r]\\n                if unknown_cnt + cnt[color] == (r-l+1)*(b-t+1):\\n                    to_delete=color\\n                    break\\n            if not to_delete:\\n                return False\\n            colors.remove(to_delete)\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j]==to_delete:\\n                        targetGrid[i][j]=0\\n        return True\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        left = [n] * 65\\n        right = [0] * 65\\n        top = [m] * 65\\n        bottom = [0] * 65\\n        cnt = [0] * 65\\n        colors = set([])\\n        for i in range(m):\\n            for j in range(n):\\n                colors.add(targetGrid[i][j])\\n                left[targetGrid[i][j]] = min(left[targetGrid[i][j]],j)\\n                right[targetGrid[i][j]] = max(right[targetGrid[i][j]],j)\\n                top[targetGrid[i][j]]=min(top[targetGrid[i][j]],i)\\n                bottom[targetGrid[i][j]]=max(bottom[targetGrid[i][j]],i)\\n                cnt[targetGrid[i][j]]+=1\\n        while colors:\\n            to_delete = None\\n            # Update unknown.\\n            unknown = [[0 for _ in range(n)] for _ in range(m)]\\n            for i in range(m):\\n                for j in range(n):\\n                    if i==0 and j==0:\\n                        unknown[i][j]=1 if targetGrid[i][j]==0 else 0\\n                    elif i==0:\\n                        unknown[i][j]=unknown[i][j-1]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n                    elif j==0:\\n                        unknown[i][j]=unknown[i-1][j]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n                    else:\\n                        unknown[i][j]=unknown[i][j-1]+unknown[i-1][j]-unknown[i-1][j-1]\\n                        if targetGrid[i][j]==0:\\n                            unknown[i][j]+=1\\n            for color in colors:\\n                # Check if possible to remove color.\\n                l, r, t, b = left[color], right[color], top[color], bottom[color]\\n                unknown_cnt = unknown[b][r]\\n                if l and t:\\n                    unknown_cnt +=unknown[t-1][l-1]\\n                if l:\\n                    unknown_cnt -= unknown[b][l-1]\\n                if t:\\n                    unknown_cnt-=unknown[t-1][r]\\n                if unknown_cnt + cnt[color] == (r-l+1)*(b-t+1):\\n                    to_delete=color\\n                    break\\n            if not to_delete:\\n                return False\\n            colors.remove(to_delete)\\n            for i in range(m):\\n                for j in range(n):\\n                    if targetGrid[i][j]==to_delete:\\n                        targetGrid[i][j]=0\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 873695,
                "title": "python-simple-backtracking-with-memoization",
                "content": "A recursive back-tracking approach to this problem.\\n\\nBasic algorithm:\\n- Starting from the fully-printed grid, try to \"unprint\" colors one by one until we\\'re either able to unprint all the colors on the board or until we\\'ve exhausted possibilities.\\n- A color can only be unprinted if its bounding box in the initial grid is not covered by any other currently-printed color\\n\\nIt\\'s a simple approach, the only difficulty is figuring out when a color is \"valid\" to be unprinted and the rest is standard backtracking.\\n\\nIf we assume we know where each colors bounding box is, then we just need to check all the squares in the grid within that bounding box and check `square == color or square\\'s color is not printed`.\\n\\nGiven this, the check is pretty easy:\\n\\n```\\ndef isUncoveredRect(grid, color, colorRects, printed):\\n\\t\"\"\"Return whether color\\'s bounding box is currently uncovered by other colors in the grid\\n\\n\\tA colors bounding box is only uncovered by others if every square in the box is either the given color\\n\\tor !printed[color].\\n\\t\"\"\"\\n\\tstartRow, startCol, endRow, endCol = colorRects[color]\\n\\tfor row in range(startRow, endRow):\\n\\t\\tfor col in range(startCol, endCol):\\n\\t\\t\\tif grid[row][col] != color and printed[grid[row][col]]:\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```\\n\\nIn order to get `colorRects`, pre-process the grid to get this data structure `(color) -> topRow, leftCol, bottomRow, rightCol`\\n\\n```\\ncolorRects = {}\\nfor row in range(len(targetGrid)):\\n\\tfor col in range(len(targetGrid[0])):\\n\\t\\tcolor = targetGrid[row][col]\\n\\t\\tif color not in colorRects:\\n\\t\\t\\t# first row will always be start row since we\\'re moving top to bottom\\n\\t\\t\\tcolorRects[color] = (row, col, row + 1, col + 1)\\n\\t\\telse:\\n\\t\\t\\t# need to take care to update startCol and endCol for each rectangle accordingly\\n\\t\\t\\toldRow, oldCol, oldEndRow, oldEndCol = colorRects[color]\\n\\t\\t\\tcolorRects[color] = (oldRow, min(oldCol, col), row + 1, max(oldEndCol, col + 1))\\n```\\n\\nFinally, putting this together into a backtracking algorithm, we define a function `unprint` to recurse and backtrack, trying to \"unprint\" a color and then trying to `unprint` remaining printed colors which are uncovered on the board.\\n\\nFor performance, I needed to memo-ize the calculation so that we don\\'t get stuck in hopeless branches. This adds some extra space for the memo structure and is likely `O(2^C)` in theory, but in practice it only grows as much as we have valid \"uncovered\" branches which don\\'t lead to a solution.\\n\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n                \\n        # recursive backtracking with memoization\\n        \\n        # alg: choose colors to \"unprint\" one by one and backtrack when grid constraint is not satissfied\\n        # return True if all numbers have been uncovered\\n        \\n        # setup: process grid to get positions of smallest possible rect for each color\\n        # represented with (startRow, startCol, endRow, endCol)\\n        # optimization is used to determine valid unprint color candidates\\n        \\n        # start with all colors printed\\n        \\n        # isUncoveredRect(grid, color, colorRects, printed) => true if colorRect for color in grid is all either color or !printed\\n                \\n        # backtrack (dfs), choose a non-printed color that is a valid uncovered rectangle to unprint\\n        # keep going until either we can\\'t add anymore or we\\'ve reached a solution\\n        # re-print color on the backtrack path\\n        # keep memo of if we\\'ve seen the same printed state for optimization (adds O(2^C) space but in practice\\n        # only a function of potential uncovered rectangles). likely room for improvement\\n        \\n        def isUncoveredRect(grid, color, colorRects, printed):\\n            \"\"\"Return whether color\\'s bounding box is currently uncovered by other colors in the grid\\n            \\n            A colors bounding box is only uncovered by others if every square in the box is either the given color\\n            or !printed[color].\\n            \"\"\"\\n            startRow, startCol, endRow, endCol = colorRects[color]\\n            for row in range(startRow, endRow):\\n                for col in range(startCol, endCol):\\n                    if grid[row][col] != color and printed[grid[row][col]]:\\n                        return False\\n            return True\\n        \\n                       \\n        def unprint(targetGrid, color, colorRects, printed, memo):\\n            \"\"\"Backtrack by unprinting color and then trying to unprint other printed, uncovered rectangle colors\\n            \\n            Assumes only called for valid uncovered, un-printed color color\\n            \\n            Selection criteria of which color to print next likely can be improved via heuristic but keeping simple seems to work\\n            \"\"\"\\n            \\n            # printed.values() -> boolean tuple of length C\\n            if tuple(printed.values()) in memo:\\n                return memo[tuple(printed.values())]\\n            \\n            printed[color] = False\\n            if not any(printed.values()):\\n                return True\\n            \\n            for printedColor in printed:\\n                if printed[printedColor] and isUncoveredRect(targetGrid, printedColor, colorRects, printed):\\n                    if unprint(targetGrid, printedColor, colorRects, printed, memo):\\n                        return True\\n            \\n            # failed to find solution in this path, \"re-print\" color\\n            printed[color] = True\\n            memo[tuple(printed.values())] = False\\n            return False\\n        \\n        if len(targetGrid) < 1:\\n            return False\\n        \\n        # setup O(MN), space O(C)\\n        colorRects = {}\\n        for row in range(len(targetGrid)):\\n            for col in range(len(targetGrid[0])):\\n                color = targetGrid[row][col]\\n                if color not in colorRects:\\n                    # first row will always be start row\\n                    colorRects[color] = (row, col, row + 1, col + 1)\\n                else:\\n                    # need to take care to update startCol and endCol for each rectangle accordingly\\n                    oldRow, oldCol, oldEndRow, oldEndCol = colorRects[color]\\n                    colorRects[color] = (oldRow, min(oldCol, col), row + 1, max(oldEndCol, col + 1))\\n       \\n        printed = { color: True for color in colorRects }\\n        memo = {}\\n        for color in printed:\\n            if isUncoveredRect(targetGrid, color, colorRects, printed) and unprint(targetGrid, color, colorRects, printed, memo):\\n                return True\\n        return False\\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\ndef isUncoveredRect(grid, color, colorRects, printed):\\n\\t\"\"\"Return whether color\\'s bounding box is currently uncovered by other colors in the grid\\n\\n\\tA colors bounding box is only uncovered by others if every square in the box is either the given color\\n\\tor !printed[color].\\n\\t\"\"\"\\n\\tstartRow, startCol, endRow, endCol = colorRects[color]\\n\\tfor row in range(startRow, endRow):\\n\\t\\tfor col in range(startCol, endCol):\\n\\t\\t\\tif grid[row][col] != color and printed[grid[row][col]]:\\n\\t\\t\\t\\treturn False\\n\\treturn True\\n```\n```\\ncolorRects = {}\\nfor row in range(len(targetGrid)):\\n\\tfor col in range(len(targetGrid[0])):\\n\\t\\tcolor = targetGrid[row][col]\\n\\t\\tif color not in colorRects:\\n\\t\\t\\t# first row will always be start row since we\\'re moving top to bottom\\n\\t\\t\\tcolorRects[color] = (row, col, row + 1, col + 1)\\n\\t\\telse:\\n\\t\\t\\t# need to take care to update startCol and endCol for each rectangle accordingly\\n\\t\\t\\toldRow, oldCol, oldEndRow, oldEndCol = colorRects[color]\\n\\t\\t\\tcolorRects[color] = (oldRow, min(oldCol, col), row + 1, max(oldEndCol, col + 1))\\n```\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n                \\n        # recursive backtracking with memoization\\n        \\n        # alg: choose colors to \"unprint\" one by one and backtrack when grid constraint is not satissfied\\n        # return True if all numbers have been uncovered\\n        \\n        # setup: process grid to get positions of smallest possible rect for each color\\n        # represented with (startRow, startCol, endRow, endCol)\\n        # optimization is used to determine valid unprint color candidates\\n        \\n        # start with all colors printed\\n        \\n        # isUncoveredRect(grid, color, colorRects, printed) => true if colorRect for color in grid is all either color or !printed\\n                \\n        # backtrack (dfs), choose a non-printed color that is a valid uncovered rectangle to unprint\\n        # keep going until either we can\\'t add anymore or we\\'ve reached a solution\\n        # re-print color on the backtrack path\\n        # keep memo of if we\\'ve seen the same printed state for optimization (adds O(2^C) space but in practice\\n        # only a function of potential uncovered rectangles). likely room for improvement\\n        \\n        def isUncoveredRect(grid, color, colorRects, printed):\\n            \"\"\"Return whether color\\'s bounding box is currently uncovered by other colors in the grid\\n            \\n            A colors bounding box is only uncovered by others if every square in the box is either the given color\\n            or !printed[color].\\n            \"\"\"\\n            startRow, startCol, endRow, endCol = colorRects[color]\\n            for row in range(startRow, endRow):\\n                for col in range(startCol, endCol):\\n                    if grid[row][col] != color and printed[grid[row][col]]:\\n                        return False\\n            return True\\n        \\n                       \\n        def unprint(targetGrid, color, colorRects, printed, memo):\\n            \"\"\"Backtrack by unprinting color and then trying to unprint other printed, uncovered rectangle colors\\n            \\n            Assumes only called for valid uncovered, un-printed color color\\n            \\n            Selection criteria of which color to print next likely can be improved via heuristic but keeping simple seems to work\\n            \"\"\"\\n            \\n            # printed.values() -> boolean tuple of length C\\n            if tuple(printed.values()) in memo:\\n                return memo[tuple(printed.values())]\\n            \\n            printed[color] = False\\n            if not any(printed.values()):\\n                return True\\n            \\n            for printedColor in printed:\\n                if printed[printedColor] and isUncoveredRect(targetGrid, printedColor, colorRects, printed):\\n                    if unprint(targetGrid, printedColor, colorRects, printed, memo):\\n                        return True\\n            \\n            # failed to find solution in this path, \"re-print\" color\\n            printed[color] = True\\n            memo[tuple(printed.values())] = False\\n            return False\\n        \\n        if len(targetGrid) < 1:\\n            return False\\n        \\n        # setup O(MN), space O(C)\\n        colorRects = {}\\n        for row in range(len(targetGrid)):\\n            for col in range(len(targetGrid[0])):\\n                color = targetGrid[row][col]\\n                if color not in colorRects:\\n                    # first row will always be start row\\n                    colorRects[color] = (row, col, row + 1, col + 1)\\n                else:\\n                    # need to take care to update startCol and endCol for each rectangle accordingly\\n                    oldRow, oldCol, oldEndRow, oldEndCol = colorRects[color]\\n                    colorRects[color] = (oldRow, min(oldCol, col), row + 1, max(oldEndCol, col + 1))\\n       \\n        printed = { color: True for color in colorRects }\\n        memo = {}\\n        for color in printed:\\n            if isUncoveredRect(targetGrid, color, colorRects, printed) and unprint(targetGrid, color, colorRects, printed, memo):\\n                return True\\n        return False\\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 866940,
                "title": "python3-topological-sort",
                "content": "```\\nfrom typing import List\\nimport collections\\n\\n\\nclass Solution:\\n\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        limit = 60\\n        rectangles = {}\\n        for line in range(len(targetGrid)):\\n            for col in range(len(targetGrid[0])):\\n                color = targetGrid[line][col]\\n                if color not in rectangles:\\n                    rectangles[color] = {}\\n                rectangles[color] = {\\n                    \"left\":  min(rectangles[color].get(\"left\", limit), col),\\n                    \"right\": max(rectangles[color].get(\"right\", 0), col),\\n                    \"up\": min(rectangles[color].get(\"up\", limit), line),\\n                    \"down\": max(rectangles[color].get(\"down\", 0), line),\\n                }\\n\\n        graph = {}\\n        for color, rect in rectangles.items():\\n            graph[color] = set()\\n            for line in range(rect[\"up\"], rect[\"down\"]+1):\\n                for col in range(rect[\"left\"], rect[\"right\"]+1):\\n                    if targetGrid[line][col] != color:\\n                        graph[color].add(targetGrid[line][col])\\n\\n        dq = collections.deque()\\n\\n        for color in graph.keys():\\n            if len(graph[color]) == 0:\\n                dq.append(color)\\n                graph[color] = None\\n\\n        while len(dq) != 0:\\n            color = dq.pop()\\n            for deps in graph.values():\\n                if deps == None:\\n                    continue\\n                if color in deps:\\n                    deps.remove(color)\\n            for color in graph.keys():\\n                if graph[color] != None and len(graph[color]) == 0:\\n                    dq.append(color)\\n                    graph[color] = None\\n\\n        for v in graph.values():\\n            if v != None:\\n                return False\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nfrom typing import List\\nimport collections\\n\\n\\nclass Solution:\\n\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        limit = 60\\n        rectangles = {}\\n        for line in range(len(targetGrid)):\\n            for col in range(len(targetGrid[0])):\\n                color = targetGrid[line][col]\\n                if color not in rectangles:\\n                    rectangles[color] = {}\\n                rectangles[color] = {\\n                    \"left\":  min(rectangles[color].get(\"left\", limit), col),\\n                    \"right\": max(rectangles[color].get(\"right\", 0), col),\\n                    \"up\": min(rectangles[color].get(\"up\", limit), line),\\n                    \"down\": max(rectangles[color].get(\"down\", 0), line),\\n                }\\n\\n        graph = {}\\n        for color, rect in rectangles.items():\\n            graph[color] = set()\\n            for line in range(rect[\"up\"], rect[\"down\"]+1):\\n                for col in range(rect[\"left\"], rect[\"right\"]+1):\\n                    if targetGrid[line][col] != color:\\n                        graph[color].add(targetGrid[line][col])\\n\\n        dq = collections.deque()\\n\\n        for color in graph.keys():\\n            if len(graph[color]) == 0:\\n                dq.append(color)\\n                graph[color] = None\\n\\n        while len(dq) != 0:\\n            color = dq.pop()\\n            for deps in graph.values():\\n                if deps == None:\\n                    continue\\n                if color in deps:\\n                    deps.remove(color)\\n            for color in graph.keys():\\n                if graph[color] != None and len(graph[color]) == 0:\\n                    dq.append(color)\\n                    graph[color] = None\\n\\n        for v in graph.values():\\n            if v != None:\\n                return False\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 866050,
                "title": "concise-python",
                "content": "```\\nclass Solution:\\ndef isPrintable(self, g: List[List[int]]) -> bool:\\n\\tdef helper():\\n\\t\\tm = {}                \\n\\t\\tfor i, r in enumerate(g):\\n\\t\\t\\tfor j, c in enumerate(r):                \\n\\t\\t\\t\\tpos = m.get(c, (float(\\'inf\\'), float(\\'inf\\'), 0, 0))\\n\\t\\t\\t\\tm[c] = (min(pos[0], i), min(pos[1], j), max(pos[2], i), max(pos[3], j))\\n\\t\\treturn m        \\n\\tdef good(c, pos):            \\n\\t\\tfor i in range(pos[0], pos[2]+1):\\n\\t\\t\\tfor j in range(pos[1], pos[3]+1):\\n\\t\\t\\t\\tif g[i][j] not in [0, c]: return False\\n\\t\\treturn True                        \\n\\tM, N, mem = len(g), len(g[0]), helper()\\n\\twhile True:            \\n\\t\\tq = set(c for c in mem if good(c, mem[c]))\\n\\t\\tif not q: return not mem\\n\\t\\tfor i in range(M):\\n\\t\\t\\tfor j in range(N):\\n\\t\\t\\t\\tif g[i][j] in q: g[i][j] = 0\\n\\t\\tfor c in q: del mem[c]",
                "solutionTags": [],
                "code": "class Solution:\\ndef isPrintable(self, g: List[List[int]]) -> bool:\\n\\tdef helper():\\n\\t\\tm = {}",
                "codeTag": "Java"
            },
            {
                "id": 863645,
                "title": "c-topological-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        //identify the possible four corners of the rectangle for each color\\n        vector<vector<int>> grid(61, vector<int>(4, -1));\\n        int n = targetGrid.size(), m = targetGrid[0].size();\\n        for(int row=0; row<n; row++){\\n            for(int col=0; col<m; col++){\\n                int color = targetGrid[row][col];\\n                (grid[color][0] == -1) ? grid[color][0] = row : grid[color][0] = min(row, grid[color][0]);\\n                (grid[color][1] == -1) ? grid[color][1] = col : grid[color][1] = min(col, grid[color][1]);\\n                (grid[color][2] == -1) ? grid[color][2] = row : grid[color][2] = max(row, grid[color][2]);\\n                (grid[color][3] == -1) ? grid[color][3] = col : grid[color][3] = max(col, grid[color][3]);\\n            }\\n        }\\n        \\n        //build graph\\n        vector<vector<int>> graph(61, vector<int>(61, 0));\\n        vector<int> indegree(61, -1);\\n        for(int color=1; color<61; color++){\\n            if(grid[color][0] == -1) continue;\\n            indegree[color] = 0;\\n            vector<int> visited(61, 0);\\n            for(int row=grid[color][0]; row<=grid[color][2]; row++){\\n                for(int col=grid[color][1]; col<=grid[color][3]; col++){\\n                    if(targetGrid[row][col] != color && !visited[targetGrid[row][col]]){\\n                        visited[targetGrid[row][col]] = 1;\\n                        graph[targetGrid[row][col]][color] = 1;\\n                        indegree[color]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //topological sort\\n        queue<int> q;\\n        for(int color=1; color<=60; color++) if(indegree[color] == 0) q.push(color);\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n            for(int color=1; color<61; color++){\\n                if(graph[front][color] == 1){\\n                    indegree[color]--;\\n                    if(indegree[color] == 0) q.push(color);\\n                }\\n            }\\n        }\\n        \\n        for(int color=1; color<61; color++){\\n            if(indegree[color] > 0) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        //identify the possible four corners of the rectangle for each color\\n        vector<vector<int>> grid(61, vector<int>(4, -1));\\n        int n = targetGrid.size(), m = targetGrid[0].size();\\n        for(int row=0; row<n; row++){\\n            for(int col=0; col<m; col++){\\n                int color = targetGrid[row][col];\\n                (grid[color][0] == -1) ? grid[color][0] = row : grid[color][0] = min(row, grid[color][0]);\\n                (grid[color][1] == -1) ? grid[color][1] = col : grid[color][1] = min(col, grid[color][1]);\\n                (grid[color][2] == -1) ? grid[color][2] = row : grid[color][2] = max(row, grid[color][2]);\\n                (grid[color][3] == -1) ? grid[color][3] = col : grid[color][3] = max(col, grid[color][3]);\\n            }\\n        }\\n        \\n        //build graph\\n        vector<vector<int>> graph(61, vector<int>(61, 0));\\n        vector<int> indegree(61, -1);\\n        for(int color=1; color<61; color++){\\n            if(grid[color][0] == -1) continue;\\n            indegree[color] = 0;\\n            vector<int> visited(61, 0);\\n            for(int row=grid[color][0]; row<=grid[color][2]; row++){\\n                for(int col=grid[color][1]; col<=grid[color][3]; col++){\\n                    if(targetGrid[row][col] != color && !visited[targetGrid[row][col]]){\\n                        visited[targetGrid[row][col]] = 1;\\n                        graph[targetGrid[row][col]][color] = 1;\\n                        indegree[color]++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        //topological sort\\n        queue<int> q;\\n        for(int color=1; color<=60; color++) if(indegree[color] == 0) q.push(color);\\n        while(!q.empty()){\\n            int front = q.front();\\n            q.pop();\\n            for(int color=1; color<61; color++){\\n                if(graph[front][color] == 1){\\n                    indegree[color]--;\\n                    if(indegree[color] == 0) q.push(color);\\n                }\\n            }\\n        }\\n        \\n        for(int color=1; color<61; color++){\\n            if(indegree[color] > 0) return false;\\n        }\\n        return true;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 863010,
                "title": "python3-98-7-81",
                "content": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        LEN = 61\\n        self.left = [LEN]* LEN\\n        self.right = [-1] * LEN\\n        self.top = [LEN] * LEN\\n        self.bottom = [-1] * LEN\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        for row in range(m):\\n            for col in range(n):\\n                a = targetGrid[row][col]\\n                if self.left[a] > row:\\n                    self.left[a] = row\\n                if self.right[a] < row:\\n                    self.right[a] = row\\n                if self.top[a] > col:\\n                    self.top[a] = col\\n                if self.bottom[a] < col:\\n                    self.bottom[a] = col\\n        keys = set()\\n        for i in range(len(self.left)):\\n            if self.left[i] != LEN:\\n                keys.add(i)\\n        flag = True\\n        while flag:\\n            flag = False\\n            for k in keys:\\n                if self.canprint(k, targetGrid):\\n                    flag = True\\n                    break\\n            if flag:\\n                keys.remove(k)\\n        return len(keys) == 0\\n    \\n    def canprint(self, k, targetGrid):\\n        for i in range(self.left[k], self.right[k] + 1):\\n            for j in range(self.top[k], self.bottom[k] + 1):\\n                if targetGrid[i][j] == k or targetGrid[i][j] == 0:\\n                    pass\\n                else:\\n                    return False\\n        for i in range(self.left[k], self.right[k] + 1):\\n            for j in range(self.top[k], self.bottom[k] + 1):\\n                targetGrid[i][j] = 0\\n        return True\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        LEN = 61\\n        self.left = [LEN]* LEN\\n        self.right = [-1] * LEN\\n        self.top = [LEN] * LEN\\n        self.bottom = [-1] * LEN\\n        m = len(targetGrid)\\n        n = len(targetGrid[0])\\n        for row in range(m):\\n            for col in range(n):\\n                a = targetGrid[row][col]\\n                if self.left[a] > row:\\n                    self.left[a] = row\\n                if self.right[a] < row:\\n                    self.right[a] = row\\n                if self.top[a] > col:\\n                    self.top[a] = col\\n                if self.bottom[a] < col:\\n                    self.bottom[a] = col\\n        keys = set()\\n        for i in range(len(self.left)):\\n            if self.left[i] != LEN:\\n                keys.add(i)\\n        flag = True\\n        while flag:\\n            flag = False\\n            for k in keys:\\n                if self.canprint(k, targetGrid):\\n                    flag = True\\n                    break\\n            if flag:\\n                keys.remove(k)\\n        return len(keys) == 0\\n    \\n    def canprint(self, k, targetGrid):\\n        for i in range(self.left[k], self.right[k] + 1):\\n            for j in range(self.top[k], self.bottom[k] + 1):\\n                if targetGrid[i][j] == k or targetGrid[i][j] == 0:\\n                    pass\\n                else:\\n                    return False\\n        for i in range(self.left[k], self.right[k] + 1):\\n            for j in range(self.top[k], self.bottom[k] + 1):\\n                targetGrid[i][j] = 0\\n        return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861516,
                "title": "python3-as-digraph",
                "content": "Learned the idea from this [post](https://leetcode.com/problems/strange-printer-ii/discuss/854151/C%2B%2B-O(n3)-solution-checking-cycle-in-dependency-graph).\\n```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0]) # dimensions \\n        \\n        # build directed graph (adjacency list)\\n        digraph = {} \\n        for c in range(1, 61): \\n            imn = jmn = 60\\n            imx = jmx = 0\\n            for i in range(m): \\n                for j in range(n): \\n                    if targetGrid[i][j] == c: \\n                        imn = min(imn, i)\\n                        imx = max(imx, i)\\n                        jmn = min(jmn, j)\\n                        jmx = max(jmx, j)\\n            for i in range(imn, imx+1):\\n                for j in range(jmn, jmx+1): \\n                    if targetGrid[i][j] != c: \\n                        digraph.setdefault(c, set()).add(targetGrid[i][j])\\n            \\n        # check for cycle in digraph (tri-color)\\n        def dfs(n): \\n            \"\"\"Return True if a cycle is detected.\"\"\"\\n            if seen[n]: return seen[n] == 1 \\n            seen[n] = 1\\n            if any(dfs(nn) for nn in digraph.get(n, set())): return True \\n            seen[n] = 2\\n            return False \\n        \\n        seen = [0]*61\\n        return not any(dfs(i) for i in range(61)) # cycle, i.e. impossible to print \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isPrintable(self, targetGrid: List[List[int]]) -> bool:\\n        m, n = len(targetGrid), len(targetGrid[0]) # dimensions \\n        \\n        # build directed graph (adjacency list)\\n        digraph = {} \\n        for c in range(1, 61): \\n            imn = jmn = 60\\n            imx = jmx = 0\\n            for i in range(m): \\n                for j in range(n): \\n                    if targetGrid[i][j] == c: \\n                        imn = min(imn, i)\\n                        imx = max(imx, i)\\n                        jmn = min(jmn, j)\\n                        jmx = max(jmx, j)\\n            for i in range(imn, imx+1):\\n                for j in range(jmn, jmx+1): \\n                    if targetGrid[i][j] != c: \\n                        digraph.setdefault(c, set()).add(targetGrid[i][j])\\n            \\n        # check for cycle in digraph (tri-color)\\n        def dfs(n): \\n            \"\"\"Return True if a cycle is detected.\"\"\"\\n            if seen[n]: return seen[n] == 1 \\n            seen[n] = 1\\n            if any(dfs(nn) for nn in digraph.get(n, set())): return True \\n            seen[n] = 2\\n            return False \\n        \\n        seen = [0]*61\\n        return not any(dfs(i) for i in range(61)) # cycle, i.e. impossible to print \\n```",
                "codeTag": "Java"
            },
            {
                "id": 859391,
                "title": "c",
                "content": "```\\nclass Solution {\\n    bool solve(vector<vector<int>> &targetGrid, map<int, vector<int>> &dp) {\\n        if (dp.size() == 0) return true;\\n        vector<int> good;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            bool tmp = false;\\n            for (int i = it->second[0]; i <= it->second[2]; ++i) {\\n                for (int j = it->second[1]; j <= it->second[3]; ++j) {\\n                    if (targetGrid[i][j] != it->first && targetGrid[i][j] != -1) {\\n                        tmp = true;\\n                        break;\\n                    }\\n                }\\n                if (tmp) break;\\n            }\\n            if (!tmp) {\\n                for (int i = it->second[0]; i <= it->second[2]; ++i) {\\n                    for (int j = it->second[1]; j <= it->second[3]; ++j) {\\n                        targetGrid[i][j] = -1;\\n                    }\\n                }\\n                good.push_back(it->first);\\n            }\\n        }\\n        if (good.size() == 0) return false;\\n        for (int i = 0; i < good.size(); ++i) {\\n            dp.erase(good[i]);\\n        }\\n        return solve(targetGrid, dp);\\n    }\\n\\npublic:\\n    bool isPrintable(vector<vector<int>> &targetGrid) {\\n        map<int, vector<int>> dp;\\n        int n = targetGrid.size(), m = targetGrid[0].size();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                int c = targetGrid[i][j];\\n                if (dp.find(c) != dp.end()) {\\n                    dp[c][0] = min(dp[c][0], i);\\n                    dp[c][1] = min(dp[c][1], j);\\n                    dp[c][2] = max(dp[c][2], i);\\n                    dp[c][3] = max(dp[c][3], j);\\n                } else {\\n                    dp[c] = {i, j, i, j};\\n                }\\n            }\\n        }\\n        return solve(targetGrid, dp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    bool solve(vector<vector<int>> &targetGrid, map<int, vector<int>> &dp) {\\n        if (dp.size() == 0) return true;\\n        vector<int> good;\\n        for (auto it = dp.begin(); it != dp.end(); ++it) {\\n            bool tmp = false;\\n            for (int i = it->second[0]; i <= it->second[2]; ++i) {\\n                for (int j = it->second[1]; j <= it->second[3]; ++j) {\\n                    if (targetGrid[i][j] != it->first && targetGrid[i][j] != -1) {\\n                        tmp = true;\\n                        break;\\n                    }\\n                }\\n                if (tmp) break;\\n            }\\n            if (!tmp) {\\n                for (int i = it->second[0]; i <= it->second[2]; ++i) {\\n                    for (int j = it->second[1]; j <= it->second[3]; ++j) {\\n                        targetGrid[i][j] = -1;\\n                    }\\n                }\\n                good.push_back(it->first);\\n            }\\n        }\\n        if (good.size() == 0) return false;\\n        for (int i = 0; i < good.size(); ++i) {\\n            dp.erase(good[i]);\\n        }\\n        return solve(targetGrid, dp);\\n    }\\n\\npublic:\\n    bool isPrintable(vector<vector<int>> &targetGrid) {\\n        map<int, vector<int>> dp;\\n        int n = targetGrid.size(), m = targetGrid[0].size();\\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                int c = targetGrid[i][j];\\n                if (dp.find(c) != dp.end()) {\\n                    dp[c][0] = min(dp[c][0], i);\\n                    dp[c][1] = min(dp[c][1], j);\\n                    dp[c][2] = max(dp[c][2], i);\\n                    dp[c][3] = max(dp[c][3], j);\\n                } else {\\n                    dp[c] = {i, j, i, j};\\n                }\\n            }\\n        }\\n        return solve(targetGrid, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 859364,
                "title": "only-from-intuition-c",
                "content": "consider this matrix\\n1 1 1 1\\n1 1 1 1\\n1 3 3 3\\nIn this matrix which layer is on top?\\nVerifying this is the question\\nSo in quantifying this we introduce a term called loss\\nIn the above matrix rectangle of ones should start at (0,0) & end at (2,3)\\nso loss= nums in( (0,0)->(2,3) ) -actual counts of (1)\\ni.e., (4*3)-9=3;\\nNow we can see by intuition that 0 loss should be at top and highest loss should be the first layer\\n\\nwe sort by this and fill those rectangle with zeros.\\n\\n```\\nstruct rect{     // store max diagonal edges possible\\n    pair<int,int> start;\\n    pair<int,int> end;\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int,rect> mp;int c;\\n    unordered_map<int,int> counts; // to count number of actual numbers\\n    bool vis[61]={};\\n    bool isPrintable(vector<vector<int>>& G) {\\n        int n=G.size(),m=G[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                c=G[i][j];\\n                if(mp.find(c)==mp.end()){\\n                    mp[c].start={i,j};mp[c].end={i,j};\\n                }\\n                else{\\n                    auto [x,y]=mp[c].start;\\n                    auto [p,q]=mp[c].end;\\n                    mp[c].start={min(x,i),min(y,j)};\\n                    mp[c].end={max(p,i),max(q,j)};\\n                }\\n                counts[c]++;\\n            }\\n        }\\n        int num,loss;\\n        vector<pair<int,int>> v;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            c=it->first;\\n            num=(((it->second).end.second-(it->second).start.second)+1)*\\n                ((it->second).end.first-(it->second).start.first+1);\\n            loss=num-counts[c];\\n            v.push_back({loss,c});\\n        }\\n        sort(v.begin(),v.end());   //sort by loss\\n        for(int i=0;i<v.size();i++){\\n            rec=mp[v[i].second];\\n            if(!fillrec(rec,G,v[i].second)){  //if unable to fill maximal rectangle return false\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool fillrec(rect rec,vector<vector<int>>& G,int val){\\n        vis[val]=1; //mark the visited val\\n        for(int i=rec.start.first;i<=rec.end.first;i++){\\n            for(int j=rec.start.second;j<=rec.end.second;j++){\\n                if(G[i][j]==val || G[i][j]==0){\\n                    G[i][j]=0;\\n                }\\n                else{\\n                    if(vis[G[i][j]] || !fillrec(mp[G[i][j]],G,G[i][j]))return false; //recursion to encounter case when losses are equal\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nstruct rect{     // store max diagonal edges possible\\n    pair<int,int> start;\\n    pair<int,int> end;\\n};\\nclass Solution {\\npublic:\\n    unordered_map<int,rect> mp;int c;\\n    unordered_map<int,int> counts; // to count number of actual numbers\\n    bool vis[61]={};\\n    bool isPrintable(vector<vector<int>>& G) {\\n        int n=G.size(),m=G[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                c=G[i][j];\\n                if(mp.find(c)==mp.end()){\\n                    mp[c].start={i,j};mp[c].end={i,j};\\n                }\\n                else{\\n                    auto [x,y]=mp[c].start;\\n                    auto [p,q]=mp[c].end;\\n                    mp[c].start={min(x,i),min(y,j)};\\n                    mp[c].end={max(p,i),max(q,j)};\\n                }\\n                counts[c]++;\\n            }\\n        }\\n        int num,loss;\\n        vector<pair<int,int>> v;\\n        for(auto it=mp.begin();it!=mp.end();it++){\\n            c=it->first;\\n            num=(((it->second).end.second-(it->second).start.second)+1)*\\n                ((it->second).end.first-(it->second).start.first+1);\\n            loss=num-counts[c];\\n            v.push_back({loss,c});\\n        }\\n        sort(v.begin(),v.end());   //sort by loss\\n        for(int i=0;i<v.size();i++){\\n            rec=mp[v[i].second];\\n            if(!fillrec(rec,G,v[i].second)){  //if unable to fill maximal rectangle return false\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    bool fillrec(rect rec,vector<vector<int>>& G,int val){\\n        vis[val]=1; //mark the visited val\\n        for(int i=rec.start.first;i<=rec.end.first;i++){\\n            for(int j=rec.start.second;j<=rec.end.second;j++){\\n                if(G[i][j]==val || G[i][j]==0){\\n                    G[i][j]=0;\\n                }\\n                else{\\n                    if(vis[G[i][j]] || !fillrec(mp[G[i][j]],G,G[i][j]))return false; //recursion to encounter case when losses are equal\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857436,
                "title": "java-solution-straight-forward",
                "content": "```\\nclass Solution {\\n    \\n    boolean findRectAndUpdate(int[][] gg, int val){\\n\\t    // check if there is a rectangle with color val\\n        int minx = m;\\n        int maxx = -1;\\n        int miny = n;\\n        int maxy = -1;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(gg[i][j]==val){\\n                    minx = Math.min(minx, i);\\n                    maxx = Math.max(maxx, i);\\n                    miny = Math.min(miny, j);\\n                    maxy = Math.max(maxy, j);\\n                }\\n            }\\n        }\\n \\n        for(int i=minx; i<=maxx; i++)\\n            for(int j=miny; j<=maxy; j++)\\n                if(gg[i][j]!=val && gg[i][j]!=0)  // 0 means any color is ok\\n                    return false; \\n        // paint the rectangle to 0\\n        for(int i=minx; i<=maxx; i++)\\n            for(int j=miny; j<=maxy; j++)\\n                gg[i][j]=0;\\n        \\n        return true;\\n    }\\n\\n    int m = 0; int n = 0;\\n    \\n    public boolean isPrintable(int[][] gg) {\\n        \\n        m = gg.length;  n = gg[0].length;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                set.add(gg[i][j]);\\n  \\n        while(!set.isEmpty()){\\n            Iterator<Integer> it = set.iterator();\\n            boolean flag = false;\\n            while(it.hasNext()){\\n                int next = it.next();\\n                if(findRectAndUpdate(gg, next)){\\n                    it.remove();\\n                    flag = true;\\n                }\\n            }\\n            if(!flag) // no more rectangle\\n                break;\\n        }\\n        \\n        return set.isEmpty(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    boolean findRectAndUpdate(int[][] gg, int val){\\n\\t    // check if there is a rectangle with color val\\n        int minx = m;\\n        int maxx = -1;\\n        int miny = n;\\n        int maxy = -1;\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(gg[i][j]==val){\\n                    minx = Math.min(minx, i);\\n                    maxx = Math.max(maxx, i);\\n                    miny = Math.min(miny, j);\\n                    maxy = Math.max(maxy, j);\\n                }\\n            }\\n        }\\n \\n        for(int i=minx; i<=maxx; i++)\\n            for(int j=miny; j<=maxy; j++)\\n                if(gg[i][j]!=val && gg[i][j]!=0)  // 0 means any color is ok\\n                    return false; \\n        // paint the rectangle to 0\\n        for(int i=minx; i<=maxx; i++)\\n            for(int j=miny; j<=maxy; j++)\\n                gg[i][j]=0;\\n        \\n        return true;\\n    }\\n\\n    int m = 0; int n = 0;\\n    \\n    public boolean isPrintable(int[][] gg) {\\n        \\n        m = gg.length;  n = gg[0].length;\\n        \\n        Set<Integer> set = new HashSet<>();\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                set.add(gg[i][j]);\\n  \\n        while(!set.isEmpty()){\\n            Iterator<Integer> it = set.iterator();\\n            boolean flag = false;\\n            while(it.hasNext()){\\n                int next = it.next();\\n                if(findRectAndUpdate(gg, next)){\\n                    it.remove();\\n                    flag = true;\\n                }\\n            }\\n            if(!flag) // no more rectangle\\n                break;\\n        }\\n        \\n        return set.isEmpty(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856331,
                "title": "c-reverse-iteration-with-running-over-non-solid-areas-and-making-them-solid",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        if(m==0) return true;\\n        int n = targetGrid[0].size();\\n        if(n==0) return true;\\n        \\n        int c = 0;\\n        unordered_map<int, int> seenSolid; \\n        for(int i = 0; i< m; i++)\\n            for(int j = 0; j< n; j++){                \\n                    c = targetGrid[i][j];\\n                    seenSolid[c]=0;                \\n            }\\n        \\n        int nonSolid=0;\\n         for(auto cv : seenSolid){\\n             int minx=INT_MAX;\\n             int maxx=INT_MIN;\\n             int miny=INT_MAX;\\n             int maxy=INT_MIN;\\n             for(int i = 0; i< m; i++)\\n                for(int j = 0; j< n; j++)\\n                    if(cv.first==targetGrid[i][j]) {\\n                        minx = min(minx, i);\\n                        maxx = max(maxx, i);\\n                        miny = min(miny, j);\\n                        maxy = max(maxy, j);\\n                    }                \\n             \\n             bool ok = true;\\n             for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++)\\n                    if(cv.first!=targetGrid[ki][kj]) {\\n                        ok = false;\\n                        break;\\n                    }                \\n             \\n             if(!ok){\\n                nonSolid++;\\n             }else{\\n                seenSolid[cv.first]=1;\\n                for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++){\\n                    targetGrid[ki][kj]=\\'s\\';                    \\n                }\\n             }                          \\n         }\\n        \\n        if(nonSolid==0) return true;\\n        \\n        while(nonSolid){\\n            \\n        bool foundSolid = false;\\n            \\n        for(auto cv : seenSolid){\\n            \\n            if(cv.second==1) {\\n                continue;\\n            }\\n                \\n             int minx=INT_MAX;\\n             int maxx=INT_MIN;\\n             int miny=INT_MAX;\\n             int maxy=INT_MIN;\\n             for(int i = 0; i< m; i++)\\n                for(int j = 0; j< n; j++)\\n                    if(cv.first==targetGrid[i][j]) {\\n                        minx = min(minx, i);\\n                        maxx = max(maxx, i);\\n                        miny = min(miny, j);\\n                        maxy = max(maxy, j);\\n                    }                            \\n            \\n            bool ok = true;\\n             for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++)\\n                    if(cv.first!=targetGrid[ki][kj]) \\n                        if(targetGrid[ki][kj]!=\\'s\\'){\\n                            ok = false;\\n                            break;\\n                        }                                                            \\n            \\n             if(!ok){                 \\n             }else{\\n                 seenSolid[cv.first]=1;\\n                 for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++){\\n                    targetGrid[ki][kj]=\\'s\\';                    \\n                }\\n                 nonSolid--;\\n                 foundSolid = true;\\n             }  \\n        }\\n            \\n        if(!foundSolid) return false;\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPrintable(vector<vector<int>>& targetGrid) {\\n        int m = targetGrid.size();\\n        if(m==0) return true;\\n        int n = targetGrid[0].size();\\n        if(n==0) return true;\\n        \\n        int c = 0;\\n        unordered_map<int, int> seenSolid; \\n        for(int i = 0; i< m; i++)\\n            for(int j = 0; j< n; j++){                \\n                    c = targetGrid[i][j];\\n                    seenSolid[c]=0;                \\n            }\\n        \\n        int nonSolid=0;\\n         for(auto cv : seenSolid){\\n             int minx=INT_MAX;\\n             int maxx=INT_MIN;\\n             int miny=INT_MAX;\\n             int maxy=INT_MIN;\\n             for(int i = 0; i< m; i++)\\n                for(int j = 0; j< n; j++)\\n                    if(cv.first==targetGrid[i][j]) {\\n                        minx = min(minx, i);\\n                        maxx = max(maxx, i);\\n                        miny = min(miny, j);\\n                        maxy = max(maxy, j);\\n                    }                \\n             \\n             bool ok = true;\\n             for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++)\\n                    if(cv.first!=targetGrid[ki][kj]) {\\n                        ok = false;\\n                        break;\\n                    }                \\n             \\n             if(!ok){\\n                nonSolid++;\\n             }else{\\n                seenSolid[cv.first]=1;\\n                for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++){\\n                    targetGrid[ki][kj]=\\'s\\';                    \\n                }\\n             }                          \\n         }\\n        \\n        if(nonSolid==0) return true;\\n        \\n        while(nonSolid){\\n            \\n        bool foundSolid = false;\\n            \\n        for(auto cv : seenSolid){\\n            \\n            if(cv.second==1) {\\n                continue;\\n            }\\n                \\n             int minx=INT_MAX;\\n             int maxx=INT_MIN;\\n             int miny=INT_MAX;\\n             int maxy=INT_MIN;\\n             for(int i = 0; i< m; i++)\\n                for(int j = 0; j< n; j++)\\n                    if(cv.first==targetGrid[i][j]) {\\n                        minx = min(minx, i);\\n                        maxx = max(maxx, i);\\n                        miny = min(miny, j);\\n                        maxy = max(maxy, j);\\n                    }                            \\n            \\n            bool ok = true;\\n             for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++)\\n                    if(cv.first!=targetGrid[ki][kj]) \\n                        if(targetGrid[ki][kj]!=\\'s\\'){\\n                            ok = false;\\n                            break;\\n                        }                                                            \\n            \\n             if(!ok){                 \\n             }else{\\n                 seenSolid[cv.first]=1;\\n                 for(int ki = minx; ki<= maxx; ki++)\\n                for(int kj = miny; kj<= maxy; kj++){\\n                    targetGrid[ki][kj]=\\'s\\';                    \\n                }\\n                 nonSolid--;\\n                 foundSolid = true;\\n             }  \\n        }\\n            \\n        if(!foundSolid) return false;\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856262,
                "title": "rust-construct-graph-and-topological-sort",
                "content": "1) We find the min and max (x, y) coordinates for each number.\\n2) We construct a graph from the rectangle for each value, by checking if this rectangle intersects any other rectangle. i.e. if a rect of 1s is intersected with a rect of 2s, then 1s must be placed before the 2s, so add this directed edge in teh graph.\\n3) We simply do a topological sort to determine if there is no contradiction. \\n\\nAlso note that to iterate over `deps`, I use `deps.get(&cur).into_iter().flatten()` which is pretty nice :)\\n\\n```\\nuse std::collections::{HashMap, HashSet};\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\nenum VisitStatus {\\n    Visiting,\\n    Visited,\\n}\\n\\nfn has_cycle(\\n    cur: i32,\\n    deps: &HashMap<i32, HashSet<i32>>,\\n    seen: &mut HashMap<i32, VisitStatus>,\\n) -> bool {\\n    match seen.get(&cur) {\\n        Some(VisitStatus::Visited) => return false,\\n        Some(VisitStatus::Visiting) => return true,\\n        None => {}\\n    }\\n    seen.insert(cur, VisitStatus::Visiting);\\n\\n    for dep in deps.get(&cur).into_iter().flatten() {\\n        if has_cycle(*dep, deps, seen) {\\n            return true;\\n        }\\n    }\\n\\n    seen.insert(cur, VisitStatus::Visited);\\n    false\\n}\\n\\nfn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n    let mut starts_ends = HashMap::new();\\n\\n    for (i, row) in target_grid.iter().enumerate() {\\n        for (j, val) in row.iter().enumerate() {\\n            if let Some((x_min, y_min, x_max, y_max)) = starts_ends.get_mut(&val) {\\n                *x_min = std::cmp::min(*x_min, i);\\n                *y_min = std::cmp::min(*y_min, j);\\n\\n                *x_max = std::cmp::max(*x_max, i + 1);\\n                *y_max = std::cmp::max(*y_max, j + 1);\\n            } else {\\n                starts_ends.insert(val, (i, j, i + 1, j + 1));\\n            }\\n        }\\n    }\\n\\n    // println!(\"{:?}\", starts_ends);\\n\\n    let mut deps: HashMap<i32, HashSet<i32>> = HashMap::new();\\n    for (&&a_val, &(ax_min, ay_min, ax_max, ay_max)) in starts_ends.iter() {\\n        for (&&b_val, &(bx_min, by_min, bx_max, by_max)) in starts_ends.iter() {\\n            if a_val == b_val {\\n                continue;\\n            }\\n\\n            let (cx_min, cy_min, cx_max, cy_max) = (\\n                std::cmp::max(ax_min, bx_min),\\n                std::cmp::max(ay_min, by_min),\\n                std::cmp::min(ax_max, bx_max),\\n                std::cmp::min(ay_max, by_max),\\n            );\\n\\n            // println!(\"{:?}\", &(cx_min, cy_min, cx_max, cy_max));\\n\\n            for target_i in cx_min..cx_max {\\n                for target_j in cy_min..cy_max {\\n                    if target_grid[target_i][target_j] == b_val {\\n                        deps.entry(a_val).or_insert_with(HashSet::new).insert(b_val);\\n                    }\\n                    // else if target_grid[target_i][target_j] == a_val {\\n                    //     deps.entry(a_val).or_insert_with(Vec::new).push(b_val);\\n                    // }\\n                }\\n            }\\n        }\\n    }\\n\\n    // println!(\"{:?}\", deps);\\n\\n    let mut seen = HashMap::new();\\n    for (&&val, _) in starts_ends.iter() {\\n        // println!(\"{:?}\", val);\\n        if has_cycle(val, &deps, &mut seen) {\\n            // println!(\"{:?}\", val);\\n            return false;\\n        }\\n    }\\n\\n    true\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_lc1_simple() {\\n        assert!(is_printable(vec![\\n            vec![1, 1, 1, 1],\\n            vec![1, 2, 2, 1],\\n            vec![1, 2, 2, 1],\\n            vec![1, 1, 1, 1]\\n        ]))\\n    }\\n\\n    #[test]\\n    fn test_lc1_hard() {\\n        assert!(is_printable(vec![\\n            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],\\n            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],\\n            vec![4, 4, 4, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],\\n            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],\\n            vec![1, 1, 1, 6, 6, 6, 6, 6, 6, 2]\\n        ]))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n        is_printable(target_grid)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::{HashMap, HashSet};\\n\\n#[derive(Debug, Clone, PartialEq, Eq, Hash)]\\nenum VisitStatus {\\n    Visiting,\\n    Visited,\\n}\\n\\nfn has_cycle(\\n    cur: i32,\\n    deps: &HashMap<i32, HashSet<i32>>,\\n    seen: &mut HashMap<i32, VisitStatus>,\\n) -> bool {\\n    match seen.get(&cur) {\\n        Some(VisitStatus::Visited) => return false,\\n        Some(VisitStatus::Visiting) => return true,\\n        None => {}\\n    }\\n    seen.insert(cur, VisitStatus::Visiting);\\n\\n    for dep in deps.get(&cur).into_iter().flatten() {\\n        if has_cycle(*dep, deps, seen) {\\n            return true;\\n        }\\n    }\\n\\n    seen.insert(cur, VisitStatus::Visited);\\n    false\\n}\\n\\nfn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n    let mut starts_ends = HashMap::new();\\n\\n    for (i, row) in target_grid.iter().enumerate() {\\n        for (j, val) in row.iter().enumerate() {\\n            if let Some((x_min, y_min, x_max, y_max)) = starts_ends.get_mut(&val) {\\n                *x_min = std::cmp::min(*x_min, i);\\n                *y_min = std::cmp::min(*y_min, j);\\n\\n                *x_max = std::cmp::max(*x_max, i + 1);\\n                *y_max = std::cmp::max(*y_max, j + 1);\\n            } else {\\n                starts_ends.insert(val, (i, j, i + 1, j + 1));\\n            }\\n        }\\n    }\\n\\n    // println!(\"{:?}\", starts_ends);\\n\\n    let mut deps: HashMap<i32, HashSet<i32>> = HashMap::new();\\n    for (&&a_val, &(ax_min, ay_min, ax_max, ay_max)) in starts_ends.iter() {\\n        for (&&b_val, &(bx_min, by_min, bx_max, by_max)) in starts_ends.iter() {\\n            if a_val == b_val {\\n                continue;\\n            }\\n\\n            let (cx_min, cy_min, cx_max, cy_max) = (\\n                std::cmp::max(ax_min, bx_min),\\n                std::cmp::max(ay_min, by_min),\\n                std::cmp::min(ax_max, bx_max),\\n                std::cmp::min(ay_max, by_max),\\n            );\\n\\n            // println!(\"{:?}\", &(cx_min, cy_min, cx_max, cy_max));\\n\\n            for target_i in cx_min..cx_max {\\n                for target_j in cy_min..cy_max {\\n                    if target_grid[target_i][target_j] == b_val {\\n                        deps.entry(a_val).or_insert_with(HashSet::new).insert(b_val);\\n                    }\\n                    // else if target_grid[target_i][target_j] == a_val {\\n                    //     deps.entry(a_val).or_insert_with(Vec::new).push(b_val);\\n                    // }\\n                }\\n            }\\n        }\\n    }\\n\\n    // println!(\"{:?}\", deps);\\n\\n    let mut seen = HashMap::new();\\n    for (&&val, _) in starts_ends.iter() {\\n        // println!(\"{:?}\", val);\\n        if has_cycle(val, &deps, &mut seen) {\\n            // println!(\"{:?}\", val);\\n            return false;\\n        }\\n    }\\n\\n    true\\n}\\n\\n#[cfg(test)]\\nmod test {\\n    use super::*;\\n\\n    #[test]\\n    fn test_lc1_simple() {\\n        assert!(is_printable(vec![\\n            vec![1, 1, 1, 1],\\n            vec![1, 2, 2, 1],\\n            vec![1, 2, 2, 1],\\n            vec![1, 1, 1, 1]\\n        ]))\\n    }\\n\\n    #[test]\\n    fn test_lc1_hard() {\\n        assert!(is_printable(vec![\\n            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],\\n            vec![4, 4, 4, 1, 1, 1, 1, 1, 1, 1],\\n            vec![4, 4, 4, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 3, 1, 1, 1, 1, 1, 1],\\n            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],\\n            vec![1, 3, 3, 6, 6, 6, 6, 6, 6, 5],\\n            vec![1, 1, 1, 6, 6, 6, 6, 6, 6, 2]\\n        ]))\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn is_printable(target_grid: Vec<Vec<i32>>) -> bool {\\n        is_printable(target_grid)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 855302,
                "title": "java-remove-possible-color-rectangles-iterative",
                "content": "The idea is Brute force, every time remove all possible rectangle in the current grid, do it iterative, until only 1 color left.\\n\\n1. How to remove color?\\nset all the points in this rectangle to 0 (0 can represent any color).\\n2. How to find the rectangle?\\nfind the topmost, leftmost, rightmost, bottommost of the color, if inside this rectangle only has target color and 0, then this rectangle can be removed.\\n\\nRun time is about 13ms. \\nTime O(MNC^2), C is different colors in the grid, \\nSpace O(C)\\n```\\nclass Solution {\\n    class ColorObj {\\n        int c;\\n        int left = 60;\\n        int top = 60;\\n        int right = 0;\\n        int bottom = 0;\\n        public ColorObj(int c) {\\n            this.c = c;\\n        }\\n    }\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Set<Integer> colors = new HashSet<>();\\n        for (int i=0; i<targetGrid.length; i++){\\n            for (int j=0; j<targetGrid[0].length; j++) {\\n                colors.add(targetGrid[i][j]);\\n            }\\n        }\\n        while (colors.size() > 1) {\\n            Set<ColorObj> candidates = findColorCandidates(targetGrid, colors);\\n            if (candidates.isEmpty()) return false;\\n            for (ColorObj candidate : candidates) {\\n                colors.remove(candidate.c);\\n                removeColor(targetGrid, candidate);\\n            }\\n        }\\n        return true;\\n    }\\n    /** \\n     * Find all the color candidates at current grid which can be print in rectangle\\n     */\\n    private Set<ColorObj> findColorCandidates(int[][] grid, Set<Integer> colors){\\n        Map<Integer, ColorObj> map = new HashMap<>();\\n        // Find all the color status\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 0) continue; //0 present any number\\n                int c = grid[i][j];\\n                ColorObj colorObj = map.getOrDefault(c, new ColorObj(c));\\n                colorObj.left = Math.min(colorObj.left, j);\\n                colorObj.top = Math.min(colorObj.top, i);\\n                colorObj.right = Math.max(colorObj.right, j);\\n                colorObj.bottom = Math.max(colorObj.bottom, i);\\n                map.put(c, colorObj);\\n            }\\n        }\\n        // Verify if those color are in valid rectangle\\n        Set<ColorObj> candidates = new HashSet<>();\\n        for (ColorObj co : map.values()){\\n            if (isValidRect(grid, co)) {\\n                candidates.add(co);\\n            }\\n        }\\n        return candidates;\\n    }\\n    /**\\n     * Check if the rectangle contains only target color and 0\\n     */\\n    private boolean isValidRect(int[][] grid, ColorObj co){\\n        for (int i = co.top; i <= co.bottom; i++){\\n            for (int j = co.left;j <= co.right; j++) {\\n                if(grid[i][j] != 0 && grid[i][j] != co.c) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    /**\\n     * Remove target color from grid (set to 0)\\n     */\\n    private void removeColor(int[][] targetGrid, ColorObj co){\\n        for (int i = co.top; i <= co.bottom; i++) {\\n            for (int j = co.left; j <= co.right; j++) {\\n                targetGrid[i][j] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    class ColorObj {\\n        int c;\\n        int left = 60;\\n        int top = 60;\\n        int right = 0;\\n        int bottom = 0;\\n        public ColorObj(int c) {\\n            this.c = c;\\n        }\\n    }\\n    public boolean isPrintable(int[][] targetGrid) {\\n        Set<Integer> colors = new HashSet<>();\\n        for (int i=0; i<targetGrid.length; i++){\\n            for (int j=0; j<targetGrid[0].length; j++) {\\n                colors.add(targetGrid[i][j]);\\n            }\\n        }\\n        while (colors.size() > 1) {\\n            Set<ColorObj> candidates = findColorCandidates(targetGrid, colors);\\n            if (candidates.isEmpty()) return false;\\n            for (ColorObj candidate : candidates) {\\n                colors.remove(candidate.c);\\n                removeColor(targetGrid, candidate);\\n            }\\n        }\\n        return true;\\n    }\\n    /** \\n     * Find all the color candidates at current grid which can be print in rectangle\\n     */\\n    private Set<ColorObj> findColorCandidates(int[][] grid, Set<Integer> colors){\\n        Map<Integer, ColorObj> map = new HashMap<>();\\n        // Find all the color status\\n        for (int i = 0; i < grid.length; i++) {\\n            for (int j = 0; j < grid[0].length; j++) {\\n                if (grid[i][j] == 0) continue; //0 present any number\\n                int c = grid[i][j];\\n                ColorObj colorObj = map.getOrDefault(c, new ColorObj(c));\\n                colorObj.left = Math.min(colorObj.left, j);\\n                colorObj.top = Math.min(colorObj.top, i);\\n                colorObj.right = Math.max(colorObj.right, j);\\n                colorObj.bottom = Math.max(colorObj.bottom, i);\\n                map.put(c, colorObj);\\n            }\\n        }\\n        // Verify if those color are in valid rectangle\\n        Set<ColorObj> candidates = new HashSet<>();\\n        for (ColorObj co : map.values()){\\n            if (isValidRect(grid, co)) {\\n                candidates.add(co);\\n            }\\n        }\\n        return candidates;\\n    }\\n    /**\\n     * Check if the rectangle contains only target color and 0\\n     */\\n    private boolean isValidRect(int[][] grid, ColorObj co){\\n        for (int i = co.top; i <= co.bottom; i++){\\n            for (int j = co.left;j <= co.right; j++) {\\n                if(grid[i][j] != 0 && grid[i][j] != co.c) {\\n                    return false;\\n                }\\n            }\\n        }\\n        return true;\\n    }\\n    /**\\n     * Remove target color from grid (set to 0)\\n     */\\n    private void removeColor(int[][] targetGrid, ColorObj co){\\n        for (int i = co.top; i <= co.bottom; i++) {\\n            for (int j = co.left; j <= co.right; j++) {\\n                targetGrid[i][j] = 0;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855126,
                "title": "rust-translated-8ms-100",
                "content": "```rust\\nimpl Solution {\\n    pub fn is_printable(mut a: Vec<Vec<i32>>) -> bool {\\n        use std::collections::HashSet;\\n\\n        fn test(a: &mut Vec<Vec<i32>>, pos: &[(i32, i32, i32, i32)], c: i32) -> bool {\\n            for i in pos[c as usize].0..pos[c as usize].2 + 1 {\\n                for j in pos[c as usize].1..pos[c as usize].3 + 1 {\\n                    if a[i as usize][j as usize] > 0 && a[i as usize][j as usize] != c {\\n                        return false;\\n                    }\\n                }\\n            }\\n            for i in pos[c as usize].0..pos[c as usize].2 + 1 {\\n                for j in pos[c as usize].1..pos[c as usize].3 + 1 {\\n                    a[i as usize][j as usize] = 0;\\n                }\\n            }\\n            true\\n        }\\n\\n        let m = a.len();\\n        let n = a[0].len();\\n        let mut pos = vec![(m as i32, n as i32, 0, 0); 61];\\n        let mut colors = HashSet::<i32>::new();\\n        for i in 0..m {\\n            for j in 0..n {\\n                let c = a[i][j];\\n                colors.insert(c);\\n                pos[c as usize].0 = std::cmp::min(pos[c as usize].0, i as i32);\\n                pos[c as usize].1 = std::cmp::min(pos[c as usize].1, j as i32);\\n                pos[c as usize].2 = std::cmp::max(pos[c as usize].2, i as i32);\\n                pos[c as usize].3 = std::cmp::max(pos[c as usize].3, j as i32);\\n            }\\n        }\\n\\n        while !colors.is_empty() {\\n            let mut c2 = HashSet::<i32>::new();\\n            for &c in colors.iter() {\\n                if !test(&mut a, &pos, c) {\\n                    c2.insert(c);\\n                }\\n            }\\n            if c2.len() == colors.len() {\\n                return false;\\n            }\\n            colors = c2;\\n        }\\n        true\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_is_printable() {\\n        assert_eq!(\\n            Solution::is_printable(vec![\\n                vec![1, 1, 1, 1],\\n                vec![1, 2, 2, 1],\\n                vec![1, 2, 2, 1],\\n                vec![1, 1, 1, 1]\\n            ]),\\n            true\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_02() {\\n        assert_eq!(\\n            Solution::is_printable(vec![\\n                vec![1, 1, 1, 1],\\n                vec![1, 1, 3, 3],\\n                vec![1, 1, 3, 4],\\n                vec![5, 5, 1, 4]\\n            ]),\\n            true\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_03() {\\n        assert_eq!(\\n            Solution::is_printable(vec![vec![1, 2, 1], vec![2, 1, 2], vec![1, 2, 1]]),\\n            false\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_04() {\\n        assert_eq!(\\n            Solution::is_printable(vec![vec![1, 1, 1], vec![3, 1, 3]]),\\n            false\\n        );\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn is_printable(mut a: Vec<Vec<i32>>) -> bool {\\n        use std::collections::HashSet;\\n\\n        fn test(a: &mut Vec<Vec<i32>>, pos: &[(i32, i32, i32, i32)], c: i32) -> bool {\\n            for i in pos[c as usize].0..pos[c as usize].2 + 1 {\\n                for j in pos[c as usize].1..pos[c as usize].3 + 1 {\\n                    if a[i as usize][j as usize] > 0 && a[i as usize][j as usize] != c {\\n                        return false;\\n                    }\\n                }\\n            }\\n            for i in pos[c as usize].0..pos[c as usize].2 + 1 {\\n                for j in pos[c as usize].1..pos[c as usize].3 + 1 {\\n                    a[i as usize][j as usize] = 0;\\n                }\\n            }\\n            true\\n        }\\n\\n        let m = a.len();\\n        let n = a[0].len();\\n        let mut pos = vec![(m as i32, n as i32, 0, 0); 61];\\n        let mut colors = HashSet::<i32>::new();\\n        for i in 0..m {\\n            for j in 0..n {\\n                let c = a[i][j];\\n                colors.insert(c);\\n                pos[c as usize].0 = std::cmp::min(pos[c as usize].0, i as i32);\\n                pos[c as usize].1 = std::cmp::min(pos[c as usize].1, j as i32);\\n                pos[c as usize].2 = std::cmp::max(pos[c as usize].2, i as i32);\\n                pos[c as usize].3 = std::cmp::max(pos[c as usize].3, j as i32);\\n            }\\n        }\\n\\n        while !colors.is_empty() {\\n            let mut c2 = HashSet::<i32>::new();\\n            for &c in colors.iter() {\\n                if !test(&mut a, &pos, c) {\\n                    c2.insert(c);\\n                }\\n            }\\n            if c2.len() == colors.len() {\\n                return false;\\n            }\\n            colors = c2;\\n        }\\n        true\\n    }\\n}\\n\\n#[cfg(test)]\\nmod tests {\\n    use super::*;\\n\\n    #[test]\\n    fn test_is_printable() {\\n        assert_eq!(\\n            Solution::is_printable(vec![\\n                vec![1, 1, 1, 1],\\n                vec![1, 2, 2, 1],\\n                vec![1, 2, 2, 1],\\n                vec![1, 1, 1, 1]\\n            ]),\\n            true\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_02() {\\n        assert_eq!(\\n            Solution::is_printable(vec![\\n                vec![1, 1, 1, 1],\\n                vec![1, 1, 3, 3],\\n                vec![1, 1, 3, 4],\\n                vec![5, 5, 1, 4]\\n            ]),\\n            true\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_03() {\\n        assert_eq!(\\n            Solution::is_printable(vec![vec![1, 2, 1], vec![2, 1, 2], vec![1, 2, 1]]),\\n            false\\n        );\\n    }\\n\\n    #[test]\\n    fn test_is_printable_04() {\\n        assert_eq!(\\n            Solution::is_printable(vec![vec![1, 1, 1], vec![3, 1, 3]]),\\n            false\\n        );\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854828,
                "title": "javascript-all-pretty-commented",
                "content": "```\\n\\n// isPrintable returns true if every color in the grid could have been a valid rectangle\\nconst isPrintable = grid => {\\n\\n    // obtain info on each color\\n    const colors = new Map()\\n    grid.forEach( ( row, i ) => {\\n        row.forEach( ( color, j ) => {\\n\\n            let o = colors.get( color )\\n            if ( ! o ) {\\n                o = { left: Infinity, right: -Infinity, top: Infinity, bottom: -Infinity } \\n                colors.set( color, o )\\n            }\\n\\n            o.left   = Math.min( j, o.left )\\n            o.right  = Math.max( j, o.right )\\n            o.top    = Math.min( i, o.top )\\n            o.bottom = Math.max( i, o.bottom )\\n\\n        })\\n    })\\n\\n    // get every color key  this will serve to track which colors we need to validate\\n    const tofind = new Set([...colors.keys()])\\n    \\n    // a color is considered a rectangle if the cells of it\\'s 4 corners and inwards\\n    // contain only that color. Colors already validated could have been printed on top\\n\\t// so we\\'ll give those a pass too, and only break if it\\'s a color we\\'ve yet to find\\n    const isRectangle = ( color, { left, right, bottom, top } ) => {\\n\\n        for ( let i = top; i <= bottom; i++ ) {\\n            for ( let j = left; j <= right; j++ ) {\\n\\n                if ( grid[i][j] != color && tofind.has( grid[i][j] ) ) {\\n\\n                    return false\\n                    \\n                }\\n\\n            }\\n        }\\n        \\n        return true\\n\\n    }\\n\\n    // if a new rectangle is found that means it could uncover new, additional rectangles,\\n    // so keep looping while new rectangles are found\\n    let keepLooping = true\\n    while ( keepLooping ) {\\n\\n        keepLooping = false\\n        \\n        colors.forEach( ( info, color ) => {\\n\\n            if ( ! tofind.has( color ) ) return\\n\\n            if ( isRectangle( color, info ) ) {\\n                keepLooping = true\\n                \\n                tofind.delete( color )\\n            }\\n\\n        })\\n\\n    }\\n    \\n    return tofind.size === 0\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n// isPrintable returns true if every color in the grid could have been a valid rectangle\\nconst isPrintable = grid => {\\n\\n    // obtain info on each color\\n    const colors = new Map()\\n    grid.forEach( ( row, i ) => {\\n        row.forEach( ( color, j ) => {\\n\\n            let o = colors.get( color )\\n            if ( ! o ) {\\n                o = { left: Infinity, right: -Infinity, top: Infinity, bottom: -Infinity } \\n                colors.set( color, o )\\n            }\\n\\n            o.left   = Math.min( j, o.left )\\n            o.right  = Math.max( j, o.right )\\n            o.top    = Math.min( i, o.top )\\n            o.bottom = Math.max( i, o.bottom )\\n\\n        })\\n    })\\n\\n    // get every color key  this will serve to track which colors we need to validate\\n    const tofind = new Set([...colors.keys()])\\n    \\n    // a color is considered a rectangle if the cells of it\\'s 4 corners and inwards\\n    // contain only that color. Colors already validated could have been printed on top\\n\\t// so we\\'ll give those a pass too, and only break if it\\'s a color we\\'ve yet to find\\n    const isRectangle = ( color, { left, right, bottom, top } ) => {\\n\\n        for ( let i = top; i <= bottom; i++ ) {\\n            for ( let j = left; j <= right; j++ ) {\\n\\n                if ( grid[i][j] != color && tofind.has( grid[i][j] ) ) {\\n\\n                    return false\\n                    \\n                }\\n\\n            }\\n        }\\n        \\n        return true\\n\\n    }\\n\\n    // if a new rectangle is found that means it could uncover new, additional rectangles,\\n    // so keep looping while new rectangles are found\\n    let keepLooping = true\\n    while ( keepLooping ) {\\n\\n        keepLooping = false\\n        \\n        colors.forEach( ( info, color ) => {\\n\\n            if ( ! tofind.has( color ) ) return\\n\\n            if ( isRectangle( color, info ) ) {\\n                keepLooping = true\\n                \\n                tofind.delete( color )\\n            }\\n\\n        })\\n\\n    }\\n    \\n    return tofind.size === 0\\n}\\n\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1719213,
                "content": [
                    {
                        "username": "kkd14",
                        "content": "how to know whether this problem is related to graph?"
                    },
                    {
                        "username": "singhdurgesh",
                        "content": "[@Devin_Leamy](/Devin_Leamy) Yes. There we can use Topological Sort algorithm to solve problem."
                    },
                    {
                        "username": "Devin_Leamy",
                        "content": "If there some color \"A\" and within the bounds in which color \"A\" appears there is some other color \"B\", then \"A\" must be drawn before \"B\". Using this logic, you can view every color as having to be drawn before some set of other colors. You can then construct a dependency graph among the colors. Some colors need to be drawn before or after other colors and these relationships can be modelled with a graph."
                    }
                ]
            }
        ]
    },
    {
        "title": "Build Array from Permutation",
        "question_content": "<p>Given a <strong>zero-based permutation</strong> <code>nums</code> (<strong>0-indexed</strong>), build an array <code>ans</code> of the <strong>same length</strong> where <code>ans[i] = nums[nums[i]]</code> for each <code>0 &lt;= i &lt; nums.length</code> and return it.</p>\n\n<p>A <strong>zero-based permutation</strong> <code>nums</code> is an array of <strong>distinct</strong> integers from <code>0</code> to <code>nums.length - 1</code> (<strong>inclusive</strong>).</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [0,2,1,5,3,4]\n<strong>Output:</strong> [0,1,2,4,5,3]<strong>\nExplanation:</strong> The array ans is built as follows: \nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[0], nums[2], nums[1], nums[5], nums[3], nums[4]]\n    = [0,1,2,4,5,3]</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [5,0,1,2,3,4]\n<strong>Output:</strong> [4,5,0,1,2,3]\n<strong>Explanation:</strong> The array ans is built as follows:\nans = [nums[nums[0]], nums[nums[1]], nums[nums[2]], nums[nums[3]], nums[nums[4]], nums[nums[5]]]\n    = [nums[5], nums[0], nums[1], nums[2], nums[3], nums[4]]\n    = [4,5,0,1,2,3]</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>0 &lt;= nums[i] &lt; nums.length</code></li>\n\t<li>The elements in <code>nums</code> are <strong>distinct</strong>.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow-up:</strong> Can you solve it without using an extra space (i.e., <code>O(1)</code> memory)?</p>\n",
        "solutions": [
            {
                "id": 1315926,
                "title": "python-o-n-time-o-1-space-w-full-explanation",
                "content": "The intuition behind doing the problem in constant space is that we must process the original array:\\n1. in-place,\\n2. in a way that allows us to move the correct value (`nums[nums[i]`) to it\\'s correct place (`i`) \\n3. while also keeping the original value, (`nums[i]`), in-place, in some way so that we can use it when needed later. \\n\\nWe must keep `nums[i]` intact because if, for example, a later position in the array, say `j`, has a value `nums[j] = i`, but we\\'ve overwrote the value at `i` (`nums[i]`) with `nums[nums[i]]` already, then we\\'re out of luck.\\n\\nTo accomplish this task, we\\'re going to use the fact that if we have a number of the form `a = qb + r`, where `b` and `r` are *not* multiples of `q` and `r` < `q`, then we can extract `b` and `r` with the following:\\n- `b = a // q` (where `//` is integer division) - we know that `qb` when divided by `q` will give us `b`, however we still would need to get rid of the `r // q`. From our requirements though, `r < q`, so `r // q` will always be `0`, thus `b = (qb//q) + (r//q) = b + 0 = b`\\n- `r = a % q` - we know that `qb` is a multiple of `q`, thus is divided by it cleanly and we know that `r < q`, so `r` is not a multiple of `q`, therefore the remainder when dividing `a = qb + r` by `q` is just `r`\\n\\nWe need to find a way to transform every element of `nums` into the form `a = qb + r`. \\n\\nAt every `i`,  `nums[nums[i]]` is going to be our `b` and the original value, `nums[i]` is our `r`.  Now we just need a `q` that satisfies the `r < q`, for all the possible `r` values (all `nums[i]`). Luckily, we have such a `q` already, as our array values are ***indices*** into the same array. `q = len(nums)` is always guaranteed to be greater than all `nums[i]` because each index is always within the bounds of the array, from `0` to `len(nums) - 1`.\\n\\nThe rest is translation to code (purposely verbose):\\n```\\ndef buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  \\n  # turn the array into a=qb+r\\n  for i in range(len(nums)):\\n\\tr = nums[i]\\n\\t\\n\\t# retrieve correct value from potentially already processed element\\n\\t# i.e. get r from something maybe already in the form a = qb + r\\n\\t# if it isnt already processed (doesnt have qb yet), that\\'s ok b/c\\n\\t# r < q, so r % q will return the same value\\n\\tb = nums[nums[i]] % q\\n\\t\\n    # put it all together\\n\\tnums[i] = q*b + r\\n\\t\\n# extract just the final b values\\n  for i in range(len(nums)):\\n    nums[i] = nums[i] // q\\n  \\n  return nums\\n```\\nCondensed version:\\n```\\ndef buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  for i,c in enumerate(nums):\\n    nums[i] += q * (nums[c] % q)\\n  for i,_ in enumerate(nums):\\n    nums[i] //= q\\n  return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  \\n  # turn the array into a=qb+r\\n  for i in range(len(nums)):\\n\\tr = nums[i]\\n\\t\\n\\t# retrieve correct value from potentially already processed element\\n\\t# i.e. get r from something maybe already in the form a = qb + r\\n\\t# if it isnt already processed (doesnt have qb yet), that\\'s ok b/c\\n\\t# r < q, so r % q will return the same value\\n\\tb = nums[nums[i]] % q\\n\\t\\n    # put it all together\\n\\tnums[i] = q*b + r\\n\\t\\n# extract just the final b values\\n  for i in range(len(nums)):\\n    nums[i] = nums[i] // q\\n  \\n  return nums\\n```\n```\\ndef buildArray(nums: List[int]) -> List[int]:\\n  q = len(nums)\\n  for i,c in enumerate(nums):\\n    nums[i] += q * (nums[c] % q)\\n  for i,_ in enumerate(nums):\\n    nums[i] //= q\\n  return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1316500,
                "title": "java-solution-using-o-1-space-with-explanation",
                "content": "```\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        \\n        for(int i=0; i<n; i++){\\n            // this is done to keep both old and new value together. \\n            // going by the example of [5,0,1,2,3,4]\\n            // after this nums[0] will be 5 + 6*(4%6) = 5 + 24 = 29;\\n            // now for next index calulation we might need the original value of num[0] which can be obtain by num[0]%6 = 29%6 = 5;\\n            // if we want to get just he new value of num[0], we can get it by num[0]/6 = 29/6 = 4\\n            nums[i] = nums[i] + n*(nums[nums[i]] % n);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            nums[i] = nums[i]/n;\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        \\n        for(int i=0; i<n; i++){\\n            // this is done to keep both old and new value together. \\n            // going by the example of [5,0,1,2,3,4]\\n            // after this nums[0] will be 5 + 6*(4%6) = 5 + 24 = 29;\\n            // now for next index calulation we might need the original value of num[0] which can be obtain by num[0]%6 = 29%6 = 5;\\n            // if we want to get just he new value of num[0], we can get it by num[0]/6 = 29/6 = 4\\n            nums[i] = nums[i] + n*(nums[nums[i]] % n);\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            nums[i] = nums[i]/n;\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1315481,
                "title": "c-two-solutions-with-o-n-and-o-1-space-complexity-well-explained",
                "content": "Starting with the first approach which is quite easy. Simply use another vector/array and store the values of nums[nums[i]] in the new vector. \\nSpace Complexity: O(N)\\nTime Complexity: O(N)\\nHere is my code for the first approach:\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```\\nAfter thinking of this solution, I tried to find a solution with O(1) space complexity. For doing this I simply thought to store two values in one position, As the values in the input array are ranging from 0 to n-1 where n is length of array. I can simply store the input array value in modulo by n and modified value in divide by n. This solves my problem of adding extra space to my solution. All things are sorted out :)\\nFor example:\\ninput array: {1,0}\\nso I simple used this equation nums[i]+=n*(nums[nums[i]]%n)\\nIt made my array {1,2}, so after dividing by 2 it resulted in {0,1} which is the correct answer.\\nSpace Complexity: O(1)\\nTime Complexity: O(N).\\nHere is the code for second approach:\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            nums[i]=nums[i]+(n*(nums[nums[i]]%n));\\n        }\\n        for(int i=0;i<n;i++){\\n            nums[i]/=n;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int> ans(n);\\n        for(int i=0;i<n;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            nums[i]=nums[i]+(n*(nums[nums[i]]%n));\\n        }\\n        for(int i=0;i<n;i++){\\n            nums[i]/=n;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1315480,
                "title": "java-o-1-space-o-n-time",
                "content": "Firstly, the naive O(n) space solution practically appears in full in the problem statement, so having it be a part of a weekly contest is questionable. A simple solution would look something like this:\\n```\\npublic int[] buildArray(int[] nums) {\\n\\tint[] ans = new int[nums.length];\\n\\tfor(int i = 0; i < nums.length; i++)\\n\\t\\tans[i] = nums[nums[i]];\\n\\treturn ans;\\n}\\n```\\n\\nIn order to optimize the solution somewhat, and to meet the Follow-Up requirement for O(1) space complexity, we can rely on bit-shifting, something which is possible due to the low values in `nums`. My solution is as follows:\\n\\n```\\npublic int[] buildArray(int[] nums) {\\n\\tint mask = 1023; // Decimal value of the binary number \\'1111111111\\'\\n\\tfor(int i = 0; i < nums.length; i++)\\n\\t\\tnums[i] |= (nums[nums[i]] & mask) << 10;\\n\\tfor(int i = 0; i < nums.length; i++)\\n\\t\\tnums[i] = nums[i] >> 10;\\n\\treturn nums;\\n}\\n```\\n\\n**EDIT:** Here\\'s an image I made to somewhat illustrate the process:\\n![image](https://assets.leetcode.com/users/images/a44e1990-651b-48ab-b130-4bd74f2bd403_1626099830.2351632.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] buildArray(int[] nums) {\\n\\tint[] ans = new int[nums.length];\\n\\tfor(int i = 0; i < nums.length; i++)\\n\\t\\tans[i] = nums[nums[i]];\\n\\treturn ans;\\n}\\n```\n```\\npublic int[] buildArray(int[] nums) {\\n\\tint mask = 1023; // Decimal value of the binary number \\'1111111111\\'\\n\\tfor(int i = 0; i < nums.length; i++)\\n\\t\\tnums[i] |= (nums[nums[i]] & mask) << 10;\\n\\tfor(int i = 0; i < nums.length; i++)\\n\\t\\tnums[i] = nums[i] >> 10;\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1452892,
                "title": "c-and-pseudo-code-o-n-time-and-o-1-space-solution-with-explanation",
                "content": "Method-1 would be to make a new vector and just store nums[nums[i]] in it.\\n\\nMethod-2\\n\\nThe idea is to store two numbers (nums[i] and nums[nums[i]]) at the same location.\\n\\nThe important point to be noted is that all numbers in the array are less than size of the array.\\n\\nExample - Lets say we have two numbers in the array a = 3 , b = 2 and the size of the array is n = 5\\n\\nWe can store both 3 and 2 in a as follows:-\\n\\na = a + b * n\\n\\nTo get initial value of a we do a%n\\nTo get the value of b we do a/n\\n\\na = a + b * n = 3 + 2*5 = 13\\n\\na % n = 13 % 5 = 3\\n\\na / n = 13 / 5\\t= 2\\n\\nSo we will use this technique to store two numbers in one location.\\n\\nWhy is it important that all numbers must be less than size of the array ?\\n\\nIts because when we do\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = nums[i] + n*(nums[nums[i]]);\\n        }\\n\\t\\t\\nThere may be cases when we have lost the value of nums[i] as it has already been replaced by nums[nums[i]].\\nSo in such cases we need to get the previous values of nums[i] or a\\nThis is done by finding nums[nums[i]] % n\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = nums[i] + n*(nums[nums[i]]%n);\\n        }\\n\\nOnce we have stored two numbers in each location we can simply divide each number by n to get the desired output.\\n\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> buildArray(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnums[i] = nums[i] + n*(nums[nums[i]]%n);\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnums[i] = nums[i]/n;\\n\\t\\t\\t}\\n\\t\\t\\treturn nums;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> buildArray(vector<int>& nums) \\n\\t\\t{\\n\\t\\t\\tint n = nums.size();\\n\\n\\t\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tnums[i] = nums[i] + n*(nums[nums[i]]%n);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1419134,
                "title": "interview-approach-o-1-space",
                "content": "**O(1) approach**\\n\\t\\t  \\n\\t\\t  I am just explaining O(1) space complexity approach and it can be implemented using any language. i am also sharing the c++ code.\\n\\nlet  a = nums[i] and b= nums[nums[i]]\\nlet nums=[0,2,1,5,3,4]\\nif a = nums[3] = 5 then b = nums[nums[3]] = nums[5] = 4\\na+n*b = 5 + 6*4 = 29\\n29%n = 29 % 6 = 5 = a;   so formula for a = (a+nb)%n \\n29/n = 29/6 = 4 = b ; so formula for b = (a+nb)/n\\n\\nso in the first step we will be calculating a+nb for each index and replacing element at this value by the obtained result.\\ni.e,\\n```\\nfor(int i=0;i<n;i++)\\n {\\n    nums[i] = nums[i]+(n*(nums[nums[i]]%n));   \\n // here %n is taken to compensate the changes happened in previous iteration and get exat value of b;\\n }\\n```\\n In the next step we just have to replace value at each index by num[i]/n to get b which is equal to nums[nums[i]] ;\\n i.e,\\n ```\\n for(int i=0;i<n;i++)\\n   {\\n            nums[i]/=n;\\n    }\\n```\\nnums is the vector to be returned;\\n\\t\\t\\n**FULL CODE**\\n```\\n vector<int> buildArray(vector<int>& nums) \\n    {\\n   \\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = nums[i]+(n*(nums[nums[i]]%n));\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]/=n;\\n        }\\n        return nums;\\n    }\\n\\t\\n\\t//please upvote if you guys find it useful.\\n```\\n![up.png](https://assets.leetcode.com/users/images/079d4486-0493-414f-894e-d1cf61d31cdf_1679080274.5652993.png)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Array"
                ],
                "code": "```\\nfor(int i=0;i<n;i++)\\n {\\n    nums[i] = nums[i]+(n*(nums[nums[i]]%n));   \\n // here %n is taken to compensate the changes happened in previous iteration and get exat value of b;\\n }\\n```\n```\\n for(int i=0;i<n;i++)\\n   {\\n            nums[i]/=n;\\n    }\\n```\n```\\n vector<int> buildArray(vector<int>& nums) \\n    {\\n   \\n        int n = nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = nums[i]+(n*(nums[nums[i]]%n));\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]/=n;\\n        }\\n        return nums;\\n    }\\n\\t\\n\\t//please upvote if you guys find it useful.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1692310,
                "title": "easy-explanation-for-o-1-space-complexity",
                "content": "**Explanation for O(1) space complexity**\\n\\n*Lets first see generally what should be done.*\\n\\n**1.**  We need to store 2 values in one place, so we will use math (quotient and remainder)\\n\\t   \\n\\n**2.** Let, size of array = **n**\\n       original number = **a**\\n       final number = **b**\\n\\t   \\n**3.**  So we will store **a = a + n*b**\\n\\n**4.**   On taking **a%n**, we will get **a**\\n      On doing **a/n**, we will get **b**\\n\\t  \\n**5.**  Here the **b** that we are using is actually an **a** and there is a chance that it might be an **a** that is updated (final number)\\n      To get **a** from **a**, we use **a%n**\\n       So, here it will be **b%n**\\n       \\n  **6.** Finally, our equation becomes **a=a +n(b%n)**\\n       \\n   **7.**  In the question **a=nums[i] and b=nums[nums[i]]**\\n   \\n  **8.** So finally, the equation becomes\\n       **nums[i] = nums[i] + n * (nums[nums[i]]%n)**\\n\\n***\\n**Update 1 (Intuition):**\\nIn the question, it\\'s given that `nums[i]` is always less than the length of nums. So, we take a number bigger than our numbers in the array. Here, we took it to be **nums.length()**.\\nWe are updating our number in such a way that on taking `nums[i] % n` will return the original number and `nums[i]/n` will give the new number. \\nSince we are adding` n*(new number)` to our original number, then `nums[i] % n` will be the previous number because the remainder will be the same.\\nEx: let `n=7`, `nums[i] = 3`, `new number = 5`.\\nSo, initially, `nums[i] = original number % n` => `3%7 =3`\\nNow, lets update to get the new value. `nums[i] = nums[i] + n * new number` => `nums[i] = 3 + 7*5 = 38`\\nTo get original number: `nums[i]%n` => `38%7 = 3`\\nTo get the new number: `nums[i]/n` => `38/7 = 5`\\n***\\n**Update 2 (Summary):**\\t  \\nAs we proceed through the loop, we are updating the value of `nums[i]`\\nIn `b`, we are storing the value of `nums[nums[i]]` (the original value, not the updated one)\\nFor example, **we updated nums[i] for i=0,1,2** and at 3, `let nums[3] =0` .\\nHere, we need to store two values, `a=nums[3]` and `b=nums[nums[3]] = nums[0]`\\nSo, *we need to store the value of nums[0] in b* .\\nCurrently, **the value of nums[0] is updated one** and we need to store the original value.\\nTo get the `original value from nums[i]`, we do `nums[i] % n`, which we will store in b. (see point 4)\\nSo, `nums[nums[3]] % n` = `nums[0] % n` = `original value of nums[0]`\\n(if we did not use %n here, then it would have given ( `nums[0] = nums[0] + n*(something)`) , coz it was updated by the loop for i=0 .  \\n \\n***\\t   \\n\\n*Here is the C++ solution for the same:*\\n\\t   \\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            nums[i] = nums[i] + n * (nums[nums[i]]%n);\\n                \\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            nums[i]/=n;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n        \\n        int n=nums.size();\\n        \\n        for(int i=0;i<n;++i){\\n            \\n            nums[i] = nums[i] + n * (nums[nums[i]]%n);\\n                \\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            nums[i]/=n;\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540424,
                "title": "python-one-line-simple-solution",
                "content": "**Python :**\\n\\n```\\ndef buildArray(self, nums: List[int]) -> List[int]:\\n\\treturn [nums[i] for i in nums]\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef buildArray(self, nums: List[int]) -> List[int]:\\n\\treturn [nums[i] for i in nums]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3197611,
                "title": "simple-java-runtime-0-ms-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n\\n    //using recursion\\n    public int[] buildArray(int[] nums) {\\n        aPermutation(nums,0);\\n\\n        return nums;\\n    }\\n    \\n    void aPermutation(int[] nums,int start){\\n        if(start<nums.length){\\n        int temp=nums[start];\\n        int result=nums[temp];\\n        aPermutation(nums,start+1);\\n        nums[start]=result;\\n    }\\n  \\n    }\\n}\\n```\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/e1bdd2bd-15b4-43a1-826f-22a251908f27_1676643810.4288354.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n\\n    //using recursion\\n    public int[] buildArray(int[] nums) {\\n        aPermutation(nums,0);\\n\\n        return nums;\\n    }\\n    \\n    void aPermutation(int[] nums,int start){\\n        if(start<nums.length){\\n        int temp=nums[start];\\n        int result=nums[temp];\\n        aPermutation(nums,start+1);\\n        nums[start]=result;\\n    }\\n  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362485,
                "title": "javascript-easy-solution",
                "content": "```\\nvar buildArray = function(nums) {\\n    return nums.map(a=>nums[a]);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buildArray = function(nums) {\\n    return nums.map(a=>nums[a]);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1606435,
                "title": "c-easy-solution",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        int n= nums.size();\\n        \\n        for(int i=0; i<n; i++)\\n            ans.push_back(nums[nums[i]]);\\n        \\n        return ans;\\n    }\\n};\\n```\\n---\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        int n= nums.size();\\n        \\n        for(int i=0; i<n; i++)\\n            ans.push_back(nums[nums[i]]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843832,
                "title": "c-o-1-solution-with-detailed-explanation",
                "content": "The obvious solution to the problem is to create a separate array and store the solution value there and then return in like below\\n\\n```\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// store solution value in new array\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans.push_back(nums[nums[i]]);\\n        }\\n        \\n\\t\\t// return solution array\\n        return ans;\\n    }\\n```\\n\\n--- \\n\\n\\nHowever, the tricky part comes when you want to solve the problem in O(1) space. The solution is to play around with the numbers and store 2 numbers in the same value using MATHS! :) \\n\\n**Primer:**\\nWhen you have 2 values, `x` and `y`, you can store them in the same value using `combinedValue = x + y * n` given than `n` is sufficiently bigger than both `x` and `y`\\nYou can then retrieve `x` by using `x = combined % n` and retrieve `y` using `y = combined / n`. \\n\\n**Example:**\\n`x` = 3; `y` = 4, `n` = 5. \\n`combined = 3 + 4 * 5 = 3 + 20 = 23`\\n`x = 23 % 5 = 3`\\n`y = 23 / 5 = 4 (make sure to use the lower_bound value here)`\\n\\n\\nUsing this knowledge, we can solve the problem by:\\n* storing both the original value and the solution value in one number\\n* then in another iteration, replace the value with the solution value\\n* return adjusted array\\n\\n**Code:**\\n```\\n    vector<int> buildArray(vector<int>& nums) {\\n        // store size in int since we\\'ll use it quite a bit here\\n        int n = nums.size();\\n        \\n        // \\'store\\' both the solution and original value in the same number\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// combined = originalValue + solution * size of array\\n\\t\\t\\t\\n\\t\\t\\t// the reason the solution here is (nums[nums[i]] % n) is to make sure we are only\\n\\t\\t\\t// accessing and using the original value at index \\'i\\' for the calculation in case nums[i] has already been modified\\n            nums[i] = nums[i] + (nums[nums[i]] % n) * n;\\n        }\\n                \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// solution value = combined value / n\\n            nums[i] = nums[i] / n;\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n\\t\\t\\n\\t\\t// store solution value in new array\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans.push_back(nums[nums[i]]);\\n        }\\n        \\n\\t\\t// return solution array\\n        return ans;\\n    }\\n```\n```\\n    vector<int> buildArray(vector<int>& nums) {\\n        // store size in int since we\\'ll use it quite a bit here\\n        int n = nums.size();\\n        \\n        // \\'store\\' both the solution and original value in the same number\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// combined = originalValue + solution * size of array\\n\\t\\t\\t\\n\\t\\t\\t// the reason the solution here is (nums[nums[i]] % n) is to make sure we are only\\n\\t\\t\\t// accessing and using the original value at index \\'i\\' for the calculation in case nums[i] has already been modified\\n            nums[i] = nums[i] + (nums[nums[i]] % n) * n;\\n        }\\n                \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// solution value = combined value / n\\n            nums[i] = nums[i] / n;\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3356502,
                "title": "best-c-beats-99-3-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Simple Iteration and pushing `nums[nums[i]]` value in new result array.\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n`Upvote! it just takes 1 click :)`\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> result;\\n        for (int i=0;i<nums.size();i++){\\n            result.push_back(nums[nums[i]]);\\n        }\\n        return result;\\n    }\\n};\\n```\\n![Upvote.jpeg](https://assets.leetcode.com/users/images/21e235fb-f1cf-4dda-8107-c1161904af2b_1680110707.309722.jpeg)",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> result;\\n        for (int i=0;i<nums.size();i++){\\n            result.push_back(nums[nums[i]]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314878,
                "title": "c-easy-o-1-space",
                "content": "vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=nums[i]+(n*(nums[nums[i]]%n));\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]/=n;\\n        }\\n        return nums;\\n    }",
                "solutionTags": [],
                "code": "vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]=nums[i]+(n*(nums[nums[i]]%n));\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i]/=n;\\n        }\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1314463,
                "title": "1920-map-each-element-e-to-a-e-return-resulting-array",
                "content": "---\\n\\nTook 1 minute to solve, but reading the quetion took 2 minutes :)\\n\\n---\\n\\n- Code from contest - `forEach` - Time to solve ` 0:03:01`\\n- Code from practice 0 - `forEach` - simpler\\n- Code from practice 1 - `map` 2 liner\\n- Code from practice 2 - `map` 1 liner\\n- Code from practice 3 - `map` 2 liner - simpler\\n- Code from practice 4 - `map` 1 liner - simpler\\n\\nHope it is simple to understand.\\n\\n---\\n\\n**Code from contest**\\n\\n```\\nvar buildArray = function(A) {\\n    let B = [];\\n    A.forEach((_, i) => {\\n        B.push(A[A[i]])\\n    });\\n    return B;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/86845cba-625d-4762-85a5-3b3e19091b64_1625372115.5267096.png)\\n\\n---\\n\\n**Code from practice 0**\\n\\n```\\nvar buildArray = function(A) {\\n    let B = [];\\n    A.forEach((e) => {\\n        B.push(A[e])\\n    });\\n    return B;\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/829d19af-2ed2-4c24-bd4a-ab98fbdb016c_1625372789.9337082.png)\\n\\n\\n---\\n\\n**Code from practice 1**\\n\\n```\\nvar buildArray = function(A) {\\n    return A.map((_, i) => A[A[i]]);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4dbbb3c0-a610-49ce-ba40-1e053be6170f_1625372161.8811586.png)\\n\\n---\\n\\n```\\nvar buildArray = (A) => A.map((_, i) => A[A[i]]);\\n```\\n\\n**Code from practice 2**\\n\\n![image](https://assets.leetcode.com/users/images/6ce55a44-444d-4cf5-ab25-d9e30f36a887_1625372182.6039195.png)\\n\\n---\\n\\n**Code from practice 3**\\n\\n```\\nvar buildArray = function(A) {\\n    return A.map((e) => A[e]);\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/04234f87-c1a7-42e2-ab8c-ce6a2d7bf373_1625372677.519041.png)\\n\\n---\\n\\n**Code from practice 4**\\n\\n```\\nvar buildArray = (A) => A.map((e) => A[e]);\\n```\\n\\n![image](https://assets.leetcode.com/users/images/8bfac739-b245-4670-ae8f-5ca5afef0c51_1625372712.491754.png)\\n\\n---\\n\\n```\\nvar buildArray = function (nums) {\\n    return nums\\n               .map((x) => nums[x]);\\n};\\n```\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buildArray = function(A) {\\n    let B = [];\\n    A.forEach((_, i) => {\\n        B.push(A[A[i]])\\n    });\\n    return B;\\n};\\n```\n```\\nvar buildArray = function(A) {\\n    let B = [];\\n    A.forEach((e) => {\\n        B.push(A[e])\\n    });\\n    return B;\\n};\\n```\n```\\nvar buildArray = function(A) {\\n    return A.map((_, i) => A[A[i]]);\\n};\\n```\n```\\nvar buildArray = (A) => A.map((_, i) => A[A[i]]);\\n```\n```\\nvar buildArray = function(A) {\\n    return A.map((e) => A[e]);\\n};\\n```\n```\\nvar buildArray = (A) => A.map((e) => A[e]);\\n```\n```\\nvar buildArray = function (nums) {\\n    return nums\\n               .map((x) => nums[x]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2499444,
                "title": "java-soln-without-using-extra-space",
                "content": "```\\n    public int[] buildArray(int[] arr) {\\n        int n=arr.length;\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i]=(arr[arr[i]]%n)*n + arr[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i]/=n;\\n        }\\n        \\n        return arr;\\n    }\\n\\t\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public int[] buildArray(int[] arr) {\\n        int n=arr.length;\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i]=(arr[arr[i]]%n)*n + arr[i];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            arr[i]/=n;\\n        }\\n        \\n        return arr;\\n    }\\n\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1541665,
                "title": "java-without-extra-space-detailed-explanation",
                "content": "```\\npublic int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            nums[i] = nums[i] + n *(nums[nums[i]] % n);\\n        }\\n        for(int i=0;i<n;i++){\\n            nums[i] = nums[i]/n;\\n        }\\n        return nums;\\n    }\\n\\t```\\n\\t\\n\\tTo achieve O(1) space complexicity ,we need to store two values  i.e. nums[i]  and nums[nums[i]]  in the same spot .\\n\\twe can do this by \\n\\tnums[i] = nums[i] + n *(nums[nums[i]] % n);\\n\\t\\n\\tIn this both values i.e. nums[i]  and nums[nums[i]]   are being stored \\n\\tFor eg. \\n\\t\\n\\tinput = [0,2,1,5,3,4]\\n\\tOutput: [0,1,2,4,5,3]\\n\\t\\n\\there, let i=3,\\n\\tthen nums[3] = 5;\\n\\tand   nums[nums[3]] = 4;\\n\\t\\n\\tNow we store both of them in nums[i] itself by\\n\\tnums[i] = nums[i] + n *(nums[nums[i]] % n); //Equation  1\\n\\t\\n\\tnums[3] = 5 + 6 *(4 %6);\\n\\tnums[3] = 29\\n\\tNow in Second loop we Can retrieve nums[nums[i]] by dividing by n,\\n\\tnums[i] = nums[i] + n *(nums[nums[i]] % n)  /  n;\\n\\tnums[i] = 0 + nums[nums[i]];\\n\\tnums[i]= nums[nums[i];\\n\\t\\n\\tnums[3]/n = 29/6 =4;\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t\\n\\t",
                "solutionTags": [],
                "code": "```\\npublic int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        for(int i=0;i<n;i++){\\n            nums[i] = nums[i] + n *(nums[nums[i]] % n);\\n        }\\n        for(int i=0;i<n;i++){\\n            nums[i] = nums[i]/n;\\n        }\\n        return nums;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1629622,
                "title": "c-o-1-space-easy",
                "content": "The main idea here is to, try to store the value of nums[i] and nums[nums[i]] at the same index.\\nSay n = nums.length,\\nGiven, nums[i] < n,  i.e. the numbers are in a specific range. So we can use this to do the same.\\nAt each nums[i], we add the value n * nums[nums[i]].\\nFrom which we can get both i.e. \\n*  nums[i] by taking modulo(%) by n and \\n*  ans[i] by division(/) by n.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; ++i)\\n        {\\n            nums[i] = nums[i] + (nums[nums[i]] % n) * n;\\n        }\\n        for(int i=0; i<n; ++i)\\n        {\\n            nums[i] = nums[i] / n;\\n        }\\n        return nums;\\n    }\\n};\\n```\\n* Time Complexity: O (n)\\n* Space Complexity: O(1)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        for(int i=0; i<n; ++i)\\n        {\\n            nums[i] = nums[i] + (nums[nums[i]] % n) * n;\\n        }\\n        for(int i=0; i<n; ++i)\\n        {\\n            nums[i] = nums[i] / n;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314345,
                "title": "python3-1-line",
                "content": "\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[nums[i]] for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[nums[i]] for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839928,
                "title": "java-o-1-space-o-n-easy-technique-with-explanation-1ms",
                "content": "using technique to store two values at same index\\nExample - Lets say we have two numbers in the array a = 1 , b = 3 and the size of the array is n = 5\\nWe can store both in a as :-\\na = a + b * n\\nTo get initial value of a we do a%n\\nTo get the value of b we do a/n\\na = a + b * n = 1 + 3*5 = 16\\na % n = 16 % 5 = 1\\na / n = 16 / 5 = 3\\n\\n\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n            nums[i] = nums[i] + n*(nums[nums[i]]%n);\\n        for(int i=0;i<n;i++)\\n\\t\\t\\tnums[i] = nums[i]/n;\\n\\t\\t\\n\\t\\treturn nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n=nums.length;\\n        for(int i=0;i<n;i++)\\n            nums[i] = nums[i] + n*(nums[nums[i]]%n);\\n        for(int i=0;i<n;i++)\\n\\t\\t\\tnums[i] = nums[i]/n;\\n\\t\\t\\n\\t\\treturn nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1669496,
                "title": "java-simple-1-liner",
                "content": "**Method 1:** With extra space\\n>**T/S:** O(n)/O(n)\\n```\\npublic int[] buildArray(int[] nums) {\\n\\tvar ans = new int[nums.length];\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\tans[i] = nums[nums[i]];\\n\\treturn ans;\\n}\\n```\\n\\n**1 liner variation of method 1**\\n```\\npublic int[] buildArray(int[] nums) {\\n\\treturn Arrays.stream(nums)\\n\\t\\t\\t\\t .map(num -> nums[num])\\n\\t\\t\\t\\t .toArray();\\n}\\n```\\n\\n**Method 2:** Without extra space. Store 2 numbers in 1 index using the formulat `a + b * n`, where and b are the 2 numbers to be stored and n = size(nums)\\n>**T/S:** O(n)/O(1)\\n```\\npublic int[] buildArray(int[] nums) {\\n\\tvar n = nums.length;\\n\\t\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tnums[i] += n * (nums[nums[i]] % n);\\n\\t\\t\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tnums[i] /= n;\\n\\t\\t\\n\\treturn nums;\\n}\\n```\\n\\n**3 liner variation of method 1**\\n```\\npublic int[] buildArray(int[] nums) {\\n\\tIntStream.range(0, nums.length)\\n\\t\\t\\t .forEach(i -> nums[i] += nums.length * (nums[nums[i]] % nums.length));\\n\\tIntStream.range(0, nums.length)\\n\\t\\t\\t .forEach(i -> nums[i] /= nums.length);\\n\\treturn nums;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] buildArray(int[] nums) {\\n\\tvar ans = new int[nums.length];\\n\\tfor (var i = 0; i < nums.length; i++)\\n\\t\\tans[i] = nums[nums[i]];\\n\\treturn ans;\\n}\\n```\n```\\npublic int[] buildArray(int[] nums) {\\n\\treturn Arrays.stream(nums)\\n\\t\\t\\t\\t .map(num -> nums[num])\\n\\t\\t\\t\\t .toArray();\\n}\\n```\n```\\npublic int[] buildArray(int[] nums) {\\n\\tvar n = nums.length;\\n\\t\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tnums[i] += n * (nums[nums[i]] % n);\\n\\t\\t\\n\\tfor (var i = 0; i < n; i++)\\n\\t\\tnums[i] /= n;\\n\\t\\t\\n\\treturn nums;\\n}\\n```\n```\\npublic int[] buildArray(int[] nums) {\\n\\tIntStream.range(0, nums.length)\\n\\t\\t\\t .forEach(i -> nums[i] += nums.length * (nums[nums[i]] % nums.length));\\n\\tIntStream.range(0, nums.length)\\n\\t\\t\\t .forEach(i -> nums[i] /= nums.length);\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1317383,
                "title": "rust-solutions",
                "content": "Thanks for ideas to @vishnuSReddy [solution](https://leetcode.com/problems/build-array-from-permutation/discuss/1315705/Python-and-C%2B%2B-Solution-for-both-O(n)-and-O(1)-space-complexity) and @EOAndersson [solution](https://leetcode.com/problems/build-array-from-permutation/discuss/1314616/Java-streams-one-line.-What\\'s-the-point-of-this-question/997757) in comments.\\n\\n1. Simple one-liner. Memory - O(N). Runtime - 4ms\\n```\\nimpl Solution {\\n    pub fn build_array(nums: Vec<i32>) -> Vec<i32> {\\n        (0..nums.len()).map(|i| nums[nums[i] as usize]).collect()\\n    }\\n}\\n```\\n2. Solution with modulo (store two values in one element). Memory - O(1). Runtime - 4ms\\n```\\nimpl Solution {\\n    pub fn build_array(mut nums: Vec<i32>) -> Vec<i32> {\\n        let l = nums.len() as i32;\\n        (0..l as usize).for_each(|i| nums[i] += (nums[nums[i] as usize] % l) * l);\\n        (0..l as usize).for_each(|i| nums[i] /= l);\\n        nums\\n    }\\n}\\n```\\n3. Fast solution with bit operations (same idea like previous with modulo but with bit-shifting and mask). Memory - O(1). Runtime - 0ms\\n```\\nimpl Solution {\\n    pub fn build_array(mut nums: Vec<i32>) -> Vec<i32> {\\n        let mask = 1023;\\n        (0..nums.len()).for_each(|i| nums[i] |= (nums[nums[i] as usize] & mask) << 10);\\n        (0..nums.len()).for_each(|i| nums[i] >>= 10);\\n        nums\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn build_array(nums: Vec<i32>) -> Vec<i32> {\\n        (0..nums.len()).map(|i| nums[nums[i] as usize]).collect()\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn build_array(mut nums: Vec<i32>) -> Vec<i32> {\\n        let l = nums.len() as i32;\\n        (0..l as usize).for_each(|i| nums[i] += (nums[nums[i] as usize] % l) * l);\\n        (0..l as usize).for_each(|i| nums[i] /= l);\\n        nums\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn build_array(mut nums: Vec<i32>) -> Vec<i32> {\\n        let mask = 1023;\\n        (0..nums.len()).for_each(|i| nums[i] |= (nums[nums[i] as usize] & mask) << 10);\\n        (0..nums.len()).for_each(|i| nums[i] >>= 10);\\n        nums\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1403264,
                "title": "cpp-o-1-space",
                "content": "O(1) space\\nO(n) time\\n\\ncrazy math ahead lol\\n\\n1.we can store 2 numbers using property of modulo `x=a+(b%n)*n`\\n2. to get a: `a=x%n`\\n3. to get b: `b=x/n`\\n4. n can be any number that is greater than or equal to a and b\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i]=nums[i]+(nums[nums[i]]%1000)*1000;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i]=nums[i]/1000;\\n        }\\n      return nums;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) \\n    {\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i]=nums[i]+(nums[nums[i]]%1000)*1000;\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i]=nums[i]/1000;\\n        }\\n      return nums;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314616,
                "title": "java-streams-one-line-what-s-the-point-of-this-question",
                "content": "```java\\npublic int[] buildArray(int[] a) {\\n    return Arrays.stream(a).map(n -> a[n]).toArray();\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int[] buildArray(int[] a) {\\n    return Arrays.stream(a).map(n -> a[n]).toArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314340,
                "title": "python-one-line",
                "content": "``` python\\nreturn [nums[num] for num in nums]\\n```",
                "solutionTags": [],
                "code": "``` python\\nreturn [nums[num] for num in nums]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3630609,
                "title": "best-solution-java-in-runtime-1ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n         int[] output = new int [nums.length];\\n        \\n            for (int i = 0; i <= nums.length - 1; i++) \\n            {\\n                output[i] = nums[nums[i]];\\n            }\\n        \\n           return output; \\n    }\\n}\\n```\\n\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/2bfebb09-3d9c-4f53-b30d-de2685a24e58_1686605521.0244744.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n         int[] output = new int [nums.length];\\n        \\n            for (int i = 0; i <= nums.length - 1; i++) \\n            {\\n                output[i] = nums[nums[i]];\\n            }\\n        \\n           return output; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336882,
                "title": "permutation-simple-solution-less-space-consumption",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        \\n        for(int i = 0; i < ans.length; i++){\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n,,,\\n\\nPlease upvote me, that encourages me alot!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        \\n        for(int i = 0; i < ans.length; i++){\\n            ans[i] = nums[nums[i]];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3324926,
                "title": "the-easiest-solution-ever-5-line-code-java",
                "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            al.add(nums[nums[i]]);\\n        }\\n       int []res= al.stream().mapToInt(i->i).toArray();\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        ArrayList<Integer> al=new ArrayList<>();\\n        for(int i=0;i<nums.length;i++){\\n            al.add(nums[nums[i]]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3005155,
                "title": "python3-based-solution-with-space-complexity-o-1",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        val = 0\\n        for i in range(0, n):\\n            nums[i] = n * ( nums[nums[i]] % n) + nums[i]\\n        for i in range(0,n):\\n            nums[i] = nums[i] // n\\n        return nums\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        val = 0\\n        for i in range(0, n):\\n            nums[i] = n * ( nums[nums[i]] % n) + nums[i]\\n        for i in range(0,n):\\n            nums[i] = nums[i] // n\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388649,
                "title": "java-1-ms-99-99-faster",
                "content": "![image](https://assets.leetcode.com/users/images/ef3f0952-984b-4154-b066-028f038a3548_1628326254.1526277.png)\\n\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n      int size=nums.length;\\n        for(int i=0;i<nums.length;i++)\\n            nums[i]+=(nums[nums[i]]%size)*size;\\n        for(int i=0;i<nums.length;i++)\\n            nums[i]/=size;\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n      int size=nums.length;\\n        for(int i=0;i<nums.length;i++)\\n            nums[i]+=(nums[nums[i]]%size)*size;\\n        for(int i=0;i<nums.length;i++)\\n            nums[i]/=size;\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1316619,
                "title": "python3-o-n-time-o-1-space-using-fast-slow-pointer-method-from-leetcode-287",
                "content": "**Prerequisite:**\\n[LeetCode 287](https://leetcode.com/problems/find-the-duplicate-number)\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] <= 0:\\n                continue\\n            slow = i\\n            fast = i\\n            cnt = 1\\n            while nums[slow] != nums[nums[fast]]:\\n                slow = nums[slow]\\n                fast = nums[nums[fast]]\\n                cnt += 1\\n            it = i\\n            last = nums[it]\\n            for _ in range(cnt - 1):\\n                temp = nums[it]\\n                nums[it] = -nums[nums[it]]\\n                it = temp\\n            nums[it] = -last\\n        for i in range(n):\\n            nums[i] = -nums[i]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        n = len(nums)\\n        for i in range(n):\\n            if nums[i] <= 0:\\n                continue\\n            slow = i\\n            fast = i\\n            cnt = 1\\n            while nums[slow] != nums[nums[fast]]:\\n                slow = nums[slow]\\n                fast = nums[nums[fast]]\\n                cnt += 1\\n            it = i\\n            last = nums[it]\\n            for _ in range(cnt - 1):\\n                temp = nums[it]\\n                nums[it] = -nums[nums[it]]\\n                it = temp\\n            nums[it] = -last\\n        for i in range(n):\\n            nums[i] = -nums[i]\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3818378,
                "title": "python3-one-line-faster-than-100",
                "content": "\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[i] for i in nums]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[i] for i in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3343515,
                "title": "one-line-solution-fast-and-good-for-memory-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Map\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar buildArray = function(nums) {\\n  return nums.map(num => nums[num]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar buildArray = function(nums) {\\n  return nums.map(num => nums[num]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2965129,
                "title": "c-solution-o-1-memory",
                "content": "# Intuition\\nThe idea is to find a solution where you can store the values of `nums[i]` and `nums[nums[i]]` at the same index using math. Given that `nums[i] < n`, i.e. the numbers are in a specific range, at each `nums[i]`, we add the value `n * nums[nums[i]]`, from which we can get both:\\n\\n- `nums[i]` by taking _modulo_ `%` by `n`, and\\n- `nums[i]` by _division_ `/` by `n`.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$, traversing the two `for` loop onces.\\n\\n- Space complexity:\\n$$O(1)$$, no need to allocate an auxiliary array with this approach.\\n\\n# Code\\n```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* buildArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n\\tregister int n = numsSize;\\n\\tregister int i;\\n    for(i = 0; i < n; i++) {\\n    \\tnums[i] = nums[i] + (nums[nums[i]] % n) * n;\\n    }\\n    int j;\\n    for(j = 0; j < n; ++j) {\\n    \\tnums[j] = nums[j] / n;\\n    }\\n    return nums;\\n}\\n```\\n\\n# Misc\\n- The `n` is just a short-hand for `numsSize`, can be omitted.\\n- The `register ` is optional, the compiler can choose to use the storage class `register` instead of `auto` (that is faster)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* buildArray(int* nums, int numsSize, int* returnSize){\\n    *returnSize = numsSize;\\n\\tregister int n = numsSize;\\n\\tregister int i;\\n    for(i = 0; i < n; i++) {\\n    \\tnums[i] = nums[i] + (nums[nums[i]] % n) * n;\\n    }\\n    int j;\\n    for(j = 0; j < n; ++j) {\\n    \\tnums[j] = nums[j] / n;\\n    }\\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2609977,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406217,
                "title": "c-o-1-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n                      //a      //b*n\\n            nums[i] = nums[i] + n * (nums[nums[i]] %n);\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] = nums[i]/n;\\n        }\\n        \\n        return nums;\\n\\n    }\\n};\\n```\\n\\nThe idea here is to use modulo operator to preserve the information on an index. Let there be two numbers a and b who are also less than n. if we increment a by b*n then if we divide by n we get b and if we % by n then we get a. here in this case a is nums[i] and b is nums[nums[i]] but since b is containing modified value so we add %n to get back original value of a and in the second loop we just simply divide by n to get final answer that is nums[nums[i]]",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n        int n = nums.size();\\n        for(int i = 0; i < n; i++)\\n        {\\n                      //a      //b*n\\n            nums[i] = nums[i] + n * (nums[nums[i]] %n);\\n        }\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] = nums[i]/n;\\n        }\\n        \\n        return nums;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1361141,
                "title": "kotlin-2-ways-1-liner-and-o-1-space-w-just-bit-shifts",
                "content": "The first way is the way I\\'d do it in real life. Simple one liner.\\n\\n```\\nclass Solution {\\n    fun buildArray(nums: IntArray) = IntArray(nums.size) { nums[nums[it]] }\\n}\\n```\\n\\nThe follow up asks to do it in O(1) space. Several of the other solutions are realizing you only need to worry about 10,000 items and are either doing multiply/divide/modulo or are doing bit masking. However we can just split the entire integer space (32 bits) into a `high` and a `low`. We\\'ll keep the new values in the `high` space by shifting left 16 bits before adding. (Basically packing two shorts into each integer, with the first short being the new value and the second being the old.) If that item has already had it\\'s stuff added to it, once you shift left 16 bits, the new value it was holding just overflows and falls off, so no need to divide or mask for it.\\n\\nThen to get the new values back, just need to shift right 16 bits, and the old number just gets chopped off.\\n\\n```\\nclass Solution {\\n    fun buildArray(nums: IntArray): IntArray {\\n        for (i in nums.indices)\\n            nums[i] += nums[nums[i]] shl 16\\n        \\n        for (i in nums.indices)\\n            nums[i] = nums[i] ushr 16\\n        \\n        return nums\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun buildArray(nums: IntArray) = IntArray(nums.size) { nums[nums[it]] }\\n}\\n```\n```\\nclass Solution {\\n    fun buildArray(nums: IntArray): IntArray {\\n        for (i in nums.indices)\\n            nums[i] += nums[nums[i]] shl 16\\n        \\n        for (i in nums.indices)\\n            nums[i] = nums[i] ushr 16\\n        \\n        return nums\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683365,
                "title": "python-simple-and-short-solution",
                "content": "\\'\\'\\'\\n        ans=[]\\n        for i in range(len(nums)):\\n            ans.append(nums[nums[i]])\\n        return ans\\n\\'\\'\\'",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\'\\'\\'\\n        ans=[]\\n        for i in range(len(nums)):\\n            ans.append(nums[nums[i]])\\n        return ans\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2631744,
                "title": "go-two-solutions-in-go-golang",
                "content": "Hello Gophers!\\n\\n# Problem:  Build Array from Permutation (Easy)\\n\\n## Solution 1\\n\\n```go\\nfunc buildArray(nums []int) []int {\\n    sol := make([]int, len(nums))\\n    for idx, num := range nums {\\n        sol[idx] = nums[num]\\n    }\\n    return sol\\n}\\n```\\n\\nor\\n\\n```go\\nfunc buildArray(nums []int) []int {\\n    sol := make([]int, len(nums))\\n    for idx := range nums {\\n        sol[idx] = nums[nums[idx]]\\n    }\\n    return sol\\n}\\n```\\n\\n## Solution 2\\n\\n> **Follow-up**: Can you solve it without using an extra space (i.e., O(1) memory)?\\n\\nI usually don\\'t count the returned solution in the space complexity, but let\\'s say we do and we want `O(1)` space complexity:\\n\\n```go\\nfunc buildArray(nums []int) []int {\\n    n := len(nums)\\n    for idx := range nums {\\n        nums[idx] = nums[idx] + n*(nums[nums[idx]]%n)\\n    }\\n    for idx := range nums {\\n        nums[idx] = nums[idx]/n\\n    }\\n    return nums\\n}\\n```\\n\\nSee [user5630jD\\'s great solution](https://leetcode.com/problems/build-array-from-permutation/discuss/1452892/C%2B%2B-and-Pseudo-Code.-O(n)-time-and-O(1)-space-solution-with-explanation.) for details! :)\\n\\nI hope it helped!",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc buildArray(nums []int) []int {\\n    sol := make([]int, len(nums))\\n    for idx, num := range nums {\\n        sol[idx] = nums[num]\\n    }\\n    return sol\\n}\\n```\n```go\\nfunc buildArray(nums []int) []int {\\n    sol := make([]int, len(nums))\\n    for idx := range nums {\\n        sol[idx] = nums[nums[idx]]\\n    }\\n    return sol\\n}\\n```\n```go\\nfunc buildArray(nums []int) []int {\\n    n := len(nums)\\n    for idx := range nums {\\n        nums[idx] = nums[idx] + n*(nums[nums[idx]]%n)\\n    }\\n    for idx := range nums {\\n        nums[idx] = nums[idx]/n\\n    }\\n    return nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2580232,
                "title": "java-array-simple-solution",
                "content": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[] = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            arr[i]=nums[nums[i]];\\n        return arr;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[] = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            arr[i]=nums[nums[i]];\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2294854,
                "title": "javascript-space-o-1-euclidean-division",
                "content": "https://en.wikipedia.org/wiki/Euclidean_division\\n\\n```\\nconst buildArray = (nums) => {\\n    let len = nums.length;\\n    for (let i = 0; i < len; i++) {\\n        nums[i] = nums[i] + (len * (nums[nums[i]] % len)); \\n    }\\n    \\n    for (let i = 0; i < len; i++) {\\n        nums[i] = Math.floor(nums[i] / len);\\n    }\\n    \\n    return nums;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst buildArray = (nums) => {\\n    let len = nums.length;\\n    for (let i = 0; i < len; i++) {\\n        nums[i] = nums[i] + (len * (nums[nums[i]] % len)); \\n    }\\n    \\n    for (let i = 0; i < len; i++) {\\n        nums[i] = Math.floor(nums[i] / len);\\n    }\\n    \\n    return nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2166518,
                "title": "c-solution-with-o-n-and-o-1-space-complexity-real-0-1-space-solution",
                "content": "//logic is to store and be able to retrieve 2 elements from a single location\\n // using / operator to retreive original element and % for retreiving the new element\\n vector<int> buildArray(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n\\t\\t//multipling by size so whenever i divide by size gives the input element\\n        for(int i=0;i<n;i++)\\n            nums[i]=nums[i]*n;\\n\\t\\t// adding the required element that is  nums[i]= nums[nums[i]]\\n        for(int i=0;i<n;i++)\\n            nums[i]=nums[i]+nums[nums[i]/n]/n;\\n\\t\\t//finally replacing with the required element\\n        for(int i=0;i<n;i++)\\n            nums[i]=nums[i]%n;\\n        return nums;\\n        \\n        \\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "//logic is to store and be able to retrieve 2 elements from a single location\\n // using / operator to retreive original element and % for retreiving the new element\\n vector<int> buildArray(vector<int>& nums) {\\n        \\n        int n= nums.size();\\n\\t\\t//multipling by size so whenever i divide by size gives the input element\\n        for(int i=0;i<n;i++)\\n            nums[i]=nums[i]*n;\\n\\t\\t// adding the required element that is  nums[i]= nums[nums[i]]\\n        for(int i=0;i<n;i++)\\n            nums[i]=nums[i]+nums[nums[i]/n]/n;\\n\\t\\t//finally replacing with the required element\\n        for(int i=0;i<n;i++)\\n            nums[i]=nums[i]%n;\\n        return nums;\\n        \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2135132,
                "title": "o-n-time-o-1-space-useful-technique-detailed-explanation",
                "content": "Since we are editing the array in-place, we need to find a way to have both old and new values coexist, and retrieve them easily. We achieve this by combining `*`, `/` and `%` operators.\\n\\n# First iteration\\nWe want to build a transitory array where each element looks like this: `new * n + old`. This enables us to store both old and new information at the same place. We cannot override the old information with the new yet, since we need it to build the new. \\n\\nFor example: `[0, 2, 1] --> transitory array [0, 2 + 1 * n, 1 + 2 * n]`\\n\\nWhen we iterate over the array, since we are updating the array in-place, `nums[nums[i]]` may yield an element which is already in the form `new * n + old`. Since we want the `old` value, we retrieve it with `%`.\\n\\nFor example, with the same array: if we didn\\'t use `%` we would have  `[0, 2 + 1 * n, 1 + (2 + 1 * n) * n]`\\n\\n# Second iteration\\n\\nNow that we\\'ve got our transitory array, we can retrieve the `new` value with `/`.\\n# Solution\\n```\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for (int i = 0; i < n; i++) {\\n            nums[i] += (nums[nums[i]] % n ) * n;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums[i] / n;\\n        }\\n        return nums;\\n    }\\n```\\nVariations of this technique can be used to solve some array problems on this website. See this [First Missing Positive](https://leetcode.com/problems/first-missing-positive/)[hard] and [Missing Number](https://leetcode.com/problems/missing-number/)[easy].\\nPlease consider upvoting if you find this post useful  \\uD83D\\uDE4F\\uD83C\\uDFFB\\t",
                "solutionTags": [],
                "code": "```\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for (int i = 0; i < n; i++) {\\n            nums[i] += (nums[nums[i]] % n ) * n;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = nums[i] / n;\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2038510,
                "title": "c-o-1-solution-without-using-extra-space",
                "content": "The solution is to play around with the numbers and store 2 numbers in the same value using MATHS!\\n\\nPrimer:\\nWhen you have 2 values, x and y, you can store them in the same value using combinedValue = x + y * n given than n is sufficiently bigger than both x and y\\nYou can then retrieve x by using x = combined % n and retrieve y using y = combined / n.\\n\\nExample:\\nx = 3; y = 4, n = 5.\\ncombined = 3 + 4 * 5 = 3 + 20 = 23\\nx = 23 % 5 = 3\\ny = 23 / 5 = 4 (make sure to use the lower_bound value here)\\n\\nUsing this knowledge, we can solve the problem by:\\n\\nstoring both the original value and the solution value in one number\\nthen in another iteration, replace the value with the solution value\\nreturn adjusted array\\n\\n vector<int> buildArray(vector<int>& nums) {\\n        // store size in int since we\\'ll use it quite a bit here\\n        int n = nums.size();\\n        \\n        // \\'store\\' both the solution and original value in the same number\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// combined = originalValue + solution * size of array\\n\\t\\t\\t\\n\\t\\t\\t// the reason the solution here is (nums[nums[i]] % n) is to make sure we are only\\n\\t\\t\\t// accessing and using the original value at index \\'i\\' for the calculation in case nums[i] has already been modified\\n            nums[i] = nums[i] + (nums[nums[i]] % n) * n;\\n        }\\n                \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// solution value = combined value / n\\n            nums[i] = nums[i] / n;\\n        }\\n        \\n        return nums;\\n    }",
                "solutionTags": [],
                "code": "The solution is to play around with the numbers and store 2 numbers in the same value using MATHS!\\n\\nPrimer:\\nWhen you have 2 values, x and y, you can store them in the same value using combinedValue = x + y * n given than n is sufficiently bigger than both x and y\\nYou can then retrieve x by using x = combined % n and retrieve y using y = combined / n.\\n\\nExample:\\nx = 3; y = 4, n = 5.\\ncombined = 3 + 4 * 5 = 3 + 20 = 23\\nx = 23 % 5 = 3\\ny = 23 / 5 = 4 (make sure to use the lower_bound value here)\\n\\nUsing this knowledge, we can solve the problem by:\\n\\nstoring both the original value and the solution value in one number\\nthen in another iteration, replace the value with the solution value\\nreturn adjusted array\\n\\n vector<int> buildArray(vector<int>& nums) {\\n        // store size in int since we\\'ll use it quite a bit here\\n        int n = nums.size();\\n        \\n        // \\'store\\' both the solution and original value in the same number\\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// combined = originalValue + solution * size of array\\n\\t\\t\\t\\n\\t\\t\\t// the reason the solution here is (nums[nums[i]] % n) is to make sure we are only\\n\\t\\t\\t// accessing and using the original value at index \\'i\\' for the calculation in case nums[i] has already been modified\\n            nums[i] = nums[i] + (nums[nums[i]] % n) * n;\\n        }\\n                \\n        for (int i = 0; i < n; i++) {\\n\\t\\t\\t// solution value = combined value / n\\n            nums[i] = nums[i] / n;\\n        }\\n        \\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1720718,
                "title": "go-solution-with-o-n-time-and-o-1-memory",
                "content": "Trick: We want to somehow store the element at the current index along with the element its gonna get replaced with. So, lets say the number at given index(i) is X and the number at nums[X]=Y, we want to store both X and Y at index i.\\nSince, the max length of the array can be 1000, we can use the below formula in the logic to achieve this and modify the array in place.\\n\\n\\n\\n```\\nfunc buildArray(nums []int) []int {\\n    for i := range nums {\\n        if nums[i] >= i {\\n            nums[i] = nums[i] * 1000 + nums[nums[i]]\\n        } else {\\n            nums[i] = nums[i] * 1000 + nums[nums[i]] / 1000\\n        }\\n    }\\n        \\n   for i := range nums {\\n            nums[i] = nums[i] % 1000\\n   }\\n   return nums\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Array"
                ],
                "code": "```\\nfunc buildArray(nums []int) []int {\\n    for i := range nums {\\n        if nums[i] >= i {\\n            nums[i] = nums[i] * 1000 + nums[nums[i]]\\n        } else {\\n            nums[i] = nums[i] * 1000 + nums[nums[i]] / 1000\\n        }\\n    }\\n        \\n   for i := range nums {\\n            nums[i] = nums[i] % 1000\\n   }\\n   return nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1596625,
                "title": "satisfying-python-one-liner",
                "content": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[num] for num in nums]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[num] for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1383822,
                "title": "java-no-extra-space",
                "content": "Since any nums[i] < nums.length, we can store any integer as x * nums.length in nums[i] and still get the original value as nums[i]%nums.length. Then we can retrieve the stored value as nums[i]/nums.length in a second pass. It\\'s a nice trick you can use when you have any array in which arr[i] < arr.length.\\n\\n```\\npublic int[] buildArray(int[] nums) {\\n\\tif (nums == null || nums.length < 2) {\\n\\t\\treturn nums;\\n\\t}\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint idx = nums[i] % nums.length;\\n\\t\\tint val = nums[idx] % nums.length;\\n\\t\\tnums[i] += val * nums.length;\\n\\t} \\n\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tnums[i] /= nums.length;\\n\\t}\\n\\n\\treturn nums;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic int[] buildArray(int[] nums) {\\n\\tif (nums == null || nums.length < 2) {\\n\\t\\treturn nums;\\n\\t}\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tint idx = nums[i] % nums.length;\\n\\t\\tint val = nums[idx] % nums.length;\\n\\t\\tnums[i] += val * nums.length;\\n\\t} \\n\\n\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\tnums[i] /= nums.length;\\n\\t}\\n\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3343535,
                "title": "best-solution-for-memory-97-beats-93-beats-for-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBotirjon Shokirov\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCreating new array with size of given array. And setting the corresponding value in the result array to nums[nums[i]].\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar buildArray = function(nums) {\\n  const result = new Array(nums.length);\\n  for (let i = 0; i < nums.length; i++) {\\n    result[i] = nums[nums[i]];\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar buildArray = function(nums) {\\n  const result = new Array(nums.length);\\n  for (let i = 0; i < nums.length; i++) {\\n    result[i] = nums[nums[i]];\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302498,
                "title": "super-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3256550,
                "title": "shortest-solutio-n-easy-1-liner-c",
                "content": "# Intuition\\nSolution is emphasized on having minimal lines of code.\\n\\n# Approach\\nOriginal vector \\'nums\\' is duplicated into another vector \\'numd\\'.\\nThen each element of original \\'nums\\' is updated with its value index from \\'numd\\', the original reference.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> numd(nums);\\n        return for_each(nums.begin(),nums.end(),[&](int &a){a=numd[a];}),nums;\\n    }\\n};\\n```\\n\\n---\\n\\n\\n---\\n\\n![3bjfi3.jpg](https://assets.leetcode.com/users/images/915c8f53-0c9c-42ac-af11-8ae444e3107f_1678221672.981257.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> numd(nums);\\n        return for_each(nums.begin(),nums.end(),[&](int &a){a=numd[a];}),nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096219,
                "title": "beginner-friendly-solutions",
                "content": "**Java**\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            arr[i] = nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```\\n**JavaScript**\\n ```\\nvar buildArray = function(nums) {\\n    arr = []\\n    for(let i=0; i<nums.length; i++){\\n        arr.push(nums[nums[i]])\\n    }\\n    return arr\\n};\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def buildArray(self, nums):\\n        arr = []\\n        for i in range(len(nums)):\\n            arr.append(nums[nums[i]])\\n        return arr\\n```\\n\\n**Time Complexity : O(n)**\\nWhere n is length of array = length of nums",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            arr[i] = nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```\n```\\nvar buildArray = function(nums) {\\n    arr = []\\n    for(let i=0; i<nums.length; i++){\\n        arr.push(nums[nums[i]])\\n    }\\n    return arr\\n};\\n```\n```\\nclass Solution(object):\\n    def buildArray(self, nums):\\n        arr = []\\n        for i in range(len(nums)):\\n            arr.append(nums[nums[i]])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1970319,
                "title": "4-beginner-solutions",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        \\n        #Soln - 1\\n        return [nums[i] for i in nums]\\n    \\n        #Soln - 2\\n        output = []\\n        for i in range(0,len(nums)):\\n            output.append(nums[nums[i]])\\n        return output\\n        \\n        \\n        #Soln - 3 \\n        final = []\\n        i = 0\\n        while i<len(nums):\\n            final.append(nums[nums[i]])\\n            i = i + 1\\n        return final\\n    \\n        #Soln - 4\\n        return [nums[nums[i]] for i in range(len(nums))]\\n\\n    \\n            \\n        \\n            \\n            \\n            \\n            \\n        \\n        \\n\\'\\'\\'",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        \\n        #Soln - 1\\n        return [nums[i] for i in nums]\\n    \\n        #Soln - 2\\n        output = []\\n        for i in range(0,len(nums)):\\n            output.append(nums[nums[i]])\\n        return output\\n        \\n        \\n        #Soln - 3 \\n        final = []\\n        i = 0\\n        while i<len(nums):\\n            final.append(nums[nums[i]])\\n            i = i + 1\\n        return final\\n    \\n        #Soln - 4\\n        return [nums[nums[i]] for i in range(len(nums))]\\n\\n    \\n            \\n        \\n            \\n            \\n            \\n            \\n        \\n        \\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 1897795,
                "title": "python-time-complexity-o-n-space-complexity-o-1",
                "content": "Code snippet:\\nHere we just need to append the elements at correct positions i.e. we are appending them at length of nums + (correct element position)\\n\\nhence we will finally get the array which will be appended in a way that the last elements starting from the length index would have correct positioned elements\\n\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n\\t\\tl = len(nums)\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t nums.append(nums[nums[i]])\\n\\t\\treturn nums[l:]\\n```\\nso here the time complexity will be O(n) coz we need to travel the array once to append the elements and we are appending in the same array thus space complexity is O(1).\\nIf you found this helpful please upvote!\\nThank you for stopping by!\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n\\t\\tl = len(nums)\\n\\t\\tfor i in range(len(nums)):\\n\\t\\t\\t nums.append(nums[nums[i]])\\n\\t\\treturn nums[l:]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863499,
                "title": "c-easy-solution-ii-1920-build-array-from-permutation",
                "content": "\\t\\n\\t\\n\\tclass Solution {\\n\\n\\t\\tpublic:\\n\\n\\t\\tvector<int> buildArray(vector<int>& nums) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t   for(int i=0;i<nums.size();i++) \\n\\t\\t   {\\n\\t\\t\\t   ans.push_back(nums[nums[i]]);\\n\\t\\t   }\\n\\t\\t   return ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\n\\t\\tpublic:\\n\\n\\t\\tvector<int> buildArray(vector<int>& nums) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t   for(int i=0;i<nums.size();i++) \\n\\t\\t   {\\n\\t\\t\\t   ans.push_back(nums[nums[i]]);\\n\\t\\t   }",
                "codeTag": "Java"
            },
            {
                "id": 1806782,
                "title": "c-simple-solution-space-complexity-o-1-week-8",
                "content": "Range of nums[i] is [1,1000].\\nif nums[nums[i]] * 10000 is added to nums[i],\\noriginal value is stored at the right side of 5th digit and result is stored at the left side.\\n\\nexample)\\nThe goal is to change [0,2,1,5,3,4] to [0,1,2,4,5,3], in place.\\nResult are stored after 5th digits.\\nOriginal values are kept before 5th digits and we can use it by modulo 10000.\\nnums after first loop\\n= [0 * 10000 + 0, 1 * 10000 + 2, 2 * 10000 + 1, 4 * 10000 + 5, 5 * 10000 + 3, 3 * 10000 + 4]\\n= [0, 10002, 20001, 40005, 50003, 30004]\\n\\nnums after second loop to remove unecessary original values, \\n= [0 / 10000, 10002 / 10000, 20001 / 10000, 40005 / 10000, 50003 / 10000, 30004 / 10000]\\n= [0, 1, 2, 4, 5, 3]\\n```\\nint* buildArray(int* nums, int numsSize, int* returnSize){\\n    for (int i = 0; i < numsSize; ++i)\\n        nums[i] += 10000 * (nums[nums[i]] % 10000);\\n    for (int i = 0; i < numsSize; ++i)\\n        nums[i] /= 10000;\\n    *returnSize = numsSize;\\n    return (nums);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* buildArray(int* nums, int numsSize, int* returnSize){\\n    for (int i = 0; i < numsSize; ++i)\\n        nums[i] += 10000 * (nums[nums[i]] % 10000);\\n    for (int i = 0; i < numsSize; ++i)\\n        nums[i] /= 10000;\\n    *returnSize = numsSize;\\n    return (nums);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1773778,
                "title": "c-simple-solution-w-explanation-o-n-and-o-1-space-complexities",
                "content": "- Approach 1 : Just do as mentioned in the question, will take O(N) space though.\\n\\n```cpp\\n//Build an array with ans[i] = nums[nums[i]]\\nvector<int> buildArray(vector<int>& nums) {\\n    vector<int> ans;\\n    for(int i = 0; i < nums.size(); i++) {\\n        ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;   \\n}\\n```\\n ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n \\n- Approach 2 : Using O(1) space\\n    - What you need to do is to store the two elements `nums[i]` as well as `nums[nums[i]]` at the same position: How?\\n        - `For every given position store a certain number which can be used later to translate into nums[nums[i]] and that number should also not disturbed the original nums[i] value`\\n        - You can do this by using `a = a + b * n` formula where a is `nums[i] and b is nums[nums[i]]`\\n        - So for every `nums[i]` we will store `nums[i] + nums[nums[i]] * n` value in it.\\n        - Let\\u2019s say a = 3 and b = 2 and the size of the array is 5\\n        - So `a = a + b * n = 3 + 2*5 = 13`\\n        - To get the `a` and `b` back from the modified value we will use the division and modulo operator:\\n            - `a % n = 13 % 5 = 3`\\n            - `a / n = 13 / 5 = 2`\\n        \\n        ```cpp\\n           for(int i=0;i<n;i++)\\n            {\\n                nums[i] = nums[i] + n*(nums[nums[i]]);\\n            }\\n        ```\\n        \\n        - But there is a problem:\\n            - Imagine you are at the last index let\\u2019s say for the given array `[-,-,24,-,-,2]` and you know that the `2` should be replace with `a = a + b * n` . But the b is 24 here which is already modified value, so to get our `nums[nums[i]` back, we will take the modulo of b that is add the `%n to b` and we are done!\\n            - Why we didn\\u2019t do `/` ? : Because to get the `nums[i]` from `a + b*n` we perform the modulo operation that is, to get the original `nums[i]` back we do modulo not integer division, as integer division is reserved for getting the `nums[nums[i]]` in that case\\n                - Follow up :  To get original number back, do the modulo not integer division as later one is reserved for it\\u2019s counterpart\\n                - Counterpart of `nums[i] = nums[nums[i]` and vice versa.\\n            - As we want to get original `nums[nums[i]] from our modified nums[nums[i]` we used `%` with the `nums[nums[i]` and voila it\\u2019s done.\\n ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\\n \\n**Solution : O(1) Space Complexity and O(N) Time Complexity**\\n```cpp\\nvector<int> buildArray(vector<int>& nums) \\n\\t{\\n\\t\\tint n = nums.size();\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i] = nums[i] + n*(nums[nums[i]]%n);\\n\\t\\t}\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i] = nums[i]/n;\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\n//Build an array with ans[i] = nums[nums[i]]\\nvector<int> buildArray(vector<int>& nums) {\\n    vector<int> ans;\\n    for(int i = 0; i < nums.size(); i++) {\\n        ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;   \\n}\\n```\n```cpp\\n           for(int i=0;i<n;i++)\\n            {\\n                nums[i] = nums[i] + n*(nums[nums[i]]);\\n            }\\n        ```\n```cpp\\nvector<int> buildArray(vector<int>& nums) \\n\\t{\\n\\t\\tint n = nums.size();\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i] = nums[i] + n*(nums[nums[i]]%n);\\n\\t\\t}\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tnums[i] = nums[i]/n;\\n\\t\\t}\\n\\t\\treturn nums;\\n\\t}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729421,
                "title": "slightly-different-approach-using-a-n-b-technique",
                "content": "This question has a straight forward solution, so I guess you jumped into discussion section most likely to find some other unique approach to this solution. So here it is : -\\nIn this solution, we have overloaded each position of a array to store two values instead of one.\\nThe technique is **A* N+B approach**\\nwherein **A** represents the **first** number, **B** represents **second** number, **N** represents a number which is larger than any of the possible number given in the constraints.\\nSay, I want to store 245, 48 in one position. We can take N as 1000\\nso we can store our number as 245* 1000 + 48, which is 245048\\nWhenever we want our first number back, we\\'ll divide 245048 by 1000, we\\'ll get 245\\nWhenever we want our second number, we\\'ll take remainder 245048 by 1000, we\\'ll get 48\\nCheck out the code below.\\nHowever this code will only work properly when contraints are very low.\\n*Upvote if helpful*\\n \\n```\\nclass Solution {\\npublic:\\n    #define N 10000\\n    vector<int> buildArray(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]= (nums[nums[i]%N]%N) * N +nums[i] ;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]/=N;\\n        }\\n        return nums;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define N 10000\\n    vector<int> buildArray(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]= (nums[nums[i]%N]%N) * N +nums[i] ;\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]/=N;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625828,
                "title": "python-o-1-space-o-n-time",
                "content": "```\\nclass Solution:\\n\\t#As maximum value of the array element is 1000, this solution would work\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        for i in range(len(nums)):            \\n            if nums[nums[i]] <= len(nums):\\n                nums[i] = nums[nums[i]] * 1000 + nums[i]\\n            else:\\n                nums[i] = mod(nums[nums[i]],1000) * 1000 + nums[i]\\n            \\n        for i in range(len(nums)):\\n            nums[i]  = nums[i] // 1000\\n            \\n        return nums\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n\\t#As maximum value of the array element is 1000, this solution would work\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        for i in range(len(nums)):            \\n            if nums[nums[i]] <= len(nums):\\n                nums[i] = nums[nums[i]] * 1000 + nums[i]\\n            else:\\n                nums[i] = mod(nums[nums[i]],1000) * 1000 + nums[i]\\n            \\n        for i in range(len(nums)):\\n            nums[i]  = nums[i] // 1000\\n            \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356986,
                "title": "swift-solution-without-using-map",
                "content": "*<- Please vote if my solution was helpful to you.*\\nRuntime and Memory as the same as when using .map\\n```\\nclass Solution {\\n\\tfunc buildArray(_ nums: [Int]) -> [Int] {\\n\\t\\tvar result = [Int]()\\n\\t\\tfor i in 0..<nums.count {\\n\\t\\t\\tresult.append(nums[nums[i]])\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\tfunc buildArray(_ nums: [Int]) -> [Int] {\\n\\t\\tvar result = [Int]()\\n\\t\\tfor i in 0..<nums.count {\\n\\t\\t\\tresult.append(nums[nums[i]])\\n\\t\\t}\\n\\t\\treturn result\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1317706,
                "title": "c-language-answer",
                "content": "```\\nint* buildArray(int* nums, int numsSize, int* returnSize){\\n       \\n    *returnSize =numsSize ;                          //dereferencing the given pointer as this represent the size of array \"ans\" . \\n     int *ans = (int*) malloc( numsSize * sizeof(int )) ;    //allocating the memory space  to the array \"ans\" \\n    \\n     for ( int i =0; i<numsSize ; i++)\\n         ans[i] = nums[ nums[i]]; \\n    return   ans ; \\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* buildArray(int* nums, int numsSize, int* returnSize){\\n       \\n    *returnSize =numsSize ;                          //dereferencing the given pointer as this represent the size of array \"ans\" . \\n     int *ans = (int*) malloc( numsSize * sizeof(int )) ;    //allocating the memory space  to the array \"ans\" \\n    \\n     for ( int i =0; i<numsSize ; i++)\\n         ans[i] = nums[ nums[i]]; \\n    return   ans ; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328194,
                "title": "dart-solution-with-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem statement asks to build an array of the same length as the input array, where the value at each index is the value of the element at the index specified by the element in the input array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can iterate through the input array and create a new array using the value at each index as the index of the value to retrieve from the input array. We can use a list comprehension or a loop to construct the new array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the buildArray function is O(n), where n is the length of the input list nums. This is because the function iterates through the entire input list once to construct the output list.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the function is also O(n), because it creates a new list of the same size as the input list to store the output. However, this space complexity can be reduced to O(1) if we modify the input list in place instead of creating a new list.\\n\\n# Code\\n```\\nclass Solution {\\n  List<int> buildArray(List<int> nums) {\\n      return([for (var element in nums) nums[element]]);\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  List<int> buildArray(List<int> nums) {\\n      return([for (var element in nums) nums[element]]);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147259,
                "title": "python-easy-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        vec = [0]*len(nums)\\n        for i in range(0, len(nums)):\\n            vec[i] = nums[nums[i]]\\n        return vec\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        vec = [0]*len(nums)\\n        for i in range(0, len(nums)):\\n            vec[i] = nums[nums[i]]\\n        return vec\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066300,
                "title": "simple-java-solution-99-95-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++){\\n            arr[i] = nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] arr = new int[n];\\n        for(int i = 0; i < n; i++){\\n            arr[i] = nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892737,
                "title": "java-2-line-code-100-faster",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830005,
                "title": "c-std-transform",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nJust do what the problem asks to do.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse ```std::transform```.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ for the output.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        transform(nums.begin(), nums.end(), back_inserter(ans),\\n            [&](int x) { return nums[x]; });\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```std::transform```\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        transform(nums.begin(), nums.end(), back_inserter(ans),\\n            [&](int x) { return nums[x]; });\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593032,
                "title": "with-explanation-comments-time-14-ms-93-04-space-16-1-mb-92-03",
                "content": "**Like it? ->Upvote please!** \\u30C4\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n        //initialize a new vector of the same size of the given vector\\n        vector<int> res(nums.size());\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size();i++)\\n            //add the value of the permutation to the array\\n            res[i]=nums[nums[i]];\\n        \\n        //return the new array values\\n        return res;\\n    }\\n};\\n\\'\\'\\'\\n\\n\\n**Like it? ->Upvote please!** \\u30C4\\n**If still not understood, feel free to comment. I will help you out**\\n**Happy Coding :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Simulation"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n        //initialize a new vector of the same size of the given vector\\n        vector<int> res(nums.size());\\n        \\n        //loop over the whole array elements\\n        for(int i=0;i<nums.size();i++)\\n            //add the value of the permutation to the array\\n            res[i]=nums[nums[i]];\\n        \\n        //return the new array values\\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2566353,
                "title": "java-solution-with-o-1-space-complexity",
                "content": "public int[] buildArray(int[] nums) {\\n        int l= nums.length;\\n        for(int i=0; i<l; i++){\\n            nums[i] = nums[i] + l*(nums[nums[i]] % l);\\n        }\\n        for(int i=0; i<l; i++){\\n            nums[i] = nums[i]/l;\\n        }\\n        return nums;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "public int[] buildArray(int[] nums) {\\n        int l= nums.length;\\n        for(int i=0; i<l; i++){\\n            nums[i] = nums[i] + l*(nums[nums[i]] % l);\\n        }\\n        for(int i=0; i<l; i++){\\n            nums[i] = nums[i]/l;\\n        }\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2196806,
                "title": "c-vector-6-liner-solution-easiest",
                "content": "**If you find this solution easy and well explantory then do upvote (press up symbol present on left side) **\\t\\t\\n\\t\\t\\n\\t\\tint length=nums.size();\\n        vector<int> v(length);\\n        for(int i=0; i<length; i++){\\n            v[i]=nums[nums[i]];\\n        }   \\n        return v;",
                "solutionTags": [],
                "code": "**If you find this solution easy and well explantory then do upvote (press up symbol present on left side) **\\t\\t\\n\\t\\t\\n\\t\\tint length=nums.size();\\n        vector<int> v(length);\\n        for(int i=0; i<length; i++){\\n            v[i]=nums[nums[i]];\\n        }   \\n        return v;",
                "codeTag": "Unknown"
            },
            {
                "id": 2046846,
                "title": "simple-java-o-1-space-solution-with-full-explanation",
                "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int len=nums.length;\\n        //int nums2[]=new int[len];\\n        for(int i=0;i<len;i++){\\n            nums[i]=nums[i]+(nums[nums[i]]%len)*len;\\n        }\\n        for(int i=0;i<len;i++){\\n            nums[i]=nums[i]/len;\\n        }\\n        return nums;\\n    }\\n}\\n\\nEXPLANATION :\\n\\nIf you have two numbers A and B , then you can store both the numbers in one number , question is how?\\n\\nso let\\'s take a fixed value X , Now we will calculate Combined value using the given numbers using below formula ,\\n\\nCombined = A + B*X; ( I hope you remember the formula DIVIDEND = DIVISOR * QUOTIENT + REMAINDER relate it with that)\\n\\nSo now if we have to calculate A then we will use : A = Combined % X\\n\\nAnd if we have to calculate B then we will use B = Combined / X ;\\n\\nNow let\\'s dry run our code you will understand better :\\nI/P : [0 , 2 , 1 , 5 , 3 , 4]\\nO/P : [0 , 1, 2 , 4 , 5 , 3]\\n\\nNUMS[0] = NUMS[0] + (NUMS[NUMS[0]] % 6) * 6 // NUMS[NUMS[0]] % 6 -- This one we have written because if suppose at one index value have changed then we need original value right\\n\\nNUMS[0] = 0 + (0%6)*6 =0\\n\\nNUMS[1] = NUMS[1] + (NUMS[NUMS[1]]%6) * 6 // 6 is the length of the array -- fixed value\\nNUMS[1]= 2 + (1%6)*6 = 8 // NOW do the calculation as per above logic\\n\\nPlease let me know if you need any further explanation.",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int len=nums.length;\\n        //int nums2[]=new int[len];\\n        for(int i=0;i<len;i++){\\n            nums[i]=nums[i]+(nums[nums[i]]%len)*len;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1830808,
                "title": "java-o-1-space-solution-using-modulo-arithmetic",
                "content": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        for(int i = 0; i < n; ++i)\\n            nums[i] = (nums[nums[i]] % n) * n + nums[i];\\n        \\n        for(int i = 0; i < n; ++i)\\n            nums[i] = nums[i] / n;\\n        \\n        return nums;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        for(int i = 0; i < n; ++i)\\n            nums[i] = (nums[nums[i]] % n) * n + nums[i];\\n        \\n        for(int i = 0; i < n; ++i)\\n            nums[i] = nums[i] / n;\\n        \\n        return nums;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580171,
                "title": "javascript-bitmask-solution-o-1-space",
                "content": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n const buildArray = (nums) => {\\n    const bitMask = 0b1111111111; \\n     \\n     nums.forEach((_, i) => {\\n\\t\\tnums[i] |= (nums[nums[i]] & bitMask) << 10;\\n     })\\n     \\n     nums.forEach((_, i) => {\\n\\t\\tnums[i] = nums[i] >> 10;\\n     })\\n     \\n\\treturn nums;\\n }\\n ```\\n\\n[ref solution](https://leetcode.com/problems/build-array-from-permutation/discuss/1315480/Java-or-O(1)-Space-O(n)-Time)",
                "solutionTags": [
                    "JavaScript",
                    "Bitmask"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n const buildArray = (nums) => {\\n    const bitMask = 0b1111111111; \\n     \\n     nums.forEach((_, i) => {\\n\\t\\tnums[i] |= (nums[nums[i]] & bitMask) << 10;\\n     })\\n     \\n     nums.forEach((_, i) => {\\n\\t\\tnums[i] = nums[i] >> 10;\\n     })\\n     \\n\\treturn nums;\\n }\\n ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3976421,
                "title": "beats-97-4-memory-and-beats-75-83-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def buildArray(self, nums):\\n        return [nums[nums[i]] for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def buildArray(self, nums):\\n        return [nums[nums[i]] for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3857339,
                "title": "1920-build-array-from-permutation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBegin by fully understanding the problem statement. In this case, we are given an array nums, and we need to create a new array ans, where ans[i] = nums[nums[i]] for each index i in the array.\\n\\nOne straightforward approach would be to use a brute-force method. We can iterate through the nums array and for each index i, set ans[i] to nums[nums[i]]. This would result in a time complexity of O(n) since we have to traverse the array once. The space complexity would also be O(n) since we need to store the new array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nYour approach to solving the problem is to use a single-pass algorithm that builds a new array ans based on the given array nums. The algorithm is implemented in the following steps:\\n\\nInitialization: You start by initializing the length of the input array nums as len and create a new array ans of the same length, with all elements set to 0.\\n\\nBuilding the new array: Then, you use a for loop to iterate over the elements of the nums array. For each index i, you set ans[i] to nums[nums[i]].\\n\\nFor example, if nums[i] is 3, then you set ans[i] to nums[3].\\nIf nums[3] is 7, then you set ans[i] to 7.\\nReturning the Result: After the loop completes, you have built the new array ans, and you return it as the final result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution is O(n), where n is the number of elements in the input array nums. The reason for this is that the code iterates through the nums array once, performing a constant-time operation for each element.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is O(n) as well. The space complexity is determined by the additional space used by the ans array, which has the same length as the input array nums. Therefore, the space complexity scales linearly with the input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int len = nums.length;\\n        int[] ans = new int[len];\\n\\n        for(int i = 0; i < len; i++){\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int len = nums.length;\\n        int[] ans = new int[len];\\n\\n        for(int i = 0; i < len; i++){\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787055,
                "title": "easy-3-line-of-code-with-100-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[nums[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n``\\n/*PLEASE UPVOTE IF THE SOLUTION WAS HELPFUL FOR YOU*/",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.push_back(nums[nums[i]]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3399724,
                "title": "simple-go-solution-with-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc buildArray(nums []int) []int {\\n\\tfor i, n := range nums {\\n\\t\\tnums[i] += (nums[n] % 1000) * 1000\\n\\t}\\n\\n\\tfor i, _ := range nums {\\n\\t\\tnums[i] = nums[i] / 1000\\n\\t}\\n\\n\\treturn nums\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc buildArray(nums []int) []int {\\n\\tfor i, n := range nums {\\n\\t\\tnums[i] += (nums[n] % 1000) * 1000\\n\\t}\\n\\n\\tfor i, _ := range nums {\\n\\t\\tnums[i] = nums[i] / 1000\\n\\t}\\n\\n\\treturn nums\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3107215,
                "title": "one-line-c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        return nums.Select(x => nums[x]).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        return nums.Select(x => nums[x]).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100592,
                "title": "1920-build-array-from-permutation",
                "content": "The problem is asking to build an array \"ans\" of the same length as the input array \"nums\" where each element in \"ans\" is equal to the element in \"nums\" at the index specified by the corresponding element in \"nums\".\\n\\nA possible solution to this problem in C++ is to use a for loop to iterate through each element in \"nums\" and build \"ans\" using the formula ans[i] = nums[nums[i]]. The solution would have a time complexity of O(n) and a space complexity of O(n) because it uses an extra array \"ans\" to store the result.\\n\\n```\\nvector<int> build_ans(vector<int>& nums) {\\n    vector<int> ans(nums.size());\\n    for (int i = 0; i < nums.size(); i++) {\\n        ans[i] = nums[nums[i]];\\n    }\\n    return ans;\\n}\\n```\\nFor the follow up question, we can achieve the same result with O(1) memory by manipulating the original array in place.\\n\\n```\\nvoid build_ans(vector<int>& nums) {\\n    int temp;\\n    for (int i = 0; i < nums.size(); i++) {\\n        temp = nums[i];\\n        nums[i] = nums[temp];\\n        nums[temp] = temp;\\n    }\\n}\\n```\\nIt iterates through each element in the array and swaps the current element with the element at the index specified by the current element.\\nNote that in the above solution, the original array is modified. If you want to keep the original array, then you need to make a copy of it before passing to this function.",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "```\\nvector<int> build_ans(vector<int>& nums) {\\n    vector<int> ans(nums.size());\\n    for (int i = 0; i < nums.size(); i++) {\\n        ans[i] = nums[nums[i]];\\n    }\\n    return ans;\\n}\\n```\n```\\nvoid build_ans(vector<int>& nums) {\\n    int temp;\\n    for (int i = 0; i < nums.size(); i++) {\\n        temp = nums[i];\\n        nums[i] = nums[temp];\\n        nums[temp] = temp;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2997732,
                "title": "easy-to-understand-c-solution",
                "content": "\\n\\n# Approach\\nmake a vector so that orginal one doesnt get disturbed\\n\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n    vector<int> ans ;\\n        for(int i =0 ; i<nums.size() ; i++){\\nans.push_back(nums[nums[i]]);\\n        }return ans ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n    vector<int> ans ;\\n        for(int i =0 ; i<nums.size() ; i++){\\nans.push_back(nums[nums[i]]);\\n        }return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2918360,
                "title": "java-easy-soln-o-1-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869937,
                "title": "o-1-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe main goal is to keep both the original and secondary values as an infromation on the array.\\n\\nI am not the owner/creator/inventor of the approach for certain\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1\\n)\\n# Code\\n```\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        for(int i = 0; i < nums.Length; i++){\\n            // add secondary values onto original values as multples of the length of the array\\n            // modulus means original value while integer division gives the result values\\n            nums[i] += (nums[nums[i]] % nums.Length) * nums.Length;\\n        }\\n        for(int i = 0; i < nums.Length; i++){\\n            nums[i] = nums[i] / nums.Length;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        for(int i = 0; i < nums.Length; i++){\\n            // add secondary values onto original values as multples of the length of the array\\n            // modulus means original value while integer division gives the result values\\n            nums[i] += (nums[nums[i]] % nums.Length) * nums.Length;\\n        }\\n        for(int i = 0; i < nums.Length; i++){\\n            nums[i] = nums[i] / nums.Length;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2856766,
                "title": "1920-build-array-from-permutation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>arr(n);\\n        int i=0;\\n        int a=0;        \\n        while (i<n){\\n            a=nums[i];\\n            arr[i]=nums[a];\\n            i++;\\n            a==0;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Array",
                    "Probability and Statistics"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>arr(n);\\n        int i=0;\\n        int a=0;        \\n        while (i<n){\\n            a=nums[i];\\n            arr[i]=nums[a];\\n            i++;\\n            a==0;\\n        }\\n        return arr;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569363,
                "title": "best-approach-simple-and-easy-best-for-beginners",
                "content": "class Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        for i in range(len(nums)):\\n            ans.append(nums[nums[i]])\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        ans=[]\\n        for i in range(len(nums)):\\n            ans.append(nums[nums[i]])\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2536095,
                "title": "simple-java-solution-space-complexity-o-1-time-complexity-o-n",
                "content": "```\\n    public int[] buildArray(int[] nums) {\\n      int n= nums.length;   \\n      for(int i=0;i<n;i++){\\n          nums[i]= nums[i] + (nums[nums[i]]%n)*n;\\n      }  \\n        \\n      for(int i=0;i<n;i++){\\n          nums[i]= nums[i]/n;\\n      }  \\n       return nums; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] buildArray(int[] nums) {\\n      int n= nums.length;   \\n      for(int i=0;i<n;i++){\\n          nums[i]= nums[i] + (nums[nums[i]]%n)*n;\\n      }  \\n        \\n      for(int i=0;i<n;i++){\\n          nums[i]= nums[i]/n;\\n      }  \\n       return nums; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2249756,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[]=new int[nums.length],i;\\n        for(i=0;i<nums.length;i++)\\n            arr[i]=nums[nums[i]];\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[]=new int[nums.length],i;\\n        for(i=0;i<nums.length;i++)\\n            arr[i]=nums[nums[i]];\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2194754,
                "title": "java-beginner-level-simplest-solution-99-83-faster-runtime-1ms",
                "content": "***If you understood and liked my code then please upvote it.\\nHappy Learning!!***\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2160218,
                "title": "array-from-permutation",
                "content": "```\\nvar buildArray = function(nums) {\\n    return nums.map((num, i) => nums[nums[i]])\\n};\\n```\\n```\\nvar buildArray = function(nums) {\\n    return nums.map((i) => nums[i])\\n};\\n```\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar buildArray = function(nums) {\\n    let ans = [];\\n    for (let i=0; i<nums.length; i++) {\\n        ans[i] = nums[nums[i]];\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar buildArray = function(nums) {\\n    return nums.map((num, i) => nums[nums[i]])\\n};\\n```\n```\\nvar buildArray = function(nums) {\\n    return nums.map((i) => nums[i])\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar buildArray = function(nums) {\\n    let ans = [];\\n    for (let i=0; i<nums.length; i++) {\\n        ans[i] = nums[nums[i]];\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2102751,
                "title": "crazy-math-solution-o-1",
                "content": "```javascript\\n// put a debugger to have better understanding.\\n// example - [0,2,1,5,3,4]\\nvar buildArray = function(nums) {\\n// with O(1) and O(n+n)\\n    // store two numbers with math.\\n    // ex - for 0 -> 0, 2 -> 1002, 1 -> 1002, 5 -> 5004, 3 -> 3005, 4 -> 4003 \\n    for(let i=0;i<nums.length;i++){\\n        nums[i]=nums[i]+(nums[nums[i]]%1000)*1000;\\n    }\\n    // get the result number\\n    // // ex - for 0 -> 0, 1002 -> 1, 1002 -> 2, 5004 -> 4, 3005 -> 5, 4003 -> 3\\n    for(let i=0;i<nums.length;i++){\\n        // bitwise not operator to make the number integer.\\n        nums[i]=~(~(nums[i]/1000));\\n    }\\n    return nums; \\n    \\n//  with extra space O(n)   \\n//     let answer = [];\\n    \\n//     for(let i = 0; i < nums.length; i++){\\n//         answer[i] = nums[nums[i]];\\n//     }\\n//     return answer;\\n};\\n```\\n\\nReference - [sammridhiroy99](https://leetcode.com/problems/build-array-from-permutation/discuss/1403264/cpp-or-O(1)-space)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n// put a debugger to have better understanding.\\n// example - [0,2,1,5,3,4]\\nvar buildArray = function(nums) {\\n// with O(1) and O(n+n)\\n    // store two numbers with math.\\n    // ex - for 0 -> 0, 2 -> 1002, 1 -> 1002, 5 -> 5004, 3 -> 3005, 4 -> 4003 \\n    for(let i=0;i<nums.length;i++){\\n        nums[i]=nums[i]+(nums[nums[i]]%1000)*1000;\\n    }\\n    // get the result number\\n    // // ex - for 0 -> 0, 1002 -> 1, 1002 -> 2, 5004 -> 4, 3005 -> 5, 4003 -> 3\\n    for(let i=0;i<nums.length;i++){\\n        // bitwise not operator to make the number integer.\\n        nums[i]=~(~(nums[i]/1000));\\n    }\\n    return nums; \\n    \\n//  with extra space O(n)   \\n//     let answer = [];\\n    \\n//     for(let i = 0; i < nums.length; i++){\\n//         answer[i] = nums[nums[i]];\\n//     }\\n//     return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1980136,
                "title": "java-o-1-memory-o-n-time-solution",
                "content": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[i] *= n;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[i] += nums[nums[i] / n] / n;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[i] %= n;\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[i] *= n;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[i] += nums[nums[i] / n] / n;\\n        }\\n        \\n        for (int i = 0; i < n; i++) {\\n            nums[i] %= n;\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941460,
                "title": "c-o-1-space-using-bit-manipulation",
                "content": "Similar idea to what others posted, but using bit shifting.  Since the maxiumum value of n is 1000 (<1024) we can safely allocate the last 10 bits to the original values and the next 10 bits to storing the second value.  Then bit shift by 10 on the second pass to get the final result.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        for (int i=0; i<nums.size(); ++i) \\n            nums[i]|=(nums[nums[i] & 1023] & 1023)<<10;\\n        for (int i=0; i<nums.size(); ++i)\\n            nums[i]>>=10;\\n        return nums;                    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        for (int i=0; i<nums.size(); ++i) \\n            nums[i]|=(nums[nums[i] & 1023] & 1023)<<10;\\n        for (int i=0; i<nums.size(); ++i)\\n            nums[i]>>=10;\\n        return nums;                    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790964,
                "title": "js-1-line-map",
                "content": "```\\n\\nconst buildArray=nums=>nums.map((item,index)=>nums[nums[index]])\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\nconst buildArray=nums=>nums.map((item,index)=>nums[nums[index]])\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1779300,
                "title": "java-o-1-solution-with-circular-swap",
                "content": "In the array `arr`, for each index `i`, we know there can be only 2 cases:\\n1. `arr[i] == i`\\n2. `arr[i] != i`\\n\\nThe first case is trivial, we dont do anything. But what about the second case?\\nWell we know if `arr[i] != i`, we can assume `arr[i] = j`. Our next question is , what is `arr[j]`?\\nWe know that `arr[j] != j`, because `arr[i] == j`, so we `arr[j]` can again have 2 possiblities:\\n1. `arr[j] == i`\\n2. `arr[j] != i`\\n\\nThe first case is trivial again, we just swap the value between index `i` and `j`. But what about the second case?\\nWe know if `arr[j] != i`, and `arr[j] != j`, we can assum `arr[j] = k`. \\n\\nWith the same logic, we know the following:\\n1.`arr[k] != j`\\n2.`arr[k] != k`\\nAgain, `arr[k]` can either be `i`, where we can just swap between `i`, `j`, `k`. Or there has to be new value `m` that we have never seen before.\\n\\nSee the pattern now? If we start from any index `i`, and follow the trail by checking each index `i`, what is `arr[i]`, we will soon find out there has to be a index in the end that `arr[r] == i`. Once we identify that final `r` where `arr[r] == i`, the only thing we need to do is to move each value in this chain one step forward.\\n\\nThe problem become another famous problem that ask us to move each item in an array one index forward with O(1) space. We can simply store the first value, and overwrite the previous value as we traverse the array, then replace the last value with the saved value from the first index.\\n\\n```java\\nprivate void swap(int[] nums, int pointer){\\n        int index = pointer, value = nums[pointer], next = nums[pointer];\\n        while(nums[pointer] != index){\\n            next = nums[pointer];\\n            nums[pointer] = -nums[nums[pointer]];\\n            pointer = next;\\n        }\\n        nums[pointer] = -value;\\n    }\\n```\\n\\nOne caveat is that once a circular swap is completed, we need to find a way to mark the current index so we wont accidently swap these index again. We can achieve this by using the negative sign as the completed flag.\\n\\nFull code below:\\n```java\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i] > 0)\\n                swap(nums, i);\\n        }\\n        for(int i = 0; i < nums.length; i++)\\n            nums[i] = -nums[i];\\n        return nums;\\n    }\\n    private void swap(int[] nums, int pointer){\\n        int index = pointer, value = nums[pointer], next = nums[pointer];\\n        while(nums[pointer] != index){\\n            next = nums[pointer];\\n            nums[pointer] = -nums[nums[pointer]];\\n            pointer = next;\\n        }\\n        nums[pointer] = -value;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```java\\nprivate void swap(int[] nums, int pointer){\\n        int index = pointer, value = nums[pointer], next = nums[pointer];\\n        while(nums[pointer] != index){\\n            next = nums[pointer];\\n            nums[pointer] = -nums[nums[pointer]];\\n            pointer = next;\\n        }\\n        nums[pointer] = -value;\\n    }\\n```\n```java\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i = 0; i < nums.length; i++){\\n            if(i == 0 || nums[i] > 0)\\n                swap(nums, i);\\n        }\\n        for(int i = 0; i < nums.length; i++)\\n            nums[i] = -nums[i];\\n        return nums;\\n    }\\n    private void swap(int[] nums, int pointer){\\n        int index = pointer, value = nums[pointer], next = nums[pointer];\\n        while(nums[pointer] != index){\\n            next = nums[pointer];\\n            nums[pointer] = -nums[nums[pointer]];\\n            pointer = next;\\n        }\\n        nums[pointer] = -value;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1712213,
                "title": "with-o-1-space-complexity-with-explanation-of-logic",
                "content": "if we take 3 numbers a,b and n in such a way that,\\na and b < n\\nthen we can write a equation a = a + b(n) \\nand a&b can be retrieved by a = a%n and b = a/n;\\nso taking a = nums[i] and b = nums[nums[i]] and n = size of array\\nwe can write following code : \\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0; i<nums.size(); i++){\\n            nums[i] += (nums[nums[i]]%n)*n;\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            nums[i] = nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0; i<nums.size(); i++){\\n            nums[i] += (nums[nums[i]]%n)*n;\\n        }\\n        \\n        for(int i=0; i<nums.size(); i++){\\n            nums[i] = nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673221,
                "title": "scala-3-word-solution",
                "content": "```\\nobject Solution {\\n    def buildArray(nums: Array[Int]): Array[Int] = {\\n        nums.map(i=>nums(i))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def buildArray(nums: Array[Int]): Array[Int] = {\\n        nums.map(i=>nums(i))\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1661866,
                "title": "c-solution-inplace-permutation-linear-time",
                "content": "````\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& arr) {\\n        int n= arr.size();\\n        int MOD = 1003;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = (arr[arr[i]]%MOD)*MOD + arr[i];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = arr[i]/MOD;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n````\\n\\n<p> INTUITION: </p>\\n\\n<p> We take a MOD value , here 1003 as maximum value given in problem statement is 1000 only. Then we use relation : </p>\\n\\n````\\n// New Value at index =  (Look-up % MOD) * MOD + Original Value at index \\n````\\n\\n<p> Which is derived from : </p>\\n\\n````\\n// Divided =  (Divisor) * Quotient + Remainder \\n````\\n\\n<p> This way we are able to store two numbers in one place as dividend. Both Divisor and Remainder can be obtained by Quotient using division and modulo operation respectively. </ p>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& arr) {\\n        int n= arr.size();\\n        int MOD = 1003;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = (arr[arr[i]]%MOD)*MOD + arr[i];\\n        }\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            arr[i] = arr[i]/MOD;\\n        }\\n        \\n        return arr;\\n    }\\n};\\n```\n````\\n// New Value at index =  (Look-up % MOD) * MOD + Original Value at index \\n```\n````\\n// Divided =  (Divisor) * Quotient + Remainder \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563249,
                "title": "rust-straightforward",
                "content": "```\\nimpl Solution {\\n    pub fn build_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut res: Vec<i32> = Vec::with_capacity(nums.len());\\n        for &n in nums.iter() {\\n            res.push(nums[n as usize]);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn build_array(nums: Vec<i32>) -> Vec<i32> {\\n        let mut res: Vec<i32> = Vec::with_capacity(nums.len());\\n        for &n in nums.iter() {\\n            res.push(nums[n as usize]);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1558880,
                "title": "python-simple-solution-faster-than-96",
                "content": "\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        for i in range(len(nums)):\\n            a.append(nums[nums[i]])\\n        return a     \\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        for i in range(len(nums)):\\n            a.append(nums[nums[i]])\\n        return a     \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1498556,
                "title": "with-explanation-space-complexity-o-1",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n       \\n        // code without using extra space\\n        // Instead of creating any new array, we will store two values in nums (one is initial and other is final)\\n\\t\\t\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n           nums[i] = n*( (nums[nums[i]])%n ) + nums[i] ;           //storing two values in one\\n            \\n        }\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            nums[i] = nums[i]/n ;                           // taking one value as per required\\n        }\\n        return nums;\\n    }\\n};\\n\\n//Input example: nums = [0,2,1,5,3,4] , n=6\\n// when i=1  nums[1] = 6*( (nums[nums[1]])%6 ) + nums[1]  =   6*( (1)%6 ) + 2 = 6*1 + 2 = 8\\n// now this 8 contain both value:\\n//the initial value of nums = (8%n) = (8%6) = 2\\n// the final value of nums or the ans = (8/n) = (8/6) = 1\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n       \\n        // code without using extra space\\n        // Instead of creating any new array, we will store two values in nums (one is initial and other is final)\\n\\t\\t\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n           nums[i] = n*( (nums[nums[i]])%n ) + nums[i] ;           //storing two values in one\\n            \\n        }\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n            nums[i] = nums[i]/n ;                           // taking one value as per required\\n        }\\n        return nums;\\n    }\\n};\\n\\n//Input example: nums = [0,2,1,5,3,4] , n=6\\n// when i=1  nums[1] = 6*( (nums[nums[1]])%6 ) + nums[1]  =   6*( (1)%6 ) + 2 = 6*1 + 2 = 8\\n// now this 8 contain both value:\\n//the initial value of nums = (8%n) = (8%6) = 2\\n// the final value of nums or the ans = (8/n) = (8/6) = 1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1447388,
                "title": "python-solution",
                "content": "class Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        li = []\\n        self.nums = nums\\n        for i in range(len(self.nums)):\\n            li.append(self.nums[self.nums[i]])\\n        return li",
                "solutionTags": [],
                "code": "class Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        li = []\\n        self.nums = nums\\n        for i in range(len(self.nums)):\\n            li.append(self.nums[self.nums[i]])\\n        return li",
                "codeTag": "Java"
            },
            {
                "id": 1432229,
                "title": "go-easy-solution",
                "content": "```\\nfunc buildArray(nums []int) []int {\\n    ans := make([]int, len(nums))\\n\\tfor i := range nums {\\n\\t\\tans[i] = nums[nums[i]]\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc buildArray(nums []int) []int {\\n    ans := make([]int, len(nums))\\n\\tfor i := range nums {\\n\\t\\tans[i] = nums[nums[i]]\\n\\t}\\n\\n\\treturn ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1350101,
                "title": "o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int maxNum = nums.size();\\n        for(int i=0; i<nums.size(); i++) {\\n            nums[i] = nums[i] + (nums[nums[i]]%maxNum )*maxNum;\\n        }\\n        for(int i=0; i<nums.size(); i++) {\\n            nums[i] = nums[i]/maxNum;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int maxNum = nums.size();\\n        for(int i=0; i<nums.size(); i++) {\\n            nums[i] = nums[i] + (nums[nums[i]]%maxNum )*maxNum;\\n        }\\n        for(int i=0; i<nums.size(); i++) {\\n            nums[i] = nums[i]/maxNum;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1326020,
                "title": "python-single-line-solution-very-easy-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[nums[i]] for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[nums[i]] for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1325071,
                "title": "python3-one-liner",
                "content": "```\\ndef buildArray(self, nums: List[int]) -> List[int]:\\n    return [nums[i] for i in nums]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef buildArray(self, nums: List[int]) -> List[int]:\\n    return [nums[i] for i in nums]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1324667,
                "title": "c-one-line-linq-solution",
                "content": "```\\npublic int[] BuildArray(int[] nums) \\n        => nums.Select(n => nums[n]).ToArray();        \\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] BuildArray(int[] nums) \\n        => nums.Select(n => nums[n]).ToArray();        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314368,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int j=nums[i];\\n            arr[i]=nums[j];\\n        }\\n        return arr;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int j=nums[i];\\n            arr[i]=nums[j];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3805281,
                "title": "this-is-right-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        // int a=nums.length;\\n        int arr[]=new int[nums.length];\\n        int i=0;\\n        while(i<nums.length){\\n          arr[i] =nums[nums[i]];\\n          i++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        // int a=nums.length;\\n        int arr[]=new int[nums.length];\\n        int i=0;\\n        while(i<nums.length){\\n          arr[i] =nums[nums[i]];\\n          i++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3683553,
                "title": "1920-build-array-from-permutation-100-easy-java-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[] = new int[nums.length];\\n\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int arr[] = new int[nums.length];\\n\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579606,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> buildArray(vector<int>& nums) {\\n\\t\\n        vector<int> ans ; \\n        for(int i=0 ;i<nums.size() ; i++){\\n            ans.push_back(nums[nums[i]]);\\n        }\\n        return ans ; \\n    }\\n};",
                "solutionTags": [
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> buildArray(vector<int>& nums) {\\n\\t\\n        vector<int> ans ; \\n        for(int i=0 ;i<nums.size() ; i++){\\n            ans.push_back(nums[nums[i]]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3507047,
                "title": "simplest-efficient-c-code-time-o-n-space-o-n",
                "content": "# Intuition\\nThe problem asks us to build an array arr of the same length as the given array nums, where arr[i] is equal to nums[nums[i]]. This can be done by iterating over the given array nums and for each index i, assigning the value at index nums[i] in nums to arr[i].\\n\\n# Approach\\nWe can iterate over the given array nums using a for loop, and for each index i, we can set arr[i] to nums[nums[i]]. We also need to set the value of *returnSize to numsSize, which is the size of the input array.\\n\\n# Complexity\\n- Time complexity: $O(n)$, where n is the size of the input array. We iterate over the array only once, assigning each element to the correct position in arr.\\n\\n- Space complexity: $O(n)$, where n is the size of the input array. We create an array of the same size as the input array to store the result.\\n\\n# Code\\n```\\nint* buildArray(int* nums, int numsSize, int* returnSize){\\n    int*arr = (int*)malloc(numsSize*sizeof(int));\\n    *returnSize = numsSize;\\n    for(int i=0;i<numsSize;i++){\\n        arr[i] = nums[nums[i]];\\n    }\\n    return arr;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint* buildArray(int* nums, int numsSize, int* returnSize){\\n    int*arr = (int*)malloc(numsSize*sizeof(int));\\n    *returnSize = numsSize;\\n    for(int i=0;i<numsSize;i++){\\n        arr[i] = nums[nums[i]];\\n    }\\n    return arr;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3496544,
                "title": "build-array-from-permutation-java-solution-explained-1ms-runtime-beats-94-92",
                "content": "# Intuition\\nResultant array has to be of the same length as that of given array.\\n\\n# Approach\\n1. Declare the ans[] array of the same length as that of the nums[] array.\\n2. Iterate for each element of the ans[] array where each element is a value of num[nums[i]].\\n3. Store the value and return the array.\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i = 0 ; i < nums.length ; i++){\\n            ans[i] = nums[nums[i]];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i = 0 ; i < nums.length ; i++){\\n            ans[i] = nums[nums[i]];\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482047,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++) ans.push_back(nums[nums[i]]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0; i<nums.size(); i++) ans.push_back(nums[nums[i]]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3478374,
                "title": "java-easy-solution-for-beginners",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int [] ans = new int [nums.length];\\n        for(int i =0;i<nums.length;i++){\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int [] ans = new int [nums.length];\\n        for(int i =0;i<nums.length;i++){\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208123,
                "title": "simple-3-line-code-in-c-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.emplace_back(nums[nums[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int>ans;\\n        for(int i=0;i<nums.size();i++){\\n            ans.emplace_back(nums[nums[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3124554,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n\\n        vector<int> Ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            Ans.push_back(nums[nums[i]]);\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n\\n        vector<int> Ans;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n            Ans.push_back(nums[nums[i]]);\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979192,
                "title": "simple-java-solution-runtime-1-ms-beats-99-96-of-the-available-solutions",
                "content": "# Intuition\\nSimple array programming.\\n\\n# Approach\\nUsing Java array programming.\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public int[] buildArray(int[] nums) \\n    {\\n        int n = nums.length;\\n        int a[] = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            a[i] = nums[nums[i]];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int[] buildArray(int[] nums) \\n    {\\n        int n = nums.length;\\n        int a[] = new int[n];\\n        for(int i=0; i<n; i++)\\n        {\\n            a[i] = nums[nums[i]];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973839,
                "title": "c-easiest-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n        vector<int> ans(nums.size(),0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n        vector<int> ans(nums.size(),0);\\n\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2783325,
                "title": "easy-c-o-n-soln-faang-interview-optimized-code",
                "content": "\\u2714 Extremely easy approach !\\n\\n[Self Explainatory]\\n\\n## Upvote if it helps \\uD83D\\uDE4F\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> result;\\n        for(auto i = 0 ; i < nums.size() ; i++){\\n            result.push_back(nums[nums[i]]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> result;\\n        for(auto i = 0 ; i < nums.size() ; i++){\\n            result.push_back(nums[nums[i]]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2779773,
                "title": "c-clean-easy-code",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> buildArray(vector<int> &nums)\\n        {\\n            vector<int> ans;\\n            for (int i = 0; i < nums.size(); i++)  ans.push_back(nums[nums[i]]); \\n            return ans;\\n        }\\n};\\n\\n//  TC -> O(N)\\n// SC -> O(N)\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        vector<int> buildArray(vector<int> &nums)\\n        {\\n            vector<int> ans;\\n            for (int i = 0; i < nums.size(); i++)  ans.push_back(nums[nums[i]]); \\n            return ans;\\n        }\\n};\\n\\n//  TC -> O(N)\\n// SC -> O(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2703556,
                "title": "simple-java-solution",
                "content": "# class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int a[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            a[i]=nums[nums[i]];\\n        }\\n        return a;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int a[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            a[i]=nums[nums[i]];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2601959,
                "title": "c-o-1-space-solution-would-work-even-if-n-is-large-with-brief-explanation",
                "content": "1. Observe the cycle that get\\'s formed. Let\\'s say we start at `i\\'th` index. At `nums[i]`, we copy `nums[nums[i]]`. Update `i` to value of `nums[i]` before updation. This goes on till we don\\'t reach the index we started from.\\n2. To make sure we process every element only once, mark them negative indicating it\\'s processed.\\n3. In the end, change sign of every element back to positive.\\n```\\n    vector<int> buildArray(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] > 0) {\\n                int start_num = nums[i];\\n                int start_i = i;\\n                int curr_i = i;\\n                while(nums[curr_i] != start_i) {\\n                    int prev_i = nums[curr_i];\\n                    nums[curr_i] = -nums[nums[curr_i]];\\n                    curr_i = prev_i;\\n                }\\n                nums[curr_i] = -start_num;\\n            }\\n        }\\n        for(int i = 0; i < nums.size(); i++) {\\n            nums[i] = -nums[i];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> buildArray(vector<int>& nums) {\\n        for(int i = 0; i < nums.size(); i++) {\\n            if(nums[i] > 0) {\\n                int start_num = nums[i];\\n                int start_i = i;\\n                int curr_i = i;\\n                while(nums[curr_i] != start_i) {\\n                    int prev_i = nums[curr_i];\\n                    nums[curr_i] = -nums[nums[curr_i]];\\n                    curr_i = prev_i;\\n                }\\n                nums[curr_i] = -start_num;\\n            }\\n        }\\n        for(int i = 0; i < nums.size(); i++) {\\n            nums[i] = -nums[i];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2573328,
                "title": "c-solution-with-0ms-run-time-best-approach-easypezy",
                "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        int size = nums.size();\\n        for(int i=0;i<size;i++){\\n            ans.push_back(nums[nums[i]]);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        int size = nums.size();\\n        for(int i=0;i<size;i++){\\n            ans.push_back(nums[nums[i]]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2569379,
                "title": "java-most-simple-solution",
                "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\t\\n        int [] ans = new int[nums.length];\\n        for(int i = 0 ; i<nums.length ; i++){\\n            int check = nums[i];\\n            ans[i] = nums[check];\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\t\\n        int [] ans = new int[nums.length];\\n        for(int i = 0 ; i<nums.length ; i++){\\n            int check = nums[i];\\n            ans[i] = nums[check];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2501501,
                "title": "o-n-6-lines-code-easy-to-understand-java",
                "content": "```\\nclass Solution {\\npublic int[] buildArray(int[] nums) {\\nint [] ans= new int[nums.length];\\nfor(int i=0;i<nums.length;i++){\\nans[i]=nums[nums[i]];\\n}\\n return ans;\\n}\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic int[] buildArray(int[] nums) {\\nint [] ans= new int[nums.length];\\nfor(int i=0;i<nums.length;i++){\\nans[i]=nums[nums[i]];\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2491848,
                "title": "o-n-time-o-n-space-solution-o-1-space-follow-up-question-solution",
                "content": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++)\\n            res[i] = nums[nums[i]];\\n        return res;\\n    }\\n    \\n    // For the follow-up question, solution\\n     public int[] buildArrayFollowUp(int[] nums) {\\n       int n = nums.length;\\n        for(int i = 0; i < n; i++)\\n            nums[i] = nums[i] + n * (nums[nums[i]] % n);\\n        for(int i = 0; i < n; i++)\\n            nums[i] /= n;\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++)\\n            res[i] = nums[nums[i]];\\n        return res;\\n    }\\n    \\n    // For the follow-up question, solution\\n     public int[] buildArrayFollowUp(int[] nums) {\\n       int n = nums.length;\\n        for(int i = 0; i < n; i++)\\n            nums[i] = nums[i] + n * (nums[nums[i]] % n);\\n        for(int i = 0; i < n; i++)\\n            nums[i] /= n;\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469109,
                "title": "runtime-11-ms-faster-than-98-04-of-c-online-submissions",
                "content": "```\\n/***  1920 . Build Aray from Permutation - CPP17 ***/\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();++i){\\n            ans.push_back(nums[nums[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\n/***  1920 . Build Aray from Permutation - CPP17 ***/\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();++i){\\n            ans.push_back(nums[nums[i]]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2438761,
                "title": "python-2-line-code",
                "content": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        arr = []\\n        for i in range(len(nums)):\\n            arr.append(nums[nums[i]])\\n        return arr\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        arr = []\\n        for i in range(len(nums)):\\n            arr.append(nums[nums[i]])\\n        return arr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428947,
                "title": "build-array-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n\\n        vector<int> ans;                 //initializing vector\\n        for(int i=0;i<nums.size();i++)\\n            ans.push_back(nums[nums[i]]);      // giving values to vector\\n  \\n        return ans;                         //returning vector\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n\\n        vector<int> ans;                 //initializing vector\\n        for(int i=0;i<nums.size();i++)\\n            ans.push_back(nums[nums[i]]);      // giving values to vector\\n  \\n        return ans;                         //returning vector\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397250,
                "title": "c-solution-in-just-4-lines-super-easy",
                "content": "\\t\\tvector<int>vec;\\n        for(int i=0;i<nums.size();i++)\\n            vec.push_back(nums[nums[i]]);\\n        return vec;\\n\\t\\t//Please upvote if you like it",
                "solutionTags": [],
                "code": "\\t\\tvector<int>vec;\\n        for(int i=0;i<nums.size();i++)\\n            vec.push_back(nums[nums[i]]);\\n        return vec;\\n\\t\\t//Please upvote if you like it",
                "codeTag": "Unknown"
            },
            {
                "id": 2351331,
                "title": "java-solution-normal-and-memory-optimised-o-1",
                "content": "```\\n// TC: O(N), SC: O(N)\\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < nums.length; ++i){\\n            ans[i] = nums[nums[i]];\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n}\\n\\n\\n// Memory optimised solution:\\n// TC: O(N), SC: O(1) because no extra space is taken\\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        for(int i = 0; i < n; ++i){\\n            nums[i] += n * (nums[nums[i]] % n);\\n        }\\n\\n        for(int i = 0; i < n; ++i){\\n            nums[i] /= n;\\n        }\\n\\t\\t\\n        return nums;\\n    }\\n}\\n```\\n\\nnums[i] += n * (nums[nums[i]] % n) OR **nums[i] = n * (nums[nums[i]] % n) + nums[i]** is based upon **Euclid\\'s division algorithm a = bq + r**\\nSee google to know more about it. Its a 10th standard concept.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TC: O(N), SC: O(N)\\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < nums.length; ++i){\\n            ans[i] = nums[nums[i]];\\n        }\\n\\t\\t\\n        return ans;\\n    }\\n}\\n\\n\\n// Memory optimised solution:\\n// TC: O(N), SC: O(1) because no extra space is taken\\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        for(int i = 0; i < n; ++i){\\n            nums[i] += n * (nums[nums[i]] % n);\\n        }\\n\\n        for(int i = 0; i < n; ++i){\\n            nums[i] /= n;\\n        }\\n\\t\\t\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2337920,
                "title": "java-solution-s-o-with-explanation",
                "content": "\\n\\n\\n```\\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n       for(int i=0;i<n;i++)\\n\\t\\t {\\n\\t\\t\\t nums[i] =( (nums[nums[i]] % n) * n) + nums[i];\\n\\t\\t }\\n\\t\\t for(int i =0;i<n;i++)\\n\\t\\t \\tnums[i] = nums[i]/n;\\n\\t\\t \\t return nums;\\n    }\\n}\\n\\n```\\n\\nTo reduce space complexity we have to make change in the nums array only. so we store both values original as well as new value in the nums array using ( nums [ nums [ i ] ] % n ) + nums [ i ]  formula.\\n\\nnums : [0, 2, 1, 5, 3, 4]\\nnew nums : [0, 8, 13, 29, 33]\\n\\n13 = 2 * 6 (length of array which is 6) + 1\\nHere 2 is nums[nums[i]]    and 1 is nums[i]\\n\\nwe can get original value by doing %      i.e. 13 % 6 = 1\\nwe can get new value by doing /       i.e. 13 / 6 = 2 \\n\\n ( nums [ nums [ i ] ] % n ) + nums [ i ]  In this formula % is use to get the original value from array\\n for eg. nums[2] =  ( nums [ nums [ 2 ] ] % 6 ) + nums [ 2 ]\\n\\t\\t\\t\\t\\t\\t  =  ( nums [ 1 ] % 6 ) + nums [ 2 ]  Here nums[1] will have new value 8 but we want the original value for this reason we use %",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n       for(int i=0;i<n;i++)\\n\\t\\t {\\n\\t\\t\\t nums[i] =( (nums[nums[i]] % n) * n) + nums[i];\\n\\t\\t }\\n\\t\\t for(int i =0;i<n;i++)\\n\\t\\t \\tnums[i] = nums[i]/n;\\n\\t\\t \\t return nums;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2313746,
                "title": "build-array-from-permutation",
                "content": "\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i= 0; i< nums.length ; i++)\\n        {\\n            arr[i] = nums[nums[i]];\\n        }\\n        return arr;\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i= 0; i< nums.length ; i++)\\n        {\\n            arr[i] = nums[nums[i]];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2241831,
                "title": "easy-to-understand-java-beginner-level",
                "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int i =0;\\n        while(i < n){\\n            ans[i] = nums[nums[i]];\\n            i++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        \\n        int n = nums.length;\\n        int[] ans = new int[n];\\n        int i =0;\\n        while(i < n){\\n            ans[i] = nums[nums[i]];\\n            i++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2201503,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> res;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=nums[i];\\n            res.push_back(nums[temp]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int> res;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            int temp=nums[i];\\n            res.push_back(nums[temp]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2090070,
                "title": "c-simple-4-lines-of-code-beats-95",
                "content": "```\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            res.push_back(nums[nums[i]]);\\n        }\\n        return res;\\n    }\\n};\\nplz upvote;",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        vector<int>res;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            res.push_back(nums[nums[i]]);\\n        }\\n        return res;\\n    }\\n};\\nplz upvote;",
                "codeTag": "Unknown"
            },
            {
                "id": 2065966,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [ nums[nums[i]] for i in range(len(nums)) ]\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [ nums[nums[i]] for i in range(len(nums)) ]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064918,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        \\n        for i in range(len(nums)):\\n            ans.append(nums[nums[i]])\\n            \\n        return ans\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        \\n        for i in range(len(nums)):\\n            ans.append(nums[nums[i]])\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1991631,
                "title": "java-very-easy-clean-space-o-n-time-o-n-93-faster",
                "content": "# JAVA O(n) Esay friendly solution || 93% faster\\n\\nWe create and auxiliary int[ ] array with the same length as the one given.\\n\\nFor each int in `res` we insert the int in nums[nums[i]]\\n\\nFinally, we return the auxiliary array!!\\n\\nEasy as that, hope you have understand it, leave a like and comment if you have questions ;)\\n\\n```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for(int i = 0; i < nums.length;i++){\\n            res[i] = nums[nums[i]];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] res = new int[nums.length];\\n        for(int i = 0; i < nums.length;i++){\\n            res[i] = nums[nums[i]];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1949186,
                "title": "o-1-solution-c",
                "content": "Time Complexity - T= 2n = O(n)\\nSpace COmplexity = O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& A) {\\n        int n = A.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            if(A[i] >= i)\\n                A[i]=(A[i]*n) + (A[A[i]%n]);\\n            else\\n                A[i]=(A[i]*n) + (A[A[i]%n])/n;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            A[i]%=n;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& A) {\\n        int n = A.size();\\n        \\n        for(int i=0; i<n; i++) {\\n            if(A[i] >= i)\\n                A[i]=(A[i]*n) + (A[A[i]%n]);\\n            else\\n                A[i]=(A[i]*n) + (A[A[i]%n])/n;\\n        }\\n        \\n        for(int i=0; i<n; i++) {\\n            A[i]%=n;\\n        }\\n        return A;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1911063,
                "title": "python3-brute-force-optimal-brute-force",
                "content": "## first sol.\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        # time:O(N) space:O(N)\\n        \\n         ans=[0]*len(nums)\\n         for i in range(len(nums)):\\n             ans[i] = nums[nums[i]]\\n         return ans\\n```\\n### simple short and one-liner\\n\\n```\\n\\t# time:O(N) space:O(N)\\n\\treturn [nums[i] for i in nums]\\n```\\n## second sol.\\n```\\n\\t# time:O(N) space:O(1)\\n\\tn=len(nums)\\n\\t#need to modify nums such that nums[i] contains 2 number(initial value & final value)\\n\\t#such that nums[i]//n will give final val & nums[i]%n will gives initial val\\n\\t#a = qb + r where  b=a//q & r = a % q\\n\\t# here lets take a = nums[i], q = len(nums), b=nums[nums[i]], r = nums[i]\\n\\n\\tfor i in range(len(nums)):\\n\\t\\tnums[i]=n*(nums[nums[i]]%n)+nums[i]\\n\\tfor i in range(len(nums)):\\n\\t\\tnums[i]=nums[i]//n\\n\\treturn nums\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        # time:O(N) space:O(N)\\n        \\n         ans=[0]*len(nums)\\n         for i in range(len(nums)):\\n             ans[i] = nums[nums[i]]\\n         return ans\\n```\n```\\n\\t# time:O(N) space:O(N)\\n\\treturn [nums[i] for i in nums]\\n```\n```\\n\\t# time:O(N) space:O(1)\\n\\tn=len(nums)\\n\\t#need to modify nums such that nums[i] contains 2 number(initial value & final value)\\n\\t#such that nums[i]//n will give final val & nums[i]%n will gives initial val\\n\\t#a = qb + r where  b=a//q & r = a % q\\n\\t# here lets take a = nums[i], q = len(nums), b=nums[nums[i]], r = nums[i]\\n\\n\\tfor i in range(len(nums)):\\n\\t\\tnums[i]=n*(nums[nums[i]]%n)+nums[i]\\n\\tfor i in range(len(nums)):\\n\\t\\tnums[i]=nums[i]//n\\n\\treturn nums\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1883127,
                "title": "python-soln-for-beginners",
                "content": "Please Upvote :)\\n```class Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        lst=[]\\n        for i in range(0,len(nums)):\\n            lst.append(nums[nums[i]])\\n        return lst\\n",
                "solutionTags": [],
                "code": "Please Upvote :)\\n```class Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        lst=[]\\n        for i in range(0,len(nums)):\\n            lst.append(nums[nums[i]])\\n        return lst\\n",
                "codeTag": "Java"
            },
            {
                "id": 1856306,
                "title": "python-simple-approach-and-beginner-friendly",
                "content": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        arr = []\\n        for i in range (0,len(nums)):\\n            arr.append(nums[nums[i]])\\n        return arr\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        arr = []\\n        for i in range (0,len(nums)):\\n            arr.append(nums[nums[i]])\\n        return arr\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1817695,
                "title": "easy-modern-c",
                "content": "```\\nvector<int> buildArray(vector<int>& nums) {\\n    vector<int> ans(nums.size());\\n    transform(begin(nums), end(nums), begin(ans), [&](int n){ return nums[n]; });\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> buildArray(vector<int>& nums) {\\n    vector<int> ans(nums.size());\\n    transform(begin(nums), end(nums), begin(ans), [&](int n){ return nums[n]; });\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1801351,
                "title": "python-63-33",
                "content": "first ever lines of python\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        result = [0] * len(nums)\\n        \\n        for n in nums:\\n            result[n] = nums[nums[n]]\\n            \\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        result = [0] * len(nums)\\n        \\n        for n in nums:\\n            result[n] = nums[nums[n]]\\n            \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790010,
                "title": "python-7-ways-map-list-comp-accumulate-reduce-cyclic-cascade-euclidean-and-bit-encoding",
                "content": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return list(map(lambda i: nums[i] ,nums))\\n        \\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[i] for i in nums] \\n\\n    def buildArray(self, nums: List[int]) -> List[int]: # accumulate returns generator, needs to be listified; initial= is keyword only argument, needed here because otherwise default for 1st element is identity and bypassed func, then we need to remove first element because initial= creates one more element\\n        return list(itertools.accumulate(nums, lambda i,j: nums[j],initial=nums[0]))[1:]\\n    \\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return functools.reduce(lambda init,i: init+[nums[i]], nums,[])\\n        \\n    #follow up O(1) space : follow cyclic chain, mark processed node to negative -1 (add -1 to mark special case 0)\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        for i,v in enumerate(nums):\\n            if v>=0:\\n                nums[i],oldValAtI,j=nums[v],v,v\\n                while nums[j]!=i:\\n                    nums[j],j=-1-nums[nums[j]],nums[j]\\n                nums[j]=-oldValAtI-1\\n        for i in range(len(nums)):\\n            nums[i]=-nums[i]-1 if nums[i]<0 else nums[i]\\n        return nums\\n                    \\n    #follow up O(1) space:use Eucledian formula to encode both old and new info into a new number\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        q=len(nums)\\n        print(q)\\n        for i in range(q):\\n            nums[i]=nums[nums[i]]%q*q+nums[i] # as nums[i] is distinct,all new num is distinct too\\n        print(nums)    \\n        for i in range(q):\\n            nums[i]=nums[i]//q\\n        return nums\\n        \\n    #follow up O(1) space:use higher bits and lower bits to store old and new info\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        zero=None\\n        for i,v in enumerate(nums):\\n            if v==0: # zero is special case because >>16 ==> 0\\n                zero=i\\n            #nums[i] = old | new    \\n            nums[i]=nums[i]<<16 | (t if (t:=nums[nums[i]]>>16) >0 or nums[i]==zero else nums[nums[i]])\\n        for i in range(len(nums)):\\n            nums[i]=nums[i]& (1<<16)-1\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return list(map(lambda i: nums[i] ,nums))\\n        \\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return [nums[i] for i in nums] \\n\\n    def buildArray(self, nums: List[int]) -> List[int]: # accumulate returns generator, needs to be listified; initial= is keyword only argument, needed here because otherwise default for 1st element is identity and bypassed func, then we need to remove first element because initial= creates one more element\\n        return list(itertools.accumulate(nums, lambda i,j: nums[j],initial=nums[0]))[1:]\\n    \\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        return functools.reduce(lambda init,i: init+[nums[i]], nums,[])\\n        \\n    #follow up O(1) space : follow cyclic chain, mark processed node to negative -1 (add -1 to mark special case 0)\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        for i,v in enumerate(nums):\\n            if v>=0:\\n                nums[i],oldValAtI,j=nums[v],v,v\\n                while nums[j]!=i:\\n                    nums[j],j=-1-nums[nums[j]],nums[j]\\n                nums[j]=-oldValAtI-1\\n        for i in range(len(nums)):\\n            nums[i]=-nums[i]-1 if nums[i]<0 else nums[i]\\n        return nums\\n                    \\n    #follow up O(1) space:use Eucledian formula to encode both old and new info into a new number\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        q=len(nums)\\n        print(q)\\n        for i in range(q):\\n            nums[i]=nums[nums[i]]%q*q+nums[i] # as nums[i] is distinct,all new num is distinct too\\n        print(nums)    \\n        for i in range(q):\\n            nums[i]=nums[i]//q\\n        return nums\\n        \\n    #follow up O(1) space:use higher bits and lower bits to store old and new info\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        zero=None\\n        for i,v in enumerate(nums):\\n            if v==0: # zero is special case because >>16 ==> 0\\n                zero=i\\n            #nums[i] = old | new    \\n            nums[i]=nums[i]<<16 | (t if (t:=nums[nums[i]]>>16) >0 or nums[i]==zero else nums[nums[i]])\\n        for i in range(len(nums)):\\n            nums[i]=nums[i]& (1<<16)-1\\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763311,
                "title": "c-sol-with-explanation-4-lines-o-1-space-o-n-time",
                "content": "As all numbers are distinct and between **0** and **n-1**, increasing every element by **(nums[nums[i]] % n) * n** and then dividing by n will result in **nums[nums[i]] % n**. For example,\\n\\nLet **B + (C * N) = A**\\nNow, **A / N = C**\\nand, **A % N = B**\\n\\nNow, the question demands that you only put\\n**B = array element**,\\n**C = nums[nums[i]]**,\\n**N = array size**\\n\\n**Input:** 2 4 1 0 3\\n\\n```\\nB +     C   *N = A       A / N = C    A % N = B\\n2 + (1  % 5)*5 = 7       7 / 5 = 1\\n4 + (3  % 5)*5 = 19     19 / 5 = 3\\n1 + (19 % 5)*5 = 21     21 / 5 = 4\\n0 + (7  % 5)*5 = 10     10 / 5 = 2\\n3 + (10 % 5)*5 = 3       3 / 5 = 0\\n```\\n\\n**Output:** 1 3 4 2 0\\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)    nums[i]+=(nums[nums[i]]%n)*n;\\n        for(int i=0;i<n;i++)    nums[i]/=n;\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nB +     C   *N = A       A / N = C    A % N = B\\n2 + (1  % 5)*5 = 7       7 / 5 = 1\\n4 + (3  % 5)*5 = 19     19 / 5 = 3\\n1 + (19 % 5)*5 = 21     21 / 5 = 4\\n0 + (7  % 5)*5 = 10     10 / 5 = 2\\n3 + (10 % 5)*5 = 3       3 / 5 = 0\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<n;i++)    nums[i]+=(nums[nums[i]]%n)*n;\\n        for(int i=0;i<n;i++)    nums[i]/=n;\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1748262,
                "title": "python-solution-with-o-1-space",
                "content": "Achieve constant time by performing operations in-place using arithmetic transformations to essentially store multiple values in each element\\n\\n```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        \\n        for i in range(len(nums)):\\n            nums[i] += len(nums) * (nums[nums[i]] % len(nums))\\n            \\n        for i in range(len(nums)):      \\n            nums[i] //= len(nums)\\n                \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def buildArray(self, nums: List[int]) -> List[int]:\\n        \\n        for i in range(len(nums)):\\n            nums[i] += len(nums) * (nums[nums[i]] % len(nums))\\n            \\n        for i in range(len(nums)):      \\n            nums[i] //= len(nums)\\n                \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744132,
                "title": "c-2-approach-solution",
                "content": "1. By creating new vector and adding element into that:-\\n    Time Complexity = O[N]\\n\\tSpace Complexity = O[N]\\n```\\nvector<int> buildArray(vector<int>& nums) {\\n        vector<int> n;\\n        for(int i=0;i<nums.size();i++){\\n            n.push_back(nums[nums[i]]);\\n        }\\n        return n;     \\n    }\\n```\\n2. Now here comes a smart solution in which there is no need to create new array instead we manipulate into same vector array which saves us memory and reduces space complexity from O[N] to O[1].\\n```\\nvector<int> buildArray(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]+=nums.size()*(nums[nums[i]]%nums.size());\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]/=nums.size();\\n        }\\n        return nums;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nvector<int> buildArray(vector<int>& nums) {\\n        vector<int> n;\\n        for(int i=0;i<nums.size();i++){\\n            n.push_back(nums[nums[i]]);\\n        }\\n        return n;     \\n    }\\n```\n```\\nvector<int> buildArray(vector<int>& nums) {\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]+=nums.size()*(nums[nums[i]]%nums.size());\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]/=nums.size();\\n        }\\n        return nums;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734623,
                "title": "java-1ms-99-49-faster-easy",
                "content": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        if(nums.length==0) return null;\\n        int l=nums.length;\\n        int[] ans= new int[l];\\n        for(int i=0; i<l; i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        if(nums.length==0) return null;\\n        int l=nums.length;\\n        int[] ans= new int[l];\\n        for(int i=0; i<l; i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1730782,
                "title": "python3-single-line-code",
                "content": "```\\nreturn [nums[nums[i]] for i in range(len(nums))]\\n```",
                "solutionTags": [],
                "code": "```\\nreturn [nums[nums[i]] for i in range(len(nums))]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1654394,
                "title": "o-1-space-with-detailed-explanation",
                "content": "Copied not my original idea, just trying to help others understand\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n       \\n        // since all elements are < size of array\\n        // we can store both numbers at same index\\n        // let a & b be two number \\n        // c = a + b * n\\n        // c % n  =  a;\\n        // c / n  = b // int divison \\n        int n = nums.size();\\n        for(int i=0;i< n;i++){\\n            nums[i] += n * (nums[nums[i]] % n);\\n        }\\n        \\n        for(int i=0;i< n;i++)\\n            nums[i] /= n;\\n        \\n        return nums;\\n            \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n       \\n        // since all elements are < size of array\\n        // we can store both numbers at same index\\n        // let a & b be two number \\n        // c = a + b * n\\n        // c % n  =  a;\\n        // c / n  = b // int divison \\n        int n = nums.size();\\n        for(int i=0;i< n;i++){\\n            nums[i] += n * (nums[nums[i]] % n);\\n        }\\n        \\n        for(int i=0;i< n;i++)\\n            nums[i] /= n;\\n        \\n        return nums;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1597623,
                "title": "c-sc-o-1-and-tc-o-n",
                "content": "Simple tric of modulo arithmatic to store two elements at a place as one and then extract both as:\\narr[i] = a+(b%n)*n;\\na = arr[i]%n;\\nb = arr[i]/n;\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i] = nums[i]+(nums[nums[i]]%n)*n;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            nums[i] = nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n=nums.size();\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            nums[i] = nums[i]+(nums[nums[i]]%n)*n;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1810942,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1849019,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1723885,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1576296,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1979165,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1725590,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1575932,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1576357,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1719281,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1920864,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1810942,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1849019,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1723885,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1576296,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1979165,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1725590,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1575932,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1576357,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1719281,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1920864,
                "content": [
                    {
                        "username": "CyberMaestro",
                        "content": "1. reading the task \\n2. don\\'t understand anything. \\n3. solving the task\\n4. still don\\'t understand anything."
                    },
                    {
                        "username": "mawhadmd",
                        "content": "build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it."
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@raihansikdar](/raihansikdar) why can't you just do ans[i] = nums[i], why ans[i]=nums[nums[i]]; understood, the number of the second array is the index of the first"
                    },
                    {
                        "username": "ILikeChowFun",
                        "content": "[@raihansikdar](/raihansikdar) Aaaah thank you for that explanation"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "look at the examples more clearly, u will get an idea. forget the description just look at the examples. mention in the problem"
                    },
                    {
                        "username": "itsparaspatil",
                        "content": "This is the first problem that i am trying to solve in leetcode and i cannot understand anything. Maybe i am super dumb.\\n"
                    },
                    {
                        "username": "rahulteli3018",
                        "content": "Sam here "
                    },
                    {
                        "username": "IsmanDaiyrov",
                        "content": "not the best problem to start but with practice you will get better 100%"
                    },
                    {
                        "username": "Harshavardhan-create",
                        "content": "No, you just need little more practice that\\'s it"
                    },
                    {
                        "username": "lum7023",
                        "content": "Solution in the problem itself \\n0_\\u043E"
                    },
                    {
                        "username": "KS88",
                        "content": "Hi Folks,\\n\\nThose who posted the solution with extra O(n) space. If this was your first ever program on leetcode, I congratulate you. But please avoid posting such solution. This is shadowing the good ones with O(1) space which is the tricky one. \\n\\nThank you."
                    },
                    {
                        "username": "0xD503",
                        "content": "O(n) space complexity solution is actually better in speed, because you don't need spend time to make the math"
                    },
                    {
                        "username": "lsgraalq",
                        "content": "it took 30 minutes just to understand what i need to do)"
                    },
                    {
                        "username": "indranil_majee",
                        "content": "I couldn\\'t understand this solution by using O(1) space complexity using modulo operator to store 2 numbers\\n\\nWhy we cannot swap a and b to get the same solution\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        // int n= nums.size();\\n        // vector<int>ans;\\n        // for(int i=0;i<n;i++)\\n        // ans.push_back(nums[nums[i]]);\\n        \\n        // return ans;\\n\\n        int n= 1024;\\n        int size=nums.size();\\n        for(int i=0;i<size;i++)\\n        {\\n            \\n            //we can store 2 nos using this formula\\n            // x= a+(b%n)*n \\n            //a= x%n\\n            //b= x/n        \\n            int a= nums[i];\\n            int b= nums[nums[i]];\\n            nums[i]=a+(b%n)*n;\\n\\n        }\\n        for(int i=0;i<size;i++)\\n        {\\n            nums[i]=nums[i]/n;\\n        }\\n        return nums;\\n    }\\n};\\n"
                    },
                    {
                        "username": "FSLV",
                        "content": "The trick is that as long as a,b < n dividing an int by n yields 0 and %n instead gives the same int variable. If you switched a and b then nums would be returned unchanged. "
                    },
                    {
                        "username": "tonynan",
                        "content": "\"\"\"\\nreturn map(lambda i: nums[i], nums)\\n\"\"\"\\nnot sure if this is really what the interviewer wants."
                    },
                    {
                        "username": "user0458gi",
                        "content": "\"\"\"return [nums[i] for i in nums]\"\"\""
                    },
                    {
                        "username": "vipashasable3005",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }return ans;\\n    }\\n}"
                    },
                    {
                        "username": "sureshcodes",
                        "content": "Nice man.\\n"
                    },
                    {
                        "username": "trinitykhuman",
                        "content": "takes more than 10 mins to understand the question"
                    }
                ]
            },
            {
                "id": 1837353,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1799932,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1795051,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1987762,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1983742,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1909130,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1818000,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1795288,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1782152,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 1758768,
                "content": [
                    {
                        "username": "secreto",
                        "content": "Now Leetcode is mostly focused on maths approch "
                    },
                    {
                        "username": "Muawb",
                        "content": "What is this ans[i] = nums[nums[i]]; ?"
                    },
                    {
                        "username": "kishokkumar",
                        "content": "Input: nums = [0,2,1,5,3,4]\\nOutput: [0,1,2,4,5,3]\\n\\nlet us consider i as 1\\nso, nums[i] = 2 , \\nnums[2] = 1 \\n\\nso num[2] value will place on index 1 of \"ans[]\" array."
                    },
                    {
                        "username": "pranavkolapkar167",
                        "content": "Can someone please explain the problem to me. I am not getting how the input list which is  nums = [0,2,1,5,3,4]  gets converted to Output: [0,1,2,4,5,3].\\n\\nHow does nums[nums[i]] transforms the list  [0,2,1,5,3,4]  to  [0,1,2,4,5,3]\\n"
                    },
                    {
                        "username": "yarjuny234",
                        "content": "1.nums[0]=0; ans[0]=nums[nums[0]]=nums[0]=0\\n2.nums[1]=2;\\nans[1]=nums[nums[1]]=nums[2]=1\\nand so on"
                    },
                    {
                        "username": "shubham-31",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        for(int i=0;i<nums.length;i++){\\n            nums[i]=nums[nums[i]];\\n        }\\n        return nums;\\n    }\\n}\\nWhy this solution is wrong??????"
                    },
                    {
                        "username": "close27",
                        "content": "This might help -\nz = a + n*b, where a,b < n\nz/n = 0 + b = b\nz % n = a + 0 = a"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "rishavm",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int [nums.length];\\n        result( nums, ans, 0);\\n        return ans;\\n    }\\n    public void result( int[] nums, int[] ans, int i ){\\n        if( i == nums.length ) return;\\n        ans[i] = nums[nums[i]];\\n        result( nums, ans, (i+1));\\n    }\\n}\\n//////////////////////////////////////////////////////////////////////////////////////////////////////\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n     int [] temp = new int[nums.length];\\n\\n     for(int i=0;i<nums.length;i++){\\n         temp[i]=nums[nums[i]];\\n     } \\n\\n     return temp;  \\n    }\\n}\\n\\nThere are 2 solutions 1st one executed in o(0) and 2nd one executed in o(1).\\ncan someone explain why ?\\neven if it is recursion, the no. of times method is going to be called is the same as the no.of times loop is going to be executed, plus one extra operation of calling of a method is also being executed, then , how the time complexity in recursion method(1st case) is less than the loop method (2nd case). \\n\\n\\n"
                    },
                    {
                        "username": "kaushikc44",
                        "content": "\\nSimple do nothing more than this, however its O(n) if you find the O(1) solution do provide thanks \\n` ans = []\\n        for i in nums:\\n            ans.append(nums[i])\\n        return ans `"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "beats 92% in space complexity\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int jugad[1234] = {0};\\n        for(int i=0;i<nums.size();i++){\\n            jugad[i] = nums[i]; \\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i] = jugad[jugad[i]] ;\\n        }\\n        return nums;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "developerkaran025",
                        "content": "yo bro"
                    },
                    {
                        "username": "Hack_Shiba",
                        "content": " `class Solution {\\n    int k = 0;\\n    public int[] buildArray(int[] nums) {\\n\\n        if(k == nums.length)\\n        {\\n            return nums;\\n        }\\n        int res = nums[nums[k++]];\\n        buildArray(nums);\\n        nums[--k] = res;\\n        return nums;\\n    }\\n}`"
                    }
                ]
            },
            {
                "id": 2075623,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2070553,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2068798,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2068431,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2055332,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2045735,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2045722,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2038275,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2033995,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2022311,
                "content": [
                    {
                        "username": "bhavleen_singh_fsd",
                        "content": "Easy for a reason."
                    },
                    {
                        "username": "Musfik41",
                        "content": "SUPER EASY\\uD83D\\uDE05"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I agree it is easy using extra space but \\nthe problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "kesava-karri",
                        "content": "I know *it is not ideal* but for the _follow up question_ can the interviewer ask if I could declare thousand variables (1 <= nums.length <= 1000) and store each old value in the respective variables? (it would still lead to constant space right?)"
                    },
                    {
                        "username": "mawhadmd",
                        "content": "\"build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\" literally the answer.\n\n Also if you ask what if nums[i] is greater than the length: 0 <= nums[i] < nums.length constarints"
                    },
                    {
                        "username": "markosmalek3",
                        "content": "to clarify consider each number in the original array an index and the answer should be whatever number that index refer to also in the original array ans[i] = nums[nums[i]]\nwhat is inside nums[nums[i]] is the numbers of the array as you go then as the code written its considered an index \nhope this helps"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "i solve it but i dont understand  the problem yet lol"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "really this is an easy problem ?? i think i am dumb or something lol"
                    },
                    {
                        "username": "kesava-karri",
                        "content": "The problem\\'s intention is to do the follow-up question i.e., try to solve this by modifying the array in place (O(1) space)."
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "This is just very poorly described, but it is easy. I recommend to find the explanation on youtube and you will be surprised"
                    },
                    {
                        "username": "Kirill_JSDEV",
                        "content": "If we read examples - we have to get the same array as a result..."
                    },
                    {
                        "username": "12213100",
                        "content": "what the question is asking\\n"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "I haven\\'t done C programming in a while, but could someone please explain why are we initialising *returnSize = numSize. I mean, what are the paramaters in this function, I don\\'t get it?"
                    },
                    {
                        "username": "Denis2611",
                        "content": "[@shivansh7623](/shivansh7623)sorry i write in Java"
                    },
                    {
                        "username": "shivansh7623",
                        "content": "[@Denis2611](/Denis2611) but in C it has given 3 formal arguments"
                    },
                    {
                        "username": "Denis2611",
                        "content": "buildArray(int[] nums) <- parametr input"
                    }
                ]
            },
            {
                "id": 2014026,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 2004648,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1999269,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1987093,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1986884,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1964039,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1957947,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1950560,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1930654,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1917741,
                "content": [
                    {
                        "username": "Chenbao2021",
                        "content": "Just for some context,\\nthis is a exercice of cryptography .\\nthe input is the original message .\\nand what we return is the crypted message."
                    },
                    {
                        "username": "omijagtap304",
                        "content": "Yes Finally My first code run Successfully "
                    },
                    {
                        "username": "lmholland",
                        "content": "What is the point of the language being used in these questions? English is my mother language and sometimes I have to read these strings of words 3-4 times and still have no idea what it says. Is it just a bottle neck to filter out as many people as possible?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "i sumbit the code it is better than 99 % i improved memory no changes in code jus did not used ans variable... code  now takes a lot of time ... now submit previous code 99% better code....now it becomes bad.... are you dumb leet code\\n"
                    },
                    {
                        "username": "vaishnavikennedy",
                        "content": "EXAMPLE 1 [0,2,1,5,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 0\\n    nums[1] 2\\n    nums[2] 1\\n    nums[3] 5\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[0] = 0\\n    nums[nums[1]],= nums[2] = 1\\n    nums[nums[2]],= nums[1] = 2\\n    nums[nums[3]],= nums[5] = 4\\n    nums[nums[4]],= nums[3] = 5\\n    nums[nums[5]],= nums[4] = 3\\nEXAMPLE 2 [5,0,1,2,3,4]\\n    STEP 1: given\\n\\n    nums[0]= 5\\n    nums[1] 0\\n    nums[2] 1\\n    nums[3] 2\\n    nums[4] 3\\n    nums[5] 4\\n\\n    STEP 2 : ans\\n\\n    nums[nums[0]],= nums[5] = 4\\n    nums[nums[1]],= nums[0] = 5\\n    nums[nums[2]],= nums[1] = 0\\n    nums[nums[3]],= nums[2] = 1\\n    nums[nums[4]],= nums[3] = 2\\n    nums[nums[5]],= nums[4] = 3"
                    },
                    {
                        "username": "salmanMaqbool",
                        "content": "what actually question is saying that , it does its internal permutation with these we gey sorted array actually\\ne.g\\nnums=[0,2,1,5,3,4]\\ncreate new array with same length as nums put these elemnts in new array and it will do automatic permutations and we will get an array\\ne.g\\nint n=nums.length;\\n        int arr[]=new int [n];\\n        for(int i=0;i<nums.length;i++)\\n        {\\n         arr[i]=nums[nums[i]];\\n        }\\n        return arr;\\n    }\\nwhen i=0 ,nums[0]=0 and nums[nums[0]]=nums[0]=0;\\ni=1,nums[1]=2 and nums[nums[1]]=nums[2]=1\\nlike wise  we get arr[0,1,2,3,4,5]\\n"
                    },
                    {
                        "username": "bapatanuparth",
                        "content": "Why is this?"
                    },
                    {
                        "username": "sahilthakurxyz",
                        "content": "after some time i\\'ll able to solve question it is very simple read the array 0th integer make that arr[arr[0]],   take 1th position which is 2 make arr[arr[2]] now check which integer on arr[2] that is 1 so put in the 1th postion similarly the same next"
                    },
                    {
                        "username": "hafezachu",
                        "content": "The function buildArray takes an array of numbers called nums as a parameter.\\nThe function creates an empty array called ans to store the result.\\nThe function uses a for loop to iterate through the input array from index 0 to index nums.length - 1.\\nInside the loop, the function gets the value at the current index and assigns it to a variable called val.\\nThen, the function gets the value at the index equal to val in the input array and assigns it to a variable called newVal. The function pushes the newVal to the result array using the push method. After the loop ends, the function returns the result array as the output."
                    },
                    {
                        "username": "gyanuKharel",
                        "content": "The idea here is to store the new values in the nums[] array itself. We can achieve this by encoding the current nums[i] and nums[nums[i]] as a single int value. Then use another loop to decode the nums[nums[i]] out. \\n\\n `\\npublic class Solution {\\n    public int[] BuildArray(int[] nums) {\\n        int n = nums.Length;\\n        for(int i = 0; i < n; i++)\\n        {\\n            nums[i] += (nums[nums[i]] % n) * n;\\n        }\\n\\n        for(int i=0; i < n; i++)\\n        {\\n            nums[i] /= n;\\n        }\\n\\n        return nums;\\n    }\\n}\\n`"
                    }
                ]
            },
            {
                "id": 1917612,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1910668,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1903215,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1899787,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1867994,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1793975,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1784386,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1782349,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1775724,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1767400,
                "content": [
                    {
                        "username": "noobcoder191",
                        "content": "please can anyone explain me the problem\\n"
                    },
                    {
                        "username": "raihansikdar",
                        "content": "Read the question carefully. In this case, \"nums\" is an array, and \"i\" is an index variable. The expression nums[i] retrieves the value at index \"i\" in the \"nums\" array. Then, nums[nums[i]] uses the value obtained from nums[i] as the index to retrieve another value from the \"nums\" array."
                    },
                    {
                        "username": "aslankobzhanov6",
                        "content": "why the solution is in the problem, you just have to create a loop"
                    },
                    {
                        "username": "oplaesradrigas",
                        "content": "What am I doing wrong?\n\nCode:\n`class Solution:\n    def buildArray(nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]`\n\nResult:\n`Runtime Error\nTypeError: Solution.buildArray() takes 1 positional argument but 2 were given\n    ret = Solution().buildArray(param_1)\nLine 22 in _driver (Solution.py)\n    _driver()\nLine 33 in <module> (Solution.py)`\n\nP.s. everything works fine in the terminal"
                    },
                    {
                        "username": "bandavida_3000",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> ans(n);\\n        for (int i = 0; i < n; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AlecLC",
                        "content": "# <span style='color:green'>Easiest Solution</span>\n\n    def buildArray(self, nums: List[int]) -> List[int]:\n        return [nums[i] for i in nums]\n"
                    },
                    {
                        "username": "KITSCODER",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] s = new int[n];\\n        for(int i=0;i<n;i++){\\n           \\n                s[i]=nums[nums[i]];\\n            \\n        }\\n        return s;\\n    }\\n}"
                    },
                    {
                        "username": "Abhishek9668",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans=new int[nums.length];\\n\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n\\nthe answer is in the question itself...."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy \\n\\nclass Solution {\\n    public int[] buildArray(int[] nums) {\\n        int n = nums.length;\\n        int[] ans = new int[n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "jchav5150",
                        "content": "Can someone actually explain what the problem is asking?  I can\\'t even read it and understand it.\\n"
                    },
                    {
                        "username": "brtn",
                        "content": "Problem is asking to create a new array whose value at index 0 will be the value of nums[nums[0]]. The next index will be for example: ans[1] = nums[nums[1]] and so on. Look at the sample explanation. \n\nYou can view my solution here: https://leetcode.com/problems/build-array-from-permutation/solutions/3152380/beats-99-95-runtime/"
                    },
                    {
                        "username": "Yurtis",
                        "content": "I\\'m with you jchav..."
                    },
                    {
                        "username": "Sahil_Dahat",
                        "content": "Hey guys! How do you think about the optimized approach? I understood that we would need to update the existing nums but how to do that?"
                    }
                ]
            },
            {
                "id": 1751641,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1741361,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1715482,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1714372,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1713294,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1679626,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1678270,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1672906,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1623934,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            },
            {
                "id": 1763257,
                "content": [
                    {
                        "username": "adarshvats09",
                        "content": "Java Solution with 99.95\\n `class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] resultArr = new int[nums.length];\\n        for(int i=0;i<nums.length;i++)\\n            resultArr[i] = nums[nums[i]];\\n        return resultArr;\\n    }\\n}`"
                    },
                    {
                        "username": "kumarsandeep12192",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n\\n        int[] ans = new int[nums.length];\\n        for(int i=0;i<nums.length;i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Hey_its_Aryan",
                        "content": "**********************************************\nWORKS FOR PYTHON !\n\nmy_list = []\n        for i in range(0, len(nums)):\n            my_list.append(nums[nums[i]])\n        return my_list\n**********************************************"
                    },
                    {
                        "username": "acwankhede",
                        "content": "Fastest solution as python one liner:\\n\\n `return [nums[nums[index]] for index in range(0, len(nums))]`"
                    },
                    {
                        "username": "user2815pp",
                        "content": " vector<int> buildArray(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i:nums)ans.push_back(nums[i]);\\n        return ans;\\n        \\n    }"
                    },
                    {
                        "username": "Ali_Gamal_Aziz",
                        "content": "/**\n * Note: The returned array must be malloced, assume caller calls free().\n */\nint* buildArray(int* nums, int numsSize, int* returnSize){\n\n     *returnSize = numsSize;\n    int* ans = (int*) malloc(sizeof(int) * numsSize);\n    for (int i = 0; i < numsSize; i++) {\n        ans[i] = nums[nums[i]];\n    }\n    return ans;\n\n\n}"
                    },
                    {
                        "username": "akashgavhane078",
                        "content": "class Solution {\\npublic:\\n    vector<int> buildArray(vector<int>& nums) {\\n        \\n    vector <int> ans;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n       ans.push_back(nums[nums[i]]);\\n    }\\n    return ans;\\n    }\\n};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easy C++ O(N) Soln. [ FAANG \\uD83E\\uDD73 Interview Optimized code ]\\n\\nhttps://leetcode.com/problems/build-array-from-permutation/solutions/2783325/easy-c-o-n-soln-faang-interview-optimized-code/"
                    },
                    {
                        "username": "agarwalvarun2012",
                        "content": "class Solution {\\n    public int[] buildArray(int[] nums) {\\n        int[] ans = new int[nums.length];\\n        for(int i=0; i< nums.length; i++) {\\n            ans[i] = nums[nums[i]];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "aqib_m31",
                        "content": "A simple beginner friendly solution (Java):\n```java\nclass Solution {\n    public int[] buildArray(int[] nums) {\n        // create an 'ans' array with same length as nums\n        int[] ans = new int[nums.length];\n        // run a for loop from 0 to a ans.length - 1 and set ans[i] = nums[nums[i]] as mentioned in question\n        for (int i = 0; i < ans.length; i++) {\n            ans[i] = nums[nums[i]];\n        }\n        return ans;\n    }\n}"
                    }
                ]
            }
        ]
    }
]