[
    {
        "title": "Remove Linked List Elements",
        "question_content": "Given the head of a linked list and an integer val, remove all the nodes of the linked list that has Node.val == val, and return the new head.\n&nbsp;\nExample 1:\n\nInput: head = [1,2,6,3,4,5,6], val = 6\nOutput: [1,2,3,4,5]\n\nExample 2:\n\nInput: head = [], val = 1\nOutput: []\n\nExample 3:\n\nInput: head = [7,7,7,7], val = 7\nOutput: []\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the list is in the range [0, 104].\n\t1 <= Node.val <= 50\n\t0 <= val <= 50",
        "solutions": [
            {
                "id": 57306,
                "title": "3-line-recursive-solution",
                "content": "    public ListNode removeElements(ListNode head, int val) {\\n            if (head == null) return null;\\n            head.next = removeElements(head.next, val);\\n            return head.val == val ? head.next : head;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "    public ListNode removeElements(ListNode head, int val) {\\n            if (head == null) return null;\\n            head.next = removeElements(head.next, val);\\n            return head.val == val ? head.next : head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 158651,
                "title": "simple-python-solution-with-explanation-single-pointer-dummy-head",
                "content": "Before writing any code, it\\'s good to make a list of edge cases that we need to consider. This is so that we can be certain that we\\'re not overlooking anything while coming up with our algorithm, and that we\\'re testing all special cases when we\\'re ready to test. These are the edge cases that I came up with.\\n\\n1. The linked list is empty, i.e. the head node is None.\\n2. Multiple nodes with the target value in a row. \\n3. The head node has the target value.\\n4. The head node, and any number of nodes immediately after it have the target value.\\n5. All of the nodes have the target value.\\n6. The last node has the target value.\\n\\nSo with that, this is the algorithm I came up with.\\n\\n```\\nclass Solution:\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        current_node = dummy_head\\n        while current_node.next != None:\\n            if current_node.next.val == val:\\n                current_node.next = current_node.next.next\\n            else:\\n                current_node = current_node.next\\n                \\n        return dummy_head.next\\n```\\n\\nIn order to save the need to treat the \"head\" as special, the algorithm uses a \"dummy\" head. This simplifies the code greatly, particularly in the case of needing to remove the head AND some of the nodes immediately after it.\\n\\nThen, we keep track of the current node we\\'re up to, and look ahead to its next node, as long as it exists. If ```current_node.next``` does need removing, then we simply replace it with ```current_node.next.next```. We know this is always \"safe\", because ```current_node.next``` is definitely not None (the loop condition ensures that), so we can safely access its ```next```.\\n\\nOtherwise, we know that ```current_node.next``` should be kept, and so we move ```current_node``` on to be ```current_node.next```.\\n\\nThe loop condition only needs to check that ```current_node.next != None```. The reason it does **not** need to check that ```current_node != None``` is because this is an impossible state to reach. Think about it this way: The ONLY case that we ever do ```current_node = current_node.next``` in is immediately after the loop has already confirmed that ```current_node.next``` is not None. \\n\\nThe algorithm requires ***```O(1)```*** extra space and takes ***```O(n)```*** time.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        dummy_head = ListNode(-1)\\n        dummy_head.next = head\\n        \\n        current_node = dummy_head\\n        while current_node.next != None:\\n            if current_node.next.val == val:\\n                current_node.next = current_node.next.next\\n            else:\\n                current_node = current_node.next\\n                \\n        return dummy_head.next\\n```\n```current_node.next```\n```current_node.next.next```\n```current_node.next```\n```next```\n```current_node.next```\n```current_node```\n```current_node.next```\n```current_node.next != None```\n```current_node != None```\n```current_node = current_node.next```\n```current_node.next```\n```O(1)```\n```O(n)```",
                "codeTag": "Java"
            },
            {
                "id": 1572932,
                "title": "java-three-simple-clean-solutions-w-explanation-iterative-recursive-beats-100",
                "content": "*<ins>Note:</ins> Kindly upvote if you find this article helpful. Thanks for reading!*\\n\\nThis is a fundamental Linked List Traversal question.\\nIn optimized solutions, we will remove the nodes with the value same as the input `val` while traversing the list.\\n\\nThere are three ways we can solve this question:\\n- Iterative Solution without using a Previous Pointer\\n- Iterative Solution using a Previous Pointer\\n- Recursive Solution (This solution requires extra auxiliary space for saving the recursion stack)\\n\\n---\\n\\u2714\\uFE0F **Approach 1: Iterative Solution without using a Previous Pointer**\\n\\nIn this solution, we create a `dummy` node and set `dummy.next = head`. This node helps us keep track of the new head in case the existing `head` has to be removed.\\nSince we are not using a previous pointer, we will set the current (`cur`) node to the `dummy` node.\\nThe list on the left side, including the `cur` node, has been solved. We now need to solve the list on the right side of the `cur` node.\\n\\nWe will check the following two conditions while iterating over the list:\\n- If `cur.next.val == val`, then we will remove the cur.next node by setting `cur.next = cur.next.next`. Please note, we will not move the current pointer in this step as new `cur.next` has not be validated yet.\\n- If `cur.next.val != val`, then we can safely move the `cur` pointer to next node, as next node is a valid node. `cur = cur.next`.\\n\\n**Time Complexity:** `O(N)` --> Each Node in the list is visited once.\\n**Space Complexity:** `O(1)` --> Contant space is used for this solution\\n*Where, N = Length of the input list.*\\n\\n**Example to understand this solution**\\nInput LinkedList: `[2, 3, 1, 2, 2]`\\nIn this input Linked List we are removing the value `2`.\\n\\n![image](https://assets.leetcode.com/users/images/5e44c980-9079-49a8-af15-1a7088b21d02_1636679350.0082548.png)\\n\\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode cur = dummy;\\n\\n        while (cur.next != null) {\\n            if (cur.next.val == val) {\\n                cur.next = cur.next.next;\\n                // Here cannot move cur to cur.next as we need to validate the next node.\\n            } else {\\n                cur = cur.next;\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n---\\n\\u2714\\uFE0F **Approach 2: Iterative Solution using a Previous Pointer**\\n\\nSame as in the previous solution, we create a `dummy` node and set `dummy.next = head`. This node helps us keep track of the new head in case the existing `head` has to be removed.\\nWe will initialize, `prev` node to `dummy` node and `cur` node to `head` node. \\nThe list on the left side, including the `prev` node, has been solved. We now need to solve the list starting from the `cur` node.\\n\\nWe will check the following two conditions while iterating over the list:\\n- If `cur.val == val`, then we will remove the cur node by setting `prev.next = cur.next`.\\n- If `cur.val != val`, then we can safely move the `prev` pointer to `cur` node, as `cur` node is a valid node. `prev = cur`.\\n\\n**Time Complexity:** `O(N)` --> Each Node in the list is visited once.\\n**Space Complexity:** `O(1)` --> Contant space is used for this solution\\n*Where, N = Length of the input list.*\\n\\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode cur = head;\\n        ListNode prev = dummy;\\n\\n        while (cur != null) {\\n            if (cur.val == val) {\\n                prev.next = cur.next;\\n            } else {\\n                prev = cur;\\n            }\\n            cur = cur.next;\\n        }\\n\\n        return dummy.next;\\n    }\\n}\\n```\\n\\n---\\n\\n\\u2714\\uFE0F **Approach 3: Recursive Solution**\\n\\nIn this solution, `removeElements` function returns the head of the solved list (nodes with `val` are removed).\\nOnce we get the solved `rightSideHead` from the recursion call, `rightSideHead` node will point to the solved list.\\nNow, we have two choices:\\n- If `head.val == val` --> Current node needs to be removed, so return the `rightSideHead` as it points to the solved rigth side list.\\n- If `head.val != val` --> Update the next pointer of current list, as the next node might have been removed. And then return the current node.\\n\\n**Time Complexity:** `O(N)` --> Each Node in the list is visited once.\\n**Space Complexity:** `O(N)` --> Recursion Stack space\\n*Where, N = Length of the input list.*\\n\\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        // Once removeElements call is done, right side of the list is solved.\\n        ListNode rightSideHead = removeElements(head.next, val);\\n        if (head.val == val) {\\n            return rightSideHead;\\n        }\\n        head.next = rightSideHead;\\n        return head;\\n    }\\n}\\n```\\n\\n---\\n\\n**<ins>Similar Linked List questions on LeetCode:</ins>**\\n\\n- [27. Remove Element](https://leetcode.com/problems/remove-element/)\\n- [237. Delete Node in a Linked List](https://leetcode.com/problems/delete-node-in-a-linked-list/)\\n- [19. Remove Nth Node From End of List](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\\n- [21. Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\\n- [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\\n- [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\\n- [445. Add Two Numbers II](https://leetcode.com/problems/add-two-numbers-ii/)\\n- [25. Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\\n- [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\\n- [92. Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\\n",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode cur = dummy;\\n\\n        while (cur.next != null) {\\n            if (cur.next.val == val) {\\n                cur.next = cur.next.next;\\n                // Here cannot move cur to cur.next as we need to validate the next node.\\n            } else {\\n                cur = cur.next;\\n            }\\n        }\\n\\n        return dummy.next;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode cur = head;\\n        ListNode prev = dummy;\\n\\n        while (cur != null) {\\n            if (cur.val == val) {\\n                prev.next = cur.next;\\n            } else {\\n                prev = cur;\\n            }\\n            cur = cur.next;\\n        }\\n\\n        return dummy.next;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) {\\n            return null;\\n        }\\n\\n        // Once removeElements call is done, right side of the list is solved.\\n        ListNode rightSideHead = removeElements(head.next, val);\\n        if (head.val == val) {\\n            return rightSideHead;\\n        }\\n        head.next = rightSideHead;\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57324,
                "title": "ac-java-solution",
                "content": "    public class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            ListNode fakeHead = new ListNode(-1);\\n            fakeHead.next = head;\\n            ListNode curr = head, prev = fakeHead;\\n            while (curr != null) {\\n                if (curr.val == val) {\\n                    prev.next = curr.next;\\n                } else {\\n                    prev = prev.next;\\n                }\\n                curr = curr.next;\\n            }\\n            return fakeHead.next;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            ListNode fakeHead = new ListNode(-1);\\n            fakeHead.next = head;\\n            ListNode curr = head, prev = fakeHead;\\n            while (curr != null) {\\n                if (curr.val == val) {\\n                    prev.next = curr.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 722528,
                "title": "c-2-solutions-with-single-pointer-with-double-pointers-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n\\t\\tApproach: 1\\n        Solving the problem using two pointers: previous and current.\\n        Time: 28 ms\\n\\t */\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==nullptr) return head;\\n        while(head!=nullptr && head->val==val){\\n            head = head->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        while(curr!=nullptr){\\n            if(curr->val==val){\\n                prev->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;        \\n            }\\n        }\\n        return head;\\n    }\\n    \\n    /*\\n\\t\\tApproach: 2\\n        Solving the problem using a single pointer: current.\\n        Time: 20 ms\\n    */\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==nullptr) return head;\\n\\t\\t// This is for the case when a linked list is like this: \\n\\t\\t// 1->1->2->null , val = 1\\n\\t\\t// 1->1->1->null , val = 1\\n        while(head!=nullptr && head->val==val){\\n            head = head->next;\\n        }\\n        ListNode* curr = head;\\n        while(curr!=nullptr  && curr->next!=nullptr){\\n            if(curr->next->val==val){\\n                curr->next = curr->next->next;\\n\\t\\t\\t\\t// After doing the above step, I am not updating \"curr\" because of these type of test cases:\\n\\t\\t\\t\\t// 1->2->3->6->6->6->5->null  val = 6\\n            }\\n            else\\n                curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n\\n```\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n\\t\\tApproach: 1\\n        Solving the problem using two pointers: previous and current.\\n        Time: 28 ms\\n\\t */\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==nullptr) return head;\\n        while(head!=nullptr && head->val==val){\\n            head = head->next;\\n        }\\n        ListNode* curr = head;\\n        ListNode* prev = nullptr;\\n        while(curr!=nullptr){\\n            if(curr->val==val){\\n                prev->next = curr->next;\\n                curr = curr->next;\\n            }\\n            else{\\n                prev = curr;\\n                curr = curr->next;        \\n            }\\n        }\\n        return head;\\n    }\\n    \\n    /*\\n\\t\\tApproach: 2\\n        Solving the problem using a single pointer: current.\\n        Time: 20 ms\\n    */\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==nullptr) return head;\\n\\t\\t// This is for the case when a linked list is like this: \\n\\t\\t// 1->1->2->null , val = 1\\n\\t\\t// 1->1->1->null , val = 1\\n        while(head!=nullptr && head->val==val){\\n            head = head->next;\\n        }\\n        ListNode* curr = head;\\n        while(curr!=nullptr  && curr->next!=nullptr){\\n            if(curr->next->val==val){\\n                curr->next = curr->next->next;\\n\\t\\t\\t\\t// After doing the above step, I am not updating \"curr\" because of these type of test cases:\\n\\t\\t\\t\\t// 1->2->3->6->6->6->5->null  val = 6\\n            }\\n            else\\n                curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57323,
                "title": "iterative-short-java-solution",
                "content": "Hi guys!\\n\\nHere's an iterative solution without dummy head. \\nFirst, we shift a head of a list while its' value equals to val. \\nThen, we iterate through the nodes of the list checking if the next node's value equals to val and removing it if needed.  \\n\\n----------\\n\\n    public class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            while (head != null && head.val == val) head = head.next;\\n            ListNode curr = head;\\n            while (curr != null && curr.next != null)\\n                if (curr.next.val == val) curr.next = curr.next.next;\\n                else curr = curr.next;\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            while (head != null && head.val == val) head = head.next;\\n            ListNode curr = head;\\n            while (curr != null && curr.next != null)\\n                if (curr.next.val == val) curr.next = curr.next.next;\\n                else curr = curr.next;\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 57331,
                "title": "accepted-7-line-clean-java-solution",
                "content": "    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        ListNode pointer = head;\\n        while (pointer.next != null) {\\n            if (pointer.next.val == val) pointer.next = pointer.next.next;\\n            else pointer = pointer.next;\\n        }\\n        return head.val == val ? head.next : head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        ListNode pointer = head;\\n        while (pointer.next != null) {\\n            if (pointer.next.val == val) pointer.next = pointer.next.next;\\n            else pointer = pointer.next;\\n        }\\n        return head.val == val ? head.next : head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1572892,
                "title": "c-python-clean-simple-solution-w-explanation-illustration-iterative-recursive",
                "content": "We are given a Linked List\\'s head pointer `head` and a target value `T`. All the nodes having value as `T` need to be deleted.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - I (Iterative using Dummy node)***\\n\\nA simple solution to delete the nodes having value `T` is to traverse over the linked list and just remove the next pointers to the node having value as `T`. Now, usually in deletion problem of linked list, there can be multiple cases where node to be deleted is either a head node or other node in rest of list. We usually make use of a dummy node at the start or **[sentinel node](https://en.wikipedia.org/wiki/Sentinel_node)** to avoid handling multiple edge cases and write a clean uniform solution.\\n\\nSo, the algorithm we are using can be summarised as -\\n\\n1. Initialize a dummy/sentinel node having its next pointer pointing to the `head` of linked list and another node pointer  `prev` pointing to this dummy node.\\n2. Start iterating over `head` of linked list\\n3. If current node\\'s value is not equal to `T`, we can just move to next node without deleting current node. In this case, \\n\\t* We first update `prev` pointer and point it to current `head`\\n\\t* Then move `head` to next node.\\n4. Otherwise, if **`head -> val == T`**, we know that this **node needs to be deleted**. In this case, \\n\\t* We can just **update the next pointer of previous node to the next pointer of current node**. This will basically remove the current node from list. \\n\\t* Then, we update head to its next node just as in previous case.\\n5. Finally, ignore the dummy node created at start and return its next node.\\n\\n**\\uD83D\\uDCDD Dry Run on Example -**\\n\\n```\\nFor eg. let the list be 1 -> 2 -> 1 -> 4  -> 7  -> 1, and T = 1.\\n                                                                         // dummy and prev initialized pointing to list head\\n 1. -1   \\u2192   1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null       // head == T, update prev pointer to head\\'s next\\n   ^dummy    ^head                                                       // and move head to next\\n   ^prev\\n => Now traverse till head reaches end\\n \\n     \\u21B1    \\u2192     \\u2192    \\u21B4\\n 2. -1      1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy           ^head                                             \\n\\t^prev\\n\\t\\t\\t\\t\\t\\t\\n     \\u21B1    \\u2192     \\u2192    \\u21B4\\n 3. -1      1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head == T, update prev pointer to head\\'s next\\n\\t^dummy           ^prev   ^head                                       // and move head to next\\n\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 4. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy           ^prev           ^head\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 5. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy                           ^prev   ^head\\t\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 6. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head == T, update prev pointer to head\\'s next\\n\\t^dummy                                   ^prev   ^head\\t\\t         // and move head to next\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4       \\u21B1    \\u2192     \\u2192    \\u21B4\\n 7. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7       1   \\u2192   null\\n\\t^dummy                                   ^prev            ^head       // Stop iteration as head = null\\t\\n\\t\\n\\t\\nFinal List = dummy -> next\\n\\t  \\uD83D\\uDC49  2   ->    4   ->   7   ->   null\\n\\n```\\n\\nThe above code will elegantly handle both cases of either head is to be deleted or some other node is to be deleted without needing to do any extra checks in code.\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int T) {\\n        ListNode *dummy = new ListNode(-1, head), *prev = dummy;\\n        for(;head; head = head -> next) \\n            if(head -> val != T) \\n                prev = head;                       // just update prev node\\n            else                                   // current node needs to be deleted\\n\\t\\t\\t\\tprev -> next = head -> next;       // just update next of prev to next of current so that current node is removed from list\\n        return dummy -> next;                     \\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def removeElements(self, head, T):\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        while head:\\n            if head.val != T:\\n                prev = head\\n            else:\\n                prev.next = head.next\\n            head = head.next\\n        return dummy.next\\n```\\n\\n***Time Complexity :*** **<code>O(N)</code>**, where `N` is the number of nodes in the given linked list. We are just iterating over the linked list once.\\n***Space Complexity :*** **`O(1)`**, only constant extra space is being used.\\n\\n---\\n\\n\\u2714\\uFE0F ***Solution - II (Recursive)***\\n\\nThe recursive implementation can be shorter but requires `O(N)` space. In this approach, we will use a top-down approach. First, we go down till the end of the list and start deleting from there on our way back to the head node. Each time, we delete the current node if it\\'s value is equal to `T` by returning its next node. Otherwise, we need to keep the current, so we can just return it.\\n\\n\\n**C++**\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int T) {\\n        if(!head) return nullptr;\\n        head -> next = removeElements(head -> next, T);\\n        return head -> val == T ? head -> next : head;\\n    }\\n};\\n```\\n\\n**Python**\\n```python\\nclass Solution:\\n    def removeElements(self, head, T):\\n        if not head: return None\\n        head.next = self.removeElements(head.next, T);\\n        return head.next if head.val == T else head\\n```\\n\\n***Time Complexity :*** **<code>O(N)</code>** We are just iterating over the linked list once.\\n***Space Complexity :*** **`O(N)`**, required by implicit recursive stack\\n\\n---\\n\\n**Note :** The Problem only asks us to **remove the node from the linked list and not delete it.** A good question to ask in an interview for this problem would be whether we just need to remove the node from linked list or completely delete it from the memory. Since it has not been stated in this problem if the node is required somewhere else later on, its better to just remove the node from linked list as asked.\\n\\nIf we want to delete the node altogether, then we can just free its memory and point it to NULL before returning from the function.\\n\\n---\\n---\\n\\n\\uD83D\\uDCBBIf there are any suggestions / questions / mistakes in my post, comment below \\uD83D\\uDC47 \\n\\n---\\n---",
                "solutionTags": [],
                "code": "```\\nFor eg. let the list be 1 -> 2 -> 1 -> 4  -> 7  -> 1, and T = 1.\\n                                                                         // dummy and prev initialized pointing to list head\\n 1. -1   \\u2192   1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null       // head == T, update prev pointer to head\\'s next\\n   ^dummy    ^head                                                       // and move head to next\\n   ^prev\\n => Now traverse till head reaches end\\n \\n     \\u21B1    \\u2192     \\u2192    \\u21B4\\n 2. -1      1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy           ^head                                             \\n\\t^prev\\n\\t\\t\\t\\t\\t\\t\\n     \\u21B1    \\u2192     \\u2192    \\u21B4\\n 3. -1      1   \\u2192    2   \\u2192   1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head == T, update prev pointer to head\\'s next\\n\\t^dummy           ^prev   ^head                                       // and move head to next\\n\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 4. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy           ^prev           ^head\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 5. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head != T, just update prev and move head to next\\n\\t^dummy                           ^prev   ^head\\t\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4\\n 6. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7   \\u2192   1   \\u2192   null        // head == T, update prev pointer to head\\'s next\\n\\t^dummy                                   ^prev   ^head\\t\\t         // and move head to next\\n\\t\\n     \\u21B1    \\u2192     \\u2192   \\u21B4 \\u21B1    \\u2192     \\u2192   \\u21B4       \\u21B1    \\u2192     \\u2192    \\u21B4\\n 7. -1      1   \\u2192    2       1   \\u2192   4   \\u2192   7       1   \\u2192   null\\n\\t^dummy                                   ^prev            ^head       // Stop iteration as head = null\\t\\n\\t\\n\\t\\nFinal List = dummy -> next\\n\\t  \\uD83D\\uDC49  2   ->    4   ->   7   ->   null\\n\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int T) {\\n        ListNode *dummy = new ListNode(-1, head), *prev = dummy;\\n        for(;head; head = head -> next) \\n            if(head -> val != T) \\n                prev = head;                       // just update prev node\\n            else                                   // current node needs to be deleted\\n\\t\\t\\t\\tprev -> next = head -> next;       // just update next of prev to next of current so that current node is removed from list\\n        return dummy -> next;                     \\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def removeElements(self, head, T):\\n        dummy = ListNode(-1, head)\\n        prev = dummy\\n        while head:\\n            if head.val != T:\\n                prev = head\\n            else:\\n                prev.next = head.next\\n            head = head.next\\n        return dummy.next\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int T) {\\n        if(!head) return nullptr;\\n        head -> next = removeElements(head -> next, T);\\n        return head -> val == T ? head -> next : head;\\n    }\\n};\\n```\n```python\\nclass Solution:\\n    def removeElements(self, head, T):\\n        if not head: return None\\n        head.next = self.removeElements(head.next, T);\\n        return head.next if head.val == T else head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572902,
                "title": "c-java-python-simple-recursive-iterative-solutions-novemberchallenge",
                "content": "This is my first ever post :)\\n\\nThis is an interesting and fairly simple Linked List problem which can be elegantly solved using both recursion and iteration. \\n\\nFirst let us discuss the **iterative approach**.\\nHere, I create a *dummy* node which acts as the predecessor to head itself. This trick is used in many Linked List problems to avoid checking for edge cases when dealing with the first node. Then I initialize a starting node *curr* equal to the *dummy* node. The thing to note here is that in each iteration, I check if the *next* node to *curr* has a value equal to the given *val*. This is done so that if that is the case, we can skip that node all together by setting *curr.next = curr.next.next*. If that isn\\'t the case, then we simply move *curr* forward. \\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode;\\n        dummy -> next = head;\\n        ListNode* curr = dummy;\\n        \\n        while(curr -> next) {\\n            if(curr -> next -> val == val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while(curr.next != null) {\\n            if(curr.next.val == val) {\\n                curr.next = curr.next.next;\\n            } else {\\n                curr = curr.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n        curr = dummy\\n        while curr.next:\\n            if curr.next.val == val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n```\\n\\n\\nMoving on to the **recursive approach.**\\nRecursion makes the code more self explanatory as it is only required to check the current element. If *head.val* is equal to the given *val*, then we can simply call recursion on *head.next* and return that (this is essentially deleting head). If it isn\\'t, then we set the value of *head.next* equal to the what is returned by recursion when called on *head.next* and return head.\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(!head)\\n            return head;\\n        ListNode* newNext = removeElements(head -> next, val);\\n        if(head -> val == val) {\\n            return newNext;\\n        } else {\\n            head -> next = newNext;\\n            return head;\\n        }\\n    }\\n};\\n```\\n\\n**Java**\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null)\\n            return head;\\n        ListNode newNext = removeElements(head.next, val);\\n        if(head.val == val) {\\n            return newNext;\\n        } else {\\n            head.next = newNext;\\n            return head;\\n        }\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head == None:\\n            return head\\n        \\n        newNext = self.removeElements(head.next, val)\\n        if head.val == val:\\n            return newNext\\n        else:\\n            head.next = newNext\\n            return head\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode;\\n        dummy -> next = head;\\n        ListNode* curr = dummy;\\n        \\n        while(curr -> next) {\\n            if(curr -> next -> val == val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while(curr.next != null) {\\n            if(curr.next.val == val) {\\n                curr.next = curr.next.next;\\n            } else {\\n                curr = curr.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode()\\n        dummy.next = head\\n        curr = dummy\\n        while curr.next:\\n            if curr.next.val == val:\\n                curr.next = curr.next.next\\n            else:\\n                curr = curr.next\\n        return dummy.next\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(!head)\\n            return head;\\n        ListNode* newNext = removeElements(head -> next, val);\\n        if(head -> val == val) {\\n            return newNext;\\n        } else {\\n            head -> next = newNext;\\n            return head;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null)\\n            return head;\\n        ListNode newNext = removeElements(head.next, val);\\n        if(head.val == val) {\\n            return newNext;\\n        } else {\\n            head.next = newNext;\\n            return head;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head == None:\\n            return head\\n        \\n        newNext = self.removeElements(head.next, val)\\n        if head.val == val:\\n            return newNext\\n        else:\\n            head.next = newNext\\n            return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57317,
                "title": "simple-and-elegant-solution-in-c",
                "content": "```c++\\nListNode *removeElements(ListNode *head, int val) {\\n\\tListNode **list = &head;\\n\\n\\twhile (*list != nullptr) {\\n\\t\\tif ((*list)->val == val) {\\n\\t\\t    // You can free `*list` here if you know how it is allocated.\\n\\t\\t\\t*list = (*list)->next;\\n\\t\\t} else {\\n\\t\\t\\tlist = &(*list)->next;\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```\\n\\nOriginal tail recursive version:\\n\\n```c++\\nvoid removeHelper(ListNode *&list, int val) {\\n\\tif (list != nullptr) {\\n\\t\\tif (list->val == val) {\\n\\t\\t    // You can free `list` here if you know how it is allocated.\\n\\t\\t\\tlist = list->next;\\n\\t\\t\\tremoveHelper(list, val);\\n\\t\\t} else {\\n\\t\\t\\tremoveHelper(list->next, val);\\n\\t\\t}\\n\\t}\\n}\\n\\nListNode *removeElements(ListNode *head, int val) {\\n\\tremoveHelper(head, val);\\n\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```c++\\nListNode *removeElements(ListNode *head, int val) {\\n\\tListNode **list = &head;\\n\\n\\twhile (*list != nullptr) {\\n\\t\\tif ((*list)->val == val) {\\n\\t\\t    // You can free `*list` here if you know how it is allocated.\\n\\t\\t\\t*list = (*list)->next;\\n\\t\\t} else {\\n\\t\\t\\tlist = &(*list)->next;\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```\n```c++\\nvoid removeHelper(ListNode *&list, int val) {\\n\\tif (list != nullptr) {\\n\\t\\tif (list->val == val) {\\n\\t\\t    // You can free `list` here if you know how it is allocated.\\n\\t\\t\\tlist = list->next;\\n\\t\\t\\tremoveHelper(list, val);\\n\\t\\t} else {\\n\\t\\t\\tremoveHelper(list->next, val);\\n\\t\\t}\\n\\t}\\n}\\n\\nListNode *removeElements(ListNode *head, int val) {\\n\\tremoveHelper(head, val);\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57461,
                "title": "simple-clear-python-solution",
                "content": "First we remove all (if any) target nodes from the beginning (we do it because the removing logic is slightly different from when the node is not in the head). After that we just loop over all nodes, if the next one is one that should be removed, just get it out of the list by moving the next pointer to the next-next node. Otherwise just move along the list.\\n\\n    class Solution(object):\\n        def removeElements(self, head, val):\\n            while head is not None and head.val == val:\\n                head = head.next\\n            current = head\\n            while current is not None:\\n                if current.next is not None and current.next.val == val:\\n                    current.next = current.next.next\\n                else:\\n                    current = current.next\\n            return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "First we remove all (if any) target nodes from the beginning (we do it because the removing logic is slightly different from when the node is not in the head). After that we just loop over all nodes, if the next one is one that should be removed, just get it out of the list by moving the next pointer to the next-next node. Otherwise just move along the list.\\n\\n    class Solution(object):\\n        def removeElements(self, head, val):\\n            while head is not None and head.val == val:\\n                head = head.next\\n            current = head\\n            while current is not None:\\n                if current.next is not None and current.next.val == val:\\n                    current.next = current.next.next\\n                else:\\n                    current = current.next\\n            return head",
                "codeTag": "Java"
            },
            {
                "id": 1572935,
                "title": "python-99-one-pass-solution-with-explanation",
                "content": "### Intuition\\n\\nTo delete a node, we need to assign the next node to the previous node. Let\\'s use `curr` to denote the current node, and `prev` to denote the previous node. Then, we have the following 4 cases:\\n\\n1. **Node to remove is at the end of the linked list.**\\n\\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\tprev curr\\n```\\n\\nSimple enough, we just need to assign `prev.next = None`, since `curr.next == None`. No further action is needed since this is the last node to check.\\n\\n2. **Node to remove is in the middle of the linked list.**\\n\\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\tprev curr\\n```\\n\\nTo remove the node `curr`, we can assign `prev.next = curr.next`, which disconnects `curr` from the linked list completely. In the following iteration, we know that `curr = curr.next`, while `prev` should remain pointing at the same node since `curr` has been removed. So, in summary:\\n\\n- `prev.next = curr.next` to remove the node;\\n- `curr = curr.next` to get the next iteration.\\n\\n3. **Node to remove is at the start of the linked list.**\\n\\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t/   \\\\\\n\\t      prev curr\\n```\\n\\nSince `prev == None`, we don\\'t need to assign `prev.next = curr.next`. However, removing nodes from the beginning of the linked list changes the head node of the linked list, so we need to assign `head = curr.next` before proceeding with the next iteration (as per case 2). In summary:\\n\\n- `head = curr.next` to change the head node;\\n- `curr = curr.next` to get the next iteration.\\n\\n4. **Current node is not to be removed.**\\n\\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t    /   \\\\\\n\\t          prev curr\\n```\\n\\nNothing needs to be done, we just need to proceed with the next iteration. This involves:\\n\\n- `curr = curr.next`, as discussed in cases 2 and 3;\\n- `prev = curr`, since the `curr` node is not removed in this case.\\n\\n---\\n\\n### Implementation\\n\\n- Start with `curr = head` and `prev = None`.\\n- Loop through the linked list and determine which of the 4 cases `curr` and `prev` belong to, and perform the action accordingly.\\n\\n```python\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev, curr = None, head\\n        while curr:\\n            if curr.val == val:  # cases 1-3\\n                if prev:  # cases 1-2\\n                    prev.next = curr.next\\n                else:  # case 3\\n                    head = curr.next\\n                curr = curr.next  # for all cases\\n            else:  # case 4\\n                prev, curr = curr, curr.next\\n        return head\\n```\\n\\n---\\n\\n### Final Result\\n\\n**TC: O(n)** where `n` is the number of nodes in the linked list.\\n**SC: O(1)**, no additional data structures were used.\\n\\n![image](https://assets.leetcode.com/users/images/236b8bc3-8262-4153-bd6f-1abc83d95594_1636678776.534016.png)\\n\\nPlease upvote of this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\t\\t\\tprev curr\\n```\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t\\t  /   \\\\\\n\\t\\t\\t\\tprev curr\\n```\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t/   \\\\\\n\\t      prev curr\\n```\n```text\\nInput: head = [6,1,2,6,3,4,5,6], val = 6\\n\\t\\t\\t    /   \\\\\\n\\t          prev curr\\n```\n```python\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev, curr = None, head\\n        while curr:\\n            if curr.val == val:  # cases 1-3\\n                if prev:  # cases 1-2\\n                    prev.next = curr.next\\n                else:  # case 3\\n                    head = curr.next\\n                curr = curr.next  # for all cases\\n            else:  # case 4\\n                prev, curr = curr, curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57308,
                "title": "concise-c-solution-with-pseudo-listhead",
                "content": "    class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            ListNode *pseudo_head = new ListNode(0);\\n            pseudo_head->next = head;\\n            ListNode *cur = pseudo_head;\\n            while(cur){\\n                if(cur->next && cur->next->val == val)   cur->next = cur->next->next;\\n                else    cur = cur->next;\\n            }\\n            return pseudo_head->next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            ListNode *pseudo_head = new ListNode(0);\\n            pseudo_head->next = head;\\n            ListNode *cur = pseudo_head;\\n            while(cur){\\n                if(cur->next && cur->next->val == val)   cur->next = cur->next->next;\\n                else    cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1572917,
                "title": "c-easy-intuitive-sol-two-approaches-recursive-and-iterative-simple-code",
                "content": "Hello Everyone! hope you all are doing great.\\n\\n**Approach 1 (Recursive):**\\n1. Here we need to think in a recursive way, so for the **base condition** it is simple: that if the current node in a recursive step is null then we can simply return NULL from that (Think of it as we have given an empty list in the input).\\n\\n2. Now, for the **recursive step**, we need to delete all the nodes that are in the right of our current node that have same value as `val` , so we\\'ll call recursive step on `node->next` so that the recursion will take care of the nodes that are ahead of our current node.\\n\\n3. Now, we only need to take care of our current node in our recursive step and here can be two cases:\\n\\t\\ta: **If current node\\'s value is equal to `val`** , then we will simply return the next of current node i.e. `node->next` as to delete current node we will simply omit this node and never return this node, so it will be lost.\\n\\t\\tb: **If current node\\'s value is NOT equal to `val`** then we want to keep this node in our list, so we will simply return this node itself.\\n\\t\\t\\nNow, below is the code for my appraoch: \\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // Base Condition\\n        if(!head) return NULL;\\n\\t\\t\\n\\t\\t// Delete the nodes that are on the right of our current node\\n        head->next = removeElements(head->next, val);\\n\\t\\t\\n\\t\\t// Omit current node if this has to be deleted or else keep this node \\n        return (head->val==val)? head->next:head;\\n    }\\n};\\n```\\n**Time Complexity:** It would be ***O(N)*** since we are iterating through every node.\\n**Space Complexity:** It\\'s amortized space complexity should be ***O(N)*** because recursion is using a stack space for every node.\\n\\n\\n**Approach 2 (Iterative):** \\n1. First I will handle the case when our list is like `[D D D S S S S]`, where` D` are the nodes that should be deleted and `S` are the safe node. This can be easily done by moving the head pointer of our list to the very first `S` node and omiting the previous `D` nodes.\\n\\n2. Then we will have a current pointer `cur` to iterate through our list and we will make sure that the nodes in the range from `head` to `cur` pointer are all `S` nodes i.e. safe nodes that need not be deleted.\\n\\n3. So, we will alway check the next of `cur` node that whether it has to be deleted or not, and** if needs to be deleted** then we will simply remove its connections (links) form the `cur` node and **if not need to be deleted** then we will simply move the `cur` pointer forward as it will be a `S` node that is a safe node.\\n\\nBelow is the code for my approach:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        \\n        // Omit the nodes from the start of list by moving head pointer\\n        // if these nodes have to be deleted\\n        // eg [7, 7, 7, 3] val = 7, then we have to delete all 7 and move head to 3\\n        while(head && head->val == val) head = head->next;\\n        \\n        // Now our head is updated\\n        \\n        // Now we will iterate our linked list using cur pointer\\n        // we surely know that cur is not to be deleted because we came to it\\n        // from the previous loop\\n        ListNode* cur = head;\\n        \\n        // loop through list and always check for next of cur node because we\\n        // know that cur has not to be deleted\\n        while(cur){\\n            \\n            // If the next of cur node is to be deleted\\n            // then point the next pointer of cur node to the next pointer\\n            // of the node that has to be deleted i.e. the next of (next of cur)\\n            if(cur->next && cur->next->val == val)\\n                cur->next = cur->next->next;\\n            \\n            // If next of cur is save and should not be deleted then move cur pointer to it\\n            // Because we want that till cur pointer we have the nodes that need not be deleted\\n            else cur = cur->next;\\n            \\n        }\\n        \\n        // then return the head of our updated list\\n        return head;\\n    }\\n};\\n```\\n\\n**Time Complexity:** ***O(N)*** (Iterating through all nodes)\\n**Space Complexity:** ***O(1)***\\n\\n**Please Upvote \\uD83D\\uDD3C if you liked my solution. It keeps me motivated to make such solution posts!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // Base Condition\\n        if(!head) return NULL;\\n\\t\\t\\n\\t\\t// Delete the nodes that are on the right of our current node\\n        head->next = removeElements(head->next, val);\\n\\t\\t\\n\\t\\t// Omit current node if this has to be deleted or else keep this node \\n        return (head->val==val)? head->next:head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        \\n        // Omit the nodes from the start of list by moving head pointer\\n        // if these nodes have to be deleted\\n        // eg [7, 7, 7, 3] val = 7, then we have to delete all 7 and move head to 3\\n        while(head && head->val == val) head = head->next;\\n        \\n        // Now our head is updated\\n        \\n        // Now we will iterate our linked list using cur pointer\\n        // we surely know that cur is not to be deleted because we came to it\\n        // from the previous loop\\n        ListNode* cur = head;\\n        \\n        // loop through list and always check for next of cur node because we\\n        // know that cur has not to be deleted\\n        while(cur){\\n            \\n            // If the next of cur node is to be deleted\\n            // then point the next pointer of cur node to the next pointer\\n            // of the node that has to be deleted i.e. the next of (next of cur)\\n            if(cur->next && cur->next->val == val)\\n                cur->next = cur->next->next;\\n            \\n            // If next of cur is save and should not be deleted then move cur pointer to it\\n            // Because we want that till cur pointer we have the nodes that need not be deleted\\n            else cur = cur->next;\\n            \\n        }\\n        \\n        // then return the head of our updated list\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 275445,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function(head, val) {\\n    if (!head) return head;\\n\\t\\n\\t// if head is the value were deleting and if there is any repetition lets handle that case first otherwise we\\'ll just break out of the loop\\n    while(head) {\\n        if(head.val === val) {\\n            head = head.next;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n\\t// skip any nodes whos values match the parameters and set it to the node after\\n\\t// if the node is found, set curr.next to the node after it then try again\\n\\t// otherwise iterate forward\\n    let curr = head;\\n    while(curr && curr.next) {\\n        if (curr.next.val === val) curr.next = curr.next.next;\\n        else curr = curr.next;\\n    }\\n    \\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function(head, val) {\\n    if (!head) return head;\\n\\t\\n\\t// if head is the value were deleting and if there is any repetition lets handle that case first otherwise we\\'ll just break out of the loop\\n    while(head) {\\n        if(head.val === val) {\\n            head = head.next;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n\\t// skip any nodes whos values match the parameters and set it to the node after\\n\\t// if the node is found, set curr.next to the node after it then try again\\n\\t// otherwise iterate forward\\n    let curr = head;\\n    while(curr && curr.next) {\\n        if (curr.next.val === val) curr.next = curr.next.next;\\n        else curr = curr.next;\\n    }\\n    \\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57326,
                "title": "32ms-c-ac-solution",
                "content": "    /**\\n     * Definition for singly-linked list.\\n     * struct ListNode {\\n     *     int val;\\n     *     ListNode *next;\\n     *     ListNode(int x) : val(x), next(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            if (head==NULL){\\n                return head;\\n            }\\n            ListNode* p=head;\\n            while(p->next!=NULL){\\n                if (p->next->val == val){\\n                    p->next = p->next->next;\\n                }\\n                else{\\n                    p=p->next;\\n                }\\n            }\\n            if (head->val==val)\\n                head=head->next;\\n            return head;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            if (head==NULL){\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3136351,
                "title": "c-recursive-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLook through every node of the linked list, joining together the nodes, which don\\'t have to be deleted\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n$$O(n)$$. Since we have to look at each node only once.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$. Since we are not storing any additional data.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        //base case, recursion ends when NULL is reached\\n        if (head == NULL) return NULL;\\n\\n        //the node has to be removed -> it is skipped during the iteration\\n        if (head->val == val) return removeElements(head->next, val);\\n\\n        //the node doesn\\'t have to be skipped -> the rest of the list has \\n        //to be joined to the node\\n        head->next = removeElements(head->next, val);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        //base case, recursion ends when NULL is reached\\n        if (head == NULL) return NULL;\\n\\n        //the node has to be removed -> it is skipped during the iteration\\n        if (head->val == val) return removeElements(head->next, val);\\n\\n        //the node doesn\\'t have to be skipped -> the rest of the list has \\n        //to be joined to the node\\n        head->next = removeElements(head->next, val);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57451,
                "title": "c-4-lines-recursive-solution",
                "content": "    ListNode* removeElements(ListNode* head, int val) {\\n        if (head == NULL) return NULL;\\n        if (val == head->val) return removeElements(head->next,val);\\n        head->next = removeElements(head->next,val);\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    ListNode* removeElements(ListNode* head, int val) {\\n        if (head == NULL) return NULL;\\n        if (val == head->val) return removeElements(head->next,val);\\n        head->next = removeElements(head->next,val);\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3086104,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode;\\n        dummy -> next = head;\\n        ListNode* curr = dummy;\\n        \\n        while(curr -> next) {\\n            if(curr -> next -> val == val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode;\\n        dummy -> next = head;\\n        ListNode* curr = dummy;\\n        \\n        while(curr -> next) {\\n            if(curr -> next -> val == val) {\\n                curr -> next = curr -> next -> next;\\n            } else {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273908,
                "title": "easy-recursive-in-python",
                "content": "```python\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return None\\n        if head.val == val:\\n            head = self.removeElements(head.next,val)\\n        else:\\n            head.next = self.removeElements(head.next,val)\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        if not head:\\n            return None\\n        if head.val == val:\\n            head = self.removeElements(head.next,val)\\n        else:\\n            head.next = self.removeElements(head.next,val)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1506318,
                "title": "c-and-python-simple-solutions",
                "content": "**C++ :**\\n\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n\\tif(!head) return head;\\n\\n\\tListNode* node = head;\\n\\twhile(node && node -> next)\\n\\t{\\n\\t\\tif(node -> next -> val == val)\\n\\t\\t\\tnode -> next = node -> next -> next;\\n\\t\\telse\\n\\t\\t\\tnode = node -> next;\\n\\t}\\n\\n\\tif(head -> val == val)\\n\\t\\thead = head -> next;\\n\\n\\treturn head;\\n}\\n```\\n\\n**Python :**\\n\\n```\\ndef removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tnode = head\\n\\twhile node and node.next:\\n\\t\\tif node.next.val == val:\\n\\t\\t\\tnode.next = node.next.next\\n\\n\\t\\telse:\\n\\t\\t\\tnode = node.next\\n\\n\\tif head.val == val:\\n\\t\\thead = head.next\\n\\n\\treturn head\\n```\\n\\n**Like it ? please upvote**",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nListNode* removeElements(ListNode* head, int val) {\\n\\tif(!head) return head;\\n\\n\\tListNode* node = head;\\n\\twhile(node && node -> next)\\n\\t{\\n\\t\\tif(node -> next -> val == val)\\n\\t\\t\\tnode -> next = node -> next -> next;\\n\\t\\telse\\n\\t\\t\\tnode = node -> next;\\n\\t}\\n\\n\\tif(head -> val == val)\\n\\t\\thead = head -> next;\\n\\n\\treturn head;\\n}\\n```\n```\\ndef removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n\\tif not head:\\n\\t\\treturn head\\n\\n\\tnode = head\\n\\twhile node and node.next:\\n\\t\\tif node.next.val == val:\\n\\t\\t\\tnode.next = node.next.next\\n\\n\\t\\telse:\\n\\t\\t\\tnode = node.next\\n\\n\\tif head.val == val:\\n\\t\\thead = head.next\\n\\n\\treturn head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 256356,
                "title": "my-fast-javascript-solution-with-explaination",
                "content": "First we have to check whether or not the linked-list is empty.If it is, we don\\'t even bother going to the next step, and just return null. If it is not empty, we can set two pointers, one points to the forward node, the other points to the previous (pay attention that we have skipped the validation for the first node, we will deal with it at the end : )\\nAfter the setting up, now we can start to run the loop.If the current-node\\'s value equals to the target\\'s value, we take a leap, let the current node equals to its next node, and set the previous node points to the current node.Else, moving two pointers(cur,prev) one step forward...\\nAt last, the target node will all be removed, except for the first one. For example, [1,1,1,1] 1. That is because we have skipped the checking for the first node. Let\\'s fix it by directly checking the value of the head node, if it equals to the target value,  we simply move it one node forward. That\\'s all.\\n```\\nvar removeElements = function(head, val) {\\n    if(!head)return null;\\n    let cur = head.next,\\n        prev = head;\\n    while(cur){\\n        if(cur.val === val){\\n            cur = cur.next;\\n            prev.next = cur;\\n        }else{\\n            prev = cur;\\n            cur = cur.next\\n        }\\n    }\\n    if(head.val === val)return head.next;\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n    if(!head)return null;\\n    let cur = head.next,\\n        prev = head;\\n    while(cur){\\n        if(cur.val === val){\\n            cur = cur.next;\\n            prev.next = cur;\\n        }else{\\n            prev = cur;\\n            cur = cur.next\\n        }\\n    }\\n    if(head.val === val)return head.next;\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454737,
                "title": "very-easy-0-ms-100-fully-explained-java-c-python-js-c-python3",
                "content": "# **Java Solution:**\\nRuntime: 0 ms, faster than 100.00% of Java online submissions for Remove Linked List Elements.\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next not null...\\n        while(curr.next != null){\\n            // if we find the target val same as the value of curr.next...\\n            if(curr.next.val == val){\\n                // Skip that value and keep updating curr...\\n                curr.next = curr.next.next; \\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\\n\\n# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode *prev, *curr;\\n        //deal with leading \\'val\\'s\\n        // If the head node is not null and the value of the head node is same as the target val...\\n        while(head != NULL && head->val == val)\\n            // Skip the value and keep updating head node...\\n            head = head->next;\\n        // Deal with \\'val\\'s not in head of list...\\n        // curr node points to the head node...\\n        curr = head;\\n        // Loop till curr not null...\\n        while(curr != NULL){\\n            // If we find the target val same as the value of curr...\\n            if(curr->val == val){\\n                // Skip that value and keep updating...\\n                prev->next = curr->next;\\n            }\\n            // Move prev when the next node of prev is not \\'val\\'\\n            else{\\n                prev = curr;\\n            }\\n            // Move curr forward...\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\n# **Python Solution:**\\n```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        # create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        fake = ListNode(None)\\n        fake.next = head\\n        curr = fake\\n        # Loop till curr.next not null...\\n        while curr.next:\\n            # if we find the target val same as the value of curr.next...\\n            if curr.next.val == val:\\n                # Skip that value and keep updating curr...\\n                curr.next = curr.next.next\\n            # Otherwise, move curr forward...\\n            else:\\n                curr = curr.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n        \\n# **JavaScript Solution:**\\n```\\nvar removeElements = function(head, val) {\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next not null...\\n    while(curr.next != null){\\n        // if we find the target val same as the value of curr.next...\\n        if(curr.next.val == val){\\n            // Skip that value and keep updating curr...\\n            curr.next = curr.next.next; \\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\\n\\n# **C Language:**\\n```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode *prev, *curr;\\n    //deal with leading \\'val\\'s\\n    // If the head node is not null and the value of the head node is same as the target val...\\n    while(head != NULL && head->val == val)\\n        // Skip the value and keep updating head node...\\n        head = head->next;\\n    // Deal with \\'val\\'s not in head of list...\\n    // curr node points to the head node...\\n    curr = head;\\n    // Loop till curr not null...\\n    while(curr != NULL){\\n        // If we find the target val same as the value of curr...\\n        if(curr->val == val){\\n            // Skip that value and keep updating...\\n            prev->next = curr->next;\\n        }\\n        // Move prev when the next node of prev is not \\'val\\'\\n        else{\\n            prev = curr;\\n        }\\n        // Move curr forward...\\n        curr = curr->next;\\n    }\\n    return head;\\n}\\n```\\n\\n# **Python3 Solution:**\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        # create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        fake = ListNode(None)\\n        fake.next = head\\n        curr = fake\\n        # Loop till curr.next not null...\\n        while curr.next:\\n            # if we find the target val same as the value of curr.next...\\n            if curr.next.val == val:\\n                # Skip that value and keep updating curr...\\n                curr.next = curr.next.next\\n            # Otherwise, move curr forward...\\n            else:\\n                curr = curr.next\\n        # Return the linked list...\\n        return fake.next\\n```\\n**I am working hard for you guys...\\nPlease upvote if you found any help with this code...**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        ListNode curr = fake;\\n        // Loop till curr.next not null...\\n        while(curr.next != null){\\n            // if we find the target val same as the value of curr.next...\\n            if(curr.next.val == val){\\n                // Skip that value and keep updating curr...\\n                curr.next = curr.next.next; \\n            }\\n            // Otherwise, move curr forward...\\n            else{\\n                curr = curr.next;\\n            }\\n        }\\n        return fake.next;       // Return the linked list...\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode *prev, *curr;\\n        //deal with leading \\'val\\'s\\n        // If the head node is not null and the value of the head node is same as the target val...\\n        while(head != NULL && head->val == val)\\n            // Skip the value and keep updating head node...\\n            head = head->next;\\n        // Deal with \\'val\\'s not in head of list...\\n        // curr node points to the head node...\\n        curr = head;\\n        // Loop till curr not null...\\n        while(curr != NULL){\\n            // If we find the target val same as the value of curr...\\n            if(curr->val == val){\\n                // Skip that value and keep updating...\\n                prev->next = curr->next;\\n            }\\n            // Move prev when the next node of prev is not \\'val\\'\\n            else{\\n                prev = curr;\\n            }\\n            // Move curr forward...\\n            curr = curr->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        # create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        fake = ListNode(None)\\n        fake.next = head\\n        curr = fake\\n        # Loop till curr.next not null...\\n        while curr.next:\\n            # if we find the target val same as the value of curr.next...\\n            if curr.next.val == val:\\n                # Skip that value and keep updating curr...\\n                curr.next = curr.next.next\\n            # Otherwise, move curr forward...\\n            else:\\n                curr = curr.next\\n        # Return the linked list...\\n        return fake.next\\n```\n```\\nvar removeElements = function(head, val) {\\n    // create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n    var fake = new ListNode(0);\\n    fake.next = head;\\n    var curr = fake;\\n    // Loop till curr.next not null...\\n    while(curr.next != null){\\n        // if we find the target val same as the value of curr.next...\\n        if(curr.next.val == val){\\n            // Skip that value and keep updating curr...\\n            curr.next = curr.next.next; \\n        }\\n        // Otherwise, move curr forward...\\n        else{\\n            curr = curr.next;\\n        }\\n    }\\n    return fake.next;       // Return the linked list...\\n};\\n```\n```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode *prev, *curr;\\n    //deal with leading \\'val\\'s\\n    // If the head node is not null and the value of the head node is same as the target val...\\n    while(head != NULL && head->val == val)\\n        // Skip the value and keep updating head node...\\n        head = head->next;\\n    // Deal with \\'val\\'s not in head of list...\\n    // curr node points to the head node...\\n    curr = head;\\n    // Loop till curr not null...\\n    while(curr != NULL){\\n        // If we find the target val same as the value of curr...\\n        if(curr->val == val){\\n            // Skip that value and keep updating...\\n            prev->next = curr->next;\\n        }\\n        // Move prev when the next node of prev is not \\'val\\'\\n        else{\\n            prev = curr;\\n        }\\n        // Move curr forward...\\n        curr = curr->next;\\n    }\\n    return head;\\n}\\n```\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        # create a fake node that acts like a fake head of list pointing to the original head and it points to the original head...\\n        fake = ListNode(None)\\n        fake.next = head\\n        curr = fake\\n        # Loop till curr.next not null...\\n        while curr.next:\\n            # if we find the target val same as the value of curr.next...\\n            if curr.next.val == val:\\n                # Skip that value and keep updating curr...\\n                curr.next = curr.next.next\\n            # Otherwise, move curr forward...\\n            else:\\n                curr = curr.next\\n        # Return the linked list...\\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 492317,
                "title": "python-easy-to-follow-with-comments-no-dummy-node",
                "content": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        prev, current = None, head\\n        while current:\\n            if current.val == val:\\n                if prev:\\n                    # Remove the current node in the normal way.\\n                    prev.next = current.next\\n                    current = prev\\n                else:\\n                    # We are at the head, advance the head and keep prev as None.\\n                    head = head.next\\n            else:\\n                # Advance the prev pointer.\\n                prev = current\\n            # Advance the current pointer.\\n            current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        prev, current = None, head\\n        while current:\\n            if current.val == val:\\n                if prev:\\n                    # Remove the current node in the normal way.\\n                    prev.next = current.next\\n                    current = prev\\n                else:\\n                    # We are at the head, advance the head and keep prev as None.\\n                    head = head.next\\n            else:\\n                # Advance the prev pointer.\\n                prev = current\\n            # Advance the current pointer.\\n            current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57515,
                "title": "an-easy-understand-solution-with-pretty-fast-speed",
                "content": "    public class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            while(head != null && head.val == val) {\\n                head = head.next;\\n            }\\n            if(head == null) {\\n                return head;\\n            }\\n            ListNode p = head;\\n            while(p.next != null) {\\n                if(p.next.val == val) {\\n                    p.next = p.next.next;\\n                } else {\\n                    p = p.next;\\n                }\\n            }\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            while(head != null && head.val == val) {\\n                head = head.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 57312,
                "title": "python-solution",
                "content": "    class Solution:\\n    # @param {ListNode} head\\n    # @param {integer} val\\n    # @return {ListNode}\\n    def removeElements(self, head, val):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        next = dummy\\n        \\n        while next != None and next.next != None:\\n            if next.next.val == val:\\n                next.next = next.next.next\\n            else:\\n                next = next.next\\n            \\n        return dummy.next",
                "solutionTags": [],
                "code": "class Solution:\\n    # @param {ListNode}",
                "codeTag": "Java"
            },
            {
                "id": 3036500,
                "title": "python-simple-solution-beats-95",
                "content": "\\n## Upvote if it helps! \\uD83D\\uDE00\\n\\n# Approach\\n- The first loop is to detect **if there are nodes to delete at the beginning**.\\n    - In this case we move head until we find the first element which has a different value.\\n- The second loop iterate over the list:\\n    - If we find a node to delete, we also verify if there are a succession of nodes to be deleted with the while.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        # First loop\\n        while head and head.val == val:\\n            head = head.next\\n\\n        current = head\\n\\n        # Second loop\\n        while current:\\n            while current and current.next and current.next.val == val:\\n                current.next = current.next.next\\n            current = current.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        # First loop\\n        while head and head.val == val:\\n            head = head.next\\n\\n        current = head\\n\\n        # Second loop\\n        while current:\\n            while current and current.next and current.next.val == val:\\n                current.next = current.next.next\\n            current = current.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745470,
                "title": "python-one-pass-o-n-time-o-1-memory-explained",
                "content": "Easy linked list traversal problem, without any smart ideas: just traverse list and do what is asked. Two small things which helps to simplify code:\\n1. When traverse, always look at the next element in list, because if we already at element with value equal to `val`, we can not delete it, we need to go back somehow.\\n2. Use dummy head to deal with case when head is equal to `val`.\\n\\nSo, basically our algorithm looks like this: we traverse our list and if value of next element is equal to `val`, we need to delete it, so we do `start.next = start.next.next`. Note, that in this case we do not move our pointers, because there can be more element equal to `val`. If value is not equal to `val`, we move to the next element.\\n\\n**Complexity**: time complexity is `O(n)` with only one pass, space complexity is `O(1)`, because we do not use any additional memory except couple of variable.\\n\\n```\\nclass Solution:\\n    def removeElements(self, head, val):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        start = dummy\\n        while start.next:\\n            if start.next.val == val:\\n                start.next = start.next.next\\n            else:\\n                start = start.next         \\n        return dummy.next   \\n```\\n\\nIf you have any questoins, feel free to ask. If you like the solution and explanation, please **upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head, val):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        start = dummy\\n        while start.next:\\n            if start.next.val == val:\\n                start.next = start.next.next\\n            else:\\n                start = start.next         \\n        return dummy.next   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 745459,
                "title": "c-simple-iterative-vs-recursive-oneliner-solution-explained-85-time-85-space",
                "content": "So, our first step is to update `head` until its current value matches `val` (and provided we actually have `head` - ie: it is not `NULL`); note that we are not changing any properties here, just updating where `head` is pointing.\\n\\nIf we are done here (either `head` was initially `NULL` or it is now since we traversed the whole list and found only matching values), then we return `head` (or `NULL`, same thing in this case).\\n\\nOnce that is done, we create a support variable `tmp` (because we still have to return `head` later, so we do not want to modify it any further) and progress similarly: we know initially its value cannot be a match, so we proceeed until `tmp->next` is a valid node and if it is a match, then we change its value to point to its following node; otherwise, we just update `tmp`.\\n\\nOnce this is all done, we just return `head`.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // getting rid of potential initial matches\\n        while (head && head->val == val) head = head->next;\\n        if (!head) return head;\\n        // getting rid of other matches\\n        ListNode *tmp = head;\\n        while (tmp->next) {\\n            if (tmp->next->val == val) tmp->next = tmp->next->next;\\n            else tmp = tmp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\n\\nNow, just for fun, I converted it all to a monster onliner (don\\'t do this in interviews!); notice that the possibly only tricky part of converting it all was to use the comma operator to modify `tmp` in the penultimate clause and adding the second condition (` || (tmp && !tmp->next)`) to the very first case in order for it to work on terminal cases.\\n\\nThe unholy oneliner:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val, ListNode* tmp = NULL) {\\n        return !head || (tmp && !tmp->next) ? head : head->val == val ? removeElements(head->next, val) : !tmp ? removeElements(head, val, head) : tmp->next->val == val ? removeElements(head, val, (tmp->next = tmp->next->next, tmp)) :  removeElements(head, val, tmp->next);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // getting rid of potential initial matches\\n        while (head && head->val == val) head = head->next;\\n        if (!head) return head;\\n        // getting rid of other matches\\n        ListNode *tmp = head;\\n        while (tmp->next) {\\n            if (tmp->next->val == val) tmp->next = tmp->next->next;\\n            else tmp = tmp->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val, ListNode* tmp = NULL) {\\n        return !head || (tmp && !tmp->next) ? head : head->val == val ? removeElements(head->next, val) : !tmp ? removeElements(head, val, head) : tmp->next->val == val ? removeElements(head, val, (tmp->next = tmp->next->next, tmp)) :  removeElements(head, val, tmp->next);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2655657,
                "title": "simple-recursive-solution",
                "content": "This solution is based on recursion. Here a recursive function \"removenode\" is used. The end of the linked list is reached with the help of the recursive function. \\n![image](https://assets.leetcode.com/users/images/a95d85b9-4549-4960-a10a-5f6614b0dd0a_1664804128.6790764.png)\\n\\nLet us take the above image for illustration. The target value is 6. \\n1. When the end of the linked list is reached by recursive function and NULL is found(The base case) then that instance/stack of the function will return NULL to the previous node\\'s function call.\\n2. Here the value of the node before NULL is 6 which is equal to the target, if this is the case then that function stack will not return the current pointer to the previous node but the pointer to the NULL, Thus losing the pointer of node containing 6.\\n3. When the node 2 is reached then the condition is checked, if its equal to target or not, In this case, it is not thus the current node\\'s next will become the returned node from the previous function stack which was NULL. Thus next of two will become NULL. \\n4. When 6 is reached, the condition evalues as true and and thus returns the pointer of (2) to the previous node.\\n5. When 1 reaches the, condition evaluates as false and thus the next of 1 is the returned pointer which is 2.\\n\\n\\n```\\nListNode *removenode(ListNode *ptr, int target){\\n\\t//base case\\n    if(ptr==NULL){\\n        return NULL;\\n    }\\n\\t//call the recursive function and pass the next node\\n    ListNode *returnnode = removenode(ptr->next,target);\\n\\t///All the below lines will be executed when the recursive function comes back\\n\\t//check if the value of cuurent node is equal to the value of target.\\n    if(ptr->val == target){\\n\\t\\t//if the value of current node is equal to the taget then return the previously returned value.\\n        return returnnode;\\n    }\\n    else{\\n\\t\\t//since the value of current node is not equal to target thus modify the next node.\\n        ptr->next = returnnode;\\n\\t\\t//return the pointer to the current node.\\n        return ptr;\\n    }\\n}\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        return removenode(head,val);\\n    }\\n};\\n```\\n\\nI tried my best to explain the solution. Please upvote or any doubts u can add in comments.",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nListNode *removenode(ListNode *ptr, int target){\\n\\t//base case\\n    if(ptr==NULL){\\n        return NULL;\\n    }\\n\\t//call the recursive function and pass the next node\\n    ListNode *returnnode = removenode(ptr->next,target);\\n\\t///All the below lines will be executed when the recursive function comes back\\n\\t//check if the value of cuurent node is equal to the value of target.\\n    if(ptr->val == target){\\n\\t\\t//if the value of current node is equal to the taget then return the previously returned value.\\n        return returnnode;\\n    }\\n    else{\\n\\t\\t//since the value of current node is not equal to target thus modify the next node.\\n        ptr->next = returnnode;\\n\\t\\t//return the pointer to the current node.\\n        return ptr;\\n    }\\n}\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        return removenode(head,val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746297,
                "title": "rust-no-unwraps",
                "content": "```\\nimpl Solution {\\n    pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut ptr = &mut head;\\n\\n        loop {\\n            match ptr {\\n                None => break,\\n                Some(node) if node.val == val => {\\n                    *ptr = node.next.take();\\n                }\\n                Some(node) => {\\n                    ptr = &mut node.next;\\n                }\\n            }\\n        }\\n\\n        head\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut ptr = &mut head;\\n\\n        loop {\\n            match ptr {\\n                None => break,\\n                Some(node) if node.val == val => {\\n                    *ptr = node.next.take();\\n                }\\n                Some(node) => {\\n                    ptr = &mut node.next;\\n                }\\n            }\\n        }\\n\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 867106,
                "title": "simple-recursive-and-non-recursive-solution-in-c",
                "content": "## **Recursive Solution:**\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        if (head == 0) return head; //stopping condition.\\n        if (head->val == val)   //if value matches, ignore the element.\\n            return removeElements(head->next, val);\\n        else {                          //if does not match consider it.\\n            head->next = removeElements(head->next, val);\\n            return head;\\n        }\\n    }\\n```\\n\\n## **Non-Recursive Solution:**\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        if (head == 0) return head;\\n        \\n        ListNode* temp = head;\\n        while (temp != 0 and temp->next != 0) {\\n            if (temp->next->val == val) temp->next = temp->next->next;\\n            else temp = temp->next;\\n        }\\n        if (head->val == val) head = head->next;   \\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nListNode* removeElements(ListNode* head, int val) {\\n        if (head == 0) return head; //stopping condition.\\n        if (head->val == val)   //if value matches, ignore the element.\\n            return removeElements(head->next, val);\\n        else {                          //if does not match consider it.\\n            head->next = removeElements(head->next, val);\\n            return head;\\n        }\\n    }\\n```\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        if (head == 0) return head;\\n        \\n        ListNode* temp = head;\\n        while (temp != 0 and temp->next != 0) {\\n            if (temp->next->val == val) temp->next = temp->next->next;\\n            else temp = temp->next;\\n        }\\n        if (head->val == val) head = head->next;   \\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57514,
                "title": "java-remove-linked-list-elements-solution",
                "content": "public class Solution {\\n\\n    public ListNode removeElements(ListNode head, int val) {\\n\\n        ListNode dummy = new ListNode(1);\\n        ListNode i = dummy;\\n        ListNode j = head;\\n        dummy.next = head;\\n        \\n        while(j != null){\\n            if(j.val == val){\\n                i.next = i.next.next;\\n                j = j.next;\\n            }else{\\n                i = i.next;\\n                j = j.next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public ListNode removeElements(ListNode head, int val) {\\n\\n        ListNode dummy = new ListNode(1);\\n        ListNode i = dummy;\\n        ListNode j = head;\\n        dummy.next = head;\\n        \\n        while(j != null){\\n            if(j.val == val){\\n                i.next = i.next.next;\\n                j = j.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 57523,
                "title": "pointer-of-level-two",
                "content": "It's only intresting when implemented by \"[Two star programming][1]\"!\\n\\n    class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n    \\t\\tListNode **p = &head;\\n    \\t\\twhile(*p != NULL)\\n    \\t\\t{\\n    \\t\\t\\tif((*p)->val == val) \\n    \\t\\t\\t\\t*p = (*p)->next;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tp = &((*p)->next);\\n    \\t\\t}\\n    \\t\\treturn head;\\n        }\\n    };\\n\\n\\n  [1]: http://wordaligned.org/articles/two-star-programming",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n    \\t\\tListNode **p = &head;\\n    \\t\\twhile(*p != NULL)\\n    \\t\\t{\\n    \\t\\t\\tif((*p)->val == val) \\n    \\t\\t\\t\\t*p = (*p)->next;\\n    \\t\\t\\telse\\n    \\t\\t\\t\\tp = &((*p)->next);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1572997,
                "title": "javascript-clean-code-detailed-explanation-step-by-step",
                "content": "Problem statement is pretty clear, so let\\'s go straight to the examples where we need to remove all elements with value `0` from a linked list\\n\\n**Scenario 1.** We have some \"bad\" nodes at the beginning of the linked list\\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n```\\nLet\\'s introduce 2 pointers, `p` - points to a previous element, initially `undefined` as we do not have previous element yet, and `c` - points to the current element, initially points to the head of the linked list\\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\nc\\n```\\nNow, as `c` points to the element with value `0`, point `p` to the same element as `c`\\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\nc\\np\\n```\\nMove `c` to the next element in the linked list\\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n     c\\np\\n```\\nRemove link to the next element from `p`\\n```\\n_    0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n     c\\np\\n```\\nAs `c` points to the element with value `0` again, we need to repeat last 3 steps, so we end up at the situation, where all \"bad\" nodes are \"cut off\" and `c` points to the \"good\" element which is now a head of a resulting linked list\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n               p\\n```\\n**Scenario 2.** Now we have \"bad\" nodes in the middle of the linked list, and `c` points to the head of resulting linked list, so let\\'s introduce another variable `h` and point it to the same element `c` is pointing now\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n               p\\n\\t\\t\\t        h\\n```\\nAt this point, `c` points to a \"good\" node, so let\\'s point `p` to the same node\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n                    p\\n\\t\\t\\t        h\\n```\\nNow we can move `c` to the next element\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                         c\\n                    p\\n\\t\\t\\t        h\\n```\\nRepeat 2 last steps until `c` reaches another \"bad\" node\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                              c\\n                         p\\n\\t\\t\\t        h\\n```\\nNow, `c` points to the element with value `0`, which we need to remove, so we simply move `c` to the next element\\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                                   c\\n                         p\\n\\t\\t\\t        h\\n```\\nPoint next element of `p` to `c`, thus removing bad element from the list (You may notice here, that \"bad\" node is still poining to the \"good\" node, but we do not really care about it in this particular scenario)\\n```\\n_    _    _    _    2 -> 1 ------> 3 -> \\n                                   c\\n                         p\\n\\t\\t\\t        h\\n```\\nRepeat until `c` reches very end of the linked list and return `h`\\n```\\n_    _    _    _    2 -> 1 ------> 3 -> \\n                                        c\\n                                   p\\n\\t\\t\\t        h\\n```\\n\\n**Finally**, write some code\\n```\\nconst removeElements = function(head, val) {\\n\\t// Introduce p and c, where p is undefined and c points to the first element of a linked list \\n    let previous;\\n    let current = head;\\n\\n\\t// Handle scenario, where \"bad\" nodes are at the beginning of a linked list\\n    while (current && current.val === val) {\\n        previous = current;\\n        current = current.next;\\n        previous.next = null;\\n    }\\n\\n\\t// Introduce h and point it to the c, which is currently a head of the resulting linked list \\n    head = current;\\n    while (current) {\\n        if (current.val === val) {\\n\\t\\t\\t// Handle case when c points to a \"bad\" node, where we link p to the next node of c\\n            previous.next = current.next;\\n            current = current.next;\\n        } else {\\n\\t\\t\\t// Handle case when c points to a \"good\" node, where we simply advance to the next node of c \\n            previous = current;\\n            current = current.next;\\n        }\\n    }\\n    return head;\\n};\\n```\\n\\n**Analysis.** As we pass linked list only once, it gives us `O(n)` time complexity. As we use only fixed number of variables, which does not depend on the number of elements in a linked list, we are at `O(1)` space complexity",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n```\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\nc\\n```\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\nc\\np\\n```\n```\\n0 -> 0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n     c\\np\\n```\n```\\n_    0 -> 0 -> 0 -> 2 -> 1 -> 0 -> 3 -> \\n     c\\np\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n               p\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n               p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                    c\\n                    p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                         c\\n                    p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                              c\\n                         p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 -> 0 -> 3 -> \\n                                   c\\n                         p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 ------> 3 -> \\n                                   c\\n                         p\\n\\t\\t\\t        h\\n```\n```\\n_    _    _    _    2 -> 1 ------> 3 -> \\n                                        c\\n                                   p\\n\\t\\t\\t        h\\n```\n```\\nconst removeElements = function(head, val) {\\n\\t// Introduce p and c, where p is undefined and c points to the first element of a linked list \\n    let previous;\\n    let current = head;\\n\\n\\t// Handle scenario, where \"bad\" nodes are at the beginning of a linked list\\n    while (current && current.val === val) {\\n        previous = current;\\n        current = current.next;\\n        previous.next = null;\\n    }\\n\\n\\t// Introduce h and point it to the c, which is currently a head of the resulting linked list \\n    head = current;\\n    while (current) {\\n        if (current.val === val) {\\n\\t\\t\\t// Handle case when c points to a \"bad\" node, where we link p to the next node of c\\n            previous.next = current.next;\\n            current = current.next;\\n        } else {\\n\\t\\t\\t// Handle case when c points to a \"good\" node, where we simply advance to the next node of c \\n            previous = current;\\n            current = current.next;\\n        }\\n    }\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1283527,
                "title": "java-100-faster-and-simple",
                "content": "```class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null) return head;\\n\\n        ListNode ptr = head;\\n        \\n        while(ptr.next != null) {\\n            if(ptr.next.val == val) ptr.next = ptr.next.next;\\n            else ptr = ptr.next;\\n        }\\n        if(head.val == val) return head.next;\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null) return head;\\n\\n        ListNode ptr = head;\\n        \\n        while(ptr.next != null) {\\n            if(ptr.next.val == val) ptr.next = ptr.next.next;\\n            else ptr = ptr.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 381917,
                "title": "python-solution-using-dummy-head",
                "content": "The idea here is we do not know where `val` will appear, it could very well appear at the beginning of the list. To take care of this case we create a `dummy_head` that point to the current head. To remove a list element we need to wire the node preceding `val` to the node following `val`. We look ahead starting at the dummy node to see if the `next` node contains `val`. If it does we wire the current node `next` to `next.next`, that is the node after `val`. If `val` is not in the next node we just move our current node there.\\n\\n```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        dummy_head = ListNode(0)\\n        dummy_head.next = head\\n        node = dummy_head\\n        while node.next:\\n            if node.next.val == val:\\n                node.next = node.next.next\\n            else:\\n                node = node.next\\n        return dummy_head.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        dummy_head = ListNode(0)\\n        dummy_head.next = head\\n        node = dummy_head\\n        while node.next:\\n            if node.next.val == val:\\n                node.next = node.next.next\\n            else:\\n                node = node.next\\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57307,
                "title": "my-easy-c-solution",
                "content": "\\n\\n\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode** tmp = &head;\\n        while(*tmp){\\n            if((*tmp)->val == val) *tmp = (*tmp)->next;\\n            else tmp = &((*tmp)->next);\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "\\n\\n\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode** tmp = &head;\\n        while(*tmp){\\n            if((*tmp)->val == val) *tmp = (*tmp)->next;\\n            else tmp = &((*tmp)->next);\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 57571,
                "title": "simple-12ms-c-solution",
                "content": "Just for your reference, welcome any comment.\\n    \\n    struct ListNode* removeElements(struct ListNode* head, int val) \\n    {\\n        struct ListNode **pp, *p;\\n    \\n        pp = &head;\\n        while (*pp) {\\n            p = *pp;\\n            if ((*pp)->val == val) { /* found one */\\n                *pp = p->next;\\n                free(p);\\n            } else\\n                pp = &p->next;\\n        }\\n    \\n        return head;\\n    }",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "Just for your reference, welcome any comment.\\n    \\n    struct ListNode* removeElements(struct ListNode* head, int val) \\n    {\\n        struct ListNode **pp, *p;\\n    \\n        pp = &head;\\n        while (*pp) {\\n            p = *pp;\\n            if ((*pp)->val == val) { /* found one */\\n                *pp = p->next;\\n                free(p);\\n            } else\\n                pp = &p->next;\\n        }\\n    \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1393993,
                "title": "5-lines-solution-specially-for-beginners-optimal-easiest-easily-understandable",
                "content": "ListNode* removeElements(ListNode* head, int val) {\\n            \\n            ListNode* curr=head;\\n            \\n            \\n            if(head==NULL)return NULL;\\n           while(head!=NULL && head->val==val) head=head->next;\\n             while(curr!=NULL && curr->next!=NULL){\\n            if(curr->next->val==val) curr->next=curr->next->next;\\n                else   curr=curr->next;\\n            }\\n            \\n            return head;\\n        \\n    }\\n\\t\\n\\t// Guys plz plz plz upvote my solution if you like and understand it.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "ListNode* removeElements(ListNode* head, int val) {\\n            \\n            ListNode* curr=head;\\n            \\n            \\n            if(head==NULL)return NULL;\\n           while(head!=NULL && head->val==val) head=head->next;\\n             while(curr!=NULL && curr->next!=NULL){\\n            if(curr->next->val==val) curr->next=curr->next->next;\\n                else   curr=curr->next;\\n            }\\n            \\n            return head;\\n        \\n    }\\n\\t\\n\\t// Guys plz plz plz upvote my solution if you like and understand it.",
                "codeTag": "Unknown"
            },
            {
                "id": 2829118,
                "title": "python-easy-understandable-one-while-loop",
                "content": "## Iterative Approach\\n- Here easy and uderstadable code.\\n\\n__Python :__\\n\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        temp = head\\n        prev = None             # initially prev should points to None\\n        while temp!=None:\\n            if temp.val == val and prev == None :      # when first node is val which has to remove\\n                temp = temp.next\\n                head = temp\\n                prev = None                         # prev must None because still first Node equal to val\\n            elif temp.val == val:               # when in middle node equal to val\\n                prev.next = temp.next               # simple prev point to next node\\n                temp = temp.next\\n            else:                               # Move untill node not equal to val\\n                prev = temp\\n                temp = temp.next\\n        return head\\n```\\n\\n- One last request if you understand it do upvote.",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        temp = head\\n        prev = None             # initially prev should points to None\\n        while temp!=None:\\n            if temp.val == val and prev == None :      # when first node is val which has to remove\\n                temp = temp.next\\n                head = temp\\n                prev = None                         # prev must None because still first Node equal to val\\n            elif temp.val == val:               # when in middle node equal to val\\n                prev.next = temp.next               # simple prev point to next node\\n                temp = temp.next\\n            else:                               # Move untill node not equal to val\\n                prev = temp\\n                temp = temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702258,
                "title": "java-98-96-faster-with-comments",
                "content": "```\\npublic ListNode removeElements(ListNode head, int val) {\\n        if(head==null) return null; //list of size 0\\n        if(head.next==null && head.val==val) return null; //list of size 1\\n        // if all elements of list are equal to val given\\n        while(head!=null && head.val==val){  // \\n            head = head.next;\\n        }\\n        ListNode curr = head;\\n        \\n        while(curr!=null && curr.next!=null){\\n            if(curr.next.val==val){\\n                curr.next = curr.next.next;\\n            }else{\\n                curr = curr.next;\\n            }\\n            \\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\npublic ListNode removeElements(ListNode head, int val) {\\n        if(head==null) return null; //list of size 0\\n        if(head.next==null && head.val==val) return null; //list of size 1\\n        // if all elements of list are equal to val given\\n        while(head!=null && head.val==val){  // \\n            head = head.next;\\n        }\\n        ListNode curr = head;\\n        \\n        while(curr!=null && curr.next!=null){\\n            if(curr.next.val==val){\\n                curr.next = curr.next.next;\\n            }else{\\n                curr = curr.next;\\n            }\\n            \\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1708637,
                "title": "c-single-pointer-approach-faster-than-98-consumes-83-less-memory-explained",
                "content": "class Solution {\\npublic:\\n\\n    ListNode* removeElements(ListNode* head, int val) {\\n        \\n        while(head != NULL && head -> val == val)    // eg [7, 7, 7, 5] val = 7, then we have to delete all 7 and move head to 5.\\n        {\\n            head = head -> next;\\n        }\\n        \\n        if(head == NULL)            // eg [7, 7, 7, 7] val = 7, then we have to delete all 7 and return NULL.\\n            return head;\\n        \\n        ListNode* curr = head;\\n        \\n        while(curr -> next != NULL)\\n        {\\n            if(curr -> next -> val == val)\\n            {\\n                curr -> next = curr -> next -> next;\\n            }\\n            else  \\n            {\\n                curr = curr -> next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* removeElements(ListNode* head, int val) {\\n        \\n        while(head != NULL && head -> val == val)    // eg [7, 7, 7, 5] val = 7, then we have to delete all 7 and move head to 5.\\n        {\\n            head = head -> next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 924412,
                "title": "easy-js-solution",
                "content": "```\\nvar removeElements = function(head, val) {\\n    let dummy = new ListNode();\\n    let cur = dummy;\\n    \\n    while (head !== null) {\\n        if (head.val !== val) {\\n            cur.next = head;\\n            cur = cur.next;\\n        }\\n        head = head.next;\\n    }\\n    cur.next = null;\\n    return dummy.next;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n    let dummy = new ListNode();\\n    let cur = dummy;\\n    \\n    while (head !== null) {\\n        if (head.val !== val) {\\n            cur.next = head;\\n            cur = cur.next;\\n        }\\n        head = head.next;\\n    }\\n    cur.next = null;\\n    return dummy.next;\\n    // Time Complexity: O(n)\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 799736,
                "title": "javascript-solution-203",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nlet removeElements = function(head, val) {\\n    let h=new ListNode(-1);\\n    h.next=head;\\n    head=h;\\n    while(h.next!==null){\\n        if(h.next.val===val){\\n            h.next=h.next.next;\\n        }\\n        else{\\n            h=h.next;\\n        }\\n    }\\n    return head.next;  \\n};\\n```\\n\\n**Runtime: 100 ms, faster than 59.51% of JavaScript online submissions for Remove Linked List Elements.**\\n\\n**Memory Usage: 41.5 MB, less than 21.18% of JavaScript online submissions for Remove Linked List Elements.**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nlet removeElements = function(head, val) {\\n    let h=new ListNode(-1);\\n    h.next=head;\\n    head=h;\\n    while(h.next!==null){\\n        if(h.next.val===val){\\n            h.next=h.next.next;\\n        }\\n        else{\\n            h=h.next;\\n        }\\n    }\\n    return head.next;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 208941,
                "title": "python-solution",
                "content": "Time complexity: `O(n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        prev = ListNode(0)\\n        prev.next = head\\n        record = prev\\n        trav = head\\n        while trav:\\n            if trav.val == val:\\n                prev.next = trav.next\\n                trav = prev.next\\n            else:\\n                prev = trav\\n                trav = trav.next\\n        return record.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        prev = ListNode(0)\\n        prev.next = head\\n        record = prev\\n        trav = head\\n        while trav:\\n            if trav.val == val:\\n                prev.next = trav.next\\n                trav = prev.next\\n            else:\\n                prev = trav\\n                trav = trav.next\\n        return record.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57337,
                "title": "javascript-solution",
                "content": "````\\nvar removeElements = function(head, val) {\\n    \\n    var prev = null,\\n        actual = head;\\n    \\n    while(actual !== null){\\n        \\n        if(actual.val === val){\\n            if(prev === null){\\n                head = actual.next;\\n            }else{\\n                prev.next = actual.next;\\n            }\\n        }else{\\n            prev = actual;\\n        }\\n        \\n        actual = actual.next;\\n        \\n    }\\n    \\n    return head;\\n};",
                "solutionTags": [],
                "code": "````\\nvar removeElements = function(head, val) {\\n    \\n    var prev = null,\\n        actual = head;\\n    \\n    while(actual !== null){\\n        \\n        if(actual.val === val){\\n            if(prev === null){\\n                head = actual.next;\\n            }else{\\n                prev.next = actual.next;\\n            }\\n        }else{\\n            prev = actual;\\n        }\\n        \\n        actual = actual.next;\\n        \\n    }\\n    \\n    return head;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 57438,
                "title": "my-javascript-solution",
                "content": "    var removeElements = function(head, val) {\\n        var current = head;\\n        var previous = null;\\n        \\n        while(current){\\n            if(current.val === val){\\n                if(previous){\\n                    previous.next = current.next;\\n                }else{\\n                    head = current.next;\\n                }\\n            }else{\\n                previous = current;\\n            }\\n            \\n            current = current.next;\\n        }\\n        \\n        return head;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var removeElements = function(head, val) {\\n        var current = head;\\n        var previous = null;\\n        \\n        while(current){\\n            if(current.val === val){\\n                if(previous){\\n                    previous.next = current.next;\\n                }else{\\n                    head = current.next;\\n                }\\n            }else{\\n                previous = current;\\n            }\\n            \\n            current = current.next;\\n        }\\n        \\n        return head;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3447984,
                "title": "java-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode result = new ListNode(0);\\n        result.next = head;\\n\\n        ListNode current = result;\\n\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n        \\n        return result.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode result = new ListNode(0);\\n        result.next = head;\\n\\n        ListNode current = result;\\n\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;\\n            } else {\\n                current = current.next;\\n            }\\n        }\\n        \\n        return result.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3220587,
                "title": "203-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe will start by initializing a dummy node and make its next point to head, which will make it easy to handle edge cases.\\n\\nWe will traverse the linked list and remove all the nodes with val equal to given val.\\n\\nAt the end, we will return the next node of dummy node as the new head.\\n\\nAlgorithm:\\n\\n1. Initialize a dummy node and point its next to the head of the linked list.\\n2. Initialize two pointers, prev and curr as dummy and head, respectively.\\n3. Traverse the linked list:\\na. If the value of the current node is equal to the given value, then set the next of the prev node to the next of curr node and move curr to the next node.\\nb. Else, move prev and curr to their next nodes.\\n4. Return the next of the dummy node as the new head of the linked list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        dummy = ListNode(0)  # initialize dummy node\\n        dummy.next = head  # point its next to head\\n        prev, curr = dummy, head  # initialize prev and curr pointers\\n        \\n        while curr:  # traverse the linked list\\n            if curr.val == val:  # if val found\\n                prev.next = curr.next  # remove the node by skipping it\\n            else:\\n                prev = curr  # move prev to the next node\\n            curr = curr.next  # move curr to the next node\\n        \\n        return dummy.next  # return the new head\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        dummy = ListNode(0)  # initialize dummy node\\n        dummy.next = head  # point its next to head\\n        prev, curr = dummy, head  # initialize prev and curr pointers\\n        \\n        while curr:  # traverse the linked list\\n            if curr.val == val:  # if val found\\n                prev.next = curr.next  # remove the node by skipping it\\n            else:\\n                prev = curr  # move prev to the next node\\n            curr = curr.next  # move curr to the next node\\n        \\n        return dummy.next  # return the new head\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3198676,
                "title": "solution-intuition-approach-complexity-and-code-removing-linked-list-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires removing all nodes that match a specific value from a linked list. The approach involves iterating through the linked list while maintaining a previous node pointer to update the next node pointer of the previous node once a node that matches the specific value is found. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve the problem, we use two pointers, a previous pointer `prev` and a current pointer `curr`, both initially pointing to the head of the linked list. While iterating through the linked list, if the current node has a value equal to the specific value, we skip the current node by updating the next node pointer of the previous node to point to the next node of the current node. Otherwise, we update the previous node pointer to point to the current node.\\n# Complexity\\n- Time complexity:$O(n)$, where n is the number of nodes in the linked list. The algorithm iterates through each node in the linked list at most once to remove the nodes that match the specific value.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$O(1)$. The algorithm uses a constant amount of extra memory to maintain the previous and current node pointers.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n    \\n        while curr:\\n            if curr.val == val:\\n                if prev:\\n                    prev.next = curr.next\\n                else:\\n                    head = curr.next\\n                curr = curr.next\\n            else:\\n                prev = curr\\n                curr = curr.next\\n    \\n        return head\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n    \\n        while curr:\\n            if curr.val == val:\\n                if prev:\\n                    prev.next = curr.next\\n                else:\\n                    head = curr.next\\n                curr = curr.next\\n            else:\\n                prev = curr\\n                curr = curr.next\\n    \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126711,
                "title": "best-solution-using-data-structure-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val){\\n     ListNode x=head;\\n        ListNode it=x;\\n        while(x!=null && x.val==val){\\n            head=x.next;\\n            x=head;\\n        }\\n        while(x!=null){\\n            if(x.val==val){\\n               \\n                it.next=x.next;\\n                x=it.next;\\n            }\\n            else{\\n                it=x;\\n                x=x.next;\\n            }\\n            \\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val){\\n     ListNode x=head;\\n        ListNode it=x;\\n        while(x!=null && x.val==val){\\n            head=x.next;\\n            x=head;\\n        }\\n        while(x!=null){\\n            if(x.val==val){\\n               \\n                it.next=x.next;\\n                x=it.next;\\n            }\\n            else{\\n                it=x;\\n                x=x.next;\\n            }\\n            \\n        }\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2955214,
                "title": "c-easy-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int value) {\\n        \\n        \\n        while(head != NULL && head->val == value){\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n            return head;\\n        \\n        head->next = removeElements(head->next,value);\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int value) {\\n        \\n        \\n        while(head != NULL && head->val == value){\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n            return head;\\n        \\n        head->next = removeElements(head->next,value);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369093,
                "title": "simple-python-recursion",
                "content": "1. The base case: return None when there is no more head node i.e. the end of the linked list\\n2. The recursive case: we traverse through the rest of the linked list by repatitively calling the function itself, and point head.next to the return result \\n3. On each level of the recrusion, we check if head.val equals val. If it does, we replace the head node with the next node. Otherwise, we simply return the head\\n```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        \\n        if not head:\\n            return head\\n\\n        head.next = self.removeElements(head.next, val)        \\n        if head.val == val:\\n            head = head.next\\n\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        \\n        if not head:\\n            return head\\n\\n        head.next = self.removeElements(head.next, val)        \\n        if head.val == val:\\n            head = head.next\\n\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 456137,
                "title": "simple-java-solution-faster-than-98",
                "content": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        else {\\n            if (head.val == val) return removeElements(head.next, val);\\n            else {\\n                head.next = removeElements(head.next, val);\\n                return head;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        else {\\n            if (head.val == val) return removeElements(head.next, val);\\n            else {\\n                head.next = removeElements(head.next, val);\\n                return head;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300871,
                "title": "c-clear-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        var dummy = new ListNode(0);\\n        var cur = dummy;\\n        while (head != null) {\\n            if (head.val != val) {\\n                cur.next = head;\\n                cur = cur.next;\\n            }    \\n            head = head.next;\\n        }\\n        cur.next = null;\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        var dummy = new ListNode(0);\\n        var cur = dummy;\\n        while (head != null) {\\n            if (head.val != val) {\\n                cur.next = head;\\n                cur = cur.next;\\n            }    \\n            head = head.next;\\n        }\\n        cur.next = null;\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 57388,
                "title": "simple-python-solution",
                "content": "```\\ndef removeElements(self, head, val):\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pointer = dummy\\n        \\n        while(pointer.next):\\n            \\n            if pointer.next.val == val:\\n                pointer.next = pointer.next.next\\n            else:\\n                pointer = pointer.next\\n                \\n        return dummy.next",
                "solutionTags": [],
                "code": "```\\ndef removeElements(self, head, val):\\n        \\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pointer = dummy\\n        \\n        while(pointer.next):\\n            \\n            if pointer.next.val == val:\\n                pointer.next = pointer.next.next\\n            else:\\n                pointer = pointer.next\\n                \\n        return dummy.next",
                "codeTag": "Python3"
            },
            {
                "id": 57422,
                "title": "java-solution-with-brief-explanation",
                "content": "basic idea is to have two pointers, one for previous node and one for current, if current node.val == val \\nwe want to set our previous.next to current.next.\\n\\nbut one problem is what if the head.val == val, I used a while loop to get ride of this situation. So I can be sure that head is always a valid node.\\n\\n\\n\\npublic ListNode removeElements(ListNode head, int val)\\n {\\n\\n        while(head != null && head.val == val){\\n            head = head.next;\\n        }    \\n        if(head == null)\\n            return null;\\n        ListNode pre = head, cur = head.next;\\n        while(cur != null){\\n            if(cur.val == val){\\n                pre.next = cur.next;\\n            }else {\\n                pre = pre.next;\\n            }\\n            cur = cur.next;\\n        }\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "basic idea is to have two pointers, one for previous node and one for current, if current node.val == val \\nwe want to set our previous.next to current.next.\\n\\nbut one problem is what if the head.val == val, I used a while loop to get ride of this situation. So I can be sure that head is always a valid node.\\n\\n\\n\\npublic ListNode removeElements(ListNode head, int val)\\n {\\n\\n        while(head != null && head.val == val){\\n            head = head.next;\\n        }    \\n        if(head == null)\\n            return null;\\n        ListNode pre = head, cur = head.next;\\n        while(cur != null){\\n            if(cur.val == val){\\n                pre.next = cur.next;\\n            }else {\\n                pre = pre.next;\\n            }\\n            cur = cur.next;\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3742478,
                "title": "simple-solution-beats-maximum",
                "content": "# Please upvote if you feel it easy\\uD83D\\uDE0A\\u2764\\n# Code\\n```\\n\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        \\n        if(head == null) return null;\\n        while(head!=null && head.val == val) head = head.next;\\n        ListNode temp = head;\\n        while(temp!=null && temp.next !=null) {\\n            if(temp.next.val == val) {\\n                temp.next = temp.next.next;\\n            }else{\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        \\n        if(head == null) return null;\\n        while(head!=null && head.val == val) head = head.next;\\n        ListNode temp = head;\\n        while(temp!=null && temp.next !=null) {\\n            if(temp.next.val == val) {\\n                temp.next = temp.next.next;\\n            }else{\\n                temp = temp.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3272069,
                "title": "python3-73ms-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Two Pointers Methods.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- maintain **two pointers** **prev and current**, meaning is self-described.\\n- now when **removing element is head** then **remove** head **till** it\\'s **not removing element**, till this time our **prev will be None**.\\n- now if removing element is not head then **prev.next = curr.next** and **curr = curr.next**, prev will be same because **if** we do **prev = curr** then **prev will be removed node**.\\n- now when we encounter **node** that is **not removing** then do **prev = curr and curr = curr.next.**\\n- do this all till curr is not None\\n- **return head**.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n        while curr:\\n            if curr.val == val and prev:\\n                prev.next = curr.next\\n                curr = curr.next\\n                continue\\n            elif curr.val == val and not prev:\\n                head = head.next\\n                curr = curr.next\\n                continue\\n            prev = curr\\n            curr = curr.next\\n        return head\\n```\\n# Please like and comment below (\\u0336\\u25C9\\u035B\\u203F\\u25C9\\u0336)",
                "solutionTags": [
                    "Python3",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        prev = None\\n        curr = head\\n        while curr:\\n            if curr.val == val and prev:\\n                prev.next = curr.next\\n                curr = curr.next\\n                continue\\n            elif curr.val == val and not prev:\\n                head = head.next\\n                curr = curr.next\\n                continue\\n            prev = curr\\n            curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735959,
                "title": "c-recursive-easy-3-steps-solution-easy-approach",
                "content": "#### If you understand the approach please please upvote!!!\\n***Thanks :)***\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // base case\\n        if(head == NULL) return head;\\n        \\n        // recursive call\\n        head->next = removeElements(head->next, val);\\n        \\n        //small calculation\\n        if(head->val == val) {\\n            return head->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        // base case\\n        if(head == NULL) return head;\\n        \\n        // recursive call\\n        head->next = removeElements(head->next, val);\\n        \\n        //small calculation\\n        if(head->val == val) {\\n            return head->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722158,
                "title": "java-recursion-80-faster",
                "content": "```\\n\\npublic ListNode removeElements(ListNode head, int val) {\\n        if(head==null)\\n            return head;\\n        ListNode ans = removeElements(head.next,val);\\n        if(head.val==val)\\n            return ans;\\n        else{\\n            head.next = ans;\\n            return head;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n\\npublic ListNode removeElements(ListNode head, int val) {\\n        if(head==null)\\n            return head;\\n        ListNode ans = removeElements(head.next,val);\\n        if(head.val==val)\\n            return ans;\\n        else{\\n            head.next = ans;\\n            return head;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1573492,
                "title": "rust-simple-one-pass-solution",
                "content": "#### If you like my solution, then you should check my [leetcode github repo](https://github.com/SvetlinZarev/coding-challenges/tree/main/leetcode)\\n\\n### Solution with the old compiler version @leetcode (rust 1.48)\\n\\n```rust\\npub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut dummy = None;\\n    let mut tail = &mut dummy;\\n\\n    while let Some(mut node) = head.take() {\\n        head = node.next.take();\\n\\n        if node.val != val {\\n            *tail = Some(node);\\n            tail = &mut tail.as_mut().unwrap().next;\\n        }\\n    }\\n\\n    dummy\\n}\\n```\\n\\n\\n### Alternative implementation without `.unwrap()` for the old compiler version:\\n\\n```rust\\npub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut head = head;\\n    let mut ptr = &mut head;\\n\\n    loop {\\n        match ptr {\\n            None => break,\\n            Some(node) if node.val == val => *ptr = node.next.take(),\\n            Some(node) => ptr = &mut node.next,\\n        }\\n    }\\n\\n    head\\n}\\n```\\n\\n### Alternative, cleaner version without `unwrap()` for the new compiler (rust >= 1.53)\\n\\n```rust\\npub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut list = None;\\n    let mut tail = &mut list;\\n\\n    while let Some(mut node) = head.take() {\\n        head = node.next.take();\\n\\n        if node.val != val {\\n            tail = &mut tail.insert(node).next;\\n        }\\n    }\\n\\n    list\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\npub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut dummy = None;\\n    let mut tail = &mut dummy;\\n\\n    while let Some(mut node) = head.take() {\\n        head = node.next.take();\\n\\n        if node.val != val {\\n            *tail = Some(node);\\n            tail = &mut tail.as_mut().unwrap().next;\\n        }\\n    }\\n\\n    dummy\\n}\\n```\n```rust\\npub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut head = head;\\n    let mut ptr = &mut head;\\n\\n    loop {\\n        match ptr {\\n            None => break,\\n            Some(node) if node.val == val => *ptr = node.next.take(),\\n            Some(node) => ptr = &mut node.next,\\n        }\\n    }\\n\\n    head\\n}\\n```\n```rust\\npub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n    let mut list = None;\\n    let mut tail = &mut list;\\n\\n    while let Some(mut node) = head.take() {\\n        head = node.next.take();\\n\\n        if node.val != val {\\n            tail = &mut tail.insert(node).next;\\n        }\\n    }\\n\\n    list\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1572963,
                "title": "simple-to-understand-using-basic-loop-with-comments",
                "content": "**Thumbs up if you find this helpful** \\uD83D\\uDC4D\\n\\n```\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        var ptr = head;\\n        \\n        // Loop through data checking to see if the next node equals the target value\\n        while (ptr != null && ptr.next != null) {            \\n            // If the next node value is the target value, set the next node\\n            // to point to the one after it\\n            if (ptr.next != null && ptr.next.val == val) {\\n                ptr.next = ptr.next.next;\\n            } else {\\n                // Next node doesnt equal target, advance to the next node\\n                ptr = ptr.next;\\n            }\\n        }        \\n        // If the head equals the target value, advance to the next\\n        if (head != null && head.val == val) {\\n            head = head.next;\\n        }          \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        var ptr = head;\\n        \\n        // Loop through data checking to see if the next node equals the target value\\n        while (ptr != null && ptr.next != null) {            \\n            // If the next node value is the target value, set the next node\\n            // to point to the one after it\\n            if (ptr.next != null && ptr.next.val == val) {\\n                ptr.next = ptr.next.next;\\n            } else {\\n                // Next node doesnt equal target, advance to the next node\\n                ptr = ptr.next;\\n            }\\n        }        \\n        // If the head equals the target value, advance to the next\\n        if (head != null && head.val == val) {\\n            head = head.next;\\n        }          \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 900341,
                "title": "simple-easy-solution-by-python-3",
                "content": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        prev, curr = None, head\\n        while curr:\\n            if curr.val == val:\\n                if prev:\\n                    prev.next = curr.next\\n                else:\\n                    head = curr.next\\n            else:\\n                prev = curr\\n            curr = curr.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        prev, curr = None, head\\n        while curr:\\n            if curr.val == val:\\n                if prev:\\n                    prev.next = curr.next\\n                else:\\n                    head = curr.next\\n            else:\\n                prev = curr\\n            curr = curr.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745439,
                "title": "easy-c-solution-explained",
                "content": "```\\n  ListNode* removeElements(ListNode* head, int val) {\\n        \\n        ListNode* curr = head;\\n        if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        while(curr->next!= NULL)  //Iterate until linked list is not null\\n        {\\n            if(curr->next->val == val)  // If the next element\\'s value equals  \\'val\\' . Then Shift currents next to the next of current\\'s next node. And repeat same, checking current with currents next.\\n            {\\n                curr->next = curr->next->next;\\n            }\\n            else       // otherwise shift current to currents next.\\n            {\\n                curr = curr->next;\\n            }\\n        }\\n        if(head->val == val)   // Check if the initial Head ( beginning current) was equal to Val. If so, shift it to next.\\n        {\\n            head = head->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  ListNode* removeElements(ListNode* head, int val) {\\n        \\n        ListNode* curr = head;\\n        if(head == NULL)\\n        {\\n            return NULL;\\n        }\\n        while(curr->next!= NULL)  //Iterate until linked list is not null\\n        {\\n            if(curr->next->val == val)  // If the next element\\'s value equals  \\'val\\' . Then Shift currents next to the next of current\\'s next node. And repeat same, checking current with currents next.\\n            {\\n                curr->next = curr->next->next;\\n            }\\n            else       // otherwise shift current to currents next.\\n            {\\n                curr = curr->next;\\n            }\\n        }\\n        if(head->val == val)   // Check if the initial Head ( beginning current) was equal to Val. If so, shift it to next.\\n        {\\n            head = head->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 505560,
                "title": "c-and-js-very-short-three-lines-easy-to-understand-no-really",
                "content": "Javascript\\n```\\nconst removeElements = (h, val) => {\\n    if (!h) return null\\n    h.next = removeElements(h.next, val)\\n    return h.val === val ? h.next : h\\n}\\n```\\n\\nC#\\n```\\npublic ListNode RemoveElements(ListNode h, int v) {\\n\\tif (h == null) return null;\\n\\th.next = RemoveElements(h.next, v);\\n\\treturn h.val == v ? h.next : h;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst removeElements = (h, val) => {\\n    if (!h) return null\\n    h.next = removeElements(h.next, val)\\n    return h.val === val ? h.next : h\\n}\\n```\n```\\npublic ListNode RemoveElements(ListNode h, int v) {\\n\\tif (h == null) return null;\\n\\th.next = RemoveElements(h.next, v);\\n\\treturn h.val == v ? h.next : h;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 384312,
                "title": "easy-c-solution-20ms-no-extra-prev-pointer",
                "content": "Use a dummy node, for cases when head is to be deleted.\\nRuntime: 20 ms, faster than 99.60% of C++ online submissions for Remove Linked List Elements.\\nMemory Usage: 11 MB, less than 69.81% of C++ online submissions for Remove Linked List Elements.\\n\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        \\n        ListNode dummy(-1);\\n        dummy.next = head;\\n        ListNode* curr = &dummy;\\n        \\n        while(curr->next)\\n        {\\n            if(curr->next->val == val)\\n            {\\n                ListNode* nextNode = curr->next->next;\\n                curr->next->next = NULL;\\n                curr->next = nextNode;\\n            }\\n            else\\n                curr = curr->next;\\n        }\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Use a dummy node, for cases when head is to be deleted.\\nRuntime: 20 ms, faster than 99.60% of C++ online submissions for Remove Linked List Elements.\\nMemory Usage: 11 MB, less than 69.81% of C++ online submissions for Remove Linked List Elements.\\n\\n```\\nListNode* removeElements(ListNode* head, int val) {\\n        \\n        ListNode dummy(-1);\\n        dummy.next = head;\\n        ListNode* curr = &dummy;\\n        \\n        while(curr->next)\\n        {\\n            if(curr->next->val == val)\\n            {\\n                ListNode* nextNode = curr->next->next;\\n                curr->next->next = NULL;\\n                curr->next = nextNode;\\n            }\\n            else\\n                curr = curr->next;\\n        }\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3913251,
                "title": "only-3-liner-100-beats",
                "content": "\\n# class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head==null) return null;\\n        head.next = removeElements(head.next, val);\\n        return head.val==val?head.next:head;\\n    }\\n}\\n<!-- if(head==null){\\n            return null;\\n        }\\n        ListNode curr=head;\\n        while(curr.next!=null){\\n            if(curr.next.val==val){\\n                \\n                curr.next=curr.next.next;\\n            }\\n            else\\n            curr=curr.next;\\n        }\\n        if(head.val==val){\\n            return head.next;\\n        }\\n        else{\\n            return head; -->",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head==null) return null;\\n        head.next = removeElements(head.next, val);\\n        return head.val==val?head.next:head;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2966924,
                "title": "c-solution-with-explanation-2-pointers-listnode",
                "content": "# Approach\\n- Create 2 pointers: prev and curr\\n- prev will point to additional dummy node inserted before head, curr will point to head\\n- Iterate curr till end of list: if curr.val == val, move prev pointer to next pointer of curr (meaning it will skip the curr node)\\nOtherwise, assign prev = curr\\n- Return dummy.next as its the prev pointer\\'s path\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        \\n        while(curr != null)\\n        {\\n            if(curr.val == val)\\n                prev.next = curr.next;\\n            else\\n                prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode prev = dummy;\\n        ListNode curr = head;\\n        \\n        while(curr != null)\\n        {\\n            if(curr.val == val)\\n                prev.next = curr.next;\\n            else\\n                prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2248711,
                "title": "python-dummy-node-solution-explained-time-o-n-space-o-1",
                "content": "# Explaination:\\nWe are given a linked list and a value, we want to remove all instances of that value from the linked list.\\nA tricky issue you may have with this problem is an input like: 0->0->0->0-> val = 0\\nSince usually to delete nodes we need to take the previous node and change its `.next` pointer to point to the node after the one we want to delete.\\nIn the example 1 -> 2 -> 3, to delete 2, we would need to point 1 to 3.\\n\\nThe problem with our 0->0->0->0 example is we don\\'t have a previous node to use since we need to delete all nodes starting from the first 0.\\n\\nTo handle this issue we will create a `dummyNode` and use that as our `prev` node to help with the deletions.\\n\\n**Solution Breakdown:**\\n1. We create our `dummyNode` and initialize it as an empty `ListNode`. Then we set `dummyNode.next` to `head` to connect it to our linked list.\\n2. Now we create our `prev` and this will point to the `dummyNode`\\n3. Now we create our `current` variable and point it to the `head` of the linked list\\n4. We will iterate through the linked list until `current` becomes `None`.\\n5. If `current.val` is equal to the `val` we were given to delete, we will set our `prev.next` to point to `current.next` since we want to delete the `current` node.\\n6. If `current.val` is not equal to `val`, we just set our `prev` variable to point to `current` since this node was not marked to be deleted.\\n7. On every iteration we move our pointer forward by 1 node by doing `current = current.next`\\n8. After we finish we return `dummyNode.next` because we want to return the modified linked list without the `dummyNode` included.\\n\\n**Time O(N) | Space O(1)**\\nTime is O(N) because at most we are iterating through the entire linked list once\\nSpace is O(1) because we aren\\'t saving anything in memory which would scale with the input, we are only creating some variables and modifying them throughout our iterations.\\n\\n\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummyNode = ListNode()\\n        dummyNode.next = head\\n        \\n        prev = dummyNode\\n        current = head\\n        \\n        while current:\\n            if current.val == val:\\n                prev.next = current.next\\n            else:  \\n                prev = current\\n            current = current.next\\n        \\n        return dummyNode.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummyNode = ListNode()\\n        dummyNode.next = head\\n        \\n        prev = dummyNode\\n        current = head\\n        \\n        while current:\\n            if current.val == val:\\n                prev.next = current.next\\n            else:  \\n                prev = current\\n            current = current.next\\n        \\n        return dummyNode.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650456,
                "title": "java-100-faster-easy",
                "content": "The debugging took me three tries lol\\n## Please upvote if it helps! Thx :D\\n\\n```\\n    public ListNode removeElements(ListNode head, int val) {\\n        while (head!=null && head.val == val) {\\n            head = head.next;\\n        }\\n        ListNode p = head;\\n        while (p != null){\\n            while (p.next!=null && p.next.val == val) p.next = p.next.next;\\n            p = p.next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode removeElements(ListNode head, int val) {\\n        while (head!=null && head.val == val) {\\n            head = head.next;\\n        }\\n        ListNode p = head;\\n        while (p != null){\\n            while (p.next!=null && p.next.val == val) p.next = p.next.next;\\n            p = p.next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573799,
                "title": "c-simple-and-clean-solution-explained-with-freeing-memory",
                "content": "**Idea:**\\nWe create a `new_head` which is previous to the regular head. This makes it super easy to remove nodes in the beginning of the list.\\nThen, each time we find a node with value equals `val`, we just make a \"bypass\" and link the previous node to the next one.\\nWe save in `tmp` a pointer to the removed node to be able to free the memory.\\n\\n**Time Complexity:** O(n)\\n**Space Complexity:** O(1)\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* new_head = new ListNode(-1), *tmp;\\n        new_head->next = head;\\n        head = new_head;\\n\\n        while (head->next) {\\n            if (head->next->val == val) {\\n                tmp = head->next;\\n                head->next = head->next->next;\\n                delete tmp;\\n            }\\n            else head = head->next;\\n        }\\n\\n        return new_head->next;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* new_head = new ListNode(-1), *tmp;\\n        new_head->next = head;\\n        head = new_head;\\n\\n        while (head->next) {\\n            if (head->next->val == val) {\\n                tmp = head->next;\\n                head->next = head->next->next;\\n                delete tmp;\\n            }\\n            else head = head->next;\\n        }\\n\\n        return new_head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492438,
                "title": "96-javascript-solution-o-n-with-comments-feedback-welcomed",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n\\ninput \\n\\thead of linked list and int\\noutput \\n\\tlinked list\\nconstraints\\n\\tThe number of nodes in the list is in the range [0, 104]. => we can be given an empty linked list/ head\\nedges\\n\\tempty linked list / head\\n\\ntranslate\\n\\treturn a linked list with nodes with input val removed\\nexample1\\n\\t[1,2,3,4,5] val = 6 // [1,2,3,4,5]\\nexample2\\n\\t[1,1,1,1,1] val = 1 // []\\nexample3\\n\\t[1,2,1,2,1,2] val = 2 // [1,1,1]\\nexample4\\n\\t[] val = 1 // []\\n */\\nvar removeElements = function(head, val) {\\n// constraint stated: \"The number of nodes in the list is in the range [0, 104]. \"\\n// so we have to have a conditional to check if we\\'re given an empty head\\n\\n  if (!head) {\\n    return head;\\n  }\\n  \\n  let curr = head;\\n  \\n  // loop through curr up until 2nd to last node since our if statement checks the following node\\n  // we would error out without && curr.next since it will try to do .val on the null node\\n  while (curr && curr.next) {\\n    if (curr.next.val === val) {\\n      curr.next = curr.next.next;\\n    } else {\\n      curr = curr.next;\\n    }\\n  }\\n  \\n  // our loop never checked the head if it was the val to be removed so we use a ternary operator\\n  // to return the head.next if the current head is to be removed \\n  // if not we can return head as is\\n  return head.val === val ? head.next : head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n\\ninput \\n\\thead of linked list and int\\noutput \\n\\tlinked list\\nconstraints\\n\\tThe number of nodes in the list is in the range [0, 104]. => we can be given an empty linked list/ head\\nedges\\n\\tempty linked list / head\\n\\ntranslate\\n\\treturn a linked list with nodes with input val removed\\nexample1\\n\\t[1,2,3,4,5] val = 6 // [1,2,3,4,5]\\nexample2\\n\\t[1,1,1,1,1] val = 1 // []\\nexample3\\n\\t[1,2,1,2,1,2] val = 2 // [1,1,1]\\nexample4\\n\\t[] val = 1 // []\\n */\\nvar removeElements = function(head, val) {\\n// constraint stated: \"The number of nodes in the list is in the range [0, 104]. \"\\n// so we have to have a conditional to check if we\\'re given an empty head\\n\\n  if (!head) {\\n    return head;\\n  }\\n  \\n  let curr = head;\\n  \\n  // loop through curr up until 2nd to last node since our if statement checks the following node\\n  // we would error out without && curr.next since it will try to do .val on the null node\\n  while (curr && curr.next) {\\n    if (curr.next.val === val) {\\n      curr.next = curr.next.next;\\n    } else {\\n      curr = curr.next;\\n    }\\n  }\\n  \\n  // our loop never checked the head if it was the val to be removed so we use a ternary operator\\n  // to return the head.next if the current head is to be removed \\n  // if not we can return head as is\\n  return head.val === val ? head.next : head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1116011,
                "title": "java-0ms-100-faster",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n    if(head==null)\\n        return null;\\n    ListNode temp=head;\\n        while(temp.next!=null){\\n            if(temp.next.val==val)\\n                temp.next=temp.next.next;\\n            else\\n                temp=temp.next;\\n        }\\n        return  head.val == val ? head.next : head;\\n        \\n    }\\n}\\n \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n    if(head==null)\\n        return null;\\n    ListNode temp=head;\\n        while(temp.next!=null){\\n            if(temp.next.val==val)\\n                temp.next=temp.next.next;\\n            else\\n                temp=temp.next;\\n        }\\n        return  head.val == val ? head.next : head;\\n        \\n    }\\n}\\n \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008705,
                "title": "c-iterative-recursive-solution",
                "content": "#### Iterative Appraoch\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* removeElements(ListNode* head, int val) {\\n\\t\\t\\tListNode *preHead = new ListNode(-1);\\n\\t\\t\\tpreHead -> next = head;\\n\\t\\t\\tListNode *curr = preHead;\\n\\n\\t\\t\\twhile(curr != NULL){\\n\\t\\t\\t\\tif(curr -> next != NULL and curr -> next -> val == val){\\n\\t\\t\\t\\t\\tcurr -> next = curr -> next -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tcurr = curr -> next;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn preHead -> next;\\n\\t\\t}\\n\\t};\\n\\t\\n#### Recursive Appraoch\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tListNode* removeElements(ListNode* head, int val) {\\n\\t\\t\\tif(head == NULL){\\n\\t\\t\\t\\treturn NULL;\\n\\t\\t\\t}\\n\\t\\t\\tif(head -> val != val){\\n\\t\\t\\t\\thead -> next = removeElements(head -> next, val);\\n\\t\\t\\t\\treturn head;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tListNode* newHead = head -> next;\\n\\t\\t\\t\\treturn removeElements(newHead, val);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tListNode* removeElements(ListNode* head, int val) {\\n\\t\\t\\tListNode *preHead = new ListNode(-1);\\n\\t\\t\\tpreHead -> next = head;\\n\\t\\t\\tListNode *curr = preHead;\\n\\n\\t\\t\\twhile(curr != NULL){\\n\\t\\t\\t\\tif(curr -> next != NULL and curr -> next -> val == val){\\n\\t\\t\\t\\t\\tcurr -> next = curr -> next -> next;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 746134,
                "title": "python-3-single-loop-o-n",
                "content": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        curr = head\\n        prev = None\\n        \\n        while(curr):\\n            if curr.val == val: \\n                if curr == head:\\n                    head = head.next\\n                    curr = head\\n                else:\\n                    prev.next = curr.next\\n                    curr = prev.next\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        curr = head\\n        prev = None\\n        \\n        while(curr):\\n            if curr.val == val: \\n                if curr == head:\\n                    head = head.next\\n                    curr = head\\n                else:\\n                    prev.next = curr.next\\n                    curr = prev.next\\n            else:\\n                prev = curr\\n                curr = curr.next\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565756,
                "title": "c-c-quick-and-short-solutions-using-pointer-to-pointer-o-n-time-o-1-space",
                "content": "Often the hardest thing about using link lists is the corner cases. In this particular problem the obvious corner case is the case where the `head` gets removed.\\n\\nUsing pointer to a pointer approach allows for a solution that removes the corner cases and allows for just a few lines of code to efficently proces.\\n\\n```c []\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n  struct ListNode** nextPtr = &head;\\n  while (*nextPtr) {\\n    if ((**nextPtr).val == val) {\\n      *nextPtr = (**nextPtr).next;\\n    } else {\\n      nextPtr = &(**nextPtr).next;\\n    }\\n  }\\n  return head;\\n}\\n```\\n\\n```cpp []\\nListNode* removeElements(ListNode* head, int val) {\\n  ListNode** nextPtr = &head;\\n  while (*nextPtr) {\\n    if ((**nextPtr).val == val) {\\n      *nextPtr = (**nextPtr).next;\\n    } else {\\n      nextPtr = &(**nextPtr).next;\\n    }\\n  }\\n  return head;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c []\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n  struct ListNode** nextPtr = &head;\\n  while (*nextPtr) {\\n    if ((**nextPtr).val == val) {\\n      *nextPtr = (**nextPtr).next;\\n    } else {\\n      nextPtr = &(**nextPtr).next;\\n    }\\n  }\\n  return head;\\n}\\n```\n```cpp []\\nListNode* removeElements(ListNode* head, int val) {\\n  ListNode** nextPtr = &head;\\n  while (*nextPtr) {\\n    if ((**nextPtr).val == val) {\\n      *nextPtr = (**nextPtr).next;\\n    } else {\\n      nextPtr = &(**nextPtr).next;\\n    }\\n  }\\n  return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 355025,
                "title": "rust-two-level-pointer",
                "content": "Remove a node from a linked list is a perfect scene to use two level pointer, aka, pointer to pointer.\\nThe solution is very straight forward, use a pointer(named `walker`) to traverse the list:\\n\\t1. If we meet the deleting node, modify(delete) the node by the `walker`\\n\\t2. if not, modify `walker` to go on traversing.\\nThere is also a c++ version, may be helpful for understanding.\\n```\\nimpl Solution {\\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut walker = &mut head;\\n        while walker.is_some() {\\n            if walker.as_ref().unwrap().val == val {\\n                *walker = walker.take().unwrap().next;\\n            } else {\\n                walker = &mut walker.as_mut().unwrap().next;\\n            }\\n        }\\n        head\\n    }\\n}\\n```\\n\\nC++ verison\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        auto walker = &head;\\n        while (nullptr != *walker) {\\n            if (val == (*walker)->val) {\\n                auto to_delete = *walker;\\n                *walker = (*walker)->next;\\n                delete to_delete;\\n            } else {\\n                walker = &(*walker)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut walker = &mut head;\\n        while walker.is_some() {\\n            if walker.as_ref().unwrap().val == val {\\n                *walker = walker.take().unwrap().next;\\n            } else {\\n                walker = &mut walker.as_mut().unwrap().next;\\n            }\\n        }\\n        head\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        auto walker = &head;\\n        while (nullptr != *walker) {\\n            if (val == (*walker)->val) {\\n                auto to_delete = *walker;\\n                *walker = (*walker)->next;\\n                delete to_delete;\\n            } else {\\n                walker = &(*walker)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 271790,
                "title": "golang",
                "content": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n\\tdummy := &ListNode{Next: head}\\n\\tcur := dummy\\n\\tfor cur.Next != nil {\\n\\t\\tif cur.Next.Val == val {\\n\\t\\t\\tcur.Next = cur.Next.Next\\n\\t\\t} else {\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\t}\\n\\n\\treturn dummy.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n\\tdummy := &ListNode{Next: head}\\n\\tcur := dummy\\n\\tfor cur.Next != nil {\\n\\t\\tif cur.Next.Val == val {\\n\\t\\t\\tcur.Next = cur.Next.Next\\n\\t\\t} else {\\n\\t\\t\\tcur = cur.Next\\n\\t\\t}\\n\\t}\\n\\n\\treturn dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57310,
                "title": "python-solution-without-dummy-head",
                "content": "\\n```\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        Remove all elements from a linked list of integers that have value val.\\n        Use the head to eliminite first n hits, and use pointer to eliminite the rest\\n        e.g 1->1->1->2->3->1, 1\\n        Head will be moved to 2, pointer will start from 3\\n        \\n        time complexity: O(n)\\n        space complexity: O(1)\\n      \\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n\\n        # move the head to its next node if its value is equal to the input value\\n        while head is not None and head.val == val:\\n            head = head.next\\n\\n        # handle null value after moving\\n        if head is None:\\n            return None\\n\\n        # create a pointer reference to the head node, and loop to check its next node's value\\n        # if it is equal to the input val, skip that node\\n        cur = head\\n        while cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        Remove all elements from a linked list of integers that have value val.\\n        Use the head to eliminite first n hits, and use pointer to eliminite the rest\\n        e.g 1->1->1->2->3->1, 1\\n        Head will be moved to 2, pointer will start from 3\\n        \\n        time complexity: O(n)\\n        space complexity: O(1)\\n      \\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n\\n        # move the head to its next node if its value is equal to the input value\\n        while head is not None and head.val == val:\\n            head = head.next\\n\\n        # handle null value after moving\\n        if head is None:\\n            return None\\n\\n        # create a pointer reference to the head node, and loop to check its next node's value\\n        # if it is equal to the input val, skip that node\\n        cur = head\\n        while cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next\\n            else:\\n                cur = cur.next\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 57335,
                "title": "python-ac-solution-beat-91-submissions-easy-to-understand",
                "content": "    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        # Remove the heading nodes\\n        while head and head.val == val:\\n            head = head.next\\n        if not head:\\n            return head\\n        prev, cur = head, head.next\\n        while cur:\\n            while cur and cur.val == val:\\n                cur = cur.next\\n            prev.next = cur\\n            if cur:\\n                prev, cur = prev.next, cur.next\\n        return head",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        # Remove the heading nodes\\n        while head and head.val == val:\\n            head = head.next\\n        if not head:\\n            return head\\n        prev, cur = head, head.next\\n        while cur:\\n            while cur and cur.val == val:\\n                cur = cur.next\\n            prev.next = cur\\n            if cur:\\n                prev, cur = prev.next, cur.next\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 57504,
                "title": "java-solved-recursively",
                "content": "    public class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            ListNode result = head;\\n            if (result == null) {\\n                return null;\\n            } else if (result.val == val) {\\n                return removeElements(result.next, val);\\n            } else {\\n                result.next = removeElements(result.next, val);\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode removeElements(ListNode head, int val) {\\n            ListNode result = head;\\n            if (result == null) {\\n                return null;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 57512,
                "title": "the-answer-you-are-wished-to-offer-when-in-an-interview",
                "content": "    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode **pp = &head;\\n        while (*pp)\\n            if ((*pp)->val == val)\\n                *pp = (*pp)->next;\\n            else\\n                pp = &(*pp)->next;\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode **pp = &head;\\n        while (*pp)\\n            if ((*pp)->val == val)\\n                *pp = (*pp)->next;\\n            else\\n                pp = &(*pp)->next;\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3280921,
                "title": "c-solution",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head == NULL) return head;\\n        ListNode *node = head;\\n        while(node and node->next) {\\n            if(node->next->val == val) node->next = node->next->next;\\n            else node = node->next;\\n        }\\n        if(head->val == val) head = head->next;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head == NULL) return head;\\n        ListNode *node = head;\\n        while(node and node->next) {\\n            if(node->next->val == val) node->next = node->next->next;\\n            else node = node->next;\\n        }\\n        if(head->val == val) head = head->next;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3136809,
                "title": "python-simple-and-clean-beats-98-69",
                "content": "### Please upvote if you find this helpful. \\u270C\\n<img src=\"https://assets.leetcode.com/users/images/b8e25620-d320-420a-ae09-94c7453bd033_1678818986.7001078.jpeg\" alt=\"Cute Robot - Stable diffusion\" width=\"200\"/>\\n\\n*This is an NFT*\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe idea here is to use a dummy node as the starting point of the linked list and traverse through the linked list until the end of the list, updating the links accordingly whenever we encounter a node with value val.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create a dummy node dummy and assign head as its next node. This is to simplify the edge case where the linked list starts with a node with value val.\\n- Initialize two pointers prev and curr, both pointing to dummy.\\n- Traverse through the linked list by updating curr to its next node in each iteration and also keep a reference to the next node in nxt.\\n- If curr has value val, update prev.next to nxt to skip curr node.\\n- If curr does not have value val, update prev to curr.\\n- Repeat the process until curr is None.\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(next = head)\\n        curr = head \\n        prev = dummy\\n        \\n        while curr:\\n            nxt = curr.next\\n\\n            if curr.val == val:\\n                prev.next = nxt\\n            else:\\n                prev = curr\\n            curr = nxt\\n            \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(next = head)\\n        curr = head \\n        prev = dummy\\n        \\n        while curr:\\n            nxt = curr.next\\n\\n            if curr.val == val:\\n                prev.next = nxt\\n            else:\\n                prev = curr\\n            curr = nxt\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066708,
                "title": "using-dummy-node",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode curr = dummy;      //Start of dummy node has a fake node then head node\\n         while(curr.next!=null){    //next node is the head of curr linked list\\n           if(curr.next.val==val){\\n               curr.next=curr.next.next;\\n           }\\n           else{\\n               curr=curr.next;\\n           }\\n        }\\n        return dummy.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode curr = dummy;      //Start of dummy node has a fake node then head node\\n         while(curr.next!=null){    //next node is the head of curr linked list\\n           if(curr.next.val==val){\\n               curr.next=curr.next.next;\\n           }\\n           else{\\n               curr=curr.next;\\n           }\\n        }\\n        return dummy.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957589,
                "title": "c-90-simple-solution-o-n",
                "content": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val)\\n{\\n    while (head != NULL && head->val == val)\\n        head = head->next;\\n    \\n    for (struct ListNode *cur = head; cur && cur->next;) {\\n        if (cur->next->val == val)\\n            cur->next = cur->next->next;\\n        else\\n            cur = cur->next;\\n    }\\n\\n    return head;\\n}\\n```\\n\\n**If this was helpful, don\\'t hesitate to upvote! :)**\\nHave a nice day!",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val)\\n{\\n    while (head != NULL && head->val == val)\\n        head = head->next;\\n    \\n    for (struct ListNode *cur = head; cur && cur->next;) {\\n        if (cur->next->val == val)\\n            cur->next = cur->next->next;\\n        else\\n            cur = cur->next;\\n    }\\n\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1473682,
                "title": "simple-java-solution-0ms-100-no-dummy-head",
                "content": "Keep checking if the next node is to be deleted. If yes, set next pointer of current node to next\\'s next. Else, simple move current node pointer to next.\\nWhile returning, check if head\\'s value matches value of node to be deleted. If yes, return head.next else return head.\\n```    \\npublic ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return head;\\n        \\n        ListNode curr = head;\\n        while (curr.next != null) {\\n            if (curr.next.val == val)\\n                curr.next = curr.next.next;\\n            else\\n                curr = curr.next;\\n        }\\n        return head.val == val ? head.next : head;\\n    }",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "Keep checking if the next node is to be deleted. If yes, set next pointer of current node to next\\'s next. Else, simple move current node pointer to next.\\nWhile returning, check if head\\'s value matches value of node to be deleted. If yes, return head.next else return head.\\n```    \\npublic ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return head;\\n        \\n        ListNode curr = head;\\n        while (curr.next != null) {\\n            if (curr.next.val == val)\\n                curr.next = curr.next.next;\\n            else\\n                curr = curr.next;\\n        }\\n        return head.val == val ? head.next : head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1450105,
                "title": "python-supper-clean-code-by-using-dummyhead",
                "content": "```python\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while head != None:\\n            if head.val != val:\\n                curHead.next = head\\n                curHead = curHead.next\\n            head = head.next\\n        curHead.next = None\\n        return dummyHead.next\\n```\\nComplexity:\\n- Time: `O(N)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        while head != None:\\n            if head.val != val:\\n                curHead.next = head\\n                curHead = curHead.next\\n            head = head.next\\n        curHead.next = None\\n        return dummyHead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257519,
                "title": "c-solution-in-simple-steps",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val)\\n    {   \\n        while(head != NULL && head->val == val)\\n        {\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n        return NULL;\\n        \\n        ListNode* pointer;\\n        pointer = head;\\n        while (pointer->next != NULL)\\n        {\\n            if(pointer->next->val == val)\\n            {\\n                pointer->next = pointer->next->next;\\n            }\\n            else\\n            {\\n                pointer = pointer->next;    \\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\n**Like the solution? Please upvote.....**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val)\\n    {   \\n        while(head != NULL && head->val == val)\\n        {\\n            head = head->next;\\n        }\\n        if(head == NULL)\\n        return NULL;\\n        \\n        ListNode* pointer;\\n        pointer = head;\\n        while (pointer->next != NULL)\\n        {\\n            if(pointer->next->val == val)\\n            {\\n                pointer->next = pointer->next->next;\\n            }\\n            else\\n            {\\n                pointer = pointer->next;    \\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 745765,
                "title": "java-clean-code-o-n-optimal-solution",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic ListNode removeElements (ListNode head, int val) {\\n\\t\\t\\n\\t\\twhile (head != null && head.val == val) {\\n\\t\\t\\thead = head.next;\\n\\t\\t}\\n        \\n        if (head == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t\\n\\t\\tListNode ptr = head;\\n\\t\\twhile (ptr.next != null) {\\n\\t\\t\\tif (ptr.next.val == val) {\\n\\t\\t\\t\\tptr.next = ptr.next.next;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tptr = ptr.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn head;\\n\\t}\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic ListNode removeElements (ListNode head, int val) {\\n\\t\\t\\n\\t\\twhile (head != null && head.val == val) {\\n\\t\\t\\thead = head.next;\\n\\t\\t}\\n        \\n        if (head == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\t\\n\\t\\tListNode ptr = head;\\n\\t\\twhile (ptr.next != null) {\\n\\t\\t\\tif (ptr.next.val == val) {\\n\\t\\t\\t\\tptr.next = ptr.next.next;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tptr = ptr.next;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn head;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386446,
                "title": "4ms-c-solution",
                "content": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    if (head == NULL)\\n        return NULL;\\n    if(head->val == val) {\\n        return removeElements(head->next, val);\\n    } else {\\n        head -> next = removeElements(head->next, val);\\n    }\\n    return head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    if (head == NULL)\\n        return NULL;\\n    if(head->val == val) {\\n        return removeElements(head->next, val);\\n    } else {\\n        head -> next = removeElements(head->next, val);\\n    }\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 332814,
                "title": "3-line-swift-solution-recursion",
                "content": "```\\nfunc removeElements(_ head: ListNode?, _ val: Int) -> ListNode? {\\n        guard let head = head else { return nil }\\n        head.next = removeElements(head.next, val)\\n        return head.val != val ? head : head.next\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc removeElements(_ head: ListNode?, _ val: Int) -> ListNode? {\\n        guard let head = head else { return nil }\\n        head.next = removeElements(head.next, val)\\n        return head.val != val ? head : head.next\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 308610,
                "title": "4-simple-javascript-lines-68-ms-faster-than-95-57",
                "content": "```Javascript\\nfunction removeElements(H, target){\\n    if(!H) return null;\\n    if(H.val === target) return removeElements(H.next, target);\\n    \\n    H.next = removeElements(H.next, target);\\n    return H;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```Javascript\\nfunction removeElements(H, target){\\n    if(!H) return null;\\n    if(H.val === target) return removeElements(H.next, target);\\n    \\n    H.next = removeElements(H.next, target);\\n    return H;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 284872,
                "title": "100-golang-solution",
                "content": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n\\tif head == nil {\\n\\t\\treturn head\\n\\t}\\n\\tcurr := head\\n\\n\\tfor ;curr.Next!=nil; {\\n\\t\\tif curr.Next.Val==val {\\n\\t\\t\\tcurr.Next = curr.Next.Next\\n\\t\\t} else {\\n\\t\\t\\tcurr = curr.Next\\n\\t\\t}\\n\\t}\\n\\tif head.Val==val {\\n\\t\\treturn head.Next\\n\\t}\\n\\treturn head\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n\\tif head == nil {\\n\\t\\treturn head\\n\\t}\\n\\tcurr := head\\n\\n\\tfor ;curr.Next!=nil; {\\n\\t\\tif curr.Next.Val==val {\\n\\t\\t\\tcurr.Next = curr.Next.Next\\n\\t\\t} else {\\n\\t\\t\\tcurr = curr.Next\\n\\t\\t}\\n\\t}\\n\\tif head.Val==val {\\n\\t\\treturn head.Next\\n\\t}\\n\\treturn head\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 57442,
                "title": "my-java-solution-in-1ms",
                "content": "Here is what I did.\\n\\n    public ListNode removeElements(ListNode head, int val) {\\n        while (head != null && head.val == val) {\\n            head = head.next;\\n        }\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode current = head;\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;    \\n            } else {\\n                current = current.next;\\n            }\\n        }\\n        return head;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Here is what I did.\\n\\n    public ListNode removeElements(ListNode head, int val) {\\n        while (head != null && head.val == val) {\\n            head = head.next;\\n        }\\n        \\n        if (head == null) {\\n            return null;\\n        }\\n        \\n        ListNode current = head;\\n        while (current.next != null) {\\n            if (current.next.val == val) {\\n                current.next = current.next.next;    \\n            } else {\\n                current = current.next;\\n            }\\n        }\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3846781,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        while(head != NULL && head->val == val){\\n            head = head->next;\\n        }\\n        ListNode* temp = head;\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->next->val == val){\\n                temp->next = temp->next->next;\\n                continue;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        while(head != NULL && head->val == val){\\n            head = head->next;\\n        }\\n        ListNode* temp = head;\\n        while(temp != NULL && temp->next != NULL){\\n            if(temp->next->val == val){\\n                temp->next = temp->next->next;\\n                continue;\\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407428,
                "title": "c-o-n-solution",
                "content": "# Code\\n```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* current = head;\\n\\n    while (head && head->val == val)\\n        head = head->next;\\n    \\n    while (current && current->next) {\\n        if (current->next->val == val)\\n            current->next = current->next->next;\\n        else\\n            current = current->next;\\n    }\\n\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* current = head;\\n\\n    while (head && head->val == val)\\n        head = head->next;\\n    \\n    while (current && current->next) {\\n        if (current->next->val == val)\\n            current->next = current->next->next;\\n        else\\n            current = current->next;\\n    }\\n\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3150934,
                "title": "simple-java-c-easy-100-readable-data-structures",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode x=head;\\n        ListNode it=x;\\n        while(x!=null && x.val==val){\\n            head=x.next;\\n            x=head;\\n        }\\n        while(x!=null){\\n            if(x.val==val){\\n               \\n                it.next=x.next;\\n                x=it.next;\\n            }\\n            else{\\n                it=x;\\n                x=x.next;\\n            }\\n            \\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode x=head;\\n        ListNode it=x;\\n        while(x!=null && x.val==val){\\n            head=x.next;\\n            x=head;\\n        }\\n        while(x!=null){\\n            if(x.val==val){\\n               \\n                it.next=x.next;\\n                x=it.next;\\n            }\\n            else{\\n                it=x;\\n                x=x.next;\\n            }\\n            \\n        }\\n        \\n        return head;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3050006,
                "title": "c-just-traverse-easy-to-understand",
                "content": "\\n### Complexity\\n- Time complexity: $$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode *answer = new ListNode(0);\\n        ListNode *curr = answer;\\n\\n        while(head) {\\n            if(head -> val != val) {\\n                curr -> next = head;\\n                curr = head;\\n            }\\n            head = head -> next;\\n        }\\n        curr -> next = nullptr;\\n        return answer -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode *answer = new ListNode(0);\\n        ListNode *curr = answer;\\n\\n        while(head) {\\n            if(head -> val != val) {\\n                curr -> next = head;\\n                curr = head;\\n            }\\n            head = head -> next;\\n        }\\n        curr -> next = nullptr;\\n        return answer -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967314,
                "title": "easy-to-understand-simple-c-solution",
                "content": "### Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteAtEnd(ListNode*& head){\\n        ListNode* prev= head;\\n        if (head==NULL || head->next==NULL)return;\\n        while (prev->next){\\n            if (prev->next->next == NULL){\\n                prev->next = NULL;\\n                return;\\n            }\\n            prev= prev->next;\\n        }\\n    }\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* curr= head;\\n        while (curr){\\n            if (curr->val==val){\\n                //head\\n                if (curr == head){\\n                    head= head->next;\\n                    curr= curr->next;\\n                }\\n                //last node\\n                else if (curr->next == NULL){\\n                    deleteAtEnd(head);\\n                    curr= NULL;\\n                }\\n                // other nodes\\n                else{\\n                    curr->val= curr->next->val;\\n                    curr->next= curr->next->next;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Math"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void deleteAtEnd(ListNode*& head){\\n        ListNode* prev= head;\\n        if (head==NULL || head->next==NULL)return;\\n        while (prev->next){\\n            if (prev->next->next == NULL){\\n                prev->next = NULL;\\n                return;\\n            }\\n            prev= prev->next;\\n        }\\n    }\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* curr= head;\\n        while (curr){\\n            if (curr->val==val){\\n                //head\\n                if (curr == head){\\n                    head= head->next;\\n                    curr= curr->next;\\n                }\\n                //last node\\n                else if (curr->next == NULL){\\n                    deleteAtEnd(head);\\n                    curr= NULL;\\n                }\\n                // other nodes\\n                else{\\n                    curr->val= curr->next->val;\\n                    curr->next= curr->next->next;\\n                }\\n\\n            }\\n            else{\\n                curr = curr->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907943,
                "title": "java-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(-1, head);\\n        ListNode pre = dummy;\\n        while (pre.next != null) {\\n            if (pre.next.val != val)\\n                pre = pre.next;\\n            else\\n                pre.next = pre.next.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode dummy = new ListNode(-1, head);\\n        ListNode pre = dummy;\\n        while (pre.next != null) {\\n            if (pre.next.val != val)\\n                pre = pre.next;\\n            else\\n                pre.next = pre.next.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857650,
                "title": "beats-97-javascript-clean-easy-to-understand-javascript-solution",
                "content": "**Very easy Javascript approach, Beats 90% **\\n\\n```\\nvar removeElements = function(head, val) {\\n    \\n    let tempHead = head,prev\\n    while (tempHead){\\n        if (tempHead.val ===val){\\n            // when head is present at 0th index\\n            if (!prev){\\n                head = head.next\\n                tempHead=tempHead.next\\n            }else{\\n                prev.next =tempHead.next\\n                tempHead=tempHead.next\\n                \\n            }\\n        }else{\\n            prev=tempHead\\n            tempHead= tempHead.next   \\n        }\\n    }\\n    \\n    return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n    \\n    let tempHead = head,prev\\n    while (tempHead){\\n        if (tempHead.val ===val){\\n            // when head is present at 0th index\\n            if (!prev){\\n                head = head.next\\n                tempHead=tempHead.next\\n            }else{\\n                prev.next =tempHead.next\\n                tempHead=tempHead.next\\n                \\n            }\\n        }else{\\n            prev=tempHead\\n            tempHead= tempHead.next   \\n        }\\n    }\\n    \\n    return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2837684,
                "title": "java",
                "content": "upvote if you like it\\n```\\n\\n      public ListNode removeElements(ListNode head, int val) {\\n          ListNode temp = new ListNode(-1);\\n          temp.next = head;\\n\\n          ListNode cur = head;\\n          ListNode prev = temp;\\n\\n          while (cur != null) {\\n              if (cur.val == val) {\\n                  prev.next = cur.next;\\n              } else {\\n                  prev = cur;\\n              }\\n              cur = cur.next;\\n          }\\n          return temp.next;\\n      }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n      public ListNode removeElements(ListNode head, int val) {\\n          ListNode temp = new ListNode(-1);\\n          temp.next = head;\\n\\n          ListNode cur = head;\\n          ListNode prev = temp;\\n\\n          while (cur != null) {\\n              if (cur.val == val) {\\n                  prev.next = cur.next;\\n              } else {\\n                  prev = cur;\\n              }\\n              cur = cur.next;\\n          }\\n          return temp.next;\\n      }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828689,
                "title": "python-94-11-faster-iterative-approach-o-n-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head==None: #If head is empty\\n            return head\\n        while head and head.val==val: #If we want to delete the starting nodes\\n            head=head.next\\n        temp=head\\n        while temp:\\n            while temp.next and temp.next.val==val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```\\n\\n**Upvote if you like the solution or ask if there is any query**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head==None: #If head is empty\\n            return head\\n        while head and head.val==val: #If we want to delete the starting nodes\\n            head=head.next\\n        temp=head\\n        while temp:\\n            while temp.next and temp.next.val==val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801867,
                "title": "js-beginer-friendly",
                "content": "\\n# Intuition\\nSorry about a lot of code, I\\'m also learning Linked list. This is working and with very direct explaination.\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function (head, val) {\\n// Relocate the head, if the head\\'s value equals to val\\n  while (head) {\\n    if (head.val === val) {\\n      head = head.next;\\n    } else {\\n      break;\\n    }\\n  }\\n// cur represents head for now\\n  let cur = head;\\n// find the nodes should be removed, and jump, jump... \\n// Notice that cur only jumps to the next when found different value.\\n  while (cur && cur.next) {\\n    let nextNode = cur.next;\\n    if (nextNode.val === val) {\\n      cur.next = nextNode.next;\\n      nextNode = nextNode.next;\\n      continue;\\n    }\\n    cur = cur.next;\\n    nextNode = nextNode.next;\\n  }\\n  return head;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function (head, val) {\\n// Relocate the head, if the head\\'s value equals to val\\n  while (head) {\\n    if (head.val === val) {\\n      head = head.next;\\n    } else {\\n      break;\\n    }\\n  }\\n// cur represents head for now\\n  let cur = head;\\n// find the nodes should be removed, and jump, jump... \\n// Notice that cur only jumps to the next when found different value.\\n  while (cur && cur.next) {\\n    let nextNode = cur.next;\\n    if (nextNode.val === val) {\\n      cur.next = nextNode.next;\\n      nextNode = nextNode.next;\\n      continue;\\n    }\\n    cur = cur.next;\\n    nextNode = nextNode.next;\\n  }\\n  return head;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2372618,
                "title": "c-recursive-iterative-easy-logic",
                "content": "Iterative Solution\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {  \\n        ListNode *fast=head, *slow=NULL;       \\n        while(fast!=NULL){\\n            if(fast->val==val){  \\n                if(head==fast)\\n                    head=fast->next;\\n                else\\n                    slow->next=fast->next;\\n            }\\n            else\\n                slow=fast;\\n            fast=fast->next;\\n        }     \\n        return head;        \\n    }\\n};\\n```\\nRecursive Solution\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL)\\n            return head;              \\n        head->next= removeElements(head->next,val);       \\n        if( head->val==val)\\n            return head->next; \\n        return head;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {  \\n        ListNode *fast=head, *slow=NULL;       \\n        while(fast!=NULL){\\n            if(fast->val==val){  \\n                if(head==fast)\\n                    head=fast->next;\\n                else\\n                    slow->next=fast->next;\\n            }\\n            else\\n                slow=fast;\\n            fast=fast->next;\\n        }     \\n        return head;        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL)\\n            return head;              \\n        head->next= removeElements(head->next,val);       \\n        if( head->val==val)\\n            return head->next; \\n        return head;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2327783,
                "title": "most-intuitive-rust-for-me",
                "content": "This style makes the most sense to me personally. We have to move head into a mutable variable first since we\\'re gonna be modifying. Then we define a mutable refernence to the head which will be our walker.\\n\\nIn our loop, we match the walker. If None, the linked list is over so we break. If Some(node) and the value is val, then we modify what the walker is pointing to (by dereferencing) to be whatever is next. We can\\'t do ``` *walker = node.next``` because node.next is behind a mutable reference (node is a &mut) and we can\\'t move out of something we don\\'t own. So we take it. Then if Some(node) and the value is not val, we modify the walker pointer to point to the next node.\\n\\nAt the end we return our head\\n\\n```\\nimpl Solution {\\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut walker = &mut head;\\n        loop {\\n            match walker {\\n                None => break,\\n                Some(node) if node.val == val => {\\n                    *walker = node.next.take();\\n                },\\n                Some(node) => {\\n                    walker = &mut node.next;\\n                },\\n            }\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "``` *walker = node.next```\n```\\nimpl Solution {\\n    pub fn remove_elements(head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut head = head;\\n        let mut walker = &mut head;\\n        loop {\\n            match walker {\\n                None => break,\\n                Some(node) if node.val == val => {\\n                    *walker = node.next.take();\\n                },\\n                Some(node) => {\\n                    walker = &mut node.next;\\n                },\\n            }\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2158854,
                "title": "python3-solution-using-two-pointers-approach",
                "content": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1, None)\\n        dummy.next = head\\n        \\n        prev = dummy\\n        curr = dummy.next\\n        \\n        while curr:\\n            if(curr.val == val):\\n                prev.next = curr.next  \\n            else:\\n                prev = curr\\n            curr = curr.next if curr else None\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(-1, None)\\n        dummy.next = head\\n        \\n        prev = dummy\\n        curr = dummy.next\\n        \\n        while curr:\\n            if(curr.val == val):\\n                prev.next = curr.next  \\n            else:\\n                prev = curr\\n            curr = curr.next if curr else None\\n        \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670015,
                "title": "recursive-javascript-solution",
                "content": "```\\nvar removeElements = function(head, val) {\\n    if (!head) {\\n        return head;\\n    }\\n    if (head.val === val) {\\n        return removeElements(head.next, val);\\n    }\\n    head.next = removeElements(head.next, val)\\n    return head;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n    if (!head) {\\n        return head;\\n    }\\n    if (head.val === val) {\\n        return removeElements(head.next, val);\\n    }\\n    head.next = removeElements(head.next, val)\\n    return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1573479,
                "title": "c-solution-97-faster-very-easy-to-understand",
                "content": "```\\nListNode* removeElements(ListNode* head, int val) {\\n        ListNode*q=head;\\n       if(head==NULL)\\n       {\\n           return NULL;\\n       }\\n        \\n        while(q!=NULL&&q->val==val)\\n        {\\n            ListNode*p=q;\\n                q=q->next;\\n                delete p;\\n        }\\n        head=q;\\n        while(q&&q->next!=NULL)\\n        {\\n            \\n             if(q->next->val==val)\\n            {\\n              ListNode*temp=q->next;\\n                q->next=temp->next;\\n                delete temp;\\n            }\\n            else\\n            {\\n                q=q->next;\\n            }\\n        }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nListNode* removeElements(ListNode* head, int val) {\\n        ListNode*q=head;\\n       if(head==NULL)\\n       {\\n           return NULL;\\n       }\\n        \\n        while(q!=NULL&&q->val==val)\\n        {\\n            ListNode*p=q;\\n                q=q->next;\\n                delete p;\\n        }\\n        head=q;\\n        while(q&&q->next!=NULL)\\n        {\\n            \\n             if(q->next->val==val)\\n            {\\n              ListNode*temp=q->next;\\n                q->next=temp->next;\\n                delete temp;\\n            }\\n            else\\n            {\\n                q=q->next;\\n            }\\n        }\\n        return head;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1513727,
                "title": "easiest-approach-c",
                "content": "```\\n\\t\\tif(head==NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode* temp=head;\\n        \\n        while(temp!=NULL && temp->next!=NULL){\\n            if(temp->next->val==val){\\n                temp->next=temp->next->next;\\n            }else{\\n                temp=temp->next;\\n            }\\n        }\\n        \\n        if(head->val==val){\\n            head=head->next;\\n        }\\n        \\n\\t\\treturn head;\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\t\\tif(head==NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode* temp=head;\\n        \\n        while(temp!=NULL && temp->next!=NULL){\\n            if(temp->next->val==val){\\n                temp->next=temp->next->next;\\n            }else{\\n                temp=temp->next;\\n            }\\n        }\\n        \\n        if(head->val==val){\\n            head=head->next;\\n        }\\n        \\n\\t\\treturn head;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1477630,
                "title": "java-easy-solution-1ms-time-o-n-spaceo-1-1ms",
                "content": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n\\t\\n        if(head==null){\\n            return null;\\n        }\\n        ListNode a=head;\\n        while(a!=null){\\n            if(a.next!=null && a.next.val==val){\\n                a.next=a.next.next;\\n                \\n            }\\n            else{\\n            a=a.next;\\n            }\\n            \\n        }\\n        if( head.next==null && head.val==val ){\\n            head=null;\\n        }\\n        else if(head.next!=null && head.val==val ){\\n            head=head.next;\\n        }\\n        return head;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n\\t\\n        if(head==null){\\n            return null;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1169092,
                "title": "javascript",
                "content": "```\\nvar removeElements = function(head, val) {\\n  if(!head) return head\\n  while(head && head.val == val) head = head.next\\n  let node = head\\n  let prv = null\\n  while(node){\\n    const next = node.next\\n    if(node.val === val){\\n      prv.next = next\\n    }else{\\n      prv = node \\n    }    \\n    node = next\\n  }\\n  return head\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeElements = function(head, val) {\\n  if(!head) return head\\n  while(head && head.val == val) head = head.next\\n  let node = head\\n  let prv = null\\n  while(node){\\n    const next = node.next\\n    if(node.val === val){\\n      prv.next = next\\n    }else{\\n      prv = node \\n    }    \\n    node = next\\n  }\\n  return head\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1161918,
                "title": "python3-iterative-solution-using-dummy-head-with-explanation",
                "content": "## Implementation\\n```python\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        # dummy_head.next is the first node of list\\n        dummy_head = ListNode(next=head)\\n        \\n        prev, cur = dummy_head, head\\n        while cur:\\n            if cur.val == val:\\n                prev.next = cur.next\\n                cur = cur.next\\n            else:\\n                prev, cur = cur, cur.next\\n            \\n        return dummy_head.next\\n```\\n\\nI use a `dummy_head`, whose next element is the first node of the list. The advantage of applying a `dummy_head` is that we can treat `head` as a normal node of the list, so that we can handle the edge cases easily.\\n\\n\\n## Example\\nLet\\'s say we want to remove all the nodes whose `val` is `6`. \\n\\n- At the beginning\\n![image](https://assets.leetcode.com/users/images/18f838c7-5b91-4982-b862-55ddf92b1514_1618604170.6595209.png)\\n\\n- If `cur` should not be removed, we just move `prev` and `cur` one step forward\\n![image](https://assets.leetcode.com/users/images/813c0bef-0b3c-43bc-b8cc-d18883dbeaf3_1618604394.2694678.png)\\n\\n- If `cur` should be removed\\n\\t- We let `cur.next` be the next node of `prev`\\n\\t- and move `cur` one step forward\\n\\n\\t(I.e., We \"jump over\" the removed node) \\n![image](https://assets.leetcode.com/users/images/c5389a3d-a5c2-45cd-bf7f-d37e2a5b0280_1618604427.412363.png)\\n\\n## Complexity\\n- Time: O(n)\\n- Space: O(1)\\n\\nIf you think this is helpful, please give it a vote.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeElements(self, head: ListNode, val: int) -> ListNode:\\n        # dummy_head.next is the first node of list\\n        dummy_head = ListNode(next=head)\\n        \\n        prev, cur = dummy_head, head\\n        while cur:\\n            if cur.val == val:\\n                prev.next = cur.next\\n                cur = cur.next\\n            else:\\n                prev, cur = cur, cur.next\\n            \\n        return dummy_head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1113125,
                "title": "simple-python-solution",
                "content": "```\\ndef removeElements(self, head: ListNode, val: int) -> ListNode:\\n        \\n        dummy = ListNode() \\n        dummy.next = head \\n        cur = dummy \\n        \\n        while cur and cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next \\n            else:\\n                cur = cur.next \\n                \\n        return dummy.next \\n```",
                "solutionTags": [],
                "code": "```\\ndef removeElements(self, head: ListNode, val: int) -> ListNode:\\n        \\n        dummy = ListNode() \\n        dummy.next = head \\n        cur = dummy \\n        \\n        while cur and cur.next:\\n            if cur.next.val == val:\\n                cur.next = cur.next.next \\n            else:\\n                cur = cur.next \\n                \\n        return dummy.next \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1008395,
                "title": "rust-onepass",
                "content": "```rust\\nimpl Solution {\\n    pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = ListNode { val: 0, next: None };\\n        let mut cur = &mut dummy_head;\\n        while let Some(mut node) = head {\\n            head = std::mem::replace(&mut node.next, None);\\n            if node.val != val {\\n                cur.next = Some(node);\\n                cur = cur.next.as_mut().unwrap();\\n            }\\n        }\\n        dummy_head.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn remove_elements(mut head: Option<Box<ListNode>>, val: i32) -> Option<Box<ListNode>> {\\n        let mut dummy_head = ListNode { val: 0, next: None };\\n        let mut cur = &mut dummy_head;\\n        while let Some(mut node) = head {\\n            head = std::mem::replace(&mut node.next, None);\\n            if node.val != val {\\n                cur.next = Some(node);\\n                cur = cur.next.as_mut().unwrap();\\n            }\\n        }\\n        dummy_head.next\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 986302,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null || (head.next == null && head.val == val)) {\\n          return null;\\n        }\\n\\n        for (;head != null && head.val == val; head = head.next);\\n\\n        var curr = head;\\n\\n        while (curr != null && curr.next != null) {\\n          if (curr.next.val == val) {\\n            curr.next = curr.next.next;\\n          } else {\\n            curr = curr.next;\\n          }\\n        }\\n\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null || (head.next == null && head.val == val)) {\\n          return null;\\n        }\\n\\n        for (;head != null && head.val == val; head = head.next);\\n\\n        var curr = head;\\n\\n        while (curr != null && curr.next != null) {\\n          if (curr.next.val == val) {\\n            curr.next = curr.next.next;\\n          } else {\\n            curr = curr.next;\\n          }\\n        }\\n\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 745764,
                "title": "c-faster-than-97-21",
                "content": "Runtime: 96 ms\\nMemory Usage: 27.9 MB\\n\\n```\\n    public ListNode RemoveElements(ListNode head, int val) \\n    {\\n        ListNode tempHead = new ListNode(0, head);\\n        ListNode prev = tempHead;\\n        ListNode crnt = prev.next;\\n        \\n        while(crnt != null)\\n        {\\n            if (crnt.val == val)\\n            {\\n                prev.next = crnt.next; \\n            }\\n            else\\n            {\\n                prev = crnt;\\n            }\\n            \\n            crnt = prev.next;\\n        }\\n        \\n        return tempHead.next;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 96 ms\\nMemory Usage: 27.9 MB\\n\\n```\\n    public ListNode RemoveElements(ListNode head, int val) \\n    {\\n        ListNode tempHead = new ListNode(0, head);\\n        ListNode prev = tempHead;\\n        ListNode crnt = prev.next;\\n        \\n        while(crnt != null)\\n        {\\n            if (crnt.val == val)\\n            {\\n                prev.next = crnt.next; \\n            }\\n            else\\n            {\\n                prev = crnt;\\n            }\\n            \\n            crnt = prev.next;\\n        }\\n        \\n        return tempHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 699620,
                "title": "python-99-76-faster",
                "content": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if not head:\\n            return head\\n        while head and head.val == val:\\n            head = head.next\\n        temp = head\\n        while temp and temp.next:\\n            if temp.next.val == val:\\n                temp.next = temp.next.next\\n            else:\\n                temp =  temp.next\\n        return head\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        \"\"\"\\n        :type head: ListNode\\n        :type val: int\\n        :rtype: ListNode\\n        \"\"\"\\n        \\n        if not head:\\n            return head\\n        while head and head.val == val:\\n            head = head.next\\n        temp = head\\n        while temp and temp.next:\\n            if temp.next.val == val:\\n                temp.next = temp.next.next\\n            else:\\n                temp =  temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 594275,
                "title": "0ms-100-faster-java-simple-iterative-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null)\\n            return null;\\n        ListNode newhead = new ListNode(-1);\\n        ListNode temp = newhead;\\n        while(head != null){\\n            if(head.val != val){\\n                temp.next = head;\\n                temp = temp.next;\\n            }\\n            head = head.next;\\n        }\\n        temp.next = null;\\n        return newhead.next;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if(head == null)\\n            return null;\\n        ListNode newhead = new ListNode(-1);\\n        ListNode temp = newhead;\\n        while(head != null){\\n            if(head.val != val){\\n                temp.next = head;\\n                temp = temp.next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 318934,
                "title": "java-solution",
                "content": "```\\npublic class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        head.next = removeElements(head.next, val);\\n        return head.val == val ? head.next : head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head == null) return null;\\n        head.next = removeElements(head.next, val);\\n        return head.val == val ? head.next : head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318794,
                "title": "cpp-uses-dummy-head",
                "content": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        for (ListNode* node = dummy; node != nullptr; node = node->next) {\\n            while (node->next != nullptr && node->next->val == val) {\\n                node->next = node->next->next;\\n            }\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        for (ListNode* node = dummy; node != nullptr; node = node->next) {\\n            while (node->next != nullptr && node->next->val == val) {\\n                node->next = node->next->next;\\n            }\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 318542,
                "title": "cpp-iterative-recursive-solutions",
                "content": "**Recursive:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(!head) return nullptr;\\n        head->next = removeElements(head->next, val);\\n        return head->val == val ? head->next : head;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(N) (considering recursion stack)\\n\\n\\n\\n**Iterative:**\\n*a) with previous node:*\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* prev = nullptr, *cur = head;\\n        while(cur) {\\n            if(cur->val == val) {\\n                if(cur == head)\\n                    head = head->next;\\n                else\\n                    prev->next = cur->next;\\n            }else {\\n                prev = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(1)\\n\\n*b) use dummy head*\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode(0), *cur = dummy;\\n        dummy->next = head;\\n        while(cur) {\\n            if(cur->next && cur->next->val == val) {\\n                cur->next = cur->next->next;\\n            }else{\\n                cur = cur->next;\\n            }\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(1)\\n\\n\\n*c) pointer-to-pointer:*\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode** pp = &head;\\n        while(*pp) {\\n            if((*pp)->val == val) {\\n                *pp = (*pp)->next;\\n            }else {\\n                pp = &(*pp)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```\\nTime: O(N)\\nSpace: O(1)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(!head) return nullptr;\\n        head->next = removeElements(head->next, val);\\n        return head->val == val ? head->next : head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* prev = nullptr, *cur = head;\\n        while(cur) {\\n            if(cur->val == val) {\\n                if(cur == head)\\n                    head = head->next;\\n                else\\n                    prev->next = cur->next;\\n            }else {\\n                prev = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* dummy = new ListNode(0), *cur = dummy;\\n        dummy->next = head;\\n        while(cur) {\\n            if(cur->next && cur->next->val == val) {\\n                cur->next = cur->next->next;\\n            }else{\\n                cur = cur->next;\\n            }\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode** pp = &head;\\n        while(*pp) {\\n            if((*pp)->val == val) {\\n                *pp = (*pp)->next;\\n            }else {\\n                pp = &(*pp)->next;\\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 180101,
                "title": "python-4-line-recursive-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        if(head == None): return head;\\n        if(head.val == val): return self.removeElements(head.next, val);\\n        head.next = self.removeElements(head.next, val)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        if(head == None): return head;\\n        if(head.val == val): return self.removeElements(head.next, val);\\n        head.next = self.removeElements(head.next, val)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 142417,
                "title": "iterative-go-solution",
                "content": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n    dummy := &ListNode{-1, head}\\n    p := dummy\\n    for p.Next != nil {\\n        if p.Next.Val == val {\\n            p.Next = p.Next.Next\\n            continue\\n        }\\n        p = p.Next\\n    }\\n    return dummy.Next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc removeElements(head *ListNode, val int) *ListNode {\\n    dummy := &ListNode{-1, head}\\n    p := dummy\\n    for p.Next != nil {\\n        if p.Next.Val == val {\\n            p.Next = p.Next.Next\\n            continue\\n        }\\n        p = p.Next\\n    }\\n    return dummy.Next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 57419,
                "title": "c-28ms-beats-100-00-of-cppsubmissions",
                "content": "    class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            if(head == NULL)\\n                return NULL;\\n            while(head && head->val == val)\\n                head = head->next;\\n            if(head == NULL) return head;\\n            else {\\n                ListNode *ptr = head;\\n                while(ptr->next) {\\n                    if(ptr->next->val == val)\\n                        ptr->next = ptr->next->next;\\n                    else\\n                        ptr = ptr->next;\\n                }\\n            }\\n            return head;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* removeElements(ListNode* head, int val) {\\n            if(head == NULL)\\n                return NULL;\\n            while(head && head->val == val)\\n                head = head->next;\\n            if(head == NULL) return head;\\n            else {\\n                ListNode *ptr = head;\\n                while(ptr->next) {\\n                    if(ptr->next->val == val)\\n                        ptr->next = ptr->next->next;\\n                    else\\n                        ptr = ptr->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 57421,
                "title": "java-2-pointers-solution-2ms",
                "content": "        public ListNode removeElements(ListNode head, int val) {\\n    \\t\\tListNode dummy = new ListNode(0);\\n    \\t\\tdummy.next = head;\\n    \\t\\tListNode first = head;\\n    \\t\\tListNode second = dummy;\\n    \\t\\twhile(first != null) {\\n    \\t\\t\\tif (first.val == val) {\\n    \\t\\t\\t\\tfirst = first.next;\\n    \\t\\t\\t\\tsecond.next = first;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tfirst = first.next;\\n    \\t\\t\\t\\tsecond = second.next;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn dummy.next;\\n    \\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "        public ListNode removeElements(ListNode head, int val) {\\n    \\t\\tListNode dummy = new ListNode(0);\\n    \\t\\tdummy.next = head;\\n    \\t\\tListNode first = head;\\n    \\t\\tListNode second = dummy;\\n    \\t\\twhile(first != null) {\\n    \\t\\t\\tif (first.val == val) {\\n    \\t\\t\\t\\tfirst = first.next;\\n    \\t\\t\\t\\tsecond.next = first;\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tfirst = first.next;\\n    \\t\\t\\t\\tsecond = second.next;\\n    \\t\\t\\t}\\n    \\t\\t}\\n    \\t\\treturn dummy.next;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 57527,
                "title": "easy-c-solution",
                "content": "struct ListNode* removeElements(struct ListNode* head, int val) {\\n    \\n    struct ListNode* dummy=(struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->val=INT_MAX;\\n    dummy->next=head;\\n    struct ListNode* prev=dummy; \\n    struct ListNode* Next=NULL;    \\n    struct ListNode* curr=dummy->next;    \\n    \\n    while(curr){\\n        Next=curr->next;\\n        \\n        if(curr->val==val){\\n            prev->next=curr->next;\\n            free(curr);\\n        }\\n        else\\n            prev=curr;\\n\\n        curr=Next;  \\n    }\\n    \\n    return dummy->next;\\n}",
                "solutionTags": [],
                "code": "struct ListNode* removeElements(struct ListNode* head, int val) {\\n    \\n    struct ListNode* dummy=(struct ListNode*)malloc(sizeof(struct ListNode));\\n    dummy->val=INT_MAX;\\n    dummy->next=head;\\n    struct ListNode* prev=dummy; \\n    struct ListNode* Next=NULL;    \\n    struct ListNode* curr=dummy->next;    \\n    \\n    while(curr){\\n        Next=curr->next;\\n        \\n        if(curr->val==val){\\n            prev->next=curr->next;\\n            free(curr);\\n        }\\n        else\\n            prev=curr;\\n\\n        curr=Next;  \\n    }\\n    \\n    return dummy->next;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3885563,
                "title": "c-solutation",
                "content": "\\n\\n## \\u4EE3\\u7801\\u968F\\u60F3\\u5F55 \\u7B97\\u6CD5\\u516C\\u5F00\\u8BFE\\nhttps://youtu.be/SsU9ZmFp310\\n```c\\n\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* temp;\\n\\n    while(head && head->val == val) {\\n        temp = head;\\n        head = head->next;\\n        free(temp);\\n    }\\n\\n    struct ListNode *cur = head;\\n\\n    while(cur && (temp = cur->next)) {\\n        if(temp->val == val) {\\n            cur->next = temp->next;\\n            free(temp);\\n        }\\n        else\\n            cur = cur->next;\\n    }\\n\\n\\n    return head;\\n}\\n\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\n\\nstruct ListNode* removeElements(struct ListNode* head, int val){\\n    struct ListNode* temp;\\n\\n    while(head && head->val == val) {\\n        temp = head;\\n        head = head->next;\\n        free(temp);\\n    }\\n\\n    struct ListNode *cur = head;\\n\\n    while(cur && (temp = cur->next)) {\\n        if(temp->val == val) {\\n            cur->next = temp->next;\\n            free(temp);\\n        }\\n        else\\n            cur = cur->next;\\n    }\\n\\n\\n    return head;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3839646,
                "title": "simplest-pointer-next-pointer-next-next-method-o-n-beats-97-with-time-64ms-space-beats-80",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf value matches make the current pointer connects to next.next otherwise it just moves by to next\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHandle edge cases in beginning.\\n\\n![image.png](https://assets.leetcode.com/users/images/c30be6b8-a2cb-47e9-88dc-ba1ad7f67709_1690739091.6531463.png)\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n0(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * } 10 :44. - 11: 08\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function(head, val) {\\n    if(!head) return null;\\n    if(head.next === null && head.val === val) return null;\\n\\n    let ref = head;\\n    while(head.next !== null){\\n        if(ref && ref.val === val){\\n            ref = ref.next;\\n        }\\n        else if(head.next.val === val){\\n            head.next = head.next.next;\\n        }\\n        else{\\n            head = head.next;\\n        }\\n    }\\n    return ref;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * } 10 :44. - 11: 08\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number} val\\n * @return {ListNode}\\n */\\nvar removeElements = function(head, val) {\\n    if(!head) return null;\\n    if(head.next === null && head.val === val) return null;\\n\\n    let ref = head;\\n    while(head.next !== null){\\n        if(ref && ref.val === val){\\n            ref = ref.next;\\n        }\\n        else if(head.next.val === val){\\n            head.next = head.next.next;\\n        }\\n        else{\\n            head = head.next;\\n        }\\n    }\\n    return ref;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3758538,
                "title": "easy-beginner-solution-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(next=head)\\n        prev ,curr = dummy, head\\n\\n        while curr:\\n            if curr.val == val:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                curr =curr.next\\n                prev = prev.next\\n            \\n\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy = ListNode(next=head)\\n        prev ,curr = dummy, head\\n\\n        while curr:\\n            if curr.val == val:\\n                curr = curr.next\\n                prev.next = curr\\n            else:\\n                curr =curr.next\\n                prev = prev.next\\n            \\n\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3460235,
                "title": "simple-solution-using-one-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        while(head != nullptr && head->val == val ){// 1->1->1->null , val = 1\\n            head = head->next;\\n        }\\n        if(head == nullptr){\\n            return head;\\n        }\\n        \\n        ListNode* temp = head;\\n        while(temp->next != nullptr && temp != nullptr){\\n            if(temp->next->val == val){\\n                temp->next = temp->next->next;\\n                // After doing the above step, I am not updating \"curr\" because of these type of test cases:\\n\\t\\t\\t\\t// 1->2->3->6->6->6->5->null  val = 6\\n            }else{\\n                temp = temp->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        while(head != nullptr && head->val == val ){// 1->1->1->null , val = 1\\n            head = head->next;\\n        }\\n        if(head == nullptr){\\n            return head;\\n        }\\n        \\n        ListNode* temp = head;\\n        while(temp->next != nullptr && temp != nullptr){\\n            if(temp->next->val == val){\\n                temp->next = temp->next->next;\\n                // After doing the above step, I am not updating \"curr\" because of these type of test cases:\\n\\t\\t\\t\\t// 1->2->3->6->6->6->5->null  val = 6\\n            }else{\\n                temp = temp->next;\\n            }\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454910,
                "title": "easy-java-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode temp = head;\\n        while(temp != null) {\\n            if(head.val==val && temp==head) {\\n                head= head.next;\\n                temp = head;\\n                continue;\\n            }\\n            if(temp.next==null) {\\n                break;\\n            }\\n            if(temp.next.val == val) {\\n                temp.next = temp.next.next;\\n                continue;\\n            }\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode temp = head;\\n        while(temp != null) {\\n            if(head.val==val && temp==head) {\\n                head= head.next;\\n                temp = head;\\n                continue;\\n            }\\n            if(temp.next==null) {\\n                break;\\n            }\\n            if(temp.next.val == val) {\\n                temp.next = temp.next.next;\\n                continue;\\n            }\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3454734,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode temp = new ListNode(0);\\n\\n        temp.next = head;\\n        ListNode current = temp;\\n        while(current.next != null){\\n            if(current.next.val == val){\\n                current.next = current.next.next;\\n\\n        }else{\\n           current = current.next; \\n        }\\n        }\\n\\n        return temp.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode temp = new ListNode(0);\\n\\n        temp.next = head;\\n        ListNode current = temp;\\n        while(current.next != null){\\n            if(current.next.val == val){\\n                current.next = current.next.next;\\n\\n        }else{\\n           current = current.next; \\n        }\\n        }\\n\\n        return temp.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3333585,
                "title": "easiest-python-solution-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy=ListNode(next=head)\\n        prev,curr=dummy,head\\n        while curr:\\n            if curr.val==val:\\n                nxt=curr.next\\n                prev.next=nxt\\n                curr=nxt\\n            else:\\n                prev=curr\\n                curr=curr.next\\n        return dummy.next\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy=ListNode(next=head)\\n        prev,curr=dummy,head\\n        while curr:\\n            if curr.val==val:\\n                nxt=curr.next\\n                prev.next=nxt\\n                curr=nxt\\n            else:\\n                prev=curr\\n                curr=curr.next\\n        return dummy.next\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234945,
                "title": "c",
                "content": "# Complexity\\n- Time complexity:```O(n)```\\n- Space complexity:```O(1)```\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        if(head == null) return head;\\n\\n        //if the first element is to be removed or all elements are same as val;\\n        while(head != null && head.val == val) head = head.next;\\n\\n        ListNode current = head;\\n        \\n        while(head != null && head.next != null) {\\n            if(head.next.val == val) {\\n                head.next = head.next.next;\\n            }\\n            else\\n                head = head.next;\\n        }\\n        return current;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```O(n)```\n```O(1)```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode RemoveElements(ListNode head, int val) {\\n        if(head == null) return head;\\n\\n        //if the first element is to be removed or all elements are same as val;\\n        while(head != null && head.val == val) head = head.next;\\n\\n        ListNode current = head;\\n        \\n        while(head != null && head.next != null) {\\n            if(head.next.val == val) {\\n                head.next = head.next.next;\\n            }\\n            else\\n                head = head.next;\\n        }\\n        return current;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204124,
                "title": "beats-92-java-code",
                "content": "# Java Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n * int val;\\n * ListNode next;\\n * ListNode() {}\\n * ListNode(int val) { this.val = val; }\\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans = new ListNode();\\n        ListNode cur = ans;\\n        ListNode temp = head;\\n\\n        while (temp != null) {\\n            if (temp.val != val) {\\n                cur.next = new ListNode(temp.val);\\n                cur = cur.next;\\n            }\\n\\n            temp = temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n * int val;\\n * ListNode next;\\n * ListNode() {}\\n * ListNode(int val) { this.val = val; }\\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans = new ListNode();\\n        ListNode cur = ans;\\n        ListNode temp = head;\\n\\n        while (temp != null) {\\n            if (temp.val != val) {\\n                cur.next = new ListNode(temp.val);\\n                cur = cur.next;\\n            }\\n\\n            temp = temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106158,
                "title": "runtime-69-ms-beats-81-72-remove-linked-list-elements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        while head!=None and head.val==val:\\n            head=head.next\\n        temp=head\\n        while temp:\\n            while temp.next and temp.next.val==val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        while head!=None and head.val==val:\\n            head=head.next\\n        temp=head\\n        while temp:\\n            while temp.next and temp.next.val==val:\\n                temp.next=temp.next.next\\n            temp=temp.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3040555,
                "title": "c-iterative-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int v) {\\n        if(!head)return NULL;\\n        \\n        ListNode* h= NULL;\\n        ListNode* t= NULL;\\n        \\n        while(head){\\n            if(head->val !=  v){\\n                if(t){\\n                    t->next= head;\\n                    t= t->next;\\n                }\\n                else{\\n                    h= head;\\n                    t= head;\\n                }\\n            }\\n            head= head->next;\\n        }\\n        if(t)t->next= NULL;\\n        return h;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int v) {\\n        if(!head)return NULL;\\n        \\n        ListNode* h= NULL;\\n        ListNode* t= NULL;\\n        \\n        while(head){\\n            if(head->val !=  v){\\n                if(t){\\n                    t->next= head;\\n                    t= t->next;\\n                }\\n                else{\\n                    h= head;\\n                    t= head;\\n                }\\n            }\\n            head= head->next;\\n        }\\n        if(t)t->next= NULL;\\n        return h;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966451,
                "title": "easy-and-understandable-c",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val)\\n    {   \\n        while(head != NULL && head->val == val) // if all the elements are same\\n        {\\n            head = head->next;\\n        }\\n\\n        if(head == NULL)\\n            return NULL;\\n        \\n        ListNode* pointer;\\n        pointer = head;\\n\\n        while (pointer->next != NULL)  // removing ftom middle of the linked list\\n        {\\n            if(pointer->next->val == val)\\n            {\\n                pointer->next = pointer->next->next;\\n            }\\n            else\\n            {\\n                pointer = pointer->next;    \\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val)\\n    {   \\n        while(head != NULL && head->val == val) // if all the elements are same\\n        {\\n            head = head->next;\\n        }\\n\\n        if(head == NULL)\\n            return NULL;\\n        \\n        ListNode* pointer;\\n        pointer = head;\\n\\n        while (pointer->next != NULL)  // removing ftom middle of the linked list\\n        {\\n            if(pointer->next->val == val)\\n            {\\n                pointer->next = pointer->next->next;\\n            }\\n            else\\n            {\\n                pointer = pointer->next;    \\n            }\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2900595,
                "title": "two-pointers-concept-python3",
                "content": "\\n\\n# Two Pointers Approach--->Time:O(N)\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy=ListNode(next=head)\\n        prev=dummy\\n        cur=head\\n        while cur:\\n            nxt=cur.next\\n            if cur.val==val:\\n                prev.next=nxt\\n            else:\\n                prev=cur\\n            cur=nxt\\n        return dummy.next\\n        \\n```\\n# 2. One Pointer Approach--->Time:O(N)\\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        while head and head.val==val:\\n            head=head.next\\n        cur=head\\n        while cur and cur.next:\\n            if cur.next.val==val:\\n                cur.next=cur.next.next\\n            else:\\n                cur=cur.next\\n        return head\\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        dummy=ListNode(next=head)\\n        prev=dummy\\n        cur=head\\n        while cur:\\n            nxt=cur.next\\n            if cur.val==val:\\n                prev.next=nxt\\n            else:\\n                prev=cur\\n            cur=nxt\\n        return dummy.next\\n        \\n```\n```\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        while head and head.val==val:\\n            head=head.next\\n        cur=head\\n        while cur and cur.next:\\n            if cur.next.val==val:\\n                cur.next=cur.next.next\\n            else:\\n                cur=cur.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827937,
                "title": "java-easy-to-understand-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        while(head!=null && head.val==val) head=head.next;\\n        if(head==null) return head;\\n        ListNode ptr=head;\\n        while(ptr.next!=null){\\n            if(ptr.next.val==val){\\n                ptr.next=ptr.next.next;\\n                continue;\\n            }\\n            ptr=ptr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        while(head!=null && head.val==val) head=head.next;\\n        if(head==null) return head;\\n        ListNode ptr=head;\\n        while(ptr.next!=null){\\n            if(ptr.next.val==val){\\n                ptr.next=ptr.next.next;\\n                continue;\\n            }\\n            ptr=ptr.next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719164,
                "title": "java-simple-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head != null) {\\n            // If the starting node is equal to value move the head to the next node until the value is different\\n            while(head != null && head.val == val){\\n                head = head.next;\\n            }\\n            // Take a pointer to the current head node and check if the value of the next node is equal to the value\\n            // If it is equal to the value change the next pointer of the current node to the node ahead\\n            ListNode currentNode = head;\\n            while (currentNode != null && currentNode.next != null) {\\n                if (currentNode.next.val == val) {\\n                    currentNode.next = currentNode.next.next;\\n                } else {\\n                    currentNode = currentNode.next;\\n                }   \\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        if (head != null) {\\n            // If the starting node is equal to value move the head to the next node until the value is different\\n            while(head != null && head.val == val){\\n                head = head.next;\\n            }\\n            // Take a pointer to the current head node and check if the value of the next node is equal to the value\\n            // If it is equal to the value change the next pointer of the current node to the node ahead\\n            ListNode currentNode = head;\\n            while (currentNode != null && currentNode.next != null) {\\n                if (currentNode.next.val == val) {\\n                    currentNode.next = currentNode.next.next;\\n                } else {\\n                    currentNode = currentNode.next;\\n                }   \\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698504,
                "title": "203-remove-linked-list-elements-using-list-linked-list-for-beginners-and-using-linked-list-17ms",
                "content": "```\\n        #Using List +Linked List For Beginners\\n        t=head #assign temp variable because this is single linked list traversed only one time in one direction.\\n        a=[] #create a list for appending value of head\\n        while t:#loop run till temp is not None\\n            a.append(t.val) #t.val give the value from head  and append in a\\n            t=t.next # use for increment the pointer +1\\n        b=[] #now this list create for getting a list according to problem given\\n        for i in a: #iteration of list a\\n            if i!=val:#condition check according to question\\n                b.append(i)\\n        print(b)\\n        if not b:# this condition check if b is empty then return None\\n            return None\\n        i=0# initialize i for compare the len(b)\\n        n=ListNode()#now we create a new object which assign as head \\n        t=n\\n        while i<len(b):\\n            t.val=b[i]#assign value of list b in head n\\n            if i!=len(b)-1: \\n                t.next= ListNode()\\n                t=t.next\\n            i+=1\\n        return n\\n```\\n\\n```\\n        #Using LinkedList Only\\n\\t\\tif head==None:\\n            return head\\n        while head.val==val:\\n                head=head.next\\n                if head==None:\\n                    return head\\n        \\n        t=head\\n        while t and t.next:\\n            \\n            if t.next.val==val:\\n                t.next=t.next.next\\n            else:\\n                t=t.next\\n        return head \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        #Using List +Linked List For Beginners\\n        t=head #assign temp variable because this is single linked list traversed only one time in one direction.\\n        a=[] #create a list for appending value of head\\n        while t:#loop run till temp is not None\\n            a.append(t.val) #t.val give the value from head  and append in a\\n            t=t.next # use for increment the pointer +1\\n        b=[] #now this list create for getting a list according to problem given\\n        for i in a: #iteration of list a\\n            if i!=val:#condition check according to question\\n                b.append(i)\\n        print(b)\\n        if not b:# this condition check if b is empty then return None\\n            return None\\n        i=0# initialize i for compare the len(b)\\n        n=ListNode()#now we create a new object which assign as head \\n        t=n\\n        while i<len(b):\\n            t.val=b[i]#assign value of list b in head n\\n            if i!=len(b)-1: \\n                t.next= ListNode()\\n                t=t.next\\n            i+=1\\n        return n\\n```\n```\\n        #Using LinkedList Only\\n\\t\\tif head==None:\\n            return head\\n        while head.val==val:\\n                head=head.next\\n                if head==None:\\n                    return head\\n        \\n        t=head\\n        while t and t.next:\\n            \\n            if t.next.val==val:\\n                t.next=t.next.next\\n            else:\\n                t=t.next\\n        return head \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2698212,
                "title": "simple-java-solution-beats-100",
                "content": "# Intuition\\nSkip all the node except the val \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSkip all the node except the val  \\nCopy the rest\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans= new ListNode();\\n        ListNode cur= ans;\\n        ListNode temp = head;\\n\\n        while(temp != null){\\n            if(temp.val != val){\\n                cur.next = new ListNode(temp.val);\\n                cur = cur.next;\\n            }\\n\\n            temp= temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans= new ListNode();\\n        ListNode cur= ans;\\n        ListNode temp = head;\\n\\n        while(temp != null){\\n            if(temp.val != val){\\n                cur.next = new ListNode(temp.val);\\n                cur = cur.next;\\n            }\\n\\n            temp= temp.next;\\n        }\\n\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2693938,
                "title": "easy-c-fast",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* remove(ListNode* root, int val){\\n        if(root == NULL)return root;\\n        while(root != NULL and root->val == val){\\n            root = root->next;\\n        }\\n        return root;\\n    }\\n    \\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* root = remove(head, val);\\n        head = root;\\n        while(root != NULL){\\n            if(root->next != NULL and root->next->val == val){\\n                root->next = remove(root->next, val);\\n            }\\n            root = root->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* remove(ListNode* root, int val){\\n        if(root == NULL)return root;\\n        while(root != NULL and root->val == val){\\n            root = root->next;\\n        }\\n        return root;\\n    }\\n    \\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode* root = remove(head, val);\\n        head = root;\\n        while(root != NULL){\\n            if(root->next != NULL and root->next->val == val){\\n                root->next = remove(root->next, val);\\n            }\\n            root = root->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2686991,
                "title": "easy-java-1-ms-98-94-of-java-submissions",
                "content": "#### Runtime: 1 ms, faster than 98.94% of Java online submissions for Remove Linked List Elements.\\nMemory Usage: 43.1 MB, less than 90.68% of Java online submissions for Remove Linked List Elements.\\n\\n```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans = new ListNode();\\n        ListNode curr = ans;\\n        \\n        ListNode ptr = head;\\n        \\n        while(ptr != null) {\\n            if(ptr.val != val) {\\n                curr.next = new ListNode(ptr.val);\\n                curr = curr.next;\\n            }\\n            ptr = ptr.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        ListNode ans = new ListNode();\\n        ListNode curr = ans;\\n        \\n        ListNode ptr = head;\\n        \\n        while(ptr != null) {\\n            if(ptr.val != val) {\\n                curr.next = new ListNode(ptr.val);\\n                curr = curr.next;\\n            }\\n            ptr = ptr.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2636094,
                "title": "java-short-and-simple-code",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        \\n        if(head==null) return null;\\n        ListNode temp = head;\\n        \\n        while(temp.next!=null){\\n            \\n          if(temp.next.val==val) temp.next = temp.next.next;\\n          else temp = temp.next;\\n        \\n        }\\n        \\n        if(head.val==val) return head.next;\\n        return head;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeElements(ListNode head, int val) {\\n        \\n        if(head==null) return null;\\n        ListNode temp = head;\\n        \\n        while(temp.next!=null){\\n            \\n          if(temp.next.val==val) temp.next = temp.next.next;\\n          else temp = temp.next;\\n        \\n        }\\n        \\n        if(head.val==val) return head.next;\\n        return head;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565052,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1808716,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1731450,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1812433,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1759557,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1786008,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1834914,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1721307,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1686102,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 2058802,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1565052,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1808716,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1731450,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1812433,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1759557,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1786008,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1834914,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1721307,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 1686102,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 2058802,
                "content": [
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 12.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/remove-linked-list-elements/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Sentinel Node\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "acretu81",
                        "content": "I have a question regarding the c++ approach, if you do not free the memory for each deleted node your program still passes, and the running time is much faster than when you have another variable that you use to free each deleted node. Should we care about the running time or the correctness of the approach, i would say the second. I know that c++ does not have a garbage collector, so normally not freeing the memory should create leaks. Thanks"
                    },
                    {
                        "username": "Vanam8659",
                        "content": "just add dummy node at front and solve with loop as usual"
                    },
                    {
                        "username": "karakiyunlatif",
                        "content": "[@divyanshVerma](/divyanshVerma) Just return None\\n"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "call that dummy Node as *prev"
                    },
                    {
                        "username": "buinhatanhisded",
                        "content": "[@divyanshVerma](/divyanshVerma)  return the next node relative to the dummy head after removing. In your case, it would be Null/None"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?"
                    },
                    {
                        "username": "wagzap",
                        "content": "🎁Since we must remove nodes from a __singly__ linked list, we need the node before the one to remove.\n⚡Here's a recipe for success:\n1. Go through the list once, from head to end, with a previous and a current pointer\n1. If the current node's value ISN'T the one to remove, just advance both pointers\n1. Otherwise, detach the previous node from the current one, and link it to the next one.\n❗ Also detach the node from the list (its Next shouldn't point to the following node in the list anymore)\n1. If you're removing the current head, set it to the node after it.\n\nEasy as pie 🥧"
                    },
                    {
                        "username": "bumate90",
                        "content": "What a stupid exercise, you just need to unlink them, if you unlink + delete and set them to nullptr\\nthe address sanitizer will complain."
                    },
                    {
                        "username": "chirag123490",
                        "content": "class Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        ListNode*dummy = new ListNode();\\n        ListNode*ptr = dummy;\\n        while(head != NULL){\\n            if(head -> val == val){\\n                head = head -> next;\\n            }\\n            else{\\n                ptr -> next = head;\\n                ptr = ptr -> next;\\n                head = head -> next;\\n            }\\n        }\\n        return dummy -> next;\\n    }\\n};\\n\\n\\ncan anyone tell me that why is it printing [1,2,3,4,5,6] for testcase [1,2,6,3,4,5,6], val = 6?"
                    },
                    {
                        "username": "AshutoshPatel028",
                        "content": "Where are u deleting the found Node??\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "you also have to point the ptr to NULL in the end after the loop ends."
                    },
                    {
                        "username": "Almazino",
                        "content": "I need to update head and return head? I can not understand how I need to return my answer"
                    },
                    {
                        "username": "Anik_Karmokar",
                        "content": "add temporary node and solve with loop"
                    },
                    {
                        "username": "Tharunadhit",
                        "content": "Why is it showing last element 6 too?\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution(object):\\n    def removeElements(self, head, val):\\n        n = ListNode()\\n        temp = n\\n        \\n        while(head):\\n            if(head.val != val):\\n                temp.next = head\\n                temp = temp.next\\n            head = head.next\\n\\n        return n.next\\n       "
                    },
                    {
                        "username": "Nirmal_Kanniaiyan",
                        "content": "Its because You are adding the head to the temp variable.... by doing so u are the adding the entire head to your temp variable thats y u get 6 at last .... u should be creating a new listnode with head.val and add it to prev\\nLike this...\\nans = prev = ListNode()\\n\\n        while head :\\n            if head.val != val :\\n                prev.next = ListNode(head.val)\\n                prev = prev.next\\n            head = head.next\\n\\n        return ans.next"
                    },
                    {
                        "username": "nayanagarwal911",
                        "content": "the question is Remove Linked List Elements.....why 11th line of code is showing an error?? can anybody help\\n\\nclass Solution {\\npublic:\\n    ListNode* removeElements(ListNode* head, int val) {\\n        if(head==NULL) return head;\\n        ListNode* prev=NULL;\\n        ListNode* curr=head;\\n        while(curr!=NULL)\\n        {\\n            if(curr->val==val)\\n            {\\n                if(curr->next!=NULL) prev->next=curr->next;        // showing error\\n                else prev->next=NULL;\\n                curr=curr->next;\\n            }\\n            else\\n            {\\n                prev=curr;\\n                curr=curr->next;\\n            }\\n        }\\n        return head;\\n    }\\n};"
                    },
                    {
                        "username": "ayushanand18",
                        "content": "This will throw error because when initially prev is NULL, and in the first iteration itself the condition is true i.e. the first node has the target value then calling prev->next will throw error since prev is NULL and therefore it cannot be accessed."
                    },
                    {
                        "username": "richard-akkad",
                        "content": "this is confusing, do we only have to consider this particular lists or for all cases?"
                    }
                ]
            },
            {
                "id": 2038033,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 2017859,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1980602,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1948745,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1921645,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1895985,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1799060,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1777420,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1763555,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761830,
                "content": [
                    {
                        "username": "SkepticalYouth",
                        "content": "Is `head` the entire linked list, or just the root node?\\n"
                    },
                    {
                        "username": "rajat_171",
                        "content": "entire list"
                    },
                    {
                        "username": "Madhav_mahajan_",
                        "content": "Just add dummy node at front and solve with loop as usual .\nhttps://leetcode.com/problems/remove-linked-list-elements/solutions/3921867/simple-c-beats-100/"
                    },
                    {
                        "username": "SiddhantJha",
                        "content": "struct ListNode* removeElements(struct ListNode* head, int val){\\n        struct ListNode *temp,*curr;\\n        while(head!=NULL && head->val==val){\\n            head = head->next;\\n        }\\n        temp=curr=head;\\n        while(temp)\\n        {\\n           if(temp->val != val)\\n           { \\n               curr->next=temp;\\n               curr=temp;\\n           }\\n           temp=temp->next;\\n        }\\n        curr->next=temp;\\n        return head;\\n}\\n\\nit says time limit exceed can anyone help me please"
                    },
                    {
                        "username": "madhuraiyengar22",
                        "content": "Can I know what\\'s the problem with my code?\\n\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        \\n        if not head:\\n            return None\\n        \\n        prev = ListNode(0)\\n        prev.next = head\\n\\n        while prev.next:\\n            if prev.next.val == val:\\n                prev.next = prev.next.next\\n            else:\\n                prev = prev.next\\n            \\n        return head"
                    },
                    {
                        "username": "srapol",
                        "content": "your pointer prev is not moving forward unless a matching node appears"
                    },
                    {
                        "username": "user5722rr",
                        "content": "Does anyone know why this doesn\\'t work? lpResult get populated properly, but lpResultHead remains nullptr despite lpResult pointing towards lpResultHead initially.\\n```\\n    ListNode* removeElements(ListNode* head, int val) \\n    {\\n        ListNode* lpResult = nullptr;\\n        ListNode* lpResultHead = lpResult;\\n        while ( head != nullptr )\\n        {\\n            if (head->val != val)\\n            {\\n                lpResult = new ListNode( head->val );\\n                lpResult = lpResult->next;\\n            }\\n            head = head->next;\\n        }\\n        return lpResultHead;\\n    }\\n```"
                    },
                    {
                        "username": "divyanshVerma",
                        "content": "how to solve when whole list contains the same repeating element?\\n"
                    },
                    {
                        "username": "jyothienarendramath252",
                        "content": "At the start check if head is null if its null then return null. Otherwise use while loop to remove head if it's value is val and its not null. So the condition of while loop would be while(head!=null && head.val ==val) { head  = head.next }. After coming out of the loop again check if head is nulll. "
                    },
                    {
                        "username": "hafid-hub",
                        "content": "Just use a loop and keep removing this items."
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "is this question or test cases  changed ? \\nlast time my code work fine and it\\'s not giving the right result anymore"
                    },
                    {
                        "username": "contactaditya832126",
                        "content": "# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:\\n        if head:\\n            curr = head\\n            while curr.next:\\n                if curr.next.val == val:\\n                    curr.next = curr.next.next\\n                else:\\n                    curr = curr.next\\n            if head.val == val:\\n                head = head.next\\n            return head\\n        else:\\n            return"
                    },
                    {
                        "username": "azharsheikh760",
                        "content": "https://leetcode.com/problems/remove-linked-list-elements/solutions/3069131/js-time-efficient-83-beat-space-efficient-89-beat/\\n\\nTime and space efficient"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    }
]