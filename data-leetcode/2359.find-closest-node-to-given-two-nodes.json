[
    {
        "title": "Find Closest Node to Given Two Nodes",
        "question_content": "You are given a directed graph of n nodes numbered from 0 to n - 1, where each node has at most one outgoing edge.\nThe graph is represented with a given 0-indexed array edges of size n, indicating that there is a directed edge from node i to node edges[i]. If there is no outgoing edge from i, then edges[i] == -1.\nYou are also given two integers node1 and node2.\nReturn the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. If there are multiple answers, return the node with the smallest index, and if no possible answer exists, return -1.\nNote that edges may contain cycles.\n&nbsp;\nExample 1:\n\nInput: edges = [2,2,3,-1], node1 = 0, node2 = 1\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 1, and the distance from node 1 to node 2 is 1.\nThe maximum of those two distances is 1. It can be proven that we cannot get a node with a smaller maximum distance than 1, so we return node 2.\n\nExample 2:\n\nInput: edges = [1,2,-1], node1 = 0, node2 = 2\nOutput: 2\nExplanation: The distance from node 0 to node 2 is 2, and the distance from node 2 to itself is 0.\nThe maximum of those two distances is 2. It can be proven that we cannot get a node with a smaller maximum distance than 2, so we return node 2.\n\n&nbsp;\nConstraints:\n\n\tn == edges.length\n\t2 <= n <= 105\n\t-1 <= edges[i] < n\n\tedges[i] != i\n\t0 <= node1, node2 < n",
        "solutions": [
            {
                "id": 3095888,
                "title": "day-25-graph-dfs-easiest-beginner-friendly-sol-o-n-time-and-o-n-space",
                "content": "# Intuition\\n![WhatsApp Image 2023-01-25 at 7.47.32 AM.jpeg](https://assets.leetcode.com/users/images/bc844375-616a-4376-88d6-268660f8ec10_1674613104.616387.jpeg)\\n\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\n2. Create two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\n3. Run the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\n4. Run the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\n5. Iterate through all nodes currNode in the graph.\\n6. For each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\n7. If the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\n8. Return ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& edges, vector<int>& distance, vector<bool>& visited){\\n        visited[node] = true;\\n        int neighbor = edges[node];\\n        if (neighbor != -1 && visited[neighbor] == false) {\\n            distance[neighbor] = distance[node] + 1;\\n            dfs(neighbor, edges, distance, visited);\\n        }\\n    }\\n    //we are using DFS to solve this problem\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        int ans = -1;\\n        int minDist = INT_MAX;\\n        //dist1 store the distance from node1 to all the neighbour nodes and dist2 store the distance from node2 to all the neighbour nodes\\n        vector<int> dist1(n, 0), dist2(n, 0);\\n        //visited array helps us to identify wheather we visited to particular node form node1 or not similarly for visited2\\n        vector<bool> visited1(n, false), visited2(n, false);\\n        //calling dfs from both the nodes i.e. node1 and node2\\n        dfs(node1, edges, dist1, visited1);\\n        dfs(node2, edges, dist2, visited2);\\n\\n        for(int currNode = 0; currNode < n; currNode++){\\n            if(visited1[currNode] == true && visited2[currNode] == true && minDist > max(dist1[currNode], dist2[currNode])){\\n                minDist = max(dist1[currNode], dist2[currNode]);\\n                ans = currNode;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public void dfs(int node, int[] edges, int[] distance, boolean[] visited) {\\n        visited[node] = true;\\n        int neighbor = edges[node];\\n        if (neighbor != -1 && !visited[neighbor]) {\\n            distance[neighbor] = distance[node] + 1;\\n            dfs(neighbor, edges, distance, visited);\\n        }\\n    }\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int ans = -1;\\n        int minDist = Integer.MAX_VALUE;\\n        int[] dist1 = new int[n];\\n        int[] dist2 = new int[n];\\n        boolean[] visited1 = new boolean[n];\\n        boolean[] visited2 = new boolean[n];\\n        dfs(node1, edges, dist1, visited1);\\n        dfs(node2, edges, dist2, visited2);\\n\\n        for (int currNode = 0; currNode < n; currNode++) {\\n            if (visited1[currNode] && visited2[currNode] && minDist > Math.max(dist1[currNode], dist2[currNode])) {\\n                minDist = Math.max(dist1[currNode], dist2[currNode]);\\n                ans = currNode;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def dfs(self, node, edges, distance, visited):\\n        visited[node] = True\\n        neighbor = edges[node]\\n        if neighbor != -1 and visited[neighbor] == False:\\n            distance[neighbor] = distance[node] + 1\\n            self.dfs(neighbor, edges, distance, visited)\\n\\n    def closestMeetingNode(self, edges, node1, node2):\\n        n = len(edges)\\n        ans = -1\\n        minDist = float(\"inf\")\\n        dist1 = [0] * n\\n        dist2 = [0] * n\\n        visited1 = [False] * n\\n        visited2 = [False] * n\\n        self.dfs(node1, edges, dist1, visited1)\\n        self.dfs(node2, edges, dist2, visited2)\\n\\n        for currNode in range(n):\\n            if visited1[currNode] and visited2[currNode] and minDist > max(dist1[currNode], dist2[currNode]):\\n                minDist = max(dist1[currNode], dist2[currNode])\\n                ans = currNode\\n\\n        return ans\\n\\n```\\n\\n# Complexity\\n- Time complexity: **O(n)** // where n is the number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n)** // we are using visited, distance array of size n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& edges, vector<int>& distance, vector<bool>& visited){\\n        visited[node] = true;\\n        int neighbor = edges[node];\\n        if (neighbor != -1 && visited[neighbor] == false) {\\n            distance[neighbor] = distance[node] + 1;\\n            dfs(neighbor, edges, distance, visited);\\n        }\\n    }\\n    //we are using DFS to solve this problem\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        int ans = -1;\\n        int minDist = INT_MAX;\\n        //dist1 store the distance from node1 to all the neighbour nodes and dist2 store the distance from node2 to all the neighbour nodes\\n        vector<int> dist1(n, 0), dist2(n, 0);\\n        //visited array helps us to identify wheather we visited to particular node form node1 or not similarly for visited2\\n        vector<bool> visited1(n, false), visited2(n, false);\\n        //calling dfs from both the nodes i.e. node1 and node2\\n        dfs(node1, edges, dist1, visited1);\\n        dfs(node2, edges, dist2, visited2);\\n\\n        for(int currNode = 0; currNode < n; currNode++){\\n            if(visited1[currNode] == true && visited2[currNode] == true && minDist > max(dist1[currNode], dist2[currNode])){\\n                minDist = max(dist1[currNode], dist2[currNode]);\\n                ans = currNode;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public void dfs(int node, int[] edges, int[] distance, boolean[] visited) {\\n        visited[node] = true;\\n        int neighbor = edges[node];\\n        if (neighbor != -1 && !visited[neighbor]) {\\n            distance[neighbor] = distance[node] + 1;\\n            dfs(neighbor, edges, distance, visited);\\n        }\\n    }\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int ans = -1;\\n        int minDist = Integer.MAX_VALUE;\\n        int[] dist1 = new int[n];\\n        int[] dist2 = new int[n];\\n        boolean[] visited1 = new boolean[n];\\n        boolean[] visited2 = new boolean[n];\\n        dfs(node1, edges, dist1, visited1);\\n        dfs(node2, edges, dist2, visited2);\\n\\n        for (int currNode = 0; currNode < n; currNode++) {\\n            if (visited1[currNode] && visited2[currNode] && minDist > Math.max(dist1[currNode], dist2[currNode])) {\\n                minDist = Math.max(dist1[currNode], dist2[currNode]);\\n                ans = currNode;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def dfs(self, node, edges, distance, visited):\\n        visited[node] = True\\n        neighbor = edges[node]\\n        if neighbor != -1 and visited[neighbor] == False:\\n            distance[neighbor] = distance[node] + 1\\n            self.dfs(neighbor, edges, distance, visited)\\n\\n    def closestMeetingNode(self, edges, node1, node2):\\n        n = len(edges)\\n        ans = -1\\n        minDist = float(\"inf\")\\n        dist1 = [0] * n\\n        dist2 = [0] * n\\n        visited1 = [False] * n\\n        visited2 = [False] * n\\n        self.dfs(node1, edges, dist1, visited1)\\n        self.dfs(node2, edges, dist2, visited2)\\n\\n        for currNode in range(n):\\n            if visited1[currNode] and visited2[currNode] and minDist > max(dist1[currNode], dist2[currNode]):\\n                minDist = max(dist1[currNode], dist2[currNode])\\n                ans = currNode\\n\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357694,
                "title": "two-dfs",
                "content": "We run DFS independently for node 1 and 2, memoising the distance to each node we reach.\\n \\xA0\\nThen, we check each node, track and return the index of the one with minimum max distance.\\n\\n**C++**\\n```cpp\\nvoid dfs(int i, int dist, vector<int>& e, vector<int>& memo) {\\n    while (i != -1 && memo[i] == -1) {\\n        memo[i] = dist++;\\n        i = e[i];\\n    }\\n}\\nint closestMeetingNode(vector<int>& e, int node1, int node2) {\\n    int res = -1, min_dist = INT_MAX;\\n    vector<int> m1(e.size(), -1), m2(e.size(), -1);\\n    dfs(node1, 0, e, m1);\\n    dfs(node2, 0, e, m2);\\n    for (int i = 0; i < e.size(); ++i)\\n        if (min(m1[i], m2[i]) >= 0 && max(m1[i], m2[i]) < min_dist) {\\n            min_dist = max(m1[i], m2[i]);\\n            res = i;\\n        }\\n    return res;\\n}\\n```\\n#### Minimalizm Version\\nHere, we check for the minimum max distance during DFS from the second node.\\n\\n**C++**\\n```cpp\\nint closestMeetingNode(vector<int>& e, int node1, int node2) {\\n    int res = -1, min_dist = INT_MAX;\\n    vector<int> m1(e.size(), -1), m2(e.size(), -1);\\n    for (int i = node1, dist = 0; i != -1 && m1[i] == -1; i = e[i])\\n        m1[i] = dist++;\\n    for (int i = node2, dist = 0; i != -1 && m2[i] == -1; i = e[i]) {\\n        m2[i] = dist++;\\n        if (m1[i] >= 0 && max(m1[i], m2[i]) <= min_dist) {\\n            res = max(m1[i], m2[i]) == min_dist ? min(i, res) : i;\\n            min_dist = max(m1[i], m2[i]);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvoid dfs(int i, int dist, vector<int>& e, vector<int>& memo) {\\n    while (i != -1 && memo[i] == -1) {\\n        memo[i] = dist++;\\n        i = e[i];\\n    }\\n}\\nint closestMeetingNode(vector<int>& e, int node1, int node2) {\\n    int res = -1, min_dist = INT_MAX;\\n    vector<int> m1(e.size(), -1), m2(e.size(), -1);\\n    dfs(node1, 0, e, m1);\\n    dfs(node2, 0, e, m2);\\n    for (int i = 0; i < e.size(); ++i)\\n        if (min(m1[i], m2[i]) >= 0 && max(m1[i], m2[i]) < min_dist) {\\n            min_dist = max(m1[i], m2[i]);\\n            res = i;\\n        }\\n    return res;\\n}\\n```\n```cpp\\nint closestMeetingNode(vector<int>& e, int node1, int node2) {\\n    int res = -1, min_dist = INT_MAX;\\n    vector<int> m1(e.size(), -1), m2(e.size(), -1);\\n    for (int i = node1, dist = 0; i != -1 && m1[i] == -1; i = e[i])\\n        m1[i] = dist++;\\n    for (int i = node2, dist = 0; i != -1 && m2[i] == -1; i = e[i]) {\\n        m2[i] = dist++;\\n        if (m1[i] >= 0 && max(m1[i], m2[i]) <= min_dist) {\\n            res = max(m1[i], m2[i]) == min_dist ? min(i, res) : i;\\n            min_dist = max(m1[i], m2[i]);\\n        }\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2357744,
                "title": "bfs-concept-of-shortest-path-of-a-node-from-multiple-sources",
                "content": "**SHORTEST PATH OF A NODE FROM MULTIPLE SOURCES Concept**\\n\\n1. Use `BFS` to compute distance from `node1 to every node` and from `node2 to every node` individually.\\n 2. Loop from `0 to n` nodes and return `the first node with smallest value of max(A[node],B[node])`   \\n\\n**The question also highlighted a line -> `Note that edges may contain cycles.`**\\nBut we should not care about it because our main goal is to get distance of all nodes from node1 and node2 which doesn\\'t need any detection of cycle. why??\\nBecause while computing distance from a single source we discard the visited node which prevents us  from getting stuck in a cycle.\\n\\n\\n**The question from which I learnt this concept**: \\n[2203. Minimum Weighted Subgraph With the Required Paths](https://leetcode.com/contest/weekly-contest-284/problems/minimum-weighted-subgraph-with-the-required-paths/)  \\nbut its a bit harder than this one.\\n\\nThe people who were not able to solve, pls don\\'t feel demotivated, this question had a concept of finding **SHORTEST PATH OF A NODE FROM MULTIPLE SOURCES**.\\nI encourage you to solve this problem first and understand the concept and apply the same in the above question link as this is question is a prerequisite of the above link question.\\nThis logic will also work if there are more than 2 sources nodes, we just need small changes in those cases.\\n\\n**Updation**: Thanks to **@jaylenzhang19**\\n> We can use just check if distance of any neighbour is still INT_MAX in BFS. This way we can eliminate the use of visited vector.\\n\\n![image](https://assets.leetcode.com/users/images/48966e27-a55a-4a74-9585-a65f579c18bd_1659253302.6357615.png)\\n\\n\\n\\t\\n`Time` - O(N)\\n`Space` - O(N)\\n\\t\\n# C++\\t\\n\\tint closestMeetingNode(vector<int>& e, int n1, int n2) {\\n        auto bfs=[&](int src, vector<int> &dist,vector<int>& edge,int n){\\n            queue<int> q;\\n            q.push(src);\\n            dist[src]=0;\\n            while(q.size()>0){\\n                auto p= q.front(); q.pop();\\n                if(edge[p]!=-1 and dist[edge[p]]==INT_MAX){\\n                   q.push(edge[p]);  \\n                   dist[edge[p]]= dist[p]+1;\\n                }\\n            }\\n        };\\n        int n= e.size();\\n        vector<int> A(n,INT_MAX), B(n,INT_MAX);\\n        bfs(n1,A,e,n);   bfs(n2,B,e,n);\\n        int res= INT_MAX, node=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]==INT_MAX or B[i]==INT_MAX) continue;\\n            if(res>max(A[i],B[i])) node=i,res= max(A[i],B[i]);\\n        }\\n        return node;\\n    }\\n\\n# Java\\n   \\n    void bfs(int src, int[] dist,int[] edge,int n){\\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(src);\\n        dist[src]=0;\\n        while(q.size()>0){\\n            var p= q.remove();\\n            if(edge[p]!=-1 && dist[edge[p]]==Integer.MAX_VALUE){\\n                q.add(edge[p]);\\n                dist[edge[p]]= dist[p]+1;\\n            }\\n        }\\n    }\\n    \\n    public int closestMeetingNode(int[] e, int n1, int n2) {\\n        int n= e.length;\\n        int[] A= new int[n]; \\n        int[] B= new int[n];\\n        Arrays.fill(A,Integer.MAX_VALUE);\\n        Arrays.fill(B,Integer.MAX_VALUE);\\n        \\n        //call bfs\\n        bfs(n1,A,e,n);\\n        bfs(n2,B,e,n);\\n        \\n        //get node with minimum value of distance\\n        int res= Integer.MAX_VALUE, node=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]==Integer.MAX_VALUE || B[i]==Integer.MAX_VALUE) continue;\\n            if(res>Math.max(A[i],B[i])){\\n                node=i; \\n                res= Math.max(A[i],B[i]);\\n            }\\n        }\\n        return node;\\n    }\\n\\n**Pls Upvote If you Like**",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**SHORTEST PATH OF A NODE FROM MULTIPLE SOURCES Concept**\\n\\n1. Use `BFS` to compute distance from `node1 to every node` and from `node2 to every node` individually.\\n 2. Loop from `0 to n` nodes and return `the first node with smallest value of max(A[node],B[node])`   \\n\\n**The question also highlighted a line -> `Note that edges may contain cycles.`**\\nBut we should not care about it because our main goal is to get distance of all nodes from node1 and node2 which doesn\\'t need any detection of cycle. why??\\nBecause while computing distance from a single source we discard the visited node which prevents us  from getting stuck in a cycle.\\n\\n\\n**The question from which I learnt this concept**: \\n[2203. Minimum Weighted Subgraph With the Required Paths](https://leetcode.com/contest/weekly-contest-284/problems/minimum-weighted-subgraph-with-the-required-paths/)  \\nbut its a bit harder than this one.\\n\\nThe people who were not able to solve, pls don\\'t feel demotivated, this question had a concept of finding **SHORTEST PATH OF A NODE FROM MULTIPLE SOURCES**.\\nI encourage you to solve this problem first and understand the concept and apply the same in the above question link as this is question is a prerequisite of the above link question.\\nThis logic will also work if there are more than 2 sources nodes, we just need small changes in those cases.\\n\\n**Updation**: Thanks to **@jaylenzhang19**\\n> We can use just check if distance of any neighbour is still INT_MAX in BFS. This way we can eliminate the use of visited vector.\\n\\n![image](https://assets.leetcode.com/users/images/48966e27-a55a-4a74-9585-a65f579c18bd_1659253302.6357615.png)\\n\\n\\n\\t\\n`Time` - O(N)\\n`Space` - O(N)\\n\\t\\n# C++\\t\\n\\tint closestMeetingNode(vector<int>& e, int n1, int n2) {\\n        auto bfs=[&](int src, vector<int> &dist,vector<int>& edge,int n){\\n            queue<int> q;\\n            q.push(src);\\n            dist[src]=0;\\n            while(q.size()>0){\\n                auto p= q.front(); q.pop();\\n                if(edge[p]!=-1 and dist[edge[p]]==INT_MAX){\\n                   q.push(edge[p]);  \\n                   dist[edge[p]]= dist[p]+1;\\n                }\\n            }\\n        };\\n        int n= e.size();\\n        vector<int> A(n,INT_MAX), B(n,INT_MAX);\\n        bfs(n1,A,e,n);   bfs(n2,B,e,n);\\n        int res= INT_MAX, node=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]==INT_MAX or B[i]==INT_MAX) continue;\\n            if(res>max(A[i],B[i])) node=i,res= max(A[i],B[i]);\\n        }\\n        return node;\\n    }\\n\\n# Java\\n   \\n    void bfs(int src, int[] dist,int[] edge,int n){\\n        Queue<Integer> q= new LinkedList<>();\\n        q.add(src);\\n        dist[src]=0;\\n        while(q.size()>0){\\n            var p= q.remove();\\n            if(edge[p]!=-1 && dist[edge[p]]==Integer.MAX_VALUE){\\n                q.add(edge[p]);\\n                dist[edge[p]]= dist[p]+1;\\n            }\\n        }\\n    }\\n    \\n    public int closestMeetingNode(int[] e, int n1, int n2) {\\n        int n= e.length;\\n        int[] A= new int[n]; \\n        int[] B= new int[n];\\n        Arrays.fill(A,Integer.MAX_VALUE);\\n        Arrays.fill(B,Integer.MAX_VALUE);\\n        \\n        //call bfs\\n        bfs(n1,A,e,n);\\n        bfs(n2,B,e,n);\\n        \\n        //get node with minimum value of distance\\n        int res= Integer.MAX_VALUE, node=-1;\\n        for(int i=0;i<n;i++){\\n            if(A[i]==Integer.MAX_VALUE || B[i]==Integer.MAX_VALUE) continue;\\n            if(res>Math.max(A[i],B[i])){\\n                node=i; \\n                res= Math.max(A[i],B[i]);\\n            }\\n        }\\n        return node;\\n    }\\n\\n**Pls Upvote If you Like**",
                "codeTag": "Unknown"
            },
            {
                "id": 3095880,
                "title": "easy-solution-fully-explained-two-dfs-c-python3-commented",
                "content": "# Consider\\uD83D\\uDC4D\\n\\n   ```\\n                     Please Upvote If You Find It Helpful.\\n```\\n# Intuition\\nFirst we are checking the distance of each node from node1 and node2.\\nThen we are find that minimun and maxmimun distance of a node from node1 and node2 and return the index. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : Using DFS\\n<!-- Describe your approach to solving the problem. -->\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    // helper function to perform depth first search\\n    void dfs(int node, int dist, vector<int> edges, vector<int>& dis) {\\n        // iterate until we reach the end of the edge or a node that has already been visited\\n        while (node != -1 && dis[node] == -1) {\\n            dis[node] = dist++; // update distance of current node\\n            node = edges[node]; // move to next node\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int res = -1, min_dist = INT_MAX, n = edges.size();\\n        // create distance vectors for both nodes\\n        vector<int> dist1(n, -1), dist2(n, -1);\\n        // perform DFS starting from node1 and node2\\n        dfs(node1, 0, edges, dist1);\\n        dfs(node2, 0, edges, dist2);\\n\\n        // iterate through all nodes\\n        for (int i = 0; i < n; ++i) {\\n            // check if current node is the closest meeting point\\n            if (min(dist1[i], dist2[i]) >= 0 && max(dist1[i], dist2[i]) < min_dist) {\\n                min_dist = max(dist1[i], dist2[i]);\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def dfs(self, node, dist, edges, dis):\\n        \"\"\"\\n        Helper function to perform depth first search\\n        \"\"\"\\n        # iterate until we reach the end of the edge or a node that has already been visited\\n        while node != -1 and dis[node] == -1:\\n            dis[node] = dist\\n            dist += 1 # update distance of current node\\n            node = edges[node] # move to next node\\n\\n    def closestMeetingNode(self, edges, node1, node2):\\n        \"\"\"\\n        Function that returns the closest meeting point between two nodes\\n        \"\"\"\\n        res, min_dist, n = -1, float(\\'inf\\'), len(edges)\\n        # create distance vectors for both nodes\\n        dist1, dist2 = [-1]*n, [-1]*n\\n        # perform DFS starting from node1 and node2\\n        self.dfs(node1, 0, edges, dist1)\\n        self.dfs(node2, 0, edges, dist2)\\n\\n        # iterate through all nodes\\n        for i in range(n):\\n            # check if current node is the closest meeting point\\n            if min(dist1[i], dist2[i]) >= 0 and max(dist1[i], dist2[i]) < min_dist:\\n                min_dist = max(dist1[i], dist2[i])\\n                res = i\\n        return res\\n\\n```\\n```\\n                           Give a \\uD83D\\uDC4D. It motivates me alot.\\n```\\nLet\\'s Connect On [Linkedin](https://www.linkedin.com/in/naman-agarwal-0551aa1aa/)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\n                     Please Upvote If You Find It Helpful.\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    // helper function to perform depth first search\\n    void dfs(int node, int dist, vector<int> edges, vector<int>& dis) {\\n        // iterate until we reach the end of the edge or a node that has already been visited\\n        while (node != -1 && dis[node] == -1) {\\n            dis[node] = dist++; // update distance of current node\\n            node = edges[node]; // move to next node\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int res = -1, min_dist = INT_MAX, n = edges.size();\\n        // create distance vectors for both nodes\\n        vector<int> dist1(n, -1), dist2(n, -1);\\n        // perform DFS starting from node1 and node2\\n        dfs(node1, 0, edges, dist1);\\n        dfs(node2, 0, edges, dist2);\\n\\n        // iterate through all nodes\\n        for (int i = 0; i < n; ++i) {\\n            // check if current node is the closest meeting point\\n            if (min(dist1[i], dist2[i]) >= 0 && max(dist1[i], dist2[i]) < min_dist) {\\n                min_dist = max(dist1[i], dist2[i]);\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def dfs(self, node, dist, edges, dis):\\n        \"\"\"\\n        Helper function to perform depth first search\\n        \"\"\"\\n        # iterate until we reach the end of the edge or a node that has already been visited\\n        while node != -1 and dis[node] == -1:\\n            dis[node] = dist\\n            dist += 1 # update distance of current node\\n            node = edges[node] # move to next node\\n\\n    def closestMeetingNode(self, edges, node1, node2):\\n        \"\"\"\\n        Function that returns the closest meeting point between two nodes\\n        \"\"\"\\n        res, min_dist, n = -1, float(\\'inf\\'), len(edges)\\n        # create distance vectors for both nodes\\n        dist1, dist2 = [-1]*n, [-1]*n\\n        # perform DFS starting from node1 and node2\\n        self.dfs(node1, 0, edges, dist1)\\n        self.dfs(node2, 0, edges, dist2)\\n\\n        # iterate through all nodes\\n        for i in range(n):\\n            # check if current node is the closest meeting point\\n            if min(dist1[i], dist2[i]) >= 0 and max(dist1[i], dist2[i]) < min_dist:\\n                min_dist = max(dist1[i], dist2[i])\\n                res = i\\n        return res\\n\\n```\n```\\n                           Give a \\uD83D\\uDC4D. It motivates me alot.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096019,
                "title": "solution-using-bfs-c",
                "content": "# Code using BFS\\n``` C++ []\\nclass Solution {\\n    public:\\n        int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n            std::vector<int> dist1(edges.size(), -1);\\n        std::vector<int> dist2(edges.size(), -1);\\n\\n        // perform BFS from both nodes\\n        std::queue<int> q;\\n        q.push(node1);\\n        dist1[node1] = 0;\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            if (edges[u] != -1) {\\n                if (dist1[edges[u]] == -1) {\\n                    dist1[edges[u]] = dist1[u] + 1;\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }\\n        q.push(node2);\\n        dist2[node2] = 0;\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            if (edges[u] != -1) {\\n                if (dist2[edges[u]] == -1) {\\n                    dist2[edges[u]] = dist2[u] + 1;\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }\\n\\n        // find the node that can be reached from both nodes with the minimum maximum distance\\n        int minDist = INT_MAX;\\n        int minNode = -1;\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (dist1[i] != -1 && dist2[i] != -1) {\\n                int maxDist = std::max(dist1[i], dist2[i]);\\n                if (maxDist < minDist) {\\n                    minDist = maxDist;\\n                    minNode = i;\\n                }\\n            }\\n        }\\n\\n        return minNode;\\n    }\\n};\\n```\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/3830b6d5-453c-437a-abd6-985abdeba827_1674616069.1794453.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\n    public:\\n        int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n            std::vector<int> dist1(edges.size(), -1);\\n        std::vector<int> dist2(edges.size(), -1);\\n\\n        // perform BFS from both nodes\\n        std::queue<int> q;\\n        q.push(node1);\\n        dist1[node1] = 0;\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            if (edges[u] != -1) {\\n                if (dist1[edges[u]] == -1) {\\n                    dist1[edges[u]] = dist1[u] + 1;\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }\\n        q.push(node2);\\n        dist2[node2] = 0;\\n        while (!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            if (edges[u] != -1) {\\n                if (dist2[edges[u]] == -1) {\\n                    dist2[edges[u]] = dist2[u] + 1;\\n                    q.push(edges[u]);\\n                }\\n            }\\n        }\\n\\n        // find the node that can be reached from both nodes with the minimum maximum distance\\n        int minDist = INT_MAX;\\n        int minNode = -1;\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (dist1[i] != -1 && dist2[i] != -1) {\\n                int maxDist = std::max(dist1[i], dist2[i]);\\n                if (maxDist < minDist) {\\n                    minDist = maxDist;\\n                    minNode = i;\\n                }\\n            }\\n        }\\n\\n        return minNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357690,
                "title": "java-hashmap",
                "content": "**Code:**\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n\\n        HashMap<Integer, Integer> vis = new HashMap<>();\\n        for (int i=node1, d=0; i>=0 && !vis.containsKey(i); i=edges[i])\\n            vis.put(i, d++);\\n\\n        HashSet<Integer> vis2 = new HashSet<>();\\n        int res=-1, dist = 0, min=Integer.MAX_VALUE;\\n        \\n        for(int i=node2; i>=0 && !vis2.contains(i); i=edges[i]){\\n            if(vis.containsKey(i)){\\n                int curr = Math.max(dist, vis.get(i));\\n                if(res==-1 || curr<=min){\\n                    res = curr==min ? Math.min(res, i) : i;\\n                    min = curr;\\n                }\\n            }\\n            dist++; vis2.add(i);\\n        }\\n        return res;\\n    }\\n\\t\\n**Logic:**\\n* use dfs for node 1, and make a map for <node, distance>\\n* now use dfs for node 2, check if our map contains a value for that node\\n* if yes then check if the distance/index is minimum",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "**Code:**\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n\\n        HashMap<Integer, Integer> vis = new HashMap<>();\\n        for (int i=node1, d=0; i>=0 && !vis.containsKey(i); i=edges[i])\\n            vis.put(i, d++);\\n\\n        HashSet<Integer> vis2 = new HashSet<>();\\n        int res=-1, dist = 0, min=Integer.MAX_VALUE;\\n        \\n        for(int i=node2; i>=0 && !vis2.contains(i); i=edges[i]){\\n            if(vis.containsKey(i)){\\n                int curr = Math.max(dist, vis.get(i));\\n                if(res==-1 || curr<=min){\\n                    res = curr==min ? Math.min(res, i) : i;\\n                    min = curr;\\n                }\\n            }\\n            dist++; vis2.add(i);\\n        }\\n        return res;\\n    }\\n\\t\\n**Logic:**\\n* use dfs for node 1, and make a map for <node, distance>\\n* now use dfs for node 2, check if our map contains a value for that node\\n* if yes then check if the distance/index is minimum",
                "codeTag": "Unknown"
            },
            {
                "id": 2357662,
                "title": "cpp-bfs-three-solutions-with-explanation-o-n-time-o-n-space",
                "content": "**Intuition**:Store smallest distance from `node1` to all other nodes and smallest distance from `node2` to all other nodes in two arrays.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>> &graph,int node,vector<int> &dist){\\n        queue<int> q;\\n        q.push(node);\\n        int step=0;\\n        vector<bool> vis(graph.size());\\n        while(!q.empty()){\\n            int n=q.size();\\n            while(n--){\\n                int front=q.front();\\n                q.pop();\\n                dist[front]=step;\\n                vis[front]=true;\\n                for(int x:graph[front]){\\n                    if(!vis[x])q.push(x);\\n                }\\n            }\\n            step++;\\n        }\\n        \\n    }\\n    \\n    int closestMeetingNode(vector<int>& v, int node1, int node2) {\\n        int n=v.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<n;i++){\\n            if(v[i]==-1)continue;\\n            graph[i].push_back(v[i]);\\n        }\\n        vector<int> dist1(n,1e9),dist2(n,1e9);\\n        bfs(graph,node1,dist1);\\n        bfs(graph,node2,dist2);\\n        int dist=1e9,ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(max(dist1[i],dist2[i])<dist){\\n                dist=max(dist1[i],dist2[i]);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n**Optimization 1 :**\\n**Visualization** : See as there is at most 1 edge from any node so there will only be one path starting from any node.\\n`Example` : Assume `[2,2,3,-1]` \\n1. If we start from `node 0` we will go to `0->2` and then `2->3` and then we will terminate as there is no node connected to `node 3`.\\n2. So either we will be having a single path or we will have a termination point or we will be visiting the already visited node again.\\nSo we don\\'t need queue here as queue is required to handle multiple edges goind outwards from any node in order to give shortest path or optimal answer.\\n\\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void func(vector<vector<int>> &graph,int node,vector<int> &dist){\\n        int step=0;\\n        vector<bool> vis(graph.size());\\n        while(!graph[node].empty() && !vis[graph[node][0]]){\\n            dist[graph[node][0]]=++step;\\n            vis[graph[node][0]]=true;\\n            node=graph[node][0];\\n        }\\n        \\n    }\\n    int closestMeetingNode(vector<int>& v, int node1, int node2) {\\n        int n=v.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<n;i++){\\n            if(v[i]==-1)continue;\\n            graph[i].push_back(v[i]);\\n        }\\n        vector<int> dist1(n,1e9),dist2(n,1e9);\\n        func(graph,node1,dist1);\\n        func(graph,node2,dist2);\\n        int dist=1e9,ans=-1;\\n        dist1[node1]=0;\\n        dist2[node2]=0;\\n        for(int i=0;i<n;i++){\\n            if(max(dist1[i],dist2[i])<dist){\\n                dist=max(dist1[i],dist2[i]);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```\\n\\n**Optimization 2:**\\n\\nAs at most one path is there from any node so we don\\'t exactly need to build the graph.\\nLet\\'s understand this with an example.\\n`Example` Lets take `[2,2,3,-1]` and build adjacency list for this\\nwe will end up getting this `[0:[2],1:[2],2:[3],3:[]]` So we can represent this as `1-d array` as `[2,2,3,-1]` which is given in the argument of the function So we will be using this only.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void func(vector<int> &v,int node,vector<int> &dist){\\n        int step=0,n=v.size();\\n        vector<bool> vis(n);\\n        while(node!=-1 && !vis[node]){\\n            dist[node]=step++;\\n            vis[node]=true;\\n            node=v[node];\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& v, int node1, int node2) {\\n        int n=v.size();\\n        vector<int> dist1(n,1e9),dist2(n,1e9);\\n        func(v,node1,dist1);\\n        func(v,node2,dist2);\\n        int dist=1e9,ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(max(dist1[i],dist2[i])<dist){\\n                dist=max(dist1[i],dist2[i]);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void bfs(vector<vector<int>> &graph,int node,vector<int> &dist){\\n        queue<int> q;\\n        q.push(node);\\n        int step=0;\\n        vector<bool> vis(graph.size());\\n        while(!q.empty()){\\n            int n=q.size();\\n            while(n--){\\n                int front=q.front();\\n                q.pop();\\n                dist[front]=step;\\n                vis[front]=true;\\n                for(int x:graph[front]){\\n                    if(!vis[x])q.push(x);\\n                }\\n            }\\n            step++;\\n        }\\n        \\n    }\\n    \\n    int closestMeetingNode(vector<int>& v, int node1, int node2) {\\n        int n=v.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<n;i++){\\n            if(v[i]==-1)continue;\\n            graph[i].push_back(v[i]);\\n        }\\n        vector<int> dist1(n,1e9),dist2(n,1e9);\\n        bfs(graph,node1,dist1);\\n        bfs(graph,node2,dist2);\\n        int dist=1e9,ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(max(dist1[i],dist2[i])<dist){\\n                dist=max(dist1[i],dist2[i]);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\npublic:\\n    \\n    void func(vector<vector<int>> &graph,int node,vector<int> &dist){\\n        int step=0;\\n        vector<bool> vis(graph.size());\\n        while(!graph[node].empty() && !vis[graph[node][0]]){\\n            dist[graph[node][0]]=++step;\\n            vis[graph[node][0]]=true;\\n            node=graph[node][0];\\n        }\\n        \\n    }\\n    int closestMeetingNode(vector<int>& v, int node1, int node2) {\\n        int n=v.size();\\n        vector<vector<int>> graph(n);\\n        for(int i=0;i<n;i++){\\n            if(v[i]==-1)continue;\\n            graph[i].push_back(v[i]);\\n        }\\n        vector<int> dist1(n,1e9),dist2(n,1e9);\\n        func(graph,node1,dist1);\\n        func(graph,node2,dist2);\\n        int dist=1e9,ans=-1;\\n        dist1[node1]=0;\\n        dist2[node2]=0;\\n        for(int i=0;i<n;i++){\\n            if(max(dist1[i],dist2[i])<dist){\\n                dist=max(dist1[i],dist2[i]);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    void func(vector<int> &v,int node,vector<int> &dist){\\n        int step=0,n=v.size();\\n        vector<bool> vis(n);\\n        while(node!=-1 && !vis[node]){\\n            dist[node]=step++;\\n            vis[node]=true;\\n            node=v[node];\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& v, int node1, int node2) {\\n        int n=v.size();\\n        vector<int> dist1(n,1e9),dist2(n,1e9);\\n        func(v,node1,dist1);\\n        func(v,node2,dist2);\\n        int dist=1e9,ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(max(dist1[i],dist2[i])<dist){\\n                dist=max(dist1[i],dist2[i]);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357791,
                "title": "python-dfs-solution-easy-detailed-explanation",
                "content": "The main idea here is to find how many iterations it takes for us to reach a node from a starting node (i.e., in our cases, node1 and node2) if the end node is reachable. \\n\\nWe use simple DFS here to find if we reached the node already and assign the number of iterations (i.e., how many nodes away the end node is) to the corresponding array index. For example, if it takes 3 iterations to reach node at index 1 from node at index 0, then our arr[1] = 3 for start node (i.e., index 0) because it takes 3 moves to reach it. If we cannot reach a specific node, we keep the value of the corresponding element in the array as -1.\\n\\nWe do the same procedure for both starting points node1 and node2 and are left with arrays like this for example `[2, 2, 3, -1]` and `node1=0` and `node2=1`:\\n\\n`arr1 = [0, -1, 1, 2]` because we can reach node 0 from node 0 within 0 moves, node 2 within 1 move and node 3 within 2 moves, node 1 is not reachable. \\n\\n`arr2 = [-1, 0, 1, 2] `because we can reach node 1 from node 1 within 0 moves, node 2 within 1 move and node 3 within 2 moves, node 0 is not reachable. \\n\\nNow we need to check both of these to find the minimized maximum distance. To do that, we will compare the distance only if both distances are not -1 (i.e., reachable from both nodes). The process is straight forward from there because we just collect the maximum distance and minimize the result, as well as return the corresponding node. In this scenario it is node number 2 (with max distance 1).\\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        \\n        res = float(\"inf\")\\n        \\n        def dfs(node, arr, counter=0):\\n            \\n\\t\\t\\t#making sure we haven\\'t visited the node before (i.e., value in the array != -1)\\n            while arr[node]==-1 and node!=-1:\\n                \\n\\t\\t\\t\\t#assigning how many moves it takes to reach node \\n                arr[node] = counter\\n                next_node = edges[node]\\n\\t\\t\\t\\n\\t\\t\\t\\t#going through each neighbor if exists and updating the counter \\n                dfs(edges[node], arr, counter+1)\\n\\n            return arr\\n        \\n\\t\\t#find moves to reach nodes from node1\\n        n1 = [-1 for i in range(len(edges))]\\n        dfs(node1, n1)\\n\\t\\t\\n\\t\\t#find moves to reach nodes from node2\\n        n2 = [-1 for i in range(len(edges))]\\n        dfs(node2, n2)\\n                    \\n        answer = -1\\n        \\n        for i in range(len(edges)):\\n\\t\\t\\n\\t\\t\\t#check if the end node is reachable from both starting nodes\\n            if n1[i]!=-1 and n2[i]!=-1:\\n                maximum_distance = max(n1[i], n2[i])\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#update the distance and the final answer if relevant\\n                if maximum_distance<res:\\n                    res = maximum_distance\\n                    answer = i\\n                \\n        return answer\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        \\n        res = float(\"inf\")\\n        \\n        def dfs(node, arr, counter=0):\\n            \\n\\t\\t\\t#making sure we haven\\'t visited the node before (i.e., value in the array != -1)\\n            while arr[node]==-1 and node!=-1:\\n                \\n\\t\\t\\t\\t#assigning how many moves it takes to reach node \\n                arr[node] = counter\\n                next_node = edges[node]\\n\\t\\t\\t\\n\\t\\t\\t\\t#going through each neighbor if exists and updating the counter \\n                dfs(edges[node], arr, counter+1)\\n\\n            return arr\\n        \\n\\t\\t#find moves to reach nodes from node1\\n        n1 = [-1 for i in range(len(edges))]\\n        dfs(node1, n1)\\n\\t\\t\\n\\t\\t#find moves to reach nodes from node2\\n        n2 = [-1 for i in range(len(edges))]\\n        dfs(node2, n2)\\n                    \\n        answer = -1\\n        \\n        for i in range(len(edges)):\\n\\t\\t\\n\\t\\t\\t#check if the end node is reachable from both starting nodes\\n            if n1[i]!=-1 and n2[i]!=-1:\\n                maximum_distance = max(n1[i], n2[i])\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t#update the distance and the final answer if relevant\\n                if maximum_distance<res:\\n                    res = maximum_distance\\n                    answer = i\\n                \\n        return answer\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097917,
                "title": "short-c-explained-solution-beginner-friendly-by-mr-coder",
                "content": "\\n# Approach\\n**Watch this video(in Hindi) for the better explanation of the code.**\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution.\\n# If you find my solution helpful please upvote it.\\nhttps://t.me/dsacoder \\u2B05\\u2B05 Telegram link to discuss leetcode daily questions and other dsa problems\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n    int n= edges.size();\\n    vector<int> dist1(n, INT_MAX);\\n    vector<int> dist2(n, INT_MAX);\\n    vector<bool> visited(n, 0);\\n    int ans= INT_MAX;\\n    int index=-1;\\n    dfs(node1,dist1,edges,visited,0);\\n    visited.assign(n,0);\\n    dfs(node2,dist2,edges,visited,0);\\n    for(int i=0; i<n; i++){\\n       \\n       if(max(dist1[i],dist2[i])<ans)\\n        { ans= max(dist1[i],dist2[i]);\\n        index= i;}\\n    }\\n    return index;\\n    }\\n\\n    void dfs (int node, vector<int>&dist, vector<int>&edges, vector<bool>&visited, int distance){\\n\\n    if(  node!=-1 && !visited[node])\\n    {\\n        visited[node]=1;\\n        dist[node]= distance;\\n        dfs(edges[node],dist,edges,visited,distance+1);\\n\\n    }\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n    int n= edges.size();\\n    vector<int> dist1(n, INT_MAX);\\n    vector<int> dist2(n, INT_MAX);\\n    vector<bool> visited(n, 0);\\n    int ans= INT_MAX;\\n    int index=-1;\\n    dfs(node1,dist1,edges,visited,0);\\n    visited.assign(n,0);\\n    dfs(node2,dist2,edges,visited,0);\\n    for(int i=0; i<n; i++){\\n       \\n       if(max(dist1[i],dist2[i])<ans)\\n        { ans= max(dist1[i],dist2[i]);\\n        index= i;}\\n    }\\n    return index;\\n    }\\n\\n    void dfs (int node, vector<int>&dist, vector<int>&edges, vector<bool>&visited, int distance){\\n\\n    if(  node!=-1 && !visited[node])\\n    {\\n        visited[node]=1;\\n        dist[node]= distance;\\n        dfs(edges[node],dist,edges,visited,distance+1);\\n\\n    }\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357957,
                "title": "hashing-c-o-n-unordered-map",
                "content": "```\\npair<int, int> fun(vector<int>&edges, int node1, int node2){\\n        unordered_map<int, int > mp;\\n        int n=edges.size();\\n        vector<int> visi1(n+2, 0);\\n        vector<int> visi2(n+2, 0);\\n        mp[node1]=1;\\n        int len=0;\\n        while(edges[node1]!=-1 && visi1[node1]!=1){\\n            visi1[node1]=1;            \\n            node1=edges[node1];\\n            mp[node1]=len++;\\n        }\\n        pair<int , int> p1=make_pair(INT_MAX,-1);\\n        if(mp.find(node2)!=mp.end()){\\n             p1=make_pair(mp[node2], node2 );\\n            return p1;\\n        }\\n        while(edges[node2]!=-1 && visi2[node2]!=1){\\n            visi2[node2]=1;\\n            node2=edges[node2];\\n            if(mp.find(node2)!=mp.end()){\\n                p1=make_pair(mp[node2], node2 );\\n                return p1;\\n            }\\n        }\\n        return p1;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        pair<int ,int> p1=fun(edges, node1, node2);\\n        pair<int, int> p2=fun(edges, node2, node1);\\n        if(p1.second!=-1  && p1.first<p2.first)\\n            return p1.second;\\n        else if( p2.second!=-1 && p2.first<p1.first)\\n            return p2.second;\\n        else if(p1.first==p2.first){\\n            if(p1.second<p2.second)\\n                return p1.second;\\n            else\\n                return p2.second;\\n        }\\n        return -1;\\n    }\\n```\\nthe fun find the first common node with the distance, so i call the fun function two times one from node1 and second time with node2 as first node, so that we can cover all test can.\\nTest case1\\n[5,3,1,0,2,4,5]\\n3\\n2\\nTest Case 2\\n[2,0,0]\\n2\\n0\\nDry run on these case for better understanding!",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\npair<int, int> fun(vector<int>&edges, int node1, int node2){\\n        unordered_map<int, int > mp;\\n        int n=edges.size();\\n        vector<int> visi1(n+2, 0);\\n        vector<int> visi2(n+2, 0);\\n        mp[node1]=1;\\n        int len=0;\\n        while(edges[node1]!=-1 && visi1[node1]!=1){\\n            visi1[node1]=1;            \\n            node1=edges[node1];\\n            mp[node1]=len++;\\n        }\\n        pair<int , int> p1=make_pair(INT_MAX,-1);\\n        if(mp.find(node2)!=mp.end()){\\n             p1=make_pair(mp[node2], node2 );\\n            return p1;\\n        }\\n        while(edges[node2]!=-1 && visi2[node2]!=1){\\n            visi2[node2]=1;\\n            node2=edges[node2];\\n            if(mp.find(node2)!=mp.end()){\\n                p1=make_pair(mp[node2], node2 );\\n                return p1;\\n            }\\n        }\\n        return p1;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        pair<int ,int> p1=fun(edges, node1, node2);\\n        pair<int, int> p2=fun(edges, node2, node1);\\n        if(p1.second!=-1  && p1.first<p2.first)\\n            return p1.second;\\n        else if( p2.second!=-1 && p2.first<p1.first)\\n            return p2.second;\\n        else if(p1.first==p2.first){\\n            if(p1.second<p2.second)\\n                return p1.second;\\n            else\\n                return p2.second;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3096001,
                "title": "java-explained-in-detail-simple-fast-solution-dfs",
                "content": "I do my best everyday to give a clear explanation, so to help everyone improve their skills.\\n\\nIf you find this **helpful**, please \\uD83D\\uDC4D **upvote** this post and watch my [Github Repository](https://github.com/cheehwatang/leetcode-java).\\n\\nThank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.\\n\\n---\\n\\n\\n## Approach\\nTraverse the graph from \\'node1\\' and \\'node2\\' to get the distance of each connected node, respectively in separate integer array.\\n\\nThen, find and return the node that is with the minimum max distance from \\'node1\\' and \\'node2\\'.\\n\\n## Complexity\\n- Time complexity: O(n),\\nwhere \\'n\\' is the number of nodes in the graph.\\nWe traverse the graph from \\'node1\\' and \\'node2\\' once, with the worst-case of traversing the whole graph.\\nAdditionally, we check every node for their distance to \\'node1\\' and \\'node2\\'.\\n\\n- Space complexity: O(n),\\nwhere \\'n\\' is the number of nodes in the graph.\\nWe created two arrays of size \\'n\\' to record the distance of each node from \\'node1\\' and \\'node2\\' respectively.\\n\\n---\\n\\n## Java - With Explanation\\n```\\nclass Solution {\\n\\n    // Main method to find the closest meeting node for \\'node1\\' and \\'node2\\'.\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n\\n        // The function for the depth-first search to get the distance of each node from \\'node1\\' and \\'node2\\'\\n        // is extracted out for its reusability and better readability with named function.\\n        // Note: An alternative to Integer Array is to use HashMap.\\n        int[] distanceArray1 = getDistanceArray(edges, node1);\\n        int[] distanceArray2 = getDistanceArray(edges, node2);\\n\\n        // Minimum distance from the maximum distance between \\'node1\\' and \\'node2\\'\\n        // is set to Integer.MAX_VALUE as we are finding the minimum.\\n        int minDistance = Integer.MAX_VALUE;\\n\\n        // If \\'node1\\' and \\'node2\\' do not have the same connected nodes, the default value is returned, which is -1.\\n        // If any connected nodes are found, then result will not be -1.\\n        int result = -1;\\n\\n        // Once we have the distance array for both \\'node1\\' and \\'node2\\',\\n        // check each node to see if they have the same connected node.\\n        for (int i = 0; i < edges.length; i++) {\\n            // If the node is not connected to either or both \\'node1\\' and \\'node2\\', continue to the next node.\\n            if (distanceArray1[i] == -1 || distanceArray2[i] == -1) continue;\\n\\n            // Get the maximum distance of the connected both from \\'node1\\' and \\'node2\\'.\\n            // If the distance is less than the minimum distance found so far,\\n            // set the result to the current node and the minimum distance to the current distance.\\n            int distance = Math.max(distanceArray1[i], distanceArray2[i]);\\n            if (distance < minDistance) {\\n                result = i;\\n                minDistance = distance;\\n            }\\n        }\\n        // Return the index of the closest meeting node.\\n        // If there are no meeting node found, -1 is returned instead.\\n        return result;\\n    }\\n\\n    // Method to get the array for the distance of each node from the input node.\\n    // If the node is not connected to the input node, -1 is used.\\n    private int[] getDistanceArray(int[] edges, int node) {\\n        // Create a distance array with the values set to -1, indicating that the node is not visited.\\n        int[] distanceArray = new int[edges.length];\\n        Arrays.fill(distanceArray, -1);\\n\\n        // Traverse the graph from the input node, and record the distance from the node.\\n        // If the node already has a distance recorded (not -1),\\n        // it means that the node is visited and there is a cycle in the graph.\\n        // Thus, stop the traversal when a cycle is found or when we have reached the last node in the path.\\n        int distance = 0;\\n        while (node != -1 && distanceArray[node] == -1) {\\n            distanceArray[node] = distance++;\\n            node = edges[node];\\n        }\\n        // Return the distance array.\\n        return distanceArray;\\n    }\\n}\\n```\\n\\n## Java - Clean Code\\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int[] distanceArray1 = getDistanceArray(edges, node1);\\n        int[] distanceArray2 = getDistanceArray(edges, node2);\\n\\n        int minDistance = Integer.MAX_VALUE;\\n        int result = -1;\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (distanceArray1[i] == -1 || distanceArray2[i] == -1) continue;\\n\\n            int distance = Math.max(distanceArray1[i], distanceArray2[i]);\\n            if (distance < minDistance) {\\n                result = i;\\n                minDistance = distance;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int[] getDistanceArray(int[] edges, int node) {\\n        int[] distanceArray = new int[edges.length];\\n        Arrays.fill(distanceArray, -1);\\n\\n        int distance = 0;\\n        while (node != -1 && distanceArray[node] == -1) {\\n            distanceArray[node] = distance++;\\n            node = edges[node];\\n        }\\n        return distanceArray;\\n    }\\n}\\n```\\n\\n---",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\n    // Main method to find the closest meeting node for \\'node1\\' and \\'node2\\'.\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n\\n        // The function for the depth-first search to get the distance of each node from \\'node1\\' and \\'node2\\'\\n        // is extracted out for its reusability and better readability with named function.\\n        // Note: An alternative to Integer Array is to use HashMap.\\n        int[] distanceArray1 = getDistanceArray(edges, node1);\\n        int[] distanceArray2 = getDistanceArray(edges, node2);\\n\\n        // Minimum distance from the maximum distance between \\'node1\\' and \\'node2\\'\\n        // is set to Integer.MAX_VALUE as we are finding the minimum.\\n        int minDistance = Integer.MAX_VALUE;\\n\\n        // If \\'node1\\' and \\'node2\\' do not have the same connected nodes, the default value is returned, which is -1.\\n        // If any connected nodes are found, then result will not be -1.\\n        int result = -1;\\n\\n        // Once we have the distance array for both \\'node1\\' and \\'node2\\',\\n        // check each node to see if they have the same connected node.\\n        for (int i = 0; i < edges.length; i++) {\\n            // If the node is not connected to either or both \\'node1\\' and \\'node2\\', continue to the next node.\\n            if (distanceArray1[i] == -1 || distanceArray2[i] == -1) continue;\\n\\n            // Get the maximum distance of the connected both from \\'node1\\' and \\'node2\\'.\\n            // If the distance is less than the minimum distance found so far,\\n            // set the result to the current node and the minimum distance to the current distance.\\n            int distance = Math.max(distanceArray1[i], distanceArray2[i]);\\n            if (distance < minDistance) {\\n                result = i;\\n                minDistance = distance;\\n            }\\n        }\\n        // Return the index of the closest meeting node.\\n        // If there are no meeting node found, -1 is returned instead.\\n        return result;\\n    }\\n\\n    // Method to get the array for the distance of each node from the input node.\\n    // If the node is not connected to the input node, -1 is used.\\n    private int[] getDistanceArray(int[] edges, int node) {\\n        // Create a distance array with the values set to -1, indicating that the node is not visited.\\n        int[] distanceArray = new int[edges.length];\\n        Arrays.fill(distanceArray, -1);\\n\\n        // Traverse the graph from the input node, and record the distance from the node.\\n        // If the node already has a distance recorded (not -1),\\n        // it means that the node is visited and there is a cycle in the graph.\\n        // Thus, stop the traversal when a cycle is found or when we have reached the last node in the path.\\n        int distance = 0;\\n        while (node != -1 && distanceArray[node] == -1) {\\n            distanceArray[node] = distance++;\\n            node = edges[node];\\n        }\\n        // Return the distance array.\\n        return distanceArray;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int[] distanceArray1 = getDistanceArray(edges, node1);\\n        int[] distanceArray2 = getDistanceArray(edges, node2);\\n\\n        int minDistance = Integer.MAX_VALUE;\\n        int result = -1;\\n\\n        for (int i = 0; i < edges.length; i++) {\\n            if (distanceArray1[i] == -1 || distanceArray2[i] == -1) continue;\\n\\n            int distance = Math.max(distanceArray1[i], distanceArray2[i]);\\n            if (distance < minDistance) {\\n                result = i;\\n                minDistance = distance;\\n            }\\n        }\\n        return result;\\n    }\\n\\n    private int[] getDistanceArray(int[] edges, int node) {\\n        int[] distanceArray = new int[edges.length];\\n        Arrays.fill(distanceArray, -1);\\n\\n        int distance = 0;\\n        while (node != -1 && distanceArray[node] == -1) {\\n            distanceArray[node] = distance++;\\n            node = edges[node];\\n        }\\n        return distanceArray;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095974,
                "title": "leetcode-the-hard-way-explained-line-by-line-dfs-dijkstra",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord Study Group](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=ySmwUSc9nU4&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=25) if you are interested.\\n\\n**Approach 1: DFS**\\n\\nSince there is only at most 1 outgoing edge, we can simply use DFS.\\n\\n<iframe src=\"https://leetcode.com/playground/SPiUkFTy/shared\" frameBorder=\"0\" width=\"100%\" height=\"500\"></iframe>\\n\\n**Approach 2: Dijkstra**\\n\\nDijkstra approach in this question is not recommended but here\\'s how we do in case there are multiple outgoing edges.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    // https://leetcodethehardway.com/tutorials/graph-theory/dijkstra\\n    template<typename T_pair, typename T_vector>\\n    void dijkstra(T_pair &g, T_vector &dist, int start) {\\n      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n      dist[start] = 0;\\n      pq.push({start, 0});\\n      while (!pq.empty()) {\\n        auto [u_node, u_cost] = pq.top(); pq.pop();\\n        if (u_cost > dist[u_node]) continue;\\n        for (auto [v_node, v_cost] : g[u_node]) {\\n          if (dist[v_node] > dist[u_node] + v_cost) {\\n            dist[v_node] = dist[u_node] + v_cost;\\n            pq.push({v_node, dist[v_node]});\\n          }\\n        }\\n      }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        // d1[i]: shortest dist to node i starting from node 1\\n        // d2[i]: shortest dist to nodes i starting from node 2\\n        vector<int> d1(n, INT_MAX), d2(n, INT_MAX);\\n        // build the graph\\n        vector<vector<pair<int, int>>> g(n);\\n        // iterate each node\\n        for (int i = 0; i < n; i++) {\\n            // if there is outgoing edge from node i\\n            if (edges[i] != -1) {\\n                // by default, we define the dist to edges[i] is 1\\n                g[i].push_back({edges[i], 1});\\n            }\\n        }\\n        // build the dist for d1\\n        dijkstra(g, d1, node1);\\n        // build the dist for d2\\n        dijkstra(g, d2, node2);\\n        // iterate each node to find the min max dist\\n        int ans = -1, mi = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            if (max(d1[i], d2[i]) < mi) {\\n                mi = max(d1[i], d2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    // https://leetcodethehardway.com/tutorials/graph-theory/dijkstra\\n    template<typename T_pair, typename T_vector>\\n    void dijkstra(T_pair &g, T_vector &dist, int start) {\\n      priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n      dist[start] = 0;\\n      pq.push({start, 0});\\n      while (!pq.empty()) {\\n        auto [u_node, u_cost] = pq.top(); pq.pop();\\n        if (u_cost > dist[u_node]) continue;\\n        for (auto [v_node, v_cost] : g[u_node]) {\\n          if (dist[v_node] > dist[u_node] + v_cost) {\\n            dist[v_node] = dist[u_node] + v_cost;\\n            pq.push({v_node, dist[v_node]});\\n          }\\n        }\\n      }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        // d1[i]: shortest dist to node i starting from node 1\\n        // d2[i]: shortest dist to nodes i starting from node 2\\n        vector<int> d1(n, INT_MAX), d2(n, INT_MAX);\\n        // build the graph\\n        vector<vector<pair<int, int>>> g(n);\\n        // iterate each node\\n        for (int i = 0; i < n; i++) {\\n            // if there is outgoing edge from node i\\n            if (edges[i] != -1) {\\n                // by default, we define the dist to edges[i] is 1\\n                g[i].push_back({edges[i], 1});\\n            }\\n        }\\n        // build the dist for d1\\n        dijkstra(g, d1, node1);\\n        // build the dist for d2\\n        dijkstra(g, d2, node2);\\n        // iterate each node to find the min max dist\\n        int ans = -1, mi = INT_MAX;\\n        for (int i = 0; i < n; i++) {\\n            if (max(d1[i], d2[i]) < mi) {\\n                mi = max(d1[i], d2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095810,
                "title": "dfs-o-1-space-o-n-time-beats-100-time-and-mem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEach node can only have at most 1 outgoing edge to follow, so a straightforward DFS can be conducted without recursion.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nLoop until the closest node is found, or both paths end in a seperate loop or dead end. At each point, update the nodes to point to the next node in their path, and update the value of `edges[node]` to denote that this edge has been visited. If both nodes, at the same time, come across the other\\'s path, return the node with the smallest index. If only one comes across the other\\'s path, return its index. After the loop finishes executing, if both nodes end in the same place, return that nodes value. Otherwise, no meeting node exists, return `-1`.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(1)$, information about visited nodes is stored in-place.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        while (edges[node1] >= 0 || edges[node2] >= 0) {\\n            int temp;\\n            if (edges[node1] >= 0) {\\n                temp = node1;\\n                node1 = edges[node1];\\n                edges[temp] = -3;\\n            }\\n            if (edges[node2] >= 0) {\\n                temp = node2;\\n                node2 = edges[node2];\\n                edges[temp] = -2;\\n            }\\n            if (edges[node1] == -2 && edges[node2] == -3) return min(node1, node2);\\n            if (edges[node1] == -2) return node1;\\n            if (edges[node2] == -3) return node2;\\n        }\\n        return node1 == node2 ? node1 : -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        while (edges[node1] >= 0 || edges[node2] >= 0) {\\n            int temp;\\n            if (edges[node1] >= 0) {\\n                temp = node1;\\n                node1 = edges[node1];\\n                edges[temp] = -3;\\n            }\\n            if (edges[node2] >= 0) {\\n                temp = node2;\\n                node2 = edges[node2];\\n                edges[temp] = -2;\\n            }\\n            if (edges[node1] == -2 && edges[node2] == -3) return min(node1, node2);\\n            if (edges[node1] == -2) return node1;\\n            if (edges[node2] == -3) return node2;\\n        }\\n        return node1 == node2 ? node1 : -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095856,
                "title": "javascript-very-very-easy-to-understand-solution-with-video-explanation",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nhttps://youtu.be/LOSK0BBRifo\\n\\n# Code\\n```\\n/**\\n * @param {number[]} edges\\n * @param {number} node1\\n * @param {number} node2\\n * @return {number}\\n */\\nfunction closestMeetingNode (edges, node1, node2) {\\n    let map1 = {}\\n    let map2 = {}\\n    let count = 0;\\n\\n    while(map1[node1] == undefined && node1 != -1){\\n        map1[node1] = count;\\n        count++\\n        node1 = edges[node1];\\n    }\\n    count = 0;\\n    while(map2[node2] == undefined && node2 != -1){\\n        map2[node2] = count;\\n        count++\\n        node2 = edges[node2]\\n    }\\n    let max = Infinity;\\n    let res = -1;\\n\\n    for(let i =0; i<edges.length;i++){\\n        if(map1[i] == undefined || map2[i] == undefined) continue;\\n        let localMax = Math.max(map1[i],map2[i])\\n        if(localMax<max){\\n            max = localMax;\\n            res = i;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} edges\\n * @param {number} node1\\n * @param {number} node2\\n * @return {number}\\n */\\nfunction closestMeetingNode (edges, node1, node2) {\\n    let map1 = {}\\n    let map2 = {}\\n    let count = 0;\\n\\n    while(map1[node1] == undefined && node1 != -1){\\n        map1[node1] = count;\\n        count++\\n        node1 = edges[node1];\\n    }\\n    count = 0;\\n    while(map2[node2] == undefined && node2 != -1){\\n        map2[node2] = count;\\n        count++\\n        node2 = edges[node2]\\n    }\\n    let max = Infinity;\\n    let res = -1;\\n\\n    for(let i =0; i<edges.length;i++){\\n        if(map1[i] == undefined || map2[i] == undefined) continue;\\n        let localMax = Math.max(map1[i],map2[i])\\n        if(localMax<max){\\n            max = localMax;\\n            res = i;\\n        }\\n    }\\n\\n    return res;\\n}\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3096732,
                "title": "simple-c-using-bfs-dfs-dijkstra-s-algo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nClearly the intuition is to some how find the distances(shortest) from node 1 and node 2 to all other nodes and then compare the node distances from node1 and node2 where it can smaller and return that node.\\nSo first approach of finding shortest disatnce to all other nodes comes to our mind is bfs or dijkstra\\'s algo (mostly used algofor these kind of problems). So simply do bfs or dijkstra separately from node1 and node2 and store the distances in respective vectors and then comapare all the nodes form 0 to n-1 where max distance is minimum and return that node. This is compeletely the first approach of this problem then we can further find some shorter solutions as well but understanding is only this.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Approach 1 :** Use dijkstra algo as u do always  then just compare.\\n- **Approach 2 :** Use dfs directly since its not weighted so distance between two nodes can be direclty assigned as how far they are. So keep incrementing distance and assign distance to each node from  node1 and node 2 separately in two vectors and then compare . \\n- So the difference between the two approaches is nothing ,dfs will work only on this problem while dijkstra will work on any problem beacuse we don\\'t have a weighted graph here so we can apply dfs and make it simple.Understanding is same find all the shortest distances from node1 to all other nodes and from node2 to all other nodes then compare where max distance is mininium and return that node.\\n# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>dijkstra(vector<vector<pair<int,int>>>&adj,int node){\\n        int n=adj.size();\\n        vector<int>vis(n,false);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>>pq;\\n        pq.push({0,node});\\n        vector<int>dis(n,INT_MAX);\\n        dis[node]=0;\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int nd=pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[nd]){\\n                if(dis[it.first]>(it.second+dist)){\\n                    dis[it.first]=it.second+dist;\\n                    pq.push({it.second+dist,it.first});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<vector<pair<int,int>>>adj(n);\\n        for(int i=0;i<n;i++){\\n            if(edges[i]!=-1)\\n            adj[i].push_back({edges[i],1});\\n            \\n        }\\n        vector<int>dis1=dijkstra(adj,node1);\\n        vector<int>dis2=dijkstra(adj,node2);\\n        int ans=INT_MAX;\\n        int index=-1;\\n        for(int i=0;i<n;i++){\\n            if(max(dis1[i],dis2[i])<ans){\\n                ans=max(dis1[i],dis2[i]);\\n                index=i;\\n            }\\n        }\\n        return index;\\n       \\n    }\\n};\\n```\\n**Using DFS**\\n```\\n void dfs(vector<int>&e,int node,vector<int>&d,int dis){\\n        d[node]=dis;\\n        if(e[node]!=-1 and d[e[node]]==INT_MAX){\\n            dfs(e,e[node],d,dis+1);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        \\n        vector<int>dis1(n,INT_MAX),dis2(n,INT_MAX);\\n       dfs(edges,node1,dis1,0);\\n        dfs(edges,node2,dis2,0);\\n        int ans=INT_MAX;\\n        int index=-1;\\n        for(int i=0;i<n;i++){\\n            if(max(dis1[i],dis2[i])<ans){\\n                ans=max(dis1[i],dis2[i]);\\n                index=i;\\n            }\\n        }\\n        return index;\\n       \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>dijkstra(vector<vector<pair<int,int>>>&adj,int node){\\n        int n=adj.size();\\n        vector<int>vis(n,false);\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<>>pq;\\n        pq.push({0,node});\\n        vector<int>dis(n,INT_MAX);\\n        dis[node]=0;\\n        while(!pq.empty()){\\n            int dist=pq.top().first;\\n            int nd=pq.top().second;\\n            pq.pop();\\n            for(auto it:adj[nd]){\\n                if(dis[it.first]>(it.second+dist)){\\n                    dis[it.first]=it.second+dist;\\n                    pq.push({it.second+dist,it.first});\\n                }\\n            }\\n        }\\n        return dis;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<vector<pair<int,int>>>adj(n);\\n        for(int i=0;i<n;i++){\\n            if(edges[i]!=-1)\\n            adj[i].push_back({edges[i],1});\\n            \\n        }\\n        vector<int>dis1=dijkstra(adj,node1);\\n        vector<int>dis2=dijkstra(adj,node2);\\n        int ans=INT_MAX;\\n        int index=-1;\\n        for(int i=0;i<n;i++){\\n            if(max(dis1[i],dis2[i])<ans){\\n                ans=max(dis1[i],dis2[i]);\\n                index=i;\\n            }\\n        }\\n        return index;\\n       \\n    }\\n};\\n```\n```\\n void dfs(vector<int>&e,int node,vector<int>&d,int dis){\\n        d[node]=dis;\\n        if(e[node]!=-1 and d[e[node]]==INT_MAX){\\n            dfs(e,e[node],d,dis+1);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        \\n        vector<int>dis1(n,INT_MAX),dis2(n,INT_MAX);\\n       dfs(edges,node1,dis1,0);\\n        dfs(edges,node2,dis2,0);\\n        int ans=INT_MAX;\\n        int index=-1;\\n        for(int i=0;i<n;i++){\\n            if(max(dis1[i],dis2[i])<ans){\\n                ans=max(dis1[i],dis2[i]);\\n                index=i;\\n            }\\n        }\\n        return index;\\n       \\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096077,
                "title": "python3-traverse-from-both-nodes",
                "content": "Since there is atmost one outgoing edge with cycles, we can iterate this graph in simple manner as cdist function below. The logic briefly is as below. \\n1. Calculate distances between node1 and other reachable nodes. \\n2. Do the same as (1) for node 2\\n3. Iterate the nodes that are on the path for both distances and find max. \\n4. find min of maxes and keep track of minimum index. \\n\\nIf there was a constraint that node1 and node2 have a guarenteed path between them, the problem could have been simpler, to construct find the shortestPath between node1 -> node 2 and the ans is one of the nodes in between. Thats not the case ! \\n\\n```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```\\n\\nA slightly modified logic, \\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        N = len(edges)\\n        dist_node1 = [INF for _ in range(N)]\\n        dist_node2 = [INF for _ in range(N)]\\n        \\n        def dfs(node, di, d):\\n            if d[node] > di: \\n                d[node] = di\\n                if edges[node] != -1:\\n                    dfs(edges[node], di+1, d)\\n        \\n        dfs(node1, 0, dist_node1)\\n        dfs(node2, 0, dist_node2)\\n\\n        for i in range(N):\\n            dist_node1[i] = max(dist_node1[i], dist_node2[i])\\n                        \\n        ans = dist_node1.index(min(dist_node1))\\n        return ans if dist_node1[ans] != INF else -1\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def cdist(self, it, distArray, distArrayIndex, edges):\\n        rdist = 0 \\n        nodes = []\\n        while it != -1 and distArray[it][distArrayIndex] > rdist:\\n            distArray[it][distArrayIndex] = rdist\\n            nodes.append(it)\\n            it = edges[it]\\n            rdist += 1\\n        return nodes\\n            \\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        INF = float(\\'inf\\')\\n        dist = defaultdict(lambda: [INF,INF])\\n        mmin, ans = INF, INF\\n               \\n        n = self.cdist(node1, dist, 0, edges)\\n        n += self.cdist(node2, dist, 1, edges)\\n                \\n        for k in n:\\n            m = max(dist[k])\\n            if m != INF:\\n                if m < mmin: \\n                    mmin = m\\n                    ans = k\\n                elif m == mmin: \\n                    ans = min(ans, k)\\n                    \\n        return ans if ans != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360575,
                "title": "need-to-help-to-understand-the-following-test-case",
                "content": "```\\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\n```\\nFor above test case when moving from \\n```\\nNode 5 : 5 -> 8 -> 1 -> 4 -> 9 \\nNode 6 : 6 -> 4 -> 9 -> 1\\n```\\nHere, to reach `Node 1` net distance to be travelled = 2 + 3 = 5\\nwhere as \\nfor `Node 4` net distance to be travelled  = 3 + 1 = 4\\nSo the solution for this test case has to be `4` and not `1`\\nSomeone please correct me if I am in wrong direction.\\nThanks in advance.\\n\\n",
                "solutionTags": [],
                "code": "```\\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\n```\n```\\nNode 5 : 5 -> 8 -> 1 -> 4 -> 9 \\nNode 6 : 6 -> 4 -> 9 -> 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3096578,
                "title": "c-2-dfs-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> &dist, vector<int> &vis, vector<int> adj[])\\n    {\\n        vis[node] = 1;\\n        for (auto i : adj[node])\\n        {\\n            if (!vis[i])\\n            {\\n                dist[i] = 1 + dist[node];\\n                dfs(i, dist, vis, adj);\\n            }\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int> &edges, int node1, int node2)\\n    {\\n        int n = edges.size();\\n        vector<int> adj[n];\\n        for (int i = 0; i < n; i++)\\n            if (edges[i] != -1)\\n                adj[i].push_back(edges[i]);\\n\\n        vector<int> dist1(n, 1e9), dist2(n, 1e9);\\n        dist1[node1] = 0;\\n        dist2[node2] = 0;\\n\\n        vector<int> vis1(n);\\n        dfs(node1, dist1, vis1, adj);\\n\\n        vector<int> vis2(n);\\n        dfs(node2, dist2, vis2, adj);\\n\\n        int mn = 1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (dist1[i] == 1e9 or dist2[i] == 1e9)\\n                continue;\\n            mn = min(mn, max(dist1[i], dist2[i]));\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (dist1[i] == 1e9 or dist2[i] == 1e9)\\n                continue;\\n            if (max(dist1[i], dist2[i]) == mn)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int> &dist, vector<int> &vis, vector<int> adj[])\\n    {\\n        vis[node] = 1;\\n        for (auto i : adj[node])\\n        {\\n            if (!vis[i])\\n            {\\n                dist[i] = 1 + dist[node];\\n                dfs(i, dist, vis, adj);\\n            }\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int> &edges, int node1, int node2)\\n    {\\n        int n = edges.size();\\n        vector<int> adj[n];\\n        for (int i = 0; i < n; i++)\\n            if (edges[i] != -1)\\n                adj[i].push_back(edges[i]);\\n\\n        vector<int> dist1(n, 1e9), dist2(n, 1e9);\\n        dist1[node1] = 0;\\n        dist2[node2] = 0;\\n\\n        vector<int> vis1(n);\\n        dfs(node1, dist1, vis1, adj);\\n\\n        vector<int> vis2(n);\\n        dfs(node2, dist2, vis2, adj);\\n\\n        int mn = 1e9;\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (dist1[i] == 1e9 or dist2[i] == 1e9)\\n                continue;\\n            mn = min(mn, max(dist1[i], dist2[i]));\\n        }\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            if (dist1[i] == 1e9 or dist2[i] == 1e9)\\n                continue;\\n            if (max(dist1[i], dist2[i]) == mn)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096315,
                "title": "c-dfs-using-distance-comments-added",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int dis, vector<int>& e, vector<int>& dist) \\n    {\\n        if (i!=-1 && dist[i]==-1) \\n        {\\n            dist[i] = dis;\\n            dfs(e[i], dis + 1, e, dist);\\n        }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& e, int node1, int node2) \\n    {\\n        int res = -1, min_dist = INT_MAX;\\n        int n=e.size();\\n        \\n        vector<int> dist1(n,-1);   // distances from node1 to other nodes\\n        vector<int> dist2(n,-1);   // distances from node2 to other nodes\\n         \\n        dfs(node1, 0, e, dist1);\\n        dfs(node2, 0, e, dist2);\\n        \\n        for (int i = 0; i < n; ++i)\\n        {\\n            // if dist of min(dist1[i],dist2[i]) is -1 then do nothing\\n            if (min(dist1[i], dist2[i]) >= 0 && max(dist1[i], dist2[i]) < min_dist) \\n            {\\n                min_dist = max(dist1[i], dist2[i]);\\n                res = i;\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i, int dis, vector<int>& e, vector<int>& dist) \\n    {\\n        if (i!=-1 && dist[i]==-1) \\n        {\\n            dist[i] = dis;\\n            dfs(e[i], dis + 1, e, dist);\\n        }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& e, int node1, int node2) \\n    {\\n        int res = -1, min_dist = INT_MAX;\\n        int n=e.size();\\n        \\n        vector<int> dist1(n,-1);   // distances from node1 to other nodes\\n        vector<int> dist2(n,-1);   // distances from node2 to other nodes\\n         \\n        dfs(node1, 0, e, dist1);\\n        dfs(node2, 0, e, dist2);\\n        \\n        for (int i = 0; i < n; ++i)\\n        {\\n            // if dist of min(dist1[i],dist2[i]) is -1 then do nothing\\n            if (min(dist1[i], dist2[i]) >= 0 && max(dist1[i], dist2[i]) < min_dist) \\n            {\\n                min_dist = max(dist1[i], dist2[i]);\\n                res = i;\\n            }\\n        }\\n            \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358456,
                "title": "linear-solution-easy-and-beginner-friendly",
                "content": "First we find the distance of all node from node1 and node2\\nthen we have to find a common node which is reachable from both node1 and node2.\\n\\n```\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int>dist1(n,-1), dist2(n,-1);\\n        dist1[node1] = 0;      // Dist of all node from node1\\n        dist2[node2] = 0;      // Dist of all node from node2\\n        int dist = 0;\\n        int i = node1;\\n        while(1){\\n            dist1[i] = dist++;\\n            i = edges[i];\\n            if(i==-1 or dist1[i]!=-1)break;  // not visit to visited node\\n        }\\n        i = node2;\\n        dist = 0;\\n        while(1){\\n            dist2[i] = dist++;\\n            i = edges[i];\\n            if(i==-1 or dist2[i]!=-1)break;\\n        }\\n        \\n        int ans = -1;\\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            if(dist1[i]==-1 or dist2[i]==-1)continue; // filter the node which is not reachable\\n            if(mini > max(dist1[i], dist2[i])){  // minimizing the maximum distance\\n                mini = max(dist1[i], dist2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "First we find the distance of all node from node1 and node2\\nthen we have to find a common node which is reachable from both node1 and node2.\\n\\n```\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int>dist1(n,-1), dist2(n,-1);\\n        dist1[node1] = 0;      // Dist of all node from node1\\n        dist2[node2] = 0;      // Dist of all node from node2\\n        int dist = 0;\\n        int i = node1;\\n        while(1){\\n            dist1[i] = dist++;\\n            i = edges[i];\\n            if(i==-1 or dist1[i]!=-1)break;  // not visit to visited node\\n        }\\n        i = node2;\\n        dist = 0;\\n        while(1){\\n            dist2[i] = dist++;\\n            i = edges[i];\\n            if(i==-1 or dist2[i]!=-1)break;\\n        }\\n        \\n        int ans = -1;\\n        int mini = INT_MAX;\\n        for(int i = 0; i < n; i++){\\n            if(dist1[i]==-1 or dist2[i]==-1)continue; // filter the node which is not reachable\\n            if(mini > max(dist1[i], dist2[i])){  // minimizing the maximum distance\\n                mini = max(dist1[i], dist2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2357686,
                "title": "two-vectors-beats-100-c",
                "content": "1. Find distance of all node from node1 and store in a vector\\n2. Find distance of all node from node2 and store in a vector\\n3. Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n**Time Complexity : O(n)\\nSpace Complexity : O(n)**\\n\\n```\\n    \\n      vector<int> vec1(edges.size(),-1);\\n      vector<int> vec2(edges.size(),-1);\\n         vector<bool> visit(edges.size(),0);                 \\n        int cur = node1;\\n        int dist = 0;\\n       while(cur!=-1){ \\n           if(visit[cur])break;\\n          vec1[cur] = dist;\\n            visit[cur] = 1;\\n          dist++;\\n          cur = edges[cur];\\n       }\\n        \\n    for(int i=0;i<edges.size();i++)visit[i] = 0;\\n        \\n        \\n       cur = node2;\\n       dist = 0;\\n       while(cur!=-1){ \\n           if(visit[cur])break;\\n          vec2[cur] = dist;\\n           visit[cur] = 1;\\n          dist++;\\n          cur = edges[cur];\\n       }\\n    \\n        \\n        int x = INT_MAX;\\n        int in = -1;\\n        \\n        for(int i = 0;i<edges.size();i++){\\n           if(vec1[i]==-1 || vec2[i]==-1)continue;\\n           if(max(vec1[i],vec2[i])<x){\\n               in = i;\\n               x = max(vec1[i],vec2[i]);\\n           }  \\n        }\\n       \\n        return in;\\n        \\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    \\n      vector<int> vec1(edges.size(),-1);\\n      vector<int> vec2(edges.size(),-1);\\n         vector<bool> visit(edges.size(),0);                 \\n        int cur = node1;\\n        int dist = 0;\\n       while(cur!=-1){ \\n           if(visit[cur])break;\\n          vec1[cur] = dist;\\n            visit[cur] = 1;\\n          dist++;\\n          cur = edges[cur];\\n       }\\n        \\n    for(int i=0;i<edges.size();i++)visit[i] = 0;\\n        \\n        \\n       cur = node2;\\n       dist = 0;\\n       while(cur!=-1){ \\n           if(visit[cur])break;\\n          vec2[cur] = dist;\\n           visit[cur] = 1;\\n          dist++;\\n          cur = edges[cur];\\n       }\\n    \\n        \\n        int x = INT_MAX;\\n        int in = -1;\\n        \\n        for(int i = 0;i<edges.size();i++){\\n           if(vec1[i]==-1 || vec2[i]==-1)continue;\\n           if(max(vec1[i],vec2[i])<x){\\n               in = i;\\n               x = max(vec1[i],vec2[i]);\\n           }  \\n        }\\n       \\n        return in;\\n        \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3097185,
                "title": "c-2x-simple-bfs-fast-121ms-100",
                "content": "# Approach 1: 2x simple BFS\\n\\nGiven the problem constraints we can use a very simple BFS, as there is at most one outgoing edge.\\n\\n```\\n    static int closestMeetingNode(const vector<int>& edges, int node1, int node2) noexcept {\\n        const int n = size(edges);\\n        vector<int> dist1(n, numeric_limits<int>::max());\\n        bfs(edges, node1, dist1);\\n        vector<int> dist2(n, numeric_limits<int>::max());\\n        bfs(edges, node2, dist2);\\n        \\n        int ans = -1;\\n        int best = numeric_limits<int>::max();\\n        for (int i = 0; i < n; ++i) {\\n            const int curr = max(dist1[i], dist2[i]);\\n            if (curr < best) {\\n                ans = i;\\n                best = curr;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n    static void bfs(const vector<int>& edges, int node, vector<int>& dist) {\\n        int level = 0;\\n        while (true) {\\n            dist[node] = level;\\n            const int next = edges[node];\\n            if (next == -1 || dist[next] < level) break;\\n            \\n            node = next;\\n            ++level;\\n        }\\n    }\\n```\\n\\n# Variant 1: even shorter BFS\\n\\nIf we want to we could write the BFS as a one-liner, and being a one-liner we could even inline it. This is inspired by a solution form @tangj1905.\\n\\n```\\n    static void bfs(const vector<int>& edges, int node, vector<int>& dist) {\\n        for (int level = 0; node != -1 && level < dist[node]; node = edges[node]) dist[node] = level++;\\n    }\\n```\\n\\n**Complexity Analysis**\\nLet $$n$$ be the number of nodes in the graph then the\\n  * Time complexity is $$O(n)$$ because there is at most one outgoing edge, and we do 2 BFSs and 1 linear scan and the\\n  * Space complexity is $$O(n)$$ as we need to keep track of the distance from the 2 nodes.\\n\\n_As always: Feedback, questions, and comments are welcome. Leaving an up-vote sparks joy! :)_\\n\\n**p.s. Join us on the [LeetCode The Hard Way Discord Server](https://discord.gg/hFUyVyWy2E)!**\\n\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n    static int closestMeetingNode(const vector<int>& edges, int node1, int node2) noexcept {\\n        const int n = size(edges);\\n        vector<int> dist1(n, numeric_limits<int>::max());\\n        bfs(edges, node1, dist1);\\n        vector<int> dist2(n, numeric_limits<int>::max());\\n        bfs(edges, node2, dist2);\\n        \\n        int ans = -1;\\n        int best = numeric_limits<int>::max();\\n        for (int i = 0; i < n; ++i) {\\n            const int curr = max(dist1[i], dist2[i]);\\n            if (curr < best) {\\n                ans = i;\\n                best = curr;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t\\n    static void bfs(const vector<int>& edges, int node, vector<int>& dist) {\\n        int level = 0;\\n        while (true) {\\n            dist[node] = level;\\n            const int next = edges[node];\\n            if (next == -1 || dist[next] < level) break;\\n            \\n            node = next;\\n            ++level;\\n        }\\n    }\\n```\n```\\n    static void bfs(const vector<int>& edges, int node, vector<int>& dist) {\\n        for (int level = 0; node != -1 && level < dist[node]; node = edges[node]) dist[node] = level++;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095884,
                "title": "bfs-no-dijkstra-short-clean-well-commented-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<int> &edges, int src, map<int, int> &nodes_reachable){\\n        // queue of pair to store node and distance\\n        // Q[i].first - store the node \\n        // Q[i].second - store the distance of that node from starting node\\n        queue<pair<int, int>> Q;\\n        // distance of src from src will be zero\\n        Q.push({src, 0});\\n        // boolean array to keep track of the visited node\\n        vector<bool> vis(edges.size(), 0);\\n        vis[src] = 1;\\n        while(Q.size()){\\n            pair<int, int> fr = Q.front();\\n            Q.pop();\\n            nodes_reachable[fr.first] = fr.second;\\n            // since there can be maximum only one outgoing edge from any node, hence we don\\'t need to use any loop\\n            if(edges[fr.first] != -1 && !vis[edges[fr.first]]){\\n                vis[edges[fr.first]] = 1;\\n                Q.push({edges[fr.first], fr.second + 1});\\n            }\\n        }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        // map to store the minimum distance of the nodes reachable from node1\\n        // nodes_reachable_from1[a] = b means a is reachable from node1 and minimum distance to reach a from node1 is b\\n        // nodes_reachable_from2[a] = b means a is reachable from node2 and minimum distance to reach a from node2 is b\\n        \\n        map<int, int> nodes_reachable_from1; \\n        map<int, int> nodes_reachable_from2;\\n\\n        /*  \\n            Since weight of every edge is 1, We don\\'t need to think of dijktra algo to find the shortest \\n            distance from node1 to all other reachable nodes. Applying BFS will give us the shortest distance.\\n        */   \\n        bfs(edges, node1, nodes_reachable_from1);\\n        bfs(edges, node2, nodes_reachable_from2);\\n\\n        // ans store the minimum distance of the node reachable from both node1 and node2 \\n        int ans = numeric_limits<int>::max();\\n        \\n        //Index of the node reachable from both node1 and node2 having minimum distance\\n        int node_ind = -1;\\n        \\n        /* \\n            traverse all the nodes reachable from node1 and check if it is also reachable from node2. If reachable, \\n            update the ans if the maximum of {z1(distance of curr_node from node1), z2(distance of curr_node from node2)}\\n            is less than ans. Also update node_ind to curr_node.\\n        */\\n\\n        for(auto it : nodes_reachable_from1){\\n            // check if nodes reachable from 1 is also reachable from 2\\n            if(nodes_reachable_from2.find(it.first) != nodes_reachable_from2.end()){\\n                // update the minimum distance\\n                int z = min({ans, max({nodes_reachable_from2[it.first], it.second})});\\n                if(z < ans){\\n                    ans = z;\\n                    node_ind = it.first;\\n                }\\n            }\\n        }\\n        // return the node reachbale from both node1 and node2 and have minimum distance from both\\n        return node_ind;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<int> &edges, int src, map<int, int> &nodes_reachable){\\n        // queue of pair to store node and distance\\n        // Q[i].first - store the node \\n        // Q[i].second - store the distance of that node from starting node\\n        queue<pair<int, int>> Q;\\n        // distance of src from src will be zero\\n        Q.push({src, 0});\\n        // boolean array to keep track of the visited node\\n        vector<bool> vis(edges.size(), 0);\\n        vis[src] = 1;\\n        while(Q.size()){\\n            pair<int, int> fr = Q.front();\\n            Q.pop();\\n            nodes_reachable[fr.first] = fr.second;\\n            // since there can be maximum only one outgoing edge from any node, hence we don\\'t need to use any loop\\n            if(edges[fr.first] != -1 && !vis[edges[fr.first]]){\\n                vis[edges[fr.first]] = 1;\\n                Q.push({edges[fr.first], fr.second + 1});\\n            }\\n        }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        // map to store the minimum distance of the nodes reachable from node1\\n        // nodes_reachable_from1[a] = b means a is reachable from node1 and minimum distance to reach a from node1 is b\\n        // nodes_reachable_from2[a] = b means a is reachable from node2 and minimum distance to reach a from node2 is b\\n        \\n        map<int, int> nodes_reachable_from1; \\n        map<int, int> nodes_reachable_from2;\\n\\n        /*  \\n            Since weight of every edge is 1, We don\\'t need to think of dijktra algo to find the shortest \\n            distance from node1 to all other reachable nodes. Applying BFS will give us the shortest distance.\\n        */   \\n        bfs(edges, node1, nodes_reachable_from1);\\n        bfs(edges, node2, nodes_reachable_from2);\\n\\n        // ans store the minimum distance of the node reachable from both node1 and node2 \\n        int ans = numeric_limits<int>::max();\\n        \\n        //Index of the node reachable from both node1 and node2 having minimum distance\\n        int node_ind = -1;\\n        \\n        /* \\n            traverse all the nodes reachable from node1 and check if it is also reachable from node2. If reachable, \\n            update the ans if the maximum of {z1(distance of curr_node from node1), z2(distance of curr_node from node2)}\\n            is less than ans. Also update node_ind to curr_node.\\n        */\\n\\n        for(auto it : nodes_reachable_from1){\\n            // check if nodes reachable from 1 is also reachable from 2\\n            if(nodes_reachable_from2.find(it.first) != nodes_reachable_from2.end()){\\n                // update the minimum distance\\n                int z = min({ans, max({nodes_reachable_from2[it.first], it.second})});\\n                if(z < ans){\\n                    ans = z;\\n                    node_ind = it.first;\\n                }\\n            }\\n        }\\n        // return the node reachbale from both node1 and node2 and have minimum distance from both\\n        return node_ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2967516,
                "title": "double-bfs-c",
                "content": "# Approach\\nDirectly do bfs from node 1 and node 2 and find all the distances \\nthen simple take the maximum of those distances and whichever node you find the dist is maximum update that node as ans\\n\\n# Complexity\\n- Time complexity: 2 O(V + E)\\n\\n- Space complexity: O(V + E)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(int node , vector<int>& dist , vector<int>& vis , vector<int> adj[]){\\n        int d = 0;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int n = q.size();\\n            while(n > 0){\\n                int u = q.front();\\n                q.pop();\\n                vis[u] = 1;\\n                dist[u] = d;\\n                for(auto v : adj[u]){\\n                    if(!vis[v]){\\n                        q.push(v);\\n                    }\\n                }\\n                n--;\\n            }\\n            d++;\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> adj[n];\\n        for(int i = 0 ; i < n ; i++){\\n            if(edges[i] == -1) continue;\\n            adj[i].push_back(edges[i]);\\n        }\\n        vector<int> vis(n , 0) , vis2(n , 0) ,dist1(n , 1e9) , dist2(n , 1e9);\\n        bfs(node1 , dist1 , vis , adj);\\n        bfs(node2 , dist2 , vis2 , adj);\\n        int dist = 1e9 , ans = -1;\\n        for(int i = 0 ; i < n ; i++){\\n            if(max(dist1[i] , dist2[i]) < dist){\\n                dist = max(dist1[i] , dist2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(int node , vector<int>& dist , vector<int>& vis , vector<int> adj[]){\\n        int d = 0;\\n        queue<int> q;\\n        q.push(node);\\n        while(!q.empty()){\\n            int n = q.size();\\n            while(n > 0){\\n                int u = q.front();\\n                q.pop();\\n                vis[u] = 1;\\n                dist[u] = d;\\n                for(auto v : adj[u]){\\n                    if(!vis[v]){\\n                        q.push(v);\\n                    }\\n                }\\n                n--;\\n            }\\n            d++;\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> adj[n];\\n        for(int i = 0 ; i < n ; i++){\\n            if(edges[i] == -1) continue;\\n            adj[i].push_back(edges[i]);\\n        }\\n        vector<int> vis(n , 0) , vis2(n , 0) ,dist1(n , 1e9) , dist2(n , 1e9);\\n        bfs(node1 , dist1 , vis , adj);\\n        bfs(node2 , dist2 , vis2 , adj);\\n        int dist = 1e9 , ans = -1;\\n        for(int i = 0 ; i < n ; i++){\\n            if(max(dist1[i] , dist2[i]) < dist){\\n                dist = max(dist1[i] , dist2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433026,
                "title": "c-dfs-two-vectors",
                "content": "\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        // Create two distance vectors to save the distance of each node from node1 and node2\\n        // -1 represents unvisited node\\n        vector<int> v1(n,-1),v2(n,-1);\\n        // fill the distance vector for node1\\n        // cur represents the current element and d represent the distance travelled\\n        int cur= node1,d=0;\\n        while(1)\\n        {\\n            // if the current node doesnt have any linked node \\n            // or ve have already visited that node and updated the distance.\\n            if(cur==-1 || v1[cur]!=-1) break;\\n            // else assign the distance travelled to the current node and hop to the linked node\\n            v1[cur]=d++;\\n            cur= edges[cur];\\n        }\\n        // fill the distance vector for node1\\n        cur=node2,d=0;\\n        // we keep a track of all the nodes that we visited while traversing node2\\'s path and that came in node1\\'s path\\n        // we do this by checking if the distance vector of tha cur is already filled in v1\\n   \\n        int ans = -1, ansd=INT_MAX;\\n        while(1)\\n        {\\n            if(cur==-1 || v2[cur]!=-1) break;\\n            \\n            v2[cur]=d++;\\n            // if that node has already occured in node1\\'s path\\n            if(v1[cur]!=-1) \\n                if( max (v1[cur],v2[cur]) <= ansd)\\n                {\\n                    // check for the questions requirement\\n                    // the max of distance of both node 1 and node 2 to the common node \\n                    // must be minimized\\n                    // ansd represent max distance of (node1->cur, node2->cur)\\n                    if( max(v1[cur],v2[cur])==ansd) \\n                        ans= min(ans,cur);\\n                    else \\n                        ans=cur,ansd= max (v1[cur],v2[cur]);\\n                }\\n            cur=edges[cur];\\n        }\\n        \\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        // Create two distance vectors to save the distance of each node from node1 and node2\\n        // -1 represents unvisited node\\n        vector<int> v1(n,-1),v2(n,-1);\\n        // fill the distance vector for node1\\n        // cur represents the current element and d represent the distance travelled\\n        int cur= node1,d=0;\\n        while(1)\\n        {\\n            // if the current node doesnt have any linked node \\n            // or ve have already visited that node and updated the distance.\\n            if(cur==-1 || v1[cur]!=-1) break;\\n            // else assign the distance travelled to the current node and hop to the linked node\\n            v1[cur]=d++;\\n            cur= edges[cur];\\n        }\\n        // fill the distance vector for node1\\n        cur=node2,d=0;\\n        // we keep a track of all the nodes that we visited while traversing node2\\'s path and that came in node1\\'s path\\n        // we do this by checking if the distance vector of tha cur is already filled in v1\\n   \\n        int ans = -1, ansd=INT_MAX;\\n        while(1)\\n        {\\n            if(cur==-1 || v2[cur]!=-1) break;\\n            \\n            v2[cur]=d++;\\n            // if that node has already occured in node1\\'s path\\n            if(v1[cur]!=-1) \\n                if( max (v1[cur],v2[cur]) <= ansd)\\n                {\\n                    // check for the questions requirement\\n                    // the max of distance of both node 1 and node 2 to the common node \\n                    // must be minimized\\n                    // ansd represent max distance of (node1->cur, node2->cur)\\n                    if( max(v1[cur],v2[cur])==ansd) \\n                        ans= min(ans,cur);\\n                    else \\n                        ans=cur,ansd= max (v1[cur],v2[cur]);\\n                }\\n            cur=edges[cur];\\n        }\\n        \\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3098149,
                "title": "day-1-graph-dfs-easiest-beginner-friendly-sol-o-n-time-and-o-n-space",
                "content": "**INTUITION**\\nFirst we are checking the distance of each node from node1(n1) and node2(n2).\\nThen we are find that minimun and maxmimun distance of a node from node(n1) and node2(n2) and return the index.\\n\\n**CODE**\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& e,int n,vector<int>& v,int d,vector<bool>& vis){\\n        if(n==-1){\\n            return;\\n        }\\n        if(vis[n]==false){\\n            vis[n]=true;\\n            v[n]=min(v[n],d);\\n            dfs(e,e[n],v,d+1,vis);\\n            vis[n]=false;\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& e, int n1, int n2) {\\n        vector<int>v1(e.size(),INT_MAX),v2(e.size(),INT_MAX);\\n        vector<bool>vis1(e.size(),false),vis2(e.size(),false);\\n        dfs(e,n1,v1,0,vis1);\\n        dfs(e,n2,v2,0,vis2);\\n        int dis=INT_MAX,node=-1;\\n        for(int i=e.size()-1;i>=0;i--){\\n            if(v1[i]!=INT_MAX && v2[i]!=INT_MAX){\\n                if(max(v1[i],v2[i])<=dis){\\n                    dis=max(v1[i],v2[i]);\\n                    node=i;\\n                }\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```\\n\\n\\n**COMPLEXITY**\\n* Time complexity: O(n)  //where n is the number of nodes = e.size()\\n* Space complexity: O(n) //we are using visited, distance vectors (that are vis1, vis2, v1, v2) each of size n.\\n\\n\\n**IMPORTANT**\\n* If my solution is helpful to you then please UPVOTE my solution, your UPVOTE motivates me to post such kind of solution.\\n* Please let me know in comments if there is need to do any improvement in my approach, code, way of telling intuition and way of explaining.\\n```\\n:) HAPPY CODING\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int>& e,int n,vector<int>& v,int d,vector<bool>& vis){\\n        if(n==-1){\\n            return;\\n        }\\n        if(vis[n]==false){\\n            vis[n]=true;\\n            v[n]=min(v[n],d);\\n            dfs(e,e[n],v,d+1,vis);\\n            vis[n]=false;\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& e, int n1, int n2) {\\n        vector<int>v1(e.size(),INT_MAX),v2(e.size(),INT_MAX);\\n        vector<bool>vis1(e.size(),false),vis2(e.size(),false);\\n        dfs(e,n1,v1,0,vis1);\\n        dfs(e,n2,v2,0,vis2);\\n        int dis=INT_MAX,node=-1;\\n        for(int i=e.size()-1;i>=0;i--){\\n            if(v1[i]!=INT_MAX && v2[i]!=INT_MAX){\\n                if(max(v1[i],v2[i])<=dis){\\n                    dis=max(v1[i],v2[i]);\\n                    node=i;\\n                }\\n            }\\n        }\\n        return node;\\n    }\\n};\\n```\n```\\n:) HAPPY CODING\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096544,
                "title": "c-java-detailed-explanation",
                "content": "# Approach\\nWe can actually use DFS to store the distance of every node from node1 & node2 and then traverse on those distances and minimise the maximum distance.\\nBelow is the implementaion in C++ & JAVA.\\n\\n# Code Explanation\\n\\nWe initialize several data structures:\\n\\n1. ***distance_node1*** and ***distance_node2*** : vectors which store the distance of each node from node1 and node2, respectively.\\n2. ***visited*** is a boolean vector which keeps track of the nodes that have already been visited during the traversal.\\n3. ***adj*** is a vector of vectors used to store the *adjacency list* representation of the graph.\\n\\nThe adjacency list is constructed by looping through the \"edges\" vector. For each index i in \"edges\", the value of edges[i] is added to the adjacency list of i. If the value of edges[i] is -1, it is treated as a self-loop.\\n\\nAfter that, we perform a Depth First Search (DFS) on the graph starting from ***\"node1\"*** to find the distance of each node from ***\"node1\"***. The DFS sets the visited flag of each visited node to true and updates the corresponding entry in the ***\"distance_node1\"*** vector.\\n\\nThen the function performs another DFS starting from ***\"node2\"*** to find the distance of each node from ***\"node2\"*** in a similar way.\\n\\nFinally, the function loops through all the nodes and finds the node with the minimum maximum distance from ***\"node1\"*** and ***\"node2\"*** and returns the index of that node. This node is the closest meeting point between ***\"node1\"*** and ***\"node2\"***.\\n\\n# C++ Code\\n```\\nclass Solution {\\n    // Function for Depth First Search\\n    void dfs(int i, vector<bool>& visited, vector<vector<int>>& adj, vector<int>& distance_node1, int dist)\\n    {\\n        // Marking the node visited\\n        visited[i]=true;\\n        // Storing the distance \\n        distance_node1[i]=dist;\\n        // Checking the further nodes\\n        for (auto it: adj[i]) if (!visited[it]) dfs(it, visited, adj, distance_node1, dist+1);\\n    }\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        // Data structure to store Distance of nodes from node1 & node 2\\n        vector<int> distance_node1(edges.size(),1e6);\\n        vector<int> distance_node2(edges.size(),1e6);\\n        // Visited array to keep a traack of visited nodes\\n        vector<bool> visited(edges.size(),false);\\n        // Declaring Adjacency List\\n        vector<vector<int>> adj(edges.size());\\n\\n        // Filling Adjacency List\\n        for (int i=0;i<edges.size();i++)\\n        {\\n            // Treating -1 as self loop\\n            if (edges[i]==-1) adj[i].push_back(i);\\n            else adj[i].push_back(edges[i]);\\n        }\\n        // Calling dfs to fill the distance needed for each node\\n        dfs(node1, visited, adj, distance_node1, 0);\\n        // Reset the visited array after first dfs call\\n        for (int i=0;i<edges.size();i++) visited[i]=false;\\n        // Calling dfs to fill the distance needed for each node\\n        dfs(node2, visited, adj, distance_node2, 0);\\n\\n        int ans=1e6;\\n        // Keeping track of index\\n        int ind=-1;\\n        for (int i=0;i<edges.size();i++)\\n        {\\n            // Minimising the maximum distance of node from node1 & node2\\n            if (ans>max(distance_node1[i],distance_node2[i]))\\n            {\\n                ans=max(distance_node1[i],distance_node2[i]);\\n                ind=i;\\n            }\\n        }\\n        // Return the index\\n        return ind;\\n    }\\n};\\n```\\n# JAVA Code\\n```\\nclass Solution {\\n    // Function for Depth First Search\\n    void dfs(int i, boolean[] visited, ArrayList<ArrayList<Integer>> adj, int[] distance_node1, int dist)\\n    {\\n        // Marking the node visited\\n        visited[i]=true;\\n        // Storing the distance \\n        distance_node1[i]=dist;\\n        // Checking the further nodes\\n        for (int it: adj.get(i)) if (!visited[it]) dfs(it, visited, adj, distance_node1, dist+1);\\n    }\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        // Data structure to store Distance of nodes from node1 & node 2\\n        int[] distance_node1 = new int[edges.length];\\n        int[] distance_node2 = new int[edges.length];\\n        Arrays.fill(distance_node1, Integer.MAX_VALUE);\\n        Arrays.fill(distance_node2, Integer.MAX_VALUE);\\n        // Visited array to keep a traack of visited nodes\\n        boolean[] visited = new boolean[edges.length];\\n        // Declaring Adjacency List\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\\n        for (int i=0;i<edges.length;i++)\\n        {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n\\n        // Filling Adjacency List\\n        for (int i=0;i<edges.length;i++)\\n        {\\n            // Treating -1 as self loop\\n            if (edges[i]==-1) adj.get(i).add(i);\\n            else adj.get(i).add(edges[i]);\\n        }\\n        // Calling dfs to fill the distance needed for each node\\n        dfs(node1, visited, adj, distance_node1, 0);\\n        // Reset the visited array after first dfs call\\n        Arrays.fill(visited, false);\\n        // Calling dfs to fill the distance needed for each node\\n        dfs(node2, visited, adj, distance_node2, 0);\\n\\n        int ans=Integer.MAX_VALUE;\\n        // Keeping track of index\\n        int ind=-1;\\n        for (int i=0;i<edges.length;i++)\\n        {\\n            // Minimising the maximum distance of node from node1 & node2\\n            if (ans>Math.max(distance_node1[i],distance_node2[i]))\\n            {\\n                ans=Math.max(distance_node1[i],distance_node2[i]);\\n                ind=i;\\n            }\\n        }\\n        // Return the index\\n        return ind;\\n    }\\n}\\n```\\n# Complexity\\n- Time complexity:\\n***O(N+E)*** : \\nTwo DFS traversals are performed. In the worst case, all nodes in the graph will be visited, so the time complexity is O(N), where N is the number of nodes. Additionally, constructing the adjacency list takes O(E) time, where E is the number of edges. So, the overall time complexity is O(N+E).\\n\\n- Space complexity:\\n***O(N+E)*** :\\nThe adjacency list representation of the graph takes O(E) space, where E is the number of edges. Additionally, the \"visited\" vector, \"distance_node1\" and \"distance_node2\" vectors all take O(N) space, where N is the number of nodes. So, the overall space complexity is O(N+E).\\n\\n.\\n.\\n.\\n\\n*DO UPVOTE IF THIS HELPED :)*\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    // Function for Depth First Search\\n    void dfs(int i, vector<bool>& visited, vector<vector<int>>& adj, vector<int>& distance_node1, int dist)\\n    {\\n        // Marking the node visited\\n        visited[i]=true;\\n        // Storing the distance \\n        distance_node1[i]=dist;\\n        // Checking the further nodes\\n        for (auto it: adj[i]) if (!visited[it]) dfs(it, visited, adj, distance_node1, dist+1);\\n    }\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        // Data structure to store Distance of nodes from node1 & node 2\\n        vector<int> distance_node1(edges.size(),1e6);\\n        vector<int> distance_node2(edges.size(),1e6);\\n        // Visited array to keep a traack of visited nodes\\n        vector<bool> visited(edges.size(),false);\\n        // Declaring Adjacency List\\n        vector<vector<int>> adj(edges.size());\\n\\n        // Filling Adjacency List\\n        for (int i=0;i<edges.size();i++)\\n        {\\n            // Treating -1 as self loop\\n            if (edges[i]==-1) adj[i].push_back(i);\\n            else adj[i].push_back(edges[i]);\\n        }\\n        // Calling dfs to fill the distance needed for each node\\n        dfs(node1, visited, adj, distance_node1, 0);\\n        // Reset the visited array after first dfs call\\n        for (int i=0;i<edges.size();i++) visited[i]=false;\\n        // Calling dfs to fill the distance needed for each node\\n        dfs(node2, visited, adj, distance_node2, 0);\\n\\n        int ans=1e6;\\n        // Keeping track of index\\n        int ind=-1;\\n        for (int i=0;i<edges.size();i++)\\n        {\\n            // Minimising the maximum distance of node from node1 & node2\\n            if (ans>max(distance_node1[i],distance_node2[i]))\\n            {\\n                ans=max(distance_node1[i],distance_node2[i]);\\n                ind=i;\\n            }\\n        }\\n        // Return the index\\n        return ind;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    // Function for Depth First Search\\n    void dfs(int i, boolean[] visited, ArrayList<ArrayList<Integer>> adj, int[] distance_node1, int dist)\\n    {\\n        // Marking the node visited\\n        visited[i]=true;\\n        // Storing the distance \\n        distance_node1[i]=dist;\\n        // Checking the further nodes\\n        for (int it: adj.get(i)) if (!visited[it]) dfs(it, visited, adj, distance_node1, dist+1);\\n    }\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        // Data structure to store Distance of nodes from node1 & node 2\\n        int[] distance_node1 = new int[edges.length];\\n        int[] distance_node2 = new int[edges.length];\\n        Arrays.fill(distance_node1, Integer.MAX_VALUE);\\n        Arrays.fill(distance_node2, Integer.MAX_VALUE);\\n        // Visited array to keep a traack of visited nodes\\n        boolean[] visited = new boolean[edges.length];\\n        // Declaring Adjacency List\\n        ArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\\n        for (int i=0;i<edges.length;i++)\\n        {\\n            adj.add(new ArrayList<Integer>());\\n        }\\n\\n        // Filling Adjacency List\\n        for (int i=0;i<edges.length;i++)\\n        {\\n            // Treating -1 as self loop\\n            if (edges[i]==-1) adj.get(i).add(i);\\n            else adj.get(i).add(edges[i]);\\n        }\\n        // Calling dfs to fill the distance needed for each node\\n        dfs(node1, visited, adj, distance_node1, 0);\\n        // Reset the visited array after first dfs call\\n        Arrays.fill(visited, false);\\n        // Calling dfs to fill the distance needed for each node\\n        dfs(node2, visited, adj, distance_node2, 0);\\n\\n        int ans=Integer.MAX_VALUE;\\n        // Keeping track of index\\n        int ind=-1;\\n        for (int i=0;i<edges.length;i++)\\n        {\\n            // Minimising the maximum distance of node from node1 & node2\\n            if (ans>Math.max(distance_node1[i],distance_node2[i]))\\n            {\\n                ans=Math.max(distance_node1[i],distance_node2[i]);\\n                ind=i;\\n            }\\n        }\\n        // Return the index\\n        return ind;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096528,
                "title": "beats-100-easy-explanation-only-arrays",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![Screenshot 2023-01-25 at 11.24.59 AM.png](https://assets.leetcode.com/users/images/9c2524a1-d297-4864-b51c-98ae4c8564de_1674626111.0984154.png)\\nThe given array indicates the next index we can travel from this given index, if its -1 we can\\'t travel further.\\n\\n![Screenshot 2023-01-25 at 11.26.17 AM.png](https://assets.leetcode.com/users/images/807f779b-f6a4-4164-a569-49fd112d30f1_1674626192.8400652.png)\\n\\nThe idea is to compute the distnce of each index from given node and store in an array for example the above example [0 -1 1 3 -1 2 -1 4] indicates that from 0th node to 3rd node distance is 3 and -1 indicates this node cannot be visited.\\n\\nThe above process is done for both Node 1 and node 2. We now have 2 arrays indicating the distance to that index from n1 and n2, for example to 3rd node, n1 takes 3 while n2 takes 2, if one of them is -1, we cannot travel to that node. \\n\\nJust visit each index and compute the max, if this max is lesser than ans. ans = max;\\n\\nOption 2: while computing the distance for 2nd Node, we already have distance from node 1, so do the above calculation here.\\n![Screenshot 2023-01-25 at 10.52.09 AM.png]\\n\\nhttps://youtu.be/ziZnI00lJO4\\n\\n![upvote.webp](https://assets.leetcode.com/users/images/bcf22307-76b0-42c2-8bbb-1c2f10d2dc7d_1674626589.4819107.webp)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int [] arr1 = new int[n];\\n        int [] arr2 = new int[n];\\n        int curr = node1;\\n        int dist = 0;\\n        Arrays.fill(arr1, -1);\\n        Arrays.fill(arr2, -1);\\n        while(curr!=-1 && arr1[curr]==-1){\\n            arr1[curr] = dist;\\n            curr = edges[curr];\\n            dist++;    \\n        }\\n        dist = 0;\\n        curr = node2;\\n        int min = Integer.MAX_VALUE/10;\\n        int result = -1;\\n        int max;\\n        while(curr!=-1 && arr2[curr]==-1){\\n            arr2[curr] = dist;\\n            if(arr1[curr]!=-1){\\n                 max = Math.max(arr1[curr], arr2[curr]);\\n                 if(max<min){\\n                    result = curr;\\n                    min = max;\\n                }else if(max == min){\\n                    if(result>curr) result = curr;\\n                }\\n            }\\n            curr = edges[curr];\\n            dist++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int [] arr1 = new int[n];\\n        int [] arr2 = new int[n];\\n        int curr = node1;\\n        int dist = 0;\\n        Arrays.fill(arr1, -1);\\n        Arrays.fill(arr2, -1);\\n        while(curr!=-1 && arr1[curr]==-1){\\n            arr1[curr] = dist;\\n            curr = edges[curr];\\n            dist++;    \\n        }\\n        dist = 0;\\n        curr = node2;\\n        int min = Integer.MAX_VALUE/10;\\n        int result = -1;\\n        int max;\\n        while(curr!=-1 && arr2[curr]==-1){\\n            arr2[curr] = dist;\\n            if(arr1[curr]!=-1){\\n                 max = Math.max(arr1[curr], arr2[curr]);\\n                 if(max<min){\\n                    result = curr;\\n                    min = max;\\n                }else if(max == min){\\n                    if(result>curr) result = curr;\\n                }\\n            }\\n            curr = edges[curr];\\n            dist++;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3041864,
                "title": "one-bfs-for-both-node-100-faster-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/7346562d-29ab-494f-8d4c-b40842d346ab_1673545216.9641058.png)\\n**If you like the solution , Upvote me :)**\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        curr = [(node1,1),(node2,2)] #assuming both nodes are in curr\\n        visited = [0]*len(edges)\\n        ans = inf\\n        while curr:  # level wise BFS\\n            new = []\\n            f = False\\n            for a,w in curr:\\n                if visited[a]==0:\\n                    if edges[a]!=-1:\\n                        new.append((edges[a],w))\\n                    visited[a] = w\\n                elif visited[a]!=w: # we find our answer in this condition.no need to run while loop again\\n                    f = True\\n                    ans = min(a,ans)        \\n            if f:\\n                return ans       \\n            curr = new # assign next level array-> new to curr\\n        return -1\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/7346562d-29ab-494f-8d4c-b40842d346ab_1673545216.9641058.png)\\n**If you like the solution , Upvote me :)**\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        curr = [(node1,1),(node2,2)] #assuming both nodes are in curr\\n        visited = [0]*len(edges)\\n        ans = inf\\n        while curr:  # level wise BFS\\n            new = []\\n            f = False\\n            for a,w in curr:\\n                if visited[a]==0:\\n                    if edges[a]!=-1:\\n                        new.append((edges[a],w))\\n                    visited[a] = w\\n                elif visited[a]!=w: # we find our answer in this condition.no need to run while loop again\\n                    f = True\\n                    ans = min(a,ans)        \\n            if f:\\n                return ans       \\n            curr = new # assign next level array-> new to curr\\n        return -1\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 2695169,
                "title": "python-3-11-lines-dfs-t-m-90-98",
                "content": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], n1: int, n2: int) -> int:\\n\\n        def dfs(node):\\n\\t\\t\\n            dist, res = 0, [-1]*len(edges)\\n            \\n            while node != -1 and res[node] == -1:\\n                res[node], node = dist, edges[node]\\n                dist += 1\\n                \\n            return res\\n\\n    \\n        ans = (inf,-1)\\n        \\n        for i, (d1,d2) in enumerate(zip(dfs(n1),dfs(n2))):\\n\\t\\t\\n            if d1 == -1 or d2 == -1: continue\\n            ans = min(ans,(max(d1, d2),i))\\n                \\n        return ans[1]\\n```\\n[https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/884692793/](http://)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], n1: int, n2: int) -> int:\\n\\n        def dfs(node):\\n\\t\\t\\n            dist, res = 0, [-1]*len(edges)\\n            \\n            while node != -1 and res[node] == -1:\\n                res[node], node = dist, edges[node]\\n                dist += 1\\n                \\n            return res\\n\\n    \\n        ans = (inf,-1)\\n        \\n        for i, (d1,d2) in enumerate(zip(dfs(n1),dfs(n2))):\\n\\t\\t\\n            if d1 == -1 or d2 == -1: continue\\n            ans = min(ans,(max(d1, d2),i))\\n                \\n        return ans[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360018,
                "title": "python-double-bfs",
                "content": "We will perform a double BFS from both nodes, `node1` and `node2`.\\n\\nWe will add the nodes we visit from node1 bfs to `n1_vis` and the other way for the second bfs.\\n\\nWhenever there is a mutual node from both BFS\\'s, we found the shortest path to a mutual node.\\n\\n**Caveat**: since there could be multiple nodes, we must return the node with the smallest index.\\n\\nFor this reason, we save the path length to the nodes we visit, and if we encounter the same path length, we save the smaller node between the two.\\n\\nCode is a little bit long (competition reasons...)\\n\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        if node1 == node2: return node1\\n        \\n        n1_q, n2_q = deque([(node1, 0)]), deque([(node2, 0)])\\n        n1_vis, n2_vis = {}, {} # node and length\\n        \\n        n1_vis[node1] = 0\\n        n2_vis[node2] = 0\\n        \\n        res_node = float(\\'inf\\')\\n        res_length = float(\\'inf\\')\\n        \\n        \\n        while n1_q or n2_q:\\n            if n1_q:\\n                node, dis = n1_q.popleft()\\n                neighbor = edges[node]\\n                if neighbor in n1_vis: continue\\n                if neighbor == -1: continue\\n                    \\n                if neighbor in n2_vis:\\n                    dis = max(dis + 1, n2_vis[neighbor])\\n                    if dis < res_length:\\n                        res_node = neighbor\\n                        res_length = dis\\n                    elif dis == res_length:\\n                        res_node = min(res_node, neighbor)\\n                    \\n                \\n                n1_vis[neighbor] = dis + 1\\n                n1_q.append((neighbor, dis + 1))\\n                \\n            if n2_q:\\n                node, dis = n2_q.popleft()\\n                neighbor = edges[node]\\n                if neighbor in n2_vis: continue\\n                if neighbor == -1: continue\\n                    \\n                if neighbor in n1_vis:\\n                    dis = max(dis + 1, n1_vis[neighbor])\\n                    if dis < res_length:\\n                        res_node = neighbor\\n                        res_length = dis\\n                    elif dis == res_length:\\n                        res_node = min(res_node, neighbor)\\n                    \\n                \\n                n2_vis[neighbor] = dis + 1\\n                n2_q.append((neighbor, dis + 1))\\n                \\n            \\n        return res_node if res_node != float(\\'inf\\') else -1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        if node1 == node2: return node1\\n        \\n        n1_q, n2_q = deque([(node1, 0)]), deque([(node2, 0)])\\n        n1_vis, n2_vis = {}, {} # node and length\\n        \\n        n1_vis[node1] = 0\\n        n2_vis[node2] = 0\\n        \\n        res_node = float(\\'inf\\')\\n        res_length = float(\\'inf\\')\\n        \\n        \\n        while n1_q or n2_q:\\n            if n1_q:\\n                node, dis = n1_q.popleft()\\n                neighbor = edges[node]\\n                if neighbor in n1_vis: continue\\n                if neighbor == -1: continue\\n                    \\n                if neighbor in n2_vis:\\n                    dis = max(dis + 1, n2_vis[neighbor])\\n                    if dis < res_length:\\n                        res_node = neighbor\\n                        res_length = dis\\n                    elif dis == res_length:\\n                        res_node = min(res_node, neighbor)\\n                    \\n                \\n                n1_vis[neighbor] = dis + 1\\n                n1_q.append((neighbor, dis + 1))\\n                \\n            if n2_q:\\n                node, dis = n2_q.popleft()\\n                neighbor = edges[node]\\n                if neighbor in n2_vis: continue\\n                if neighbor == -1: continue\\n                    \\n                if neighbor in n1_vis:\\n                    dis = max(dis + 1, n1_vis[neighbor])\\n                    if dis < res_length:\\n                        res_node = neighbor\\n                        res_length = dis\\n                    elif dis == res_length:\\n                        res_node = min(res_node, neighbor)\\n                    \\n                \\n                n2_vis[neighbor] = dis + 1\\n                n2_q.append((neighbor, dis + 1))\\n                \\n            \\n        return res_node if res_node != float(\\'inf\\') else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358432,
                "title": "c-single-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int> adj[edges.size()];\\n        for(int i = 0; i < edges.size(); i++) {\\n            if(edges[i] != -1)\\n            adj[i].push_back(edges[i]);\\n        }\\n        queue<vector<int>> q;\\n        q.push({node1, 0});\\n        q.push({node2, 1});\\n        vector<vector<bool>> vis(edges.size(), vector<bool>(2, false));\\n        int ans = INT_MAX;\\n        bool flag= false;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int num = q.front()[0];\\n                int idx = q.front()[1];\\n                q.pop();\\n                vis[num][idx] = true;\\n                if(vis[num][1 - idx]) {\\n                    ans = min(ans, num);\\n                    flag = true;\\n                }\\n                for(auto x: adj[num]) {\\n                    if(!vis[x][idx])\\n                    q.push({x, idx});\\n                }\\n            }\\n            if(flag) break;\\n        }\\n        if(ans == INT_MAX) return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int> adj[edges.size()];\\n        for(int i = 0; i < edges.size(); i++) {\\n            if(edges[i] != -1)\\n            adj[i].push_back(edges[i]);\\n        }\\n        queue<vector<int>> q;\\n        q.push({node1, 0});\\n        q.push({node2, 1});\\n        vector<vector<bool>> vis(edges.size(), vector<bool>(2, false));\\n        int ans = INT_MAX;\\n        bool flag= false;\\n        while(!q.empty()) {\\n            int sz = q.size();\\n            while(sz--) {\\n                int num = q.front()[0];\\n                int idx = q.front()[1];\\n                q.pop();\\n                vis[num][idx] = true;\\n                if(vis[num][1 - idx]) {\\n                    ans = min(ans, num);\\n                    flag = true;\\n                }\\n                for(auto x: adj[num]) {\\n                    if(!vis[x][idx])\\n                    q.push({x, idx});\\n                }\\n            }\\n            if(flag) break;\\n        }\\n        if(ans == INT_MAX) return -1;\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357733,
                "title": "c-bfs",
                "content": "**Intuition**\\nWe could run 2 bfs to find the nodes accessible from `node1` and `node2` and the distances. Then, we enumerate nodes and find the min max distance. \\n\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size(); \\n        \\n        auto bfs = [&](int u, int k = 0) {\\n            vector<int> dist(n, INT_MAX); \\n            for (; u != -1 && dist[u] == INT_MAX; u = edges[u]) \\n                dist[u] = k++; \\n            return dist; \\n        }; \\n        \\n        vector<int> d1 = bfs(node1), d2 = bfs(node2); \\n        int ans = -1, m = INT_MAX; \\n        for (int i = 0; i < n; ++i) \\n            if (max(d1[i], d2[i]) < m) {\\n                ans = i; \\n                m = max(d1[i], d2[i]); \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size(); \\n        \\n        auto bfs = [&](int u, int k = 0) {\\n            vector<int> dist(n, INT_MAX); \\n            for (; u != -1 && dist[u] == INT_MAX; u = edges[u]) \\n                dist[u] = k++; \\n            return dist; \\n        }; \\n        \\n        vector<int> d1 = bfs(node1), d2 = bfs(node2); \\n        int ans = -1, m = INT_MAX; \\n        for (int i = 0; i < n; ++i) \\n            if (max(d1[i], d2[i]) < m) {\\n                ans = i; \\n                m = max(d1[i], d2[i]); \\n            }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357670,
                "title": "very-easy-bfs-c-code",
                "content": "We apply bfs on both the nodes to get the shortest distance to all nodes in a vector and then we compare both the vectors\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<long long> temp1 = bfs(node1,edges);\\n        vector<long long> temp2 = bfs(node2,edges);\\n        long long res = INT_MAX;\\n        long long ans = -1;\\n        for(int i = 0;i < n;i++){\\n            if(temp1[i] == -1 or temp2[i] == -1){\\n                continue;\\n            }\\n            if(max(temp1[i],temp2[i]) < res){\\n                res = min(max(temp1[i],temp2[i]),res);\\n                ans = i;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    vector<long long> bfs(int sv,vector<int> &adj){\\n        int n = adj.size();\\n        queue<long long>q{};\\n        q.push(sv);\\n        vector<long long> dist(n,-1);\\n        vector<bool> vis(n,false);\\n        vis[sv] = true;\\n        long long r = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                long long node = q.front();\\n                q.pop();\\n                dist[node] = r;\\n                if(adj[node] != -1 and !vis[adj[node]]){\\n                    q.push(adj[node]);\\n                    vis[adj[node]] = true;\\n                }\\n            }\\n            r++;\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<long long> temp1 = bfs(node1,edges);\\n        vector<long long> temp2 = bfs(node2,edges);\\n        long long res = INT_MAX;\\n        long long ans = -1;\\n        for(int i = 0;i < n;i++){\\n            if(temp1[i] == -1 or temp2[i] == -1){\\n                continue;\\n            }\\n            if(max(temp1[i],temp2[i]) < res){\\n                res = min(max(temp1[i],temp2[i]),res);\\n                ans = i;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n    vector<long long> bfs(int sv,vector<int> &adj){\\n        int n = adj.size();\\n        queue<long long>q{};\\n        q.push(sv);\\n        vector<long long> dist(n,-1);\\n        vector<bool> vis(n,false);\\n        vis[sv] = true;\\n        long long r = 0;\\n        while(!q.empty()){\\n            int size = q.size();\\n            while(size--){\\n                long long node = q.front();\\n                q.pop();\\n                dist[node] = r;\\n                if(adj[node] != -1 and !vis[adj[node]]){\\n                    q.push(adj[node]);\\n                    vis[adj[node]] = true;\\n                }\\n            }\\n            r++;\\n        }\\n        return dist;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098109,
                "title": "python-short-and-clean-bfs",
                "content": "# Approach\\n1. Find distance from `node1` to all reachable nodes, let\\'s call it `dist_1`.\\n\\n2. Find distance from `node2` to all reachable nodes, let\\'s call it `dist_2`.\\n\\n3. Find common node reachable by both using `dist_1 intersection dist_2`.\\n\\n4. For each common `node` consider the maximum distance, i.e `max(dist_1[node], dist_2[node])`.\\n\\n5. Return the common `node` with minimum distance.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere, `n is number of nodes`.\\n\\n# Code\\n```python\\nclass Solution:\\n    def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\\n        def dist_from(node: int) -> dict[int, int]:\\n            dist = {node: 0}\\n            while node != -1  and (next_node := edges[node]) not in dist:\\n                dist[next_node] = dist[node] + 1\\n                node = next_node\\n            return dist\\n        \\n        dist_1, dist_2 = dist_from(node1), dist_from(node2)\\n        dist_common = ((max(dist_1[node], dist_2[node]), node) for node in dist_1.keys() & dist_2.keys())\\n        return min(dist_common, default=(0, -1))[1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```python\\nclass Solution:\\n    def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\\n        def dist_from(node: int) -> dict[int, int]:\\n            dist = {node: 0}\\n            while node != -1  and (next_node := edges[node]) not in dist:\\n                dist[next_node] = dist[node] + 1\\n                node = next_node\\n            return dist\\n        \\n        dist_1, dist_2 = dist_from(node1), dist_from(node2)\\n        dist_common = ((max(dist_1[node], dist_2[node]), node) for node in dist_1.keys() & dist_2.keys())\\n        return min(dist_common, default=(0, -1))[1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097578,
                "title": "c-bfs-full-explanation",
                "content": "# Intuition\\nLoop for each node and git the distance from `node1` and `node2` to each node\\n\\n# Approach\\nIf we make 2 bfs one from `node1` and the another one from `node2` so we will calculate each distance from the two nodes to the others nodes\\n\\nfor each node we will get the max distance from `node1` and `node2` and calculate the minimum of these distance for all nodes.\\n\\n# Complexity\\n- Time complexity:\\n$O(N)$\\n\\n- Space complexity:\\n$O(N)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    vector < int > BFS(int root, vector < int >& edges){\\n        int n = edges.size();\\n        \\n        // save the distance form the root to each node\\n        vector < int > dist(n, 1e9);\\n\\n        // bfs queue\\n        queue < int > bfs;\\n\\n        // add the root to the queue and make it distance is 0\\n        bfs.push(root);\\n        dist[root] = 0;\\n\\n        while(!bfs.empty()){\\n            int u = bfs.front();\\n            bfs.pop();\\n\\n            // if the node has no outgoing edge\\n            if(edges[u] == -1) continue;\\n\\n            // update the distance for the current node and add it to the queue\\n            int v = edges[u];\\n            if(dist[v] > dist[u] + 1)\\n                dist[v] = dist[u] + 1, bfs.push(v);\\n        }\\n\\n        // return the distances\\n        return dist;\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n\\n        // get distances from node1 and node2 \\n        vector < int > dist_a = BFS(node1, edges), dist_b = BFS(node2, edges);\\n        \\n        // get the min of max distance of all distances\\n        int max_dist = 1e9, node = -1;\\n        for(int u = 0; u < n; u++){\\n            // get max_dist from node1 and node2 to the node u\\n            int curr_dist = max(dist_a[u], dist_b[u]);\\n\\n            // update the minimum distance the answer for each node\\n            if(curr_dist < max_dist)\\n                max_dist = curr_dist, node = u;\\n        }\\n\\n        // the index of the node that can be reach to the two nodes with minimum distance\\n        return node;\\n    }\\n};\\n```\\n\\n\\n<div align= \"center\">\\n<h3>Upvote me</h3>\\n\\n![upvote-breaking-bad.gif](https://assets.leetcode.com/users/images/1d5db6b4-cbc9-4114-9867-b25c610821bb_1673864133.3709664.jpeg)\\n\\n</div>",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector < int > BFS(int root, vector < int >& edges){\\n        int n = edges.size();\\n        \\n        // save the distance form the root to each node\\n        vector < int > dist(n, 1e9);\\n\\n        // bfs queue\\n        queue < int > bfs;\\n\\n        // add the root to the queue and make it distance is 0\\n        bfs.push(root);\\n        dist[root] = 0;\\n\\n        while(!bfs.empty()){\\n            int u = bfs.front();\\n            bfs.pop();\\n\\n            // if the node has no outgoing edge\\n            if(edges[u] == -1) continue;\\n\\n            // update the distance for the current node and add it to the queue\\n            int v = edges[u];\\n            if(dist[v] > dist[u] + 1)\\n                dist[v] = dist[u] + 1, bfs.push(v);\\n        }\\n\\n        // return the distances\\n        return dist;\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n\\n        // get distances from node1 and node2 \\n        vector < int > dist_a = BFS(node1, edges), dist_b = BFS(node2, edges);\\n        \\n        // get the min of max distance of all distances\\n        int max_dist = 1e9, node = -1;\\n        for(int u = 0; u < n; u++){\\n            // get max_dist from node1 and node2 to the node u\\n            int curr_dist = max(dist_a[u], dist_b[u]);\\n\\n            // update the minimum distance the answer for each node\\n            if(curr_dist < max_dist)\\n                max_dist = curr_dist, node = u;\\n        }\\n\\n        // the index of the node that can be reach to the two nodes with minimum distance\\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096983,
                "title": "java-clean-code",
                "content": "# Intuition\\nRun BFS for node1 and node2 and save the distances into an array.\\nCompare the indexes of both arrays and check for the minimum maximum distance.\\n\\n# Code\\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] n1Distances = calculateDistanceFromNode(node1, edges);\\n        int[] n2Distances = calculateDistanceFromNode(node2, edges);\\n\\n        int node = -1;\\n        int dis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(n1Distances[i] == -1 || n2Distances[i] == -1) continue;\\n            int maxDistance = Math.max(n1Distances[i], n2Distances[i]);\\n            if (maxDistance < dis) {\\n                node = i;\\n                dis = maxDistance;\\n            }\\n        }\\n\\n        return node;\\n    }\\n\\n    private int[] calculateDistanceFromNode(int node, int[] edges) {\\n        int n = edges.length;\\n        boolean[] vis = new boolean[n];\\n        int[] distances = new int[n];\\n        Arrays.fill(distances, -1);\\n\\n        Queue<Integer> bfs = new LinkedList<>();\\n        bfs.add(node);\\n        vis[node] = true;\\n        int dis = 0;\\n\\n        while (!bfs.isEmpty()) {\\n            for (int k = 0; k < bfs.size(); k++) {\\n                int curNode = bfs.poll();\\n                distances[curNode] = dis;\\n                if (edges[curNode] != -1 && !vis[edges[curNode]]) {\\n                    vis[edges[curNode]] = true;\\n                    bfs.offer(edges[curNode]);\\n                }\\n            }\\n\\n            dis++;\\n        }\\n        return distances;\\n\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] n1Distances = calculateDistanceFromNode(node1, edges);\\n        int[] n2Distances = calculateDistanceFromNode(node2, edges);\\n\\n        int node = -1;\\n        int dis = Integer.MAX_VALUE;\\n\\n        for (int i = 0; i < n; i++) {\\n            if(n1Distances[i] == -1 || n2Distances[i] == -1) continue;\\n            int maxDistance = Math.max(n1Distances[i], n2Distances[i]);\\n            if (maxDistance < dis) {\\n                node = i;\\n                dis = maxDistance;\\n            }\\n        }\\n\\n        return node;\\n    }\\n\\n    private int[] calculateDistanceFromNode(int node, int[] edges) {\\n        int n = edges.length;\\n        boolean[] vis = new boolean[n];\\n        int[] distances = new int[n];\\n        Arrays.fill(distances, -1);\\n\\n        Queue<Integer> bfs = new LinkedList<>();\\n        bfs.add(node);\\n        vis[node] = true;\\n        int dis = 0;\\n\\n        while (!bfs.isEmpty()) {\\n            for (int k = 0; k < bfs.size(); k++) {\\n                int curNode = bfs.poll();\\n                distances[curNode] = dis;\\n                if (edges[curNode] != -1 && !vis[edges[curNode]]) {\\n                    vis[edges[curNode]] = true;\\n                    bfs.offer(edges[curNode]);\\n                }\\n            }\\n\\n            dis++;\\n        }\\n        return distances;\\n\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096147,
                "title": "python-simple-traversal",
                "content": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def traverse(distance, node):\\n            distance[node] = 0\\n            d = 0\\n            while edges[node] != -1 and distance[edges[node]] == -1:\\n                d += 1\\n                node = edges[node]\\n                distance[node] = d\\n\\n        distance1 = [-1] * len(edges)\\n        traverse(distance1, node1)\\n        \\n        distance2 = [-1] * len(edges)\\n        traverse(distance2, node2)\\n        \\n        min_d = math.inf\\n        min_node = -1\\n        for node in range(len(edges)):            \\n            d1, d2 = distance1[node], distance2[node]\\n            if d1 >= 0 and d2 >= 0 and max(d1, d2) < min_d:\\n                min_d = max(d1, d2)\\n                min_node = node\\n        \\n        return min_node\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def traverse(distance, node):\\n            distance[node] = 0\\n            d = 0\\n            while edges[node] != -1 and distance[edges[node]] == -1:\\n                d += 1\\n                node = edges[node]\\n                distance[node] = d\\n\\n        distance1 = [-1] * len(edges)\\n        traverse(distance1, node1)\\n        \\n        distance2 = [-1] * len(edges)\\n        traverse(distance2, node2)\\n        \\n        min_d = math.inf\\n        min_node = -1\\n        for node in range(len(edges)):            \\n            d1, d2 = distance1[node], distance2[node]\\n            if d1 >= 0 and d2 >= 0 and max(d1, d2) < min_d:\\n                min_d = max(d1, d2)\\n                min_node = node\\n        \\n        return min_node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2363011,
                "title": "c-well-commented-iterative-dfs-solution-runtime-better-than-100",
                "content": "Since each node has **at most** one outgoing edge, we can use iterative DFS here. \\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        \\n        int n = edges.size();\\n        \\n        // 2 distance vectors to store the distance of all the nodes from node1 and node2 \\n        vector<int> dist1(n, -1);\\n        vector<int> dist2(n, -1);\\n        \\n        // 2 visited vectors to keep a track of all the nodes visited from node1 and node2 \\n        // this is done to deal with the possible cycles in the graph \\n        vector<bool> vis1(n, false);\\n        vector<bool> vis2(n, false);\\n        \\n        int curNode = node1;\\n        int curDist = 0;\\n        \\n        // iterate over the edges and keep track of the distance between node1 and current node \\n        // if curNode == -1, end of path reached. \\n        // if vis[curNode] == true, cycle detected. \\n        \\n        while(curNode!=-1 && vis1[curNode] == false) {\\n            vis1[curNode] = true;\\n            dist1[curNode] = curDist;\\n            curNode = edges[curNode];\\n            curDist++;\\n        }\\n        \\n        // repeat above steps for node2 \\n        curNode = node2;\\n        curDist = 0;\\n        while(curNode!=-1 && vis2[curNode] == false) {\\n            vis2[curNode] = true;\\n            dist2[curNode] = curDist;\\n            curNode = edges[curNode];\\n            curDist++;\\n        }\\n        \\n        // iterate over the distance vectors and check if the current node has path from node1 and node 2\\n        // the distance from both nodes to the current node will be saved in the distance vectors \\n\\n        int minDist = INT_MAX;\\n        int index = -1;\\n        for(int i=0;i<n;i++) {\\n            if(dist1[i] != -1 && dist2[i]!=-1) {\\n                int maxDist = max(dist1[i], dist2[i]);\\n                if(maxDist < minDist) {\\n                    minDist = maxDist;\\n                    index = i;\\n                }\\n            }\\n        }\\n        \\n        return index;\\n        \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/6541ee4c-72cf-4cab-8e91-8871b832423f_1659333604.3156817.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        \\n        int n = edges.size();\\n        \\n        // 2 distance vectors to store the distance of all the nodes from node1 and node2 \\n        vector<int> dist1(n, -1);\\n        vector<int> dist2(n, -1);\\n        \\n        // 2 visited vectors to keep a track of all the nodes visited from node1 and node2 \\n        // this is done to deal with the possible cycles in the graph \\n        vector<bool> vis1(n, false);\\n        vector<bool> vis2(n, false);\\n        \\n        int curNode = node1;\\n        int curDist = 0;\\n        \\n        // iterate over the edges and keep track of the distance between node1 and current node \\n        // if curNode == -1, end of path reached. \\n        // if vis[curNode] == true, cycle detected. \\n        \\n        while(curNode!=-1 && vis1[curNode] == false) {\\n            vis1[curNode] = true;\\n            dist1[curNode] = curDist;\\n            curNode = edges[curNode];\\n            curDist++;\\n        }\\n        \\n        // repeat above steps for node2 \\n        curNode = node2;\\n        curDist = 0;\\n        while(curNode!=-1 && vis2[curNode] == false) {\\n            vis2[curNode] = true;\\n            dist2[curNode] = curDist;\\n            curNode = edges[curNode];\\n            curDist++;\\n        }\\n        \\n        // iterate over the distance vectors and check if the current node has path from node1 and node 2\\n        // the distance from both nodes to the current node will be saved in the distance vectors \\n\\n        int minDist = INT_MAX;\\n        int index = -1;\\n        for(int i=0;i<n;i++) {\\n            if(dist1[i] != -1 && dist2[i]!=-1) {\\n                int maxDist = max(dist1[i], dist2[i]);\\n                if(maxDist < minDist) {\\n                    minDist = maxDist;\\n                    index = i;\\n                }\\n            }\\n        }\\n        \\n        return index;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359537,
                "title": "c-solution-time-o-n-memory-o-n-easy-to-understand-iterative-dfs",
                "content": "```C#\\npublic class Solution {\\n    public int ClosestMeetingNode(int[] edges, int node1, int node2) {\\n        Dictionary<int, int> d1 = new (), d2 = new ();\\n\\n        int iterIndex = node1, distance = 0;\\n        while (iterIndex != -1 && !d1.ContainsKey(iterIndex))\\n        {\\n            d1[iterIndex] = distance++;\\n            iterIndex = edges[iterIndex];\\n        }\\n\\n        int ansIndex = int.MaxValue, ansDistance = int.MaxValue;\\n        iterIndex = node2;\\n        distance = 0;\\n        while (iterIndex != -1 && !d2.ContainsKey(iterIndex))\\n        {\\n            d2[iterIndex] = distance++;\\n\\n            if (d1.ContainsKey(iterIndex))\\n            {\\n                int m = Math.Max(d1[iterIndex], d2[iterIndex]);\\n                if (m < ansDistance || (m == ansDistance && iterIndex < ansIndex))\\n                {\\n                    ansIndex = iterIndex;\\n                    ansDistance = m;\\n                }\\n            }\\n            iterIndex = edges[iterIndex];\\n        }\\n\\n        if (ansIndex == int.MaxValue)\\n            return -1;\\n        return ansIndex;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```C#\\npublic class Solution {\\n    public int ClosestMeetingNode(int[] edges, int node1, int node2) {\\n        Dictionary<int, int> d1 = new (), d2 = new ();\\n\\n        int iterIndex = node1, distance = 0;\\n        while (iterIndex != -1 && !d1.ContainsKey(iterIndex))\\n        {\\n            d1[iterIndex] = distance++;\\n            iterIndex = edges[iterIndex];\\n        }\\n\\n        int ansIndex = int.MaxValue, ansDistance = int.MaxValue;\\n        iterIndex = node2;\\n        distance = 0;\\n        while (iterIndex != -1 && !d2.ContainsKey(iterIndex))\\n        {\\n            d2[iterIndex] = distance++;\\n\\n            if (d1.ContainsKey(iterIndex))\\n            {\\n                int m = Math.Max(d1[iterIndex], d2[iterIndex]);\\n                if (m < ansDistance || (m == ansDistance && iterIndex < ansIndex))\\n                {\\n                    ansIndex = iterIndex;\\n                    ansDistance = m;\\n                }\\n            }\\n            iterIndex = edges[iterIndex];\\n        }\\n\\n        if (ansIndex == int.MaxValue)\\n            return -1;\\n        return ansIndex;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357636,
                "title": "c-dijstra",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint n;\\n\\n\\t\\tvector<int> bfs(int node,vector<pair<int,int>>adj[]){\\n\\t\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n\\t\\tvector<int>distance(n,INT_MAX);\\n\\t\\tdistance[node]=0;\\n\\t\\tq.push({0,node});\\n\\n\\t\\twhile(!q.empty()){\\n\\t\\t\\tint dist= q.top().first;\\n\\t\\t\\tint prev = q.top().second;\\n\\t\\t\\tq.pop();\\n\\t\\t\\tfor(auto x: adj[prev]){\\n\\t\\t\\t\\tint next = x.first;\\n\\t\\t\\t\\tint nextDistance = x.second;\\n\\t\\t\\t\\tif(distance[next]>dist+nextDistance){\\n\\t\\t\\t\\t\\tdistance[next] = dist+nextDistance;\\n\\t\\t\\t\\t\\tq.push({distance[next],next});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn distance; \\n\\t}\\n\\n\\t\\tint closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n\\t\\t\\tn = edges.size();\\n\\t\\t\\tvector<pair<int,int>>adj[n];\\n\\t\\t\\tfor(int i=0;i<n;i++) if(edges[i]>=0) adj[i].push_back({edges[i],1});\\n\\t\\t\\tvector<int>dis1 = bfs(node1,adj);\\n\\t\\t\\tvector<int>dis2 = bfs(node2,adj);\\n\\t\\t\\tint res = -1,maxi = INT_MAX;\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t  if(dis1[i]!=INT_MAX and dis2[i]!=INT_MAX){\\n\\t\\t\\t\\t  if(maxi>max(dis1[i],dis2[i])) {\\n\\t\\t\\t\\t\\t  maxi = max(dis1[i],dis2[i]);\\n\\t\\t\\t\\t\\t  res = i;\\n\\t\\t\\t\\t  }\\n\\t\\t\\t  }  \\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint n;\\n\\n\\t\\tvector<int> bfs(int node,vector<pair<int,int>>adj[]){\\n\\t\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>>q;\\n\\t\\tvector<int>distance(n,INT_MAX);\\n\\t\\tdistance[node]=0;\\n\\t\\tq.push({0,node}",
                "codeTag": "Java"
            },
            {
                "id": 3100404,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dist(vector<int>& edges, int node, vector<int>& d)\\n    {\\n        while(node!=-1 && edges[node]!=-1)\\n        {\\n            int next=edges[node];\\n            if(d[next]!=1e9)\\n            break;\\n            d[next]=1+d[node];\\n            node=next;\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n       int n=edges.size();\\n       vector<int>d1(n, 1e9), d2(n, 1e9);\\n       d1[node1]=0;\\n       d2[node2]=0;\\n       dist(edges, node1, d1);\\n       dist(edges, node2, d2);\\n       int ans=1e9, ind=-1;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(ans>max(d1[i], d2[i]))\\n           {\\n               ans=max(d1[i], d2[i]);\\n               ind=i;\\n           }\\n       }\\n       return ind;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dist(vector<int>& edges, int node, vector<int>& d)\\n    {\\n        while(node!=-1 && edges[node]!=-1)\\n        {\\n            int next=edges[node];\\n            if(d[next]!=1e9)\\n            break;\\n            d[next]=1+d[node];\\n            node=next;\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n       int n=edges.size();\\n       vector<int>d1(n, 1e9), d2(n, 1e9);\\n       d1[node1]=0;\\n       d2[node2]=0;\\n       dist(edges, node1, d1);\\n       dist(edges, node2, d2);\\n       int ans=1e9, ind=-1;\\n       for(int i=0;i<n;i++)\\n       {\\n           if(ans>max(d1[i], d2[i]))\\n           {\\n               ans=max(d1[i], d2[i]);\\n               ind=i;\\n           }\\n       }\\n       return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098415,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        queue<int> q;\\n        int n=edges.size();\\n        vector<int> v(n, 0), a(n, INT_MAX), b(n, INT_MAX);\\n        q.push(node1);\\n        v[node1]=1;\\n        a[node1]=0;\\n        while(!q.empty())\\n        {\\n            int t=edges[q.front()];\\n            if(t==-1)\\n            break;\\n            if(v[t]==0)\\n            {\\n                v[t]=1;\\n                q.push(t);\\n                a[t]=a[q.front()]+1;\\n            }\\n            q.pop();\\n        }\\n        while(!q.empty())\\n        q.pop();\\n        v.clear();\\n        for(int i=0;i<n;i++)\\n        v[i]=0;\\n        q.push(node2);\\n        v[node2]=1;\\n        b[node2]=0;\\n        while(!q.empty())\\n        {\\n            int t=edges[q.front()];\\n            if(t==-1)\\n            break;\\n            if(v[t]==0)\\n            {\\n                v[t]=1;\\n                q.push(t);\\n                b[t]=b[q.front()]+1;\\n            }\\n            q.pop();\\n        }\\n        int ans=INT_MAX;\\n        int ind=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n                int mx=max(a[i], b[i]);\\n                if(ans>mx)\\n                {\\n                    ans=mx;\\n                    ind=i;\\n                }\\n        }\\n        return ind;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        queue<int> q;\\n        int n=edges.size();\\n        vector<int> v(n, 0), a(n, INT_MAX), b(n, INT_MAX);\\n        q.push(node1);\\n        v[node1]=1;\\n        a[node1]=0;\\n        while(!q.empty())\\n        {\\n            int t=edges[q.front()];\\n            if(t==-1)\\n            break;\\n            if(v[t]==0)\\n            {\\n                v[t]=1;\\n                q.push(t);\\n                a[t]=a[q.front()]+1;\\n            }\\n            q.pop();\\n        }\\n        while(!q.empty())\\n        q.pop();\\n        v.clear();\\n        for(int i=0;i<n;i++)\\n        v[i]=0;\\n        q.push(node2);\\n        v[node2]=1;\\n        b[node2]=0;\\n        while(!q.empty())\\n        {\\n            int t=edges[q.front()];\\n            if(t==-1)\\n            break;\\n            if(v[t]==0)\\n            {\\n                v[t]=1;\\n                q.push(t);\\n                b[t]=b[q.front()]+1;\\n            }\\n            q.pop();\\n        }\\n        int ans=INT_MAX;\\n        int ind=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n                int mx=max(a[i], b[i]);\\n                if(ans>mx)\\n                {\\n                    ans=mx;\\n                    ind=i;\\n                }\\n        }\\n        return ind;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098029,
                "title": "explained-dfs-easy-way",
                "content": "# Intuition\\nForm a vector that contain distance of source node to current node and check which node is best for given condition.\\n\\n# Approach\\nFirst form two vectors that contain the distance between node1/node2 and all other nodes.\\nThen iterate over all the values of this vector and check which intermidiate node will give the answer.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs1(vector<int>&edges , int node , int m , vector<int>&r1)\\n    {\\n        if(r1[node] != -1)\\n        return;\\n\\n        r1[node] = r1[m]+1;\\n        if(edges[node] == -1) return;\\n        dfs1(edges , edges[node] , node , r1);\\n    }\\n    void dfs2(vector<int>&edges , int node , int m , vector<int>&r2)\\n    {\\n        if(r2[node] != -1)\\n        return;\\n\\n        r2[node] = r2[m]+1;\\n        if(edges[node] == -1) return;\\n        dfs2(edges , edges[node] , node , r2);\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int>r1(n , -1) , r2(n , -1);\\n        \\n        dfs1(edges , node1 , node1 , r1);\\n        dfs2(edges , node2 , node2 , r2);\\n        int ans = -1 , mx = 1e9;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(r1[i] == -1 || r2[i] == -1) continue;\\n            int t = max(r1[i] , r2[i]);\\n            if(t < mx)\\n            {\\n                ans = i;\\n                mx = t;\\n            }\\n        }\\n        if(ans == 1e9) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs1(vector<int>&edges , int node , int m , vector<int>&r1)\\n    {\\n        if(r1[node] != -1)\\n        return;\\n\\n        r1[node] = r1[m]+1;\\n        if(edges[node] == -1) return;\\n        dfs1(edges , edges[node] , node , r1);\\n    }\\n    void dfs2(vector<int>&edges , int node , int m , vector<int>&r2)\\n    {\\n        if(r2[node] != -1)\\n        return;\\n\\n        r2[node] = r2[m]+1;\\n        if(edges[node] == -1) return;\\n        dfs2(edges , edges[node] , node , r2);\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int>r1(n , -1) , r2(n , -1);\\n        \\n        dfs1(edges , node1 , node1 , r1);\\n        dfs2(edges , node2 , node2 , r2);\\n        int ans = -1 , mx = 1e9;\\n        for(int i = 0;i<n;i++)\\n        {\\n            if(r1[i] == -1 || r2[i] == -1) continue;\\n            int t = max(r1[i] , r2[i]);\\n            if(t < mx)\\n            {\\n                ans = i;\\n                mx = t;\\n            }\\n        }\\n        if(ans == 1e9) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097921,
                "title": "java-dfs-bfs-bonus-commented",
                "content": "# Please Upvote \\uD83D\\uDE07\\n---\\n#### 1. Using DFS:\\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];   // to store the distances between node1 and other nodes\\n        int[] dist2 = new int[n];   // to store the distances between node2 and other nodes\\n        Arrays.fill(dist1, Integer.MAX_VALUE);\\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n\\n        // boolean arrays to mark our visits at each node\\n        boolean[] vis1 = new boolean[n];\\n        boolean[] vis2 = new boolean[n];\\n\\n        // distance between nod1 and node1 is 0, so is for node2\\n        dist1[node1] = dist2[node2] = 0;        \\n\\n        // Call the DFS methods\\n        dfs(edges, node1, dist1, vis1);\\n        dfs(edges, node2, dist2, vis2);\\n\\n        int minDistNode = -1;   // to store our answer node\\n        // variable to store the min distance of our answer node from node1 & node2\\n        int minDistSoFar = Integer.MAX_VALUE;   \\n        for (int i = 0; i < n; i++) {\\n            // take the max between the two distances\\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            // if that max is lesser than minDistSoFar\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;   // that max becomes a candidate min distance\\n                minDistNode = i;    // that node becomes a candidate answer node\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private void dfs(int[] edges, int currNode, int[] dist, boolean[] visited) {\\n        visited[currNode] = true;           // we mark our visit\\n        int nextNode = edges[currNode];     // the node we are gonna visit\\n        // -1 indicates that there is no outgoing from our current node\\n        // also if visited already, we won\\'t visit again\\n        if (nextNode != -1 && !visited[nextNode]) {\\n            visited[nextNode] = true;   // mark the next node\\'s visit\\n            // distance for our new node 1 + distance we travelled to come to current node\\n            dist[nextNode] = 1 + dist[currNode]; \\n            dfs(edges, nextNode, dist, visited);    // call DFS for the new node\\n        }\\n    }\\n}\\n\\n// TC: O(2n), SC: O(n)\\n```\\n---\\n#### 2. Using BFS:\\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];   // to store the distances between node1 and other nodes\\n        int[] dist2 = new int[n];   // to store the distances between node2 and other nodes\\n        Arrays.fill(dist1, Integer.MAX_VALUE);\\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n\\n        // call the BFS for node1 and node2\\n        bfs(edges, node1, dist1);\\n        bfs(edges, node2, dist2);\\n\\n        // the rest stays the same just like DFS\\n        int minDistNode = -1;\\n        int minDistSoFar = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;\\n                minDistNode = i;\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private void bfs(int[] edges, int currNode, int[] dist) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(currNode);  // we push the current node\\n\\n        boolean[] visited = new boolean[edges.length];\\n        visited[currNode] = true;   // we mark our visit at current node\\n        // distance between currNode and currrNode is 0\\n        dist[currNode] = 0; \\n        // start the iteration\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();    // pop out the last visited node\\n            int nextNode = edges[curr]; // the node we are going to visit next\\n            // -1 indicates that there is no outgoing from our current node\\n            // also if visited already, we won\\'t visit again\\n            if (nextNode != -1 && !visited[nextNode]) {\\n                visited[nextNode] = true;  // mark the next node\\'s visit\\n                // distance for our new node 1 + distance we travelled to come to current node\\n                dist[nextNode] = 1 + dist[curr];\\n                q.offer(nextNode);  // push the new node to the queue\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(2n), SC: O(n)\\n```\\n---\\n#### We can space optimise our solution by getting rid of the boolean arrays to mark our visits.\\nIf our distance array holds the value `Integer.MAX_VALUE` means distance for that index/node has not been updated yet. And it hasn\\'t been updated means it wasn\\'t visited.\\n\\nSo we would simply check if `dist[node] == Integer.MAX_VALUE`. \\nIf it\\'s `true` means it wasn\\'t visited, otherwise it was visited if `false`.\\n\\n---\\n#### DFS:\\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];\\n        int[] dist2 = new int[n];\\n        Arrays.fill(dist1, Integer.MAX_VALUE); \\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n        \\n        dist1[node1] = dist2[node2] = 0;\\n\\n        dfs(edges, node1, dist1);\\n        dfs(edges, node2, dist2);\\n\\n        int minDistNode = -1;\\n        int minDistSoFar = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;\\n                minDistNode = i;\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private void dfs(int[] edges, int currNode, int[] dist) {\\n        int nextNode = edges[currNode];\\n        if (nextNode != -1 && dist[nextNode] == Integer.MAX_VALUE) {\\n            dist[nextNode] = 1 + dist[currNode];\\n            dfs(edges, nextNode, dist);\\n        }\\n    }\\n}\\n```\\n#### BFS:\\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];\\n        int[] dist2 = new int[n];\\n        Arrays.fill(dist1, Integer.MAX_VALUE); \\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n\\n        bfs(edges, node1, dist1);\\n        bfs(edges, node2, dist2);\\n\\n        int minDistNode = -1;\\n        int minDistSoFar = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;\\n                minDistNode = i;\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private void bfs(int[] edges, int currNode, int[] dist) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(currNode);\\n        dist[currNode] = 0;\\n\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            int nextNode = edges[curr];\\n            if (nextNode != -1 && dist[nextNode] == Integer.MAX_VALUE) {\\n                dist[nextNode] = 1 + dist[curr];\\n                q.offer(nextNode);\\n            }\\n        }\\n    }\\n}\\n```\\n---\\n## Bonus:\\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        // get distance arrays\\n        int[] dist1 = getDistanceArray(edges, node1);\\n        int[] dist2 = getDistanceArray(edges, node2);\\n\\n        int minDistNode = -1;\\n        int minDistSoFar = Integer.MAX_VALUE;\\n        for (int i = 0; i < edges.length; i++) {\\n            // if node i is not connected to either or both node1 & node2\\n            if (dist1[i] == -1 || dist2[i] == -1) {\\n                continue;\\n            }\\n            \\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;\\n                minDistNode = i;\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private int[] getDistanceArray(int[] edges, int node) {\\n        int[] arr = new int[edges.length];\\n        Arrays.fill(arr, -1);   // fill the array initially with -1\\n        int distance = 0;\\n        // works as DFS, travels through connections\\n        // until there is no outgoing edge \\n        // and distance of all travelled nodes is updated\\n        while (node != -1 && arr[node] == -1) {\\n            // distance increments at each node\\n            arr[node] = distance++; \\n            // new node is the node connected to our current node \\n            node = edges[node];     \\n        }\\n\\n        return arr;\\n    }\\n}\\n\\n// TC: O(2n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];   // to store the distances between node1 and other nodes\\n        int[] dist2 = new int[n];   // to store the distances between node2 and other nodes\\n        Arrays.fill(dist1, Integer.MAX_VALUE);\\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n\\n        // boolean arrays to mark our visits at each node\\n        boolean[] vis1 = new boolean[n];\\n        boolean[] vis2 = new boolean[n];\\n\\n        // distance between nod1 and node1 is 0, so is for node2\\n        dist1[node1] = dist2[node2] = 0;        \\n\\n        // Call the DFS methods\\n        dfs(edges, node1, dist1, vis1);\\n        dfs(edges, node2, dist2, vis2);\\n\\n        int minDistNode = -1;   // to store our answer node\\n        // variable to store the min distance of our answer node from node1 & node2\\n        int minDistSoFar = Integer.MAX_VALUE;   \\n        for (int i = 0; i < n; i++) {\\n            // take the max between the two distances\\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            // if that max is lesser than minDistSoFar\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;   // that max becomes a candidate min distance\\n                minDistNode = i;    // that node becomes a candidate answer node\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private void dfs(int[] edges, int currNode, int[] dist, boolean[] visited) {\\n        visited[currNode] = true;           // we mark our visit\\n        int nextNode = edges[currNode];     // the node we are gonna visit\\n        // -1 indicates that there is no outgoing from our current node\\n        // also if visited already, we won\\'t visit again\\n        if (nextNode != -1 && !visited[nextNode]) {\\n            visited[nextNode] = true;   // mark the next node\\'s visit\\n            // distance for our new node 1 + distance we travelled to come to current node\\n            dist[nextNode] = 1 + dist[currNode]; \\n            dfs(edges, nextNode, dist, visited);    // call DFS for the new node\\n        }\\n    }\\n}\\n\\n// TC: O(2n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];   // to store the distances between node1 and other nodes\\n        int[] dist2 = new int[n];   // to store the distances between node2 and other nodes\\n        Arrays.fill(dist1, Integer.MAX_VALUE);\\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n\\n        // call the BFS for node1 and node2\\n        bfs(edges, node1, dist1);\\n        bfs(edges, node2, dist2);\\n\\n        // the rest stays the same just like DFS\\n        int minDistNode = -1;\\n        int minDistSoFar = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;\\n                minDistNode = i;\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private void bfs(int[] edges, int currNode, int[] dist) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(currNode);  // we push the current node\\n\\n        boolean[] visited = new boolean[edges.length];\\n        visited[currNode] = true;   // we mark our visit at current node\\n        // distance between currNode and currrNode is 0\\n        dist[currNode] = 0; \\n        // start the iteration\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();    // pop out the last visited node\\n            int nextNode = edges[curr]; // the node we are going to visit next\\n            // -1 indicates that there is no outgoing from our current node\\n            // also if visited already, we won\\'t visit again\\n            if (nextNode != -1 && !visited[nextNode]) {\\n                visited[nextNode] = true;  // mark the next node\\'s visit\\n                // distance for our new node 1 + distance we travelled to come to current node\\n                dist[nextNode] = 1 + dist[curr];\\n                q.offer(nextNode);  // push the new node to the queue\\n            }\\n        }\\n    }\\n}\\n\\n// TC: O(2n), SC: O(n)\\n```\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];\\n        int[] dist2 = new int[n];\\n        Arrays.fill(dist1, Integer.MAX_VALUE); \\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n        \\n        dist1[node1] = dist2[node2] = 0;\\n\\n        dfs(edges, node1, dist1);\\n        dfs(edges, node2, dist2);\\n\\n        int minDistNode = -1;\\n        int minDistSoFar = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;\\n                minDistNode = i;\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private void dfs(int[] edges, int currNode, int[] dist) {\\n        int nextNode = edges[currNode];\\n        if (nextNode != -1 && dist[nextNode] == Integer.MAX_VALUE) {\\n            dist[nextNode] = 1 + dist[currNode];\\n            dfs(edges, nextNode, dist);\\n        }\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] dist1 = new int[n];\\n        int[] dist2 = new int[n];\\n        Arrays.fill(dist1, Integer.MAX_VALUE); \\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n\\n        bfs(edges, node1, dist1);\\n        bfs(edges, node2, dist2);\\n\\n        int minDistNode = -1;\\n        int minDistSoFar = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;\\n                minDistNode = i;\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private void bfs(int[] edges, int currNode, int[] dist) {\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(currNode);\\n        dist[currNode] = 0;\\n\\n        while (!q.isEmpty()) {\\n            int curr = q.poll();\\n            int nextNode = edges[curr];\\n            if (nextNode != -1 && dist[nextNode] == Integer.MAX_VALUE) {\\n                dist[nextNode] = 1 + dist[curr];\\n                q.offer(nextNode);\\n            }\\n        }\\n    }\\n}\\n```\n``` java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        // get distance arrays\\n        int[] dist1 = getDistanceArray(edges, node1);\\n        int[] dist2 = getDistanceArray(edges, node2);\\n\\n        int minDistNode = -1;\\n        int minDistSoFar = Integer.MAX_VALUE;\\n        for (int i = 0; i < edges.length; i++) {\\n            // if node i is not connected to either or both node1 & node2\\n            if (dist1[i] == -1 || dist2[i] == -1) {\\n                continue;\\n            }\\n            \\n            int maxDistBetweenTwo = Math.max(dist1[i], dist2[i]);\\n            if (maxDistBetweenTwo < minDistSoFar) {\\n                minDistSoFar = maxDistBetweenTwo;\\n                minDistNode = i;\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n\\n    private int[] getDistanceArray(int[] edges, int node) {\\n        int[] arr = new int[edges.length];\\n        Arrays.fill(arr, -1);   // fill the array initially with -1\\n        int distance = 0;\\n        // works as DFS, travels through connections\\n        // until there is no outgoing edge \\n        // and distance of all travelled nodes is updated\\n        while (node != -1 && arr[node] == -1) {\\n            // distance increments at each node\\n            arr[node] = distance++; \\n            // new node is the node connected to our current node \\n            node = edges[node];     \\n        }\\n\\n        return arr;\\n    }\\n}\\n\\n// TC: O(2n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097116,
                "title": "java-c-100-solution-with-explanation-find-closest-node-to-given-two-nodes",
                "content": "# Approach\\n- Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\n- Create two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\n- Run the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\n- Run the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\n- Iterate through all nodes currNode in the graph.\\n- For each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\n- If the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\n- Return ans as the result.\\n\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ where n is the number of nodes\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ where n is the size of vector or array\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n\\n    void dfs(int curr,vector<int>& edges,vector<int>& distance,vector<bool>& visited)\\n    {\\n        visited[curr] = true;\\n        int next = edges[curr];\\n        if(next != -1 && !visited[next])\\n        {\\n            distance[next] = distance[curr] + 1;\\n            dfs(next,edges,distance,visited);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        int ans = -1;\\n        int minDist = INT_MAX;\\n\\n        vector<int> distance1(n,0),distance2(n,0);\\n        vector<bool> visited1(n,false),visited2(n,false);\\n\\n        dfs(node1,edges,distance1,visited1);\\n        dfs(node2,edges,distance2,visited2);\\n\\n        for(int node=0;node<n;node++)\\n        {\\n            if(visited1[node] && visited2[node] && minDist>max(distance1[node],distance2[node]))\\n            {\\n                minDist = max(distance1[node],distance2[node]);\\n                ans = node;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Java []\\nclass Solution {\\n    void dfs(int curr,int[] edges,int[] distance,boolean[] visited)\\n    {\\n        visited[curr] = true;\\n        int next = edges[curr];\\n        if(next != -1 && !visited[next])\\n        {\\n            distance[next] = distance[curr] + 1;\\n            dfs(next,edges,distance,visited);\\n        }\\n    }\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int ans = -1;\\n        int minDist = Integer.MAX_VALUE;\\n\\n        int[] distance1 = new int[n];\\n        int[] distance2 = new int[n];\\n        boolean[] visited1 = new boolean[n];\\n        boolean[] visited2 = new boolean[n];\\n\\n        dfs(node1,edges,distance1,visited1);\\n        dfs(node2,edges,distance2,visited2);\\n\\n        for(int node=0;node<n;node++)\\n        {\\n            if(visited1[node] && visited2[node] && minDist>Math.max(distance1[node],distance2[node]))\\n            {\\n                minDist = Math.max(distance1[node],distance2[node]);\\n                ans = node;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\n    void dfs(int curr,vector<int>& edges,vector<int>& distance,vector<bool>& visited)\\n    {\\n        visited[curr] = true;\\n        int next = edges[curr];\\n        if(next != -1 && !visited[next])\\n        {\\n            distance[next] = distance[curr] + 1;\\n            dfs(next,edges,distance,visited);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        int ans = -1;\\n        int minDist = INT_MAX;\\n\\n        vector<int> distance1(n,0),distance2(n,0);\\n        vector<bool> visited1(n,false),visited2(n,false);\\n\\n        dfs(node1,edges,distance1,visited1);\\n        dfs(node2,edges,distance2,visited2);\\n\\n        for(int node=0;node<n;node++)\\n        {\\n            if(visited1[node] && visited2[node] && minDist>max(distance1[node],distance2[node]))\\n            {\\n                minDist = max(distance1[node],distance2[node]);\\n                ans = node;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    void dfs(int curr,int[] edges,int[] distance,boolean[] visited)\\n    {\\n        visited[curr] = true;\\n        int next = edges[curr];\\n        if(next != -1 && !visited[next])\\n        {\\n            distance[next] = distance[curr] + 1;\\n            dfs(next,edges,distance,visited);\\n        }\\n    }\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int ans = -1;\\n        int minDist = Integer.MAX_VALUE;\\n\\n        int[] distance1 = new int[n];\\n        int[] distance2 = new int[n];\\n        boolean[] visited1 = new boolean[n];\\n        boolean[] visited2 = new boolean[n];\\n\\n        dfs(node1,edges,distance1,visited1);\\n        dfs(node2,edges,distance2,visited2);\\n\\n        for(int node=0;node<n;node++)\\n        {\\n            if(visited1[node] && visited2[node] && minDist>Math.max(distance1[node],distance2[node]))\\n            {\\n                minDist = Math.max(distance1[node],distance2[node]);\\n                ans = node;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096697,
                "title": "python3-958-ms-faster-than-95-40-of-python3",
                "content": "```\\ndef closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        curr = [(node1,1),(node2,2)] \\n        visited = [0]*len(edges)\\n        node = inf\\n        while curr:  \\n            new = []\\n            f = False\\n            for a,w in curr:\\n                if visited[a]==0:\\n                    if edges[a]!=-1:\\n                        new.append((edges[a],w))\\n                    visited[a] = w\\n                elif visited[a]!=w:\\n                    f = True\\n                    node = min(a,node)        \\n            if f:\\n                return node       \\n            curr = new \\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        curr = [(node1,1),(node2,2)] \\n        visited = [0]*len(edges)\\n        node = inf\\n        while curr:  \\n            new = []\\n            f = False\\n            for a,w in curr:\\n                if visited[a]==0:\\n                    if edges[a]!=-1:\\n                        new.append((edges[a],w))\\n                    visited[a] = w\\n                elif visited[a]!=w:\\n                    f = True\\n                    node = min(a,node)        \\n            if f:\\n                return node       \\n            curr = new \\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3096616,
                "title": "2-dfs-cpp",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1) Make two dfs call from node1 and node2\\n    2) Find minmax among  all reachable node from node1 and node2\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    T(n) = O(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    T(n) = O(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = size(edges);\\n        vector<int> m1(n,-1), m2(n, -1);\\n        auto dfs = [&edges](int u, auto & memo)->void{\\n            int time = 0;\\n            while(u != -1 && memo[u] == -1){\\n                memo[u] = time++;\\n                u = edges[u];\\n            }\\n        };\\n        dfs(node1, m1), dfs(node2, m2);\\n        int id = -1, minMax = 1e9;\\n        for(int i=0; i<n; i++){\\n            if(min(m1[i], m2[i]) > -1 && max(m1[i], m2[i]) < minMax){\\n                minMax = max(m1[i], m2[i]);\\n                id = i;\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = size(edges);\\n        vector<int> m1(n,-1), m2(n, -1);\\n        auto dfs = [&edges](int u, auto & memo)->void{\\n            int time = 0;\\n            while(u != -1 && memo[u] == -1){\\n                memo[u] = time++;\\n                u = edges[u];\\n            }\\n        };\\n        dfs(node1, m1), dfs(node2, m2);\\n        int id = -1, minMax = 1e9;\\n        for(int i=0; i<n; i++){\\n            if(min(m1[i], m2[i]) > -1 && max(m1[i], m2[i]) < minMax){\\n                minMax = max(m1[i], m2[i]);\\n                id = i;\\n            }\\n        }\\n        return id;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096255,
                "title": "straighforward-python-code-no-algorithms-beats-90",
                "content": "# Intuition\\nPretty straightforward. Im still new to algorithms, so I thought I would brute force it.\\n\\n# Approach\\nKeep 2 SETS (or lists) to record the nodes travelled by nodes 1 and 2. \\n\\n-If any of the nodes\\' value is in **its** set, it means it has been to this exact point before and thus is following a cyclic path.(You dont need to record a cyclic path more than once right?)\\n\\n-If any of the nodes reaches -1, it has reached the end of its path\\n\\nKeep recording the nodes till any of these conditions are satisfied.If both have finished recording with no common nodes, return -1\\n\\nif while recording the nodes, node1 happens to be in node2\\'s set or node2 happens to be in node1\\'s set, return the node value. If node1 in set2 **and** node2 in set1, return the smallest value\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n![image.png](https://assets.leetcode.com/users/images/3cf260f5-2300-48b4-99e0-1fd801f3d268_1674621617.9171638.png)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        #These sets will keep track of its respective node; like browsing history ;)\\n        visited_1=set()\\n        visited_2=set()\\n        \\n        while node1!=-1 or node2!=-1:\\n            #record only if node is not cyclic or not at its destination\\n            if node1!=-1 and node1 not in visited_1:\\n                if node1 in visited_2:\\n                    if node2 in visited_1:\\n                        #if the code is here,there are 2 common values so return minimum\\n                        return min(node1,node2)\\n                    #if code is here then node2 NOT in visited_1 so just return node1\\n                    return node1\\n                #here we record our existing node value and move to the next node\\n                visited_1.add(node1)\\n                node1=edges[node1]\\n            \\n\\n            if node2!=-1 and node2 not in visited_2:\\n                if node2 in visited_1:\\n                    #if the code is here,it means that node1 was not in visited2 (or it would have gone to ther other loop)\\n                    return node2\\n                visited_2.add(node2)\\n                node2=edges[node2]\\n            if (node1 in visited_1 or node1==-1) and (node2 in visited_2 or node2==-1):\\n                break\\n        #if code is here, both paths have terminated with no common node\\n        return -1\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        #These sets will keep track of its respective node; like browsing history ;)\\n        visited_1=set()\\n        visited_2=set()\\n        \\n        while node1!=-1 or node2!=-1:\\n            #record only if node is not cyclic or not at its destination\\n            if node1!=-1 and node1 not in visited_1:\\n                if node1 in visited_2:\\n                    if node2 in visited_1:\\n                        #if the code is here,there are 2 common values so return minimum\\n                        return min(node1,node2)\\n                    #if code is here then node2 NOT in visited_1 so just return node1\\n                    return node1\\n                #here we record our existing node value and move to the next node\\n                visited_1.add(node1)\\n                node1=edges[node1]\\n            \\n\\n            if node2!=-1 and node2 not in visited_2:\\n                if node2 in visited_1:\\n                    #if the code is here,it means that node1 was not in visited2 (or it would have gone to ther other loop)\\n                    return node2\\n                visited_2.add(node2)\\n                node2=edges[node2]\\n            if (node1 in visited_1 or node1==-1) and (node2 in visited_2 or node2==-1):\\n                break\\n        #if code is here, both paths have terminated with no common node\\n        return -1\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096165,
                "title": "bfs-detailed-explanation",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDD7\\uD835\\uDDF2\\uD835\\uDE01\\uD835\\uDDEE\\uD835\\uDDF6\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDF1 \\uD835\\uDDD4\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF5 \\uD835\\uDDD8\\uD835\\uDE05\\uD835\\uDDFD\\uD835\\uDDF9\\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF6\\uD835\\uDDFC\\uD835\\uDDFB\\n\\uD835\\uDDD6\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDEE\\uD835\\uDDFF\\uD835\\uDDF2 \\uD835\\uDDEE\\uD835\\uDDFD\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDF2\\uD835\\uDDF0\\uD835\\uDDF6\\uD835\\uDDEE\\uD835\\uDE01\\uD835\\uDDF2\\uD835\\uDDF1\\nhttps://youtu.be/j5ByjzAD2Pw# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nvar closestMeetingNode = function(edges, node1, node2) {\\n    let n = edges.length\\n    let map1 = new Array(n).fill(-1)\\n    let map2 = new Array(n). fill(-1)\\n    map1[node1] = 0\\n    map2[node2] = 0\\n\\n    while (edges[node1] != -1 && map1[edges[node1]] == -1) {\\n        map1[edges[node1]] = map1[node1] + 1\\n        node1 = edges[node1]\\n    }\\n    while (edges[node2] != -1 && map2[edges[node2]] == -1) {\\n        map2[edges[node2]] = map2[node2] + 1\\n        node2 = edges[node2]\\n    } \\n\\n    let res = n, node = -1\\n    for (let i = 0; i < n; i++) {\\n        if (map1[i] == -1 || map2[i] == -1) continue\\n        let val = Math.max(map1[i], map2[i])\\n        if (res > val) {\\n            res = val\\n            node = i\\n        }\\n    }\\n    return node\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar closestMeetingNode = function(edges, node1, node2) {\\n    let n = edges.length\\n    let map1 = new Array(n).fill(-1)\\n    let map2 = new Array(n). fill(-1)\\n    map1[node1] = 0\\n    map2[node2] = 0\\n\\n    while (edges[node1] != -1 && map1[edges[node1]] == -1) {\\n        map1[edges[node1]] = map1[node1] + 1\\n        node1 = edges[node1]\\n    }\\n    while (edges[node2] != -1 && map2[edges[node2]] == -1) {\\n        map2[edges[node2]] = map2[node2] + 1\\n        node2 = edges[node2]\\n    } \\n\\n    let res = n, node = -1\\n    for (let i = 0; i < n; i++) {\\n        if (map1[i] == -1 || map2[i] == -1) continue\\n        let val = Math.max(map1[i], map2[i])\\n        if (res > val) {\\n            res = val\\n            node = i\\n        }\\n    }\\n    return node\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095931,
                "title": "python3-bfs-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be thought of as finding the node that is the closest to both node1 and node2. We can solve this problem by first traversing the graph from both node1 and node2, and keeping track of the distance from both nodes to each other node in the graph. We can then compare the distances and return the node that has the smallest maximum distance from both node1 and node2.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOne approach to solve this problem is to use Breadth-First Search (BFS) to traverse the graph from both node1 and node2 and keep track of the distance from each node to each other node in the graph.\\n\\n- Create two arrays distanceOne and distanceTwo, initially filled with infinity.\\n- Perform BFS starting from node1, and store the distance from node1 to each other node in the graph in distanceOne.\\n- Perform BFS starting from node2, and store the distance from node2 to each other node in the graph in distanceTwo.\\n- Initialize a variable minDistNode to -1 and minDistTillNow to infinity.\\n- Iterate through all the nodes in the graph and for each node, calculate the max of distanceOne[currentNode] and distanceTwo[currentNode]. If the max is smaller than minDistTillNow, update minDistTillNow and minDistNode.\\n- Return minDistNode.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the number of nodes in the graph. The algorithm performs BFS twice, once starting from node1 and once starting from node2. The time complexity of BFS is O(V + E) where V is the number of vertices and E is the number of edges, but in this case since each node has at most one outgoing edge, the time complexity is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) where n is the number of nodes in the graph. Two arrays of size n are created to store the distance from node1 and node2 to each other node in the graph.\\n\\n# Code\\n```\\nclass Solution:\\n    def bfs(self, startNode, edges, distance):\\n        queue = [startNode]\\n        visit = [False for _ in range(len(edges))]\\n        \\n        distance[startNode] = 0\\n        \\n        while queue:\\n            currentNode = queue.pop(0)\\n            \\n            if visit[currentNode]:\\n                return\\n            \\n            visit[currentNode] = True\\n            neighbor = edges[currentNode]\\n            \\n            if neighbor != -1 and not visit[neighbor]:\\n                distance[neighbor] = 1 + distance[currentNode]\\n                queue.append(neighbor)\\n\\n    def closestMeetingNode(self, edges, node1, node2):\\n        distanceOne = [float(\\'inf\\') for _ in range(len(edges))]\\n        distanceTwo = [float(\\'inf\\') for _ in range(len(edges))]\\n        \\n        self.bfs(node1, edges, distanceOne)\\n        self.bfs(node2, edges, distanceTwo)\\n        \\n        minDistNode = -1\\n        minDistTillNow = float(\\'inf\\')\\n        \\n        for currentNode in range(len(edges)):\\n            if minDistTillNow > max(distanceOne[currentNode], distanceTwo[currentNode]):\\n                minDistNode = currentNode\\n                minDistTillNow = max(distanceOne[currentNode], distanceTwo[currentNode])\\n                \\n        return minDistNode\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def bfs(self, startNode, edges, distance):\\n        queue = [startNode]\\n        visit = [False for _ in range(len(edges))]\\n        \\n        distance[startNode] = 0\\n        \\n        while queue:\\n            currentNode = queue.pop(0)\\n            \\n            if visit[currentNode]:\\n                return\\n            \\n            visit[currentNode] = True\\n            neighbor = edges[currentNode]\\n            \\n            if neighbor != -1 and not visit[neighbor]:\\n                distance[neighbor] = 1 + distance[currentNode]\\n                queue.append(neighbor)\\n\\n    def closestMeetingNode(self, edges, node1, node2):\\n        distanceOne = [float(\\'inf\\') for _ in range(len(edges))]\\n        distanceTwo = [float(\\'inf\\') for _ in range(len(edges))]\\n        \\n        self.bfs(node1, edges, distanceOne)\\n        self.bfs(node2, edges, distanceTwo)\\n        \\n        minDistNode = -1\\n        minDistTillNow = float(\\'inf\\')\\n        \\n        for currentNode in range(len(edges)):\\n            if minDistTillNow > max(distanceOne[currentNode], distanceTwo[currentNode]):\\n                minDistNode = currentNode\\n                minDistTillNow = max(distanceOne[currentNode], distanceTwo[currentNode])\\n                \\n        return minDistNode\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576023,
                "title": "java-easiest-dfs-solution-structured-clean-code",
                "content": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] nums, int node1, int node2) {\\n        if(nums==null || nums.length==0) return -1;\\n        if(node1==node2) return node1;\\n        \\n        int n=nums.length;\\n        int dist1[]=new int[n];\\n        int dist2[]=new int[n];\\n        \\n        Arrays.fill(dist1,-1);\\n        Arrays.fill(dist2,-1);\\n        \\n        dist1[node1]=0;\\n        dist2[node2]=0;\\n        \\n        boolean vis1[]=new boolean[n];\\n        boolean vis2[]=new boolean[n];\\n        \\n        dfs(nums,node1,dist1,vis1,0);\\n        dfs(nums,node2,dist2,vis2,0);\\n        \\n        int ans=-1;\\n        int minDist=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            if(dist1[i]!=-1 && dist2[i]!=-1 && minDist>Math.max(dist1[i],dist2[i])){\\n                ans=i;\\n                minDist=Math.max(dist1[i],dist2[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int nums[], int node, int dist[], boolean visited[], int currDist){\\n        if(node!=-1 && !visited[node]){\\n            visited[node]=true;\\n            dist[node]=currDist;\\n            dfs(nums,nums[node],dist,visited,currDist+1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] nums, int node1, int node2) {\\n        if(nums==null || nums.length==0) return -1;\\n        if(node1==node2) return node1;\\n        \\n        int n=nums.length;\\n        int dist1[]=new int[n];\\n        int dist2[]=new int[n];\\n        \\n        Arrays.fill(dist1,-1);\\n        Arrays.fill(dist2,-1);\\n        \\n        dist1[node1]=0;\\n        dist2[node2]=0;\\n        \\n        boolean vis1[]=new boolean[n];\\n        boolean vis2[]=new boolean[n];\\n        \\n        dfs(nums,node1,dist1,vis1,0);\\n        dfs(nums,node2,dist2,vis2,0);\\n        \\n        int ans=-1;\\n        int minDist=Integer.MAX_VALUE;\\n        for(int i=0;i<n;i++){\\n            if(dist1[i]!=-1 && dist2[i]!=-1 && minDist>Math.max(dist1[i],dist2[i])){\\n                ans=i;\\n                minDist=Math.max(dist1[i],dist2[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    private void dfs(int nums[], int node, int dist[], boolean visited[], int currDist){\\n        if(node!=-1 && !visited[node]){\\n            visited[node]=true;\\n            dist[node]=currDist;\\n            dfs(nums,nums[node],dist,visited,currDist+1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2537738,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using DFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // dfs function for finding the distance of all nodes from given node\\n    \\n    void dfs(vector<int>& edges, int u, vector<int>& dist, int curr_dist)\\n    {\\n        dist[u] = curr_dist;\\n        \\n        if(edges[u] != -1 && dist[edges[u]] == INT_MAX)\\n        {\\n            dfs(edges, edges[u], dist, curr_dist + 1);\\n        }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        int n = edges.size();\\n        \\n        // call dfs and find the distance of all the nodes from node1\\n        \\n        vector<int> dist1(n, INT_MAX);\\n        \\n        dist1[node1] = 0;\\n        \\n        dfs(edges, node1, dist1, 0);\\n        \\n        // call dfs and find the distance of all nodes from node1\\n        \\n        vector<int> dist2(n, INT_MAX);\\n        \\n        dist2[node2] = 0;\\n        \\n        dfs(edges, node2, dist2, 0);\\n        \\n        // find the index of the node\\n        \\n        int mini = INT_MAX;\\n        \\n        int min_idx = -1;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dist1[i] != INT_MAX && dist2[i] != INT_MAX)\\n            {\\n                int max_dist = max(dist1[i], dist2[i]);\\n                \\n                if(max_dist < mini)\\n                {\\n                    mini = max_dist;\\n                    \\n                    min_idx = i;\\n                }\\n            }\\n        }\\n        \\n        return min_idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // dfs function for finding the distance of all nodes from given node\\n    \\n    void dfs(vector<int>& edges, int u, vector<int>& dist, int curr_dist)\\n    {\\n        dist[u] = curr_dist;\\n        \\n        if(edges[u] != -1 && dist[edges[u]] == INT_MAX)\\n        {\\n            dfs(edges, edges[u], dist, curr_dist + 1);\\n        }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        int n = edges.size();\\n        \\n        // call dfs and find the distance of all the nodes from node1\\n        \\n        vector<int> dist1(n, INT_MAX);\\n        \\n        dist1[node1] = 0;\\n        \\n        dfs(edges, node1, dist1, 0);\\n        \\n        // call dfs and find the distance of all nodes from node1\\n        \\n        vector<int> dist2(n, INT_MAX);\\n        \\n        dist2[node2] = 0;\\n        \\n        dfs(edges, node2, dist2, 0);\\n        \\n        // find the index of the node\\n        \\n        int mini = INT_MAX;\\n        \\n        int min_idx = -1;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dist1[i] != INT_MAX && dist2[i] != INT_MAX)\\n            {\\n                int max_dist = max(dist1[i], dist2[i]);\\n                \\n                if(max_dist < mini)\\n                {\\n                    mini = max_dist;\\n                    \\n                    min_idx = i;\\n                }\\n            }\\n        }\\n        \\n        return min_idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479845,
                "title": "intuition-explained-shortest-path-algorithms-c-clean-code",
                "content": "**Intution :**\\n\\n* Idea here is to find length of shortest paths from given `node1` and `node2` considering it as source node.\\n\\n* After this, for all intersecting nodes, i.e we can reach node from both given nodes\\n\\t* get the minimum distance among all maximums.\\n\\t* **`dist = max(dist_1[i], dist_2[i])`** , max dist to reach ith node from given 2 source nodes.\\n* To find length of shortest paths, we can use any algorithm : \\n\\t* 0-1 BFS -> O(N)\\n\\t* Dijkstra\\'s Algo -> O(N logN)\\n\\nGo through below code and check comments to get better understanding\\n# Code : \\n\\n```\\nclass Solution {\\nprivate:\\n    \\n\\t// Get length of shortest path for all nodes from given source node\\n\\t\\n\\t// Using 0-1 BFS algorithm -> O(N)\\n    vector<int> zero_one_bfs(vector<vector<pair<int, int>>>& adj, int source, int n) {\\n        deque<pair<int, int>> dq;\\n        vector<int> dist(n, INT_MAX);\\n\\n        dist[source] = 0;\\n        dq.push_front({source, 0});\\n\\n        while(dq.size()) {\\n            int node = dq.front().first;\\n            int dis = dq.front().second;\\n            dq.pop_front();\\n\\n            for(auto& it : adj[node]) {\\n                int adjNode = it.first;\\n                int wt = it.second;\\n\\n                if(dis + wt < dist[adjNode]) {\\n                    dist[adjNode] = dis + wt;\\n                    if(wt == 1) {\\n                        dq.push_back({adjNode, dis + wt});\\n                    }\\n                    else {\\n                        dq.push_front({adjNode, dis + wt});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist;\\n    }\\n    \\n\\t// Using 0-1 BFS algorithm -> O(N logN)\\n    vector<int> djikstra(vector<vector<pair<int, int>>>& adj, int source, int n) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        vector<int> dist(n, INT_MAX);\\n        vector<int> parent(n);\\n\\n        dist[source] = 0;\\n        parent[source] = source;\\n        pq.push({0, source});\\n\\n        while(pq.size()) {\\n            int dis = pq.top().first;\\n            int node = pq.top().second;\\n            \\n            pq.pop();\\n\\n            for(auto& it : adj[node]) {\\n                int adjNode = it.first;\\n                int wt = it.second;\\n\\n                if(dis + wt < dist[adjNode]) {\\n                    dist[adjNode] = dis + wt;\\n                    parent[adjNode] = node;\\n                    pq.push({dis + wt, adjNode});\\n                }\\n            }\\n        }\\n        \\n        return dist;\\n    }\\n    \\npublic:\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        int n = edges.size();\\n        \\n\\t\\t// Create a adjacency matrix (graph) using edges\\n        vector<vector<pair<int, int>>> graph(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            if(edges[i] != -1) {\\n                graph[i].push_back({edges[i], 1});\\n            }\\n        }\\n        \\n\\t\\t// Get shortest path to all nodes from given source\\n        vector<int> dist_1 = zero_one_bfs(graph, node1, n);\\n        vector<int> dist_2 = zero_one_bfs(graph, node2, n);\\n        \\n        int minDist = INT_MAX, node = -1;\\n        \\n\\t\\t// Find the minimum among all maximum distance\\n        for(int i=0; i<n; i++) {\\n            int dist = max(dist_1[i], dist_2[i]);\\n            if(dist < minDist) {\\n                minDist = dist;\\n                node = i;\\n            }\\n        }\\n        \\n        return node;\\n    }\\n};\\n```\\n\\n**Complexity :**\\n\\n* **Time :** `O(2X + N)`, \\n\\t* `O(X)` is complexity of shortest path algo\\n\\t* `O(N)` to get minimum of maximum common distance from given nodes\\n* **Space :** `O(N)`\\n\\n***If you find this helpful, do give it a like :)***",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    \\n\\t// Get length of shortest path for all nodes from given source node\\n\\t\\n\\t// Using 0-1 BFS algorithm -> O(N)\\n    vector<int> zero_one_bfs(vector<vector<pair<int, int>>>& adj, int source, int n) {\\n        deque<pair<int, int>> dq;\\n        vector<int> dist(n, INT_MAX);\\n\\n        dist[source] = 0;\\n        dq.push_front({source, 0});\\n\\n        while(dq.size()) {\\n            int node = dq.front().first;\\n            int dis = dq.front().second;\\n            dq.pop_front();\\n\\n            for(auto& it : adj[node]) {\\n                int adjNode = it.first;\\n                int wt = it.second;\\n\\n                if(dis + wt < dist[adjNode]) {\\n                    dist[adjNode] = dis + wt;\\n                    if(wt == 1) {\\n                        dq.push_back({adjNode, dis + wt});\\n                    }\\n                    else {\\n                        dq.push_front({adjNode, dis + wt});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return dist;\\n    }\\n    \\n\\t// Using 0-1 BFS algorithm -> O(N logN)\\n    vector<int> djikstra(vector<vector<pair<int, int>>>& adj, int source, int n) {\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\\n        vector<int> dist(n, INT_MAX);\\n        vector<int> parent(n);\\n\\n        dist[source] = 0;\\n        parent[source] = source;\\n        pq.push({0, source});\\n\\n        while(pq.size()) {\\n            int dis = pq.top().first;\\n            int node = pq.top().second;\\n            \\n            pq.pop();\\n\\n            for(auto& it : adj[node]) {\\n                int adjNode = it.first;\\n                int wt = it.second;\\n\\n                if(dis + wt < dist[adjNode]) {\\n                    dist[adjNode] = dis + wt;\\n                    parent[adjNode] = node;\\n                    pq.push({dis + wt, adjNode});\\n                }\\n            }\\n        }\\n        \\n        return dist;\\n    }\\n    \\npublic:\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        int n = edges.size();\\n        \\n\\t\\t// Create a adjacency matrix (graph) using edges\\n        vector<vector<pair<int, int>>> graph(n);\\n        \\n        for(int i=0; i<n; i++) {\\n            if(edges[i] != -1) {\\n                graph[i].push_back({edges[i], 1});\\n            }\\n        }\\n        \\n\\t\\t// Get shortest path to all nodes from given source\\n        vector<int> dist_1 = zero_one_bfs(graph, node1, n);\\n        vector<int> dist_2 = zero_one_bfs(graph, node2, n);\\n        \\n        int minDist = INT_MAX, node = -1;\\n        \\n\\t\\t// Find the minimum among all maximum distance\\n        for(int i=0; i<n; i++) {\\n            int dist = max(dist_1[i], dist_2[i]);\\n            if(dist < minDist) {\\n                minDist = dist;\\n                node = i;\\n            }\\n        }\\n        \\n        return node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371550,
                "title": "swift-fastest-bfs-dfs-fully-explained",
                "content": "Not sure why other Swift solutions are using DFS-style with recursion. DFS-style creates two full paths before evaluations. Also, many solutions are labeled as BFS when they build only one path at a time (meaning they are actually DFS). The fastest solution below uses BFS to build both paths simultaneously and early-outs when an answer is determined. Scroll to bottom for full explanation.\\n\\n**BFS, Fastest Approach (accepted answer)**\\n```\\nclass Solution {\\n    func closestMeetingNode(_ edges: [Int], _ node1: Int, _ node2: Int) -> Int {\\n        var node1 = node1, node2 = node2\\n        var visited1 = Set<Int>(), visited2 = Set<Int>()\\n        while node1 > -1 || node2 > -1 {\\n            let (v1, v2) = (visited2.contains(node1), visited1.contains(node2))\\n            if v1 || v2 || node1 == node2 {\\n                return v1 && v2 ? min(node1, node2) : v1 ? node1 : node2 \\n            }            \\n            visited1.insert(node1)\\n            visited2.insert(node2)\\n            node1 = node1 > -1 && !visited1.contains(edges[node1]) ? edges[node1] : -1\\n            node2 = node2 > -1 && !visited2.contains(edges[node2]) ? edges[node2] : -1\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n---\\n\\n**For curiosity: Slower, Alternate Approach (DFS) (accepted answer)**\\n```\\nclass Solution {\\n    func closestMeetingNode(_ edges: [Int], _ node1: Int, _ node2: Int) -> Int {\\n        func createPath(for node: Int) -> [Int: Int] {\\n            var result = [-1: Int.max], counter = 0, node = node\\n            while result[node] == nil {\\n                result[node] = counter\\n                counter += 1\\n                node = edges[node]\\n            }\\n            return result\\n        }\\n        \\n        let p1 = createPath(for: node1), p2 = createPath(for: node2)\\n        let dict = Set(p1.keys).intersection(Set(p2.keys)).map{node in (node: node, dist: max(p1[node]!,p2[node]!))}\\n        return dict.sorted { a,b in a.dist == b.dist ? a.node < b.node : a.dist < b.dist }.first?.node ?? -1\\n    }\\n}\\n```\\n\\n---\\n\\n**SOLUTION EXPLANATION**\\n\\n**DFS APPROACH**\\nAs mentioned above, and present in the above DFS code, the DFS approach builds both paths into a data structure and then processes the data structure. In building the paths, cycles need to be detected. For this problem using DFS, it is OK to return the path once a cycle is detected.\\n\\n**BFS APPROACH**\\nBFS is a better approach. Both paths are built node-by-node at the same time. We can evaluate the paths for \"closest meeting node\" at each step, which means the paths will only need to be partially constructed instead of fully constructed as with DFS. We need to check for cycles here because both paths may be stuck on their own cycle, and there is no solution for that test case.\\n\\n1) We track two variables `node1` and `node2`.  We\\'ll step both of these together in the path. \\n2) Each time we move both nodes one step forward in the path, we evaluate for completion.\\n\\t* One of these paths may end and we\\'ll need to keep stepping the other path until a solution, if any, is determined.\\n\\t* One or both of these paths may turn into a cycle, when a cycle is detected, the stepping for that path ends.\\n3) If both paths have ended, there is no solution so return `-1`\\n\\n**BFS IMPLEMENTATION**\\n\\n**Data Structures**\\n1) We\\'ll shadow the incoming constants `node1` and `node2` as loop control variables.\\n2) We\\'ll have two unordered sets `visited1` and `visited2` to record the respective nodes already processed for the two paths.\\n\\t\\n**Algorithm**\\n1) We start with `node1` and `node2` about to be processed.\\n2) For both nodes: If the `visted` set for the other `node` contains this `node`, then we\\'ve found the closest node to the others and return that node. Since this is BFS, each path may simultaneously land on a different node that the other path has already seen, the problem statement instructs us to return the lowest node number of those two. Also, both paths may step to the same node at the same time, so return that node number.\\n\\n**Step 2, in code:**\\n```\\nlet (v1, v2) = (visited2.contains(node1), visited1.contains(node2))\\nif v1 || v2 || node1 == node2 {\\n\\treturn v1 && v2 ? min(node1, node2) : v1 ? node1 : node2 \\n}           \\n```\\n\\n3) Mark each node as visited.\\n\\n**Step 3, in code:**\\n``` \\nvisited1.insert(node1)\\nvisited2.insert(node2)\\n```\\n\\n4) Step each node over the next edge. If we\\'ve seen either node before, step it to `-1` to effectively break the cycle. If the node is already at `-1` then keep it there and iterate the other node.\\n\\n**Step 4, in code:**\\n```\\n            node1 = node1 > -1 && !visited1.contains(edges[node1]) ? edges[node1] : -1\\n            node2 = node2 > -1 && !visited2.contains(edges[node2]) ? edges[node2] : -1\\n```        \\n\\t\\t\\n5) If one of the nodes is not `-1`, then jump up to step 2 for the next iteration. If both are `-1`, then there is no solution and return `-1` to the caller.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func closestMeetingNode(_ edges: [Int], _ node1: Int, _ node2: Int) -> Int {\\n        var node1 = node1, node2 = node2\\n        var visited1 = Set<Int>(), visited2 = Set<Int>()\\n        while node1 > -1 || node2 > -1 {\\n            let (v1, v2) = (visited2.contains(node1), visited1.contains(node2))\\n            if v1 || v2 || node1 == node2 {\\n                return v1 && v2 ? min(node1, node2) : v1 ? node1 : node2 \\n            }            \\n            visited1.insert(node1)\\n            visited2.insert(node2)\\n            node1 = node1 > -1 && !visited1.contains(edges[node1]) ? edges[node1] : -1\\n            node2 = node2 > -1 && !visited2.contains(edges[node2]) ? edges[node2] : -1\\n        }\\n        return -1\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func closestMeetingNode(_ edges: [Int], _ node1: Int, _ node2: Int) -> Int {\\n        func createPath(for node: Int) -> [Int: Int] {\\n            var result = [-1: Int.max], counter = 0, node = node\\n            while result[node] == nil {\\n                result[node] = counter\\n                counter += 1\\n                node = edges[node]\\n            }\\n            return result\\n        }\\n        \\n        let p1 = createPath(for: node1), p2 = createPath(for: node2)\\n        let dict = Set(p1.keys).intersection(Set(p2.keys)).map{node in (node: node, dist: max(p1[node]!,p2[node]!))}\\n        return dict.sorted { a,b in a.dist == b.dist ? a.node < b.node : a.dist < b.dist }.first?.node ?? -1\\n    }\\n}\\n```\n```\\nlet (v1, v2) = (visited2.contains(node1), visited1.contains(node2))\\nif v1 || v2 || node1 == node2 {\\n\\treturn v1 && v2 ? min(node1, node2) : v1 ? node1 : node2 \\n}           \\n```\n``` \\nvisited1.insert(node1)\\nvisited2.insert(node2)\\n```\n```\\n            node1 = node1 > -1 && !visited1.contains(edges[node1]) ? edges[node1] : -1\\n            node2 = node2 > -1 && !visited2.contains(edges[node2]) ? edges[node2] : -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364787,
                "title": "understandable-easy-code-using-hashmaps-with-thought-process",
                "content": "Thought Process--\\n1.I have created hasmaps for each given nodes node1 and node2.\\n 2.These hashmaps stores the information about the distance of a particular node from the starting node. either node1 or node2.\\n 3.After that just minimising the greatest distance taken by any of the node1 or node2 to a particular node.\\n \\n one optimisation is that one can use two arrays instead of hashmaps else is the same\\n or try bfs instead of dfs  \\n  logic will remain same\\n\\n```\\nclass Solution {\\n    public static void solve(boolean[] vis,ArrayList<Integer>[] graph,int node,HashMap<Integer,Integer>mp_1,int dist){\\n        mp_1.put(node,dist);\\n        System.out.println(node+ \" \"+ dist);\\n        vis[node]=true;\\n        for(int n: graph[node]){\\n            if(n!=-1 && vis[n]==false){\\n                System.out.println(node+\"*\"+n);\\n              solve(vis,graph,n,mp_1,dist+1);\\n            }\\n        }\\n    }\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int m=edges.length;\\n        ArrayList<Integer>[] graph=new ArrayList[m];\\n        for(int i=0;i<m;i++){\\n            graph[i]=new ArrayList();\\n            graph[i].add(edges[i]);\\n        }\\n        \\n\\n        HashMap<Integer,Integer>mp_1=new HashMap<>();\\n        HashMap<Integer,Integer>mp_2=new HashMap<>();\\n        \\n        solve(new boolean[m],graph,node1,mp_1,0);\\n        System.out.println(\"node2\");\\n        solve(new boolean[m],graph,node2,mp_2,0);\\n         \\n        int min=Integer.MAX_VALUE;\\n        int ele=Integer.MAX_VALUE;\\n        for(int i=0;i<m;i++){\\n            if(mp_1.containsKey(i)==true && mp_2.containsKey(i)==true){\\n                if(Math.max(mp_1.get(i),mp_2.get(i))<min){\\n                    min=Math.max(mp_1.get(i),mp_2.get(i));\\n                    ele=i;\\n                }\\n            }\\n        }\\n        \\n        return ele==Integer.MAX_VALUE ? -1: ele;\\n        \\n    }\\n}\\n\\n\\n** upvote if you like\\n...",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public static void solve(boolean[] vis,ArrayList<Integer>[] graph,int node,HashMap<Integer,Integer>mp_1,int dist){\\n        mp_1.put(node,dist);\\n        System.out.println(node+ \" \"+ dist);\\n        vis[node]=true;\\n        for(int n: graph[node]){\\n            if(n!=-1 && vis[n]==false){\\n                System.out.println(node+\"*\"+n);\\n              solve(vis,graph,n,mp_1,dist+1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2358785,
                "title": "c-dfs-100-runtime-easy-to-read",
                "content": "**DFS Solution**\\n```cpp\\nvector<vector<int>> graph;\\nvoid dfs(int start, int d, vector<int>& visited, vector<int>& dist){\\n    if(visited[start] != 0) return;\\n    visited[start] = 1;\\n    dist[start] = d; //update distance to node\\n\\n    for(int child: graph[start]){\\n        dfs(child, d+1, visited, dist);\\n    }\\n}\\n\\nint closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n    int n = edges.size();\\n    graph.resize(n);\\n\\n\\t//build graph\\n\\tfor(int i=0; i<n; i++){\\n        if(edges[i] != -1) graph[i].push_back(edges[i]);\\n\\t}\\n\\n    vector<int> visited1(n,0), visited2(n, 0);\\n    vector<int> dist1(n, INT_MAX), dist2 (n, INT_MAX);\\n    dfs(node1, 0, visited1, dist1);\\n    dfs(node2, 0, visited2, dist2);\\n\\n    int minNode = -1;\\n    for(int i=0; i<n; i++){\\n\\t\\t//min-max of distance i.e. maximum of any node dist, but minimum of them.\\n        if((minNode == -1 || max(dist1[i], dist2[i]) < max(dist1[minNode], dist2[minNode])) && visited1[i] && visited2[i])\\n            minNode = i;\\n\\t}\\n    return minNode;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nvector<vector<int>> graph;\\nvoid dfs(int start, int d, vector<int>& visited, vector<int>& dist){\\n    if(visited[start] != 0) return;\\n    visited[start] = 1;\\n    dist[start] = d; //update distance to node\\n\\n    for(int child: graph[start]){\\n        dfs(child, d+1, visited, dist);\\n    }\\n}\\n\\nint closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n    int n = edges.size();\\n    graph.resize(n);\\n\\n\\t//build graph\\n\\tfor(int i=0; i<n; i++){\\n        if(edges[i] != -1) graph[i].push_back(edges[i]);\\n\\t}\\n\\n    vector<int> visited1(n,0), visited2(n, 0);\\n    vector<int> dist1(n, INT_MAX), dist2 (n, INT_MAX);\\n    dfs(node1, 0, visited1, dist1);\\n    dfs(node2, 0, visited2, dist2);\\n\\n    int minNode = -1;\\n    for(int i=0; i<n; i++){\\n\\t\\t//min-max of distance i.e. maximum of any node dist, but minimum of them.\\n        if((minNode == -1 || max(dist1[i], dist2[i]) < max(dist1[minNode], dist2[minNode])) && visited1[i] && visited2[i])\\n            minNode = i;\\n\\t}\\n    return minNode;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2358325,
                "title": "wrong-test-case",
                "content": "[4,4,8,-1,9,8,4,4,1,1]\\nnode1 - 5\\nnode2  -6\\nAns given for this test case is 1\\nshouldn\\'t this be 4??",
                "solutionTags": [
                    "C"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2357684,
                "title": "python3-dijkstra-shortest-path-algorithm-explained",
                "content": "Use dijkstras or bfs to find the shortest path from node1 to all remaining  nodes and from node2 to all remaining nodes.\\n\\nThen find the node reachable from both node1 and node2 ie it should be present in the distance dictionary returned by dijkstras.\\nThis can be achieved by checking if the node is present as keys in both the dictionaries.\\n\\nCheck if the max() of the distance is lesser than the previous minimum.\\nIf so we update the distance and save the node.\\n\\nFinally return the node.\\n\\n```\\ndef dijkstras(src,adjL):\\n    queue = deque()\\n\\n    distance = {src:0} #dist of source to itself = 0\\n    queue.append((0,src)) #<dist,dest>\\n\\n    while queue:\\n        w,src= queue.popleft()\\n\\n        #all the neighbours of node popped\\n        for wt,nei in adjL[src]:\\n            #path already exists,check if there is a better path\\n            if nei in distance:\\n                #if new path has smaller distance to the nei, update its distance\\n                if (w+wt) < distance[nei]:\\n                    distance[nei] = w+wt\\n                    queue.append((w+wt,nei))\\n            #no path till now between the pair of nodes\\n            else:\\n                #if no path found till now,this is the first best path\\n                distance[nei] = w+wt\\n                queue.append((w+wt,nei))\\n\\n    return distance\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        adj = [[] for _ in range(len(edges))]\\n        for i in range(len(edges)):\\n            if edges[i]!=-1:\\n                adj[i].append((1,edges[i]))\\n\\n        dist1 = dijkstras(node1,adj)\\n        dist2 = dijkstras(node2,adj)\\n\\n        ans = {\\'dist\\':inf,\\'node\\':-1}\\n        for node in range(len(edges)):\\n            if node in dist1 and node in dist2:\\n                d1,d2 = dist1[node],dist2[node]\\n                max_dist = max(d1,d2)\\n\\n                if max_dist<ans[\\'dist\\']:\\n                    ans[\\'dist\\'] = max_dist\\n                    ans[\\'node\\'] = node\\n\\n        return ans[\\'node\\']\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef dijkstras(src,adjL):\\n    queue = deque()\\n\\n    distance = {src:0} #dist of source to itself = 0\\n    queue.append((0,src)) #<dist,dest>\\n\\n    while queue:\\n        w,src= queue.popleft()\\n\\n        #all the neighbours of node popped\\n        for wt,nei in adjL[src]:\\n            #path already exists,check if there is a better path\\n            if nei in distance:\\n                #if new path has smaller distance to the nei, update its distance\\n                if (w+wt) < distance[nei]:\\n                    distance[nei] = w+wt\\n                    queue.append((w+wt,nei))\\n            #no path till now between the pair of nodes\\n            else:\\n                #if no path found till now,this is the first best path\\n                distance[nei] = w+wt\\n                queue.append((w+wt,nei))\\n\\n    return distance\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        adj = [[] for _ in range(len(edges))]\\n        for i in range(len(edges)):\\n            if edges[i]!=-1:\\n                adj[i].append((1,edges[i]))\\n\\n        dist1 = dijkstras(node1,adj)\\n        dist2 = dijkstras(node2,adj)\\n\\n        ans = {\\'dist\\':inf,\\'node\\':-1}\\n        for node in range(len(edges)):\\n            if node in dist1 and node in dist2:\\n                d1,d2 = dist1[node],dist2[node]\\n                max_dist = max(d1,d2)\\n\\n                if max_dist<ans[\\'dist\\']:\\n                    ans[\\'dist\\'] = max_dist\\n                    ans[\\'node\\'] = node\\n\\n        return ans[\\'node\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100991,
                "title": "c-simple-easy-to-understand-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int currNode, vector<int> &edges, vector<int> &dis_node, vector<bool> &visited, int currDist){\\n        if(currNode != -1 && !visited[currNode]){  // dfs will call if node is node -1 as well as it have to connect to the next if not then dfs ends\\n            visited[currNode] = true;\\n            dis_node[currNode] = currDist;\\n            return dfs(edges[currNode], edges, dis_node, visited, currDist + 1);\\n        }\\n        return;\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int> dis_node1(edges.size(), -1);  // all distances from node1\\n        vector<int> dis_node2(edges.size(), -1);  // // all distances from node2\\n        vector<bool> visited(edges.size(), false);  // wheather the node is visited or not\\n        \\n        dfs(node1, edges, dis_node1, visited, 0);  // dfs call for node1\\n        visited.assign(edges.size(), false);  // reassign visited array to all false\\n        dfs(node2, edges, dis_node2, visited, 0); //  dfs call for node2\\n        \\n        int mini_dis = INT_MAX;  // assigning the min distance as INT_MAX\\n        int ans_node = -1;    // assigning the ans node as -1 if none is ans we have to return ans as -1\\n        for(int i = 0;i<edges.size();i++){  // loop through the distance array\\n            if(dis_node1[i] != -1 && dis_node2[i] != -1){  // the distance from node1, node2 to i is not -1 then we can consider for the ans\\n                if(mini_dis > max(dis_node1[i], dis_node2[i])){  // if we find less disstance than previous then we can change our ans_node\\n                    mini_dis = max(dis_node1[i], dis_node2[i]);\\n                    ans_node = i;\\n                }\\n            }\\n        }\\n        return ans_node;\\n        \\n    }\\n};\\n/* Please upvote if you find the solution usefull*/\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(int currNode, vector<int> &edges, vector<int> &dis_node, vector<bool> &visited, int currDist){\\n        if(currNode != -1 && !visited[currNode]){  // dfs will call if node is node -1 as well as it have to connect to the next if not then dfs ends\\n            visited[currNode] = true;\\n            dis_node[currNode] = currDist;\\n            return dfs(edges[currNode], edges, dis_node, visited, currDist + 1);\\n        }\\n        return;\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int> dis_node1(edges.size(), -1);  // all distances from node1\\n        vector<int> dis_node2(edges.size(), -1);  // // all distances from node2\\n        vector<bool> visited(edges.size(), false);  // wheather the node is visited or not\\n        \\n        dfs(node1, edges, dis_node1, visited, 0);  // dfs call for node1\\n        visited.assign(edges.size(), false);  // reassign visited array to all false\\n        dfs(node2, edges, dis_node2, visited, 0); //  dfs call for node2\\n        \\n        int mini_dis = INT_MAX;  // assigning the min distance as INT_MAX\\n        int ans_node = -1;    // assigning the ans node as -1 if none is ans we have to return ans as -1\\n        for(int i = 0;i<edges.size();i++){  // loop through the distance array\\n            if(dis_node1[i] != -1 && dis_node2[i] != -1){  // the distance from node1, node2 to i is not -1 then we can consider for the ans\\n                if(mini_dis > max(dis_node1[i], dis_node2[i])){  // if we find less disstance than previous then we can change our ans_node\\n                    mini_dis = max(dis_node1[i], dis_node2[i]);\\n                    ans_node = i;\\n                }\\n            }\\n        }\\n        return ans_node;\\n        \\n    }\\n};\\n/* Please upvote if you find the solution usefull*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100185,
                "title": "python3-easy-solution-with-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**We want minimum of maximum distance of node1 and node2 to common node, hearing this triggers dfs or bfs in our mind.**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**In this dfs will be more useful to us because outgoing edge is only one so using depth traversal over level order traversal is helpful.**\\n\\n---\\n\\n\\n1. First make distance array for node1 and node2.\\n2. Mark all distance form node1 and node2 to i infinity.\\n3. Apply dfs travesal over graph from node1 and node2.\\n4. Increse distance when non visited node and reachable node found.\\n5. Make sure that assigning distance is less than previous or move forvard, because it can be case when we reach to some nodeI from nodeA and nodeB, so Only assign distance of less weight\\n6. Now traverse all node in dist_array for node1 and node2\\n7. Find maximum distance of common node from node1 and node2\\n8. if found curr_max_distance is less than previous then save it and take it\\'s index.\\n9. return found index\\n\\n# Complexity\\n- Time complexity: $$O(2V+2E+n)$$\\n\\n- Space complexity: $$O(2V+n+1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        visited = [False for _ in range(len(edges))]\\n        n1 = [float(\"inf\") for _ in range(len(edges))]\\n        n2 = [float(\"inf\") for _ in range(len(edges))]\\n\\n        def helper_dfs(node=0, dist_array=[], distance=0):\\n            nonlocal visited\\n            if node+1 and not visited[node]:\\n                visited[node] = True\\n                if distance < dist_array[node]:\\n                    dist_array[node] = distance if node != edges[node] else 0\\n                    print(f\\'{node}->{edges[node]}: {distance}\\')\\n                    helper_dfs(edges[node], dist_array, distance + 1)\\n                visited[node] = False\\n            return\\n        helper_dfs(node1, n1)\\n        helper_dfs(node2, n2)\\n        print(n1, n2)\\n        maxi_mini = float(\"inf\")\\n        ind = -1\\n        for i in range(len(edges)):\\n            curr = max(n1[i], n2[i])\\n            if maxi_mini > curr:\\n                maxi_mini = curr\\n                ind = i\\n        return ind\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        visited = [False for _ in range(len(edges))]\\n        n1 = [float(\"inf\") for _ in range(len(edges))]\\n        n2 = [float(\"inf\") for _ in range(len(edges))]\\n\\n        def helper_dfs(node=0, dist_array=[], distance=0):\\n            nonlocal visited\\n            if node+1 and not visited[node]:\\n                visited[node] = True\\n                if distance < dist_array[node]:\\n                    dist_array[node] = distance if node != edges[node] else 0\\n                    print(f\\'{node}->{edges[node]}: {distance}\\')\\n                    helper_dfs(edges[node], dist_array, distance + 1)\\n                visited[node] = False\\n            return\\n        helper_dfs(node1, n1)\\n        helper_dfs(node2, n2)\\n        print(n1, n2)\\n        maxi_mini = float(\"inf\")\\n        ind = -1\\n        for i in range(len(edges)):\\n            curr = max(n1[i], n2[i])\\n            if maxi_mini > curr:\\n                maxi_mini = curr\\n                ind = i\\n        return ind\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099686,
                "title": "java-bfs-single-queue-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse BFS to traverse in parallel from both `node1` and `node2`. Keep track of all the seen nodes from each starting node. Once we find a common node between the two sets we return the answer.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use a single queue and BFS algorithm to traverse the graph is parallel from `node1` and `node2`.\\n2. Keep track of all the seen nodes so far from both starting nodes.\\n3. Each node has at most one directed neighbor. So we will process at most two nodes at each BFS level (one for each starting node).\\n4. If a node from one of the sets is already in the other set, remember it as a potential answer. The final answer is the minimum of the two nodes processed at the current BFS level that are present in both the sets.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int closestMeetingNode(int[] edges, int node1, int node2) {\\n    int n = edges.length;\\n    boolean[] seen1 = new boolean[n];\\n    boolean[] seen2 = new boolean[n];\\n\\n    Queue<int[]> queue = new ArrayDeque<>();\\n    queue.offer(new int[] {1, node1});\\n    queue.offer(new int[] {2, node2});\\n\\n    while (!queue.isEmpty()) {\\n      int ans = Integer.MAX_VALUE;\\n\\n      for (int i = queue.size(); i > 0; i--) {\\n        int[] node = queue.poll();\\n        boolean[] s1 = node[0] == 1 ? seen1 : seen2;\\n        boolean[] s2 = node[0] == 1 ? seen2 : seen1;\\n\\n        if (s1[node[1]]) continue;\\n        if (s2[node[1]]) ans = Math.min(ans, node[1]);\\n\\n        s1[node[1]] = true;\\n        if (edges[node[1]] != -1)\\n          queue.offer(new int[] {node[0], edges[node[1]]});\\n      }\\n      if (ans != Integer.MAX_VALUE) return ans;\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n  public int closestMeetingNode(int[] edges, int node1, int node2) {\\n    int n = edges.length;\\n    boolean[] seen1 = new boolean[n];\\n    boolean[] seen2 = new boolean[n];\\n\\n    Queue<int[]> queue = new ArrayDeque<>();\\n    queue.offer(new int[] {1, node1});\\n    queue.offer(new int[] {2, node2});\\n\\n    while (!queue.isEmpty()) {\\n      int ans = Integer.MAX_VALUE;\\n\\n      for (int i = queue.size(); i > 0; i--) {\\n        int[] node = queue.poll();\\n        boolean[] s1 = node[0] == 1 ? seen1 : seen2;\\n        boolean[] s2 = node[0] == 1 ? seen2 : seen1;\\n\\n        if (s1[node[1]]) continue;\\n        if (s2[node[1]]) ans = Math.min(ans, node[1]);\\n\\n        s1[node[1]] = true;\\n        if (edges[node[1]] != -1)\\n          queue.offer(new int[] {node[0], edges[node[1]]});\\n      }\\n      if (ans != Integer.MAX_VALUE) return ans;\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099448,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    BFS\\n\\n# Code\\n```\\n#define maxn 100005\\nclass Solution {\\npublic:\\n    vector<int> g[maxn];\\n    void bfs(int s, vector<int> &vis, vector<int> &dis) {\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto v: g[u]) {\\n                if(!vis[v]) {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> vis1(n), vis2(n), dis1(n, -1), dis2(n, -1);\\n        for(int i=0; i<n; i++) if(edges[i] != -1) g[i].push_back(edges[i]);\\n        bfs(node1, vis1, dis1);\\n        bfs(node2, vis2, dis2);\\n        int ans = -1, mn_dis = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            if(dis1[i] != -1 and dis2[i] != -1) {\\n                int dis = max(dis1[i], dis2[i]);\\n                if(dis < mn_dis) {\\n                    mn_dis = dis;\\n                    ans = i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define maxn 100005\\nclass Solution {\\npublic:\\n    vector<int> g[maxn];\\n    void bfs(int s, vector<int> &vis, vector<int> &dis) {\\n        vis[s] = 1;\\n        dis[s] = 0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty()) {\\n            int u = q.front();\\n            q.pop();\\n            for(auto v: g[u]) {\\n                if(!vis[v]) {\\n                    vis[v] = 1;\\n                    dis[v] = dis[u] + 1;\\n                    q.push(v);\\n                }\\n            }\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> vis1(n), vis2(n), dis1(n, -1), dis2(n, -1);\\n        for(int i=0; i<n; i++) if(edges[i] != -1) g[i].push_back(edges[i]);\\n        bfs(node1, vis1, dis1);\\n        bfs(node2, vis2, dis2);\\n        int ans = -1, mn_dis = INT_MAX;\\n        for(int i=0; i<n; i++) {\\n            if(dis1[i] != -1 and dis2[i] != -1) {\\n                int dis = max(dis1[i], dis2[i]);\\n                if(dis < mn_dis) {\\n                    mn_dis = dis;\\n                    ans = i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098806,
                "title": "day-49-d-graph-clean-optamized-7-lines-100-vs-138ms-meme",
                "content": "![memecat.jpeg](https://assets.leetcode.com/users/images/f72f8313-8b39-435f-b0d6-5b214e58047b_1674667458.2701185.jpeg)\\n\\n# IDEA\\nFILL INT ARRAY WITH -VE VALUE & MAKE USE FOR VISITED ARRAY\\n\\n![image.png](https://assets.leetcode.com/users/images/cd4d870e-fa40-4fc2-a320-fe6988a8b14c_1674671061.1410108.png)\\n\\n# Complexity\\n- Time complexity: o(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: o(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# java\\n```\\npublic int closestMeetingNode(int[] edges, int node1, int node2) {\\nint length = edges.length, res = -1, minValue = Integer.MAX_VALUE, distance1[] = new int[length], distance2[] = new int[length];\\nArrays.fill(distance1, -1);\\nArrays.fill(distance2, -1);\\nfor (int currentIndex = node1, distance = 0; currentIndex != -1 && distance1[currentIndex] == -1; currentIndex = edges[currentIndex], distance++) distance1[currentIndex] = distance;\\nfor (int index = node2, distance = 0; index != -1 && distance2[index] == -1; index = edges[index], distance++) {\\n    distance2[index] = distance;\\n    int maxDistance = Math.max(distance1[index], distance2[index]);\\n    if (distance1[index] != -1 && maxDistance <= minValue) {\\n        res = maxDistance == minValue ? Math.min(res, index) : index;\\n        minValue = Math.min(minValue, maxDistance);\\n    }\\n} return res; }\\n```\\n# c++\\n```\\nint closestMeetingNode(vector<int>& e, int node1, int node2,int res=-1,int min_dist = INT_MAX) {\\n    int n=e.size();vector<int> m1(n, -1), m2(n, -1);\\n    for (int i = node1, dist = 0; i != -1 && m1[i] == -1; i = e[i]) m1[i] = dist++;\\n    for (int i = node2, dist = 0; i != -1 && m2[i] == -1; i = e[i]) {\\n        m2[i] = dist++;int mx=max(m1[i], m2[i]);\\n        if (m1[i] >= 0 && mx <= min_dist) {\\n            res = mx == min_dist ? min(i, res) : i;\\n            min_dist =mx;\\n        }\\n    } return res; }\\n```\\n# py\\n```\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        q = [(node1,1),(node2,2)]\\n        visited = [0]*len(edges)\\n        ans = inf\\n        while q:\\n            new = []\\n            f = False\\n            for a,w in q:\\n                if visited[a]==0:\\n                    if edges[a]!=-1:\\n                        new.append((edges[a],w))\\n                    visited[a] = w\\n                elif visited[a]!=w:\\n                    f = True\\n                    ans = min(a,ans)        \\n            if f:\\n                return ans       \\n            q = new\\n        return -1",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Graph"
                ],
                "code": "```\\npublic int closestMeetingNode(int[] edges, int node1, int node2) {\\nint length = edges.length, res = -1, minValue = Integer.MAX_VALUE, distance1[] = new int[length], distance2[] = new int[length];\\nArrays.fill(distance1, -1);\\nArrays.fill(distance2, -1);\\nfor (int currentIndex = node1, distance = 0; currentIndex != -1 && distance1[currentIndex] == -1; currentIndex = edges[currentIndex], distance++) distance1[currentIndex] = distance;\\nfor (int index = node2, distance = 0; index != -1 && distance2[index] == -1; index = edges[index], distance++) {\\n    distance2[index] = distance;\\n    int maxDistance = Math.max(distance1[index], distance2[index]);\\n    if (distance1[index] != -1 && maxDistance <= minValue) {\\n        res = maxDistance == minValue ? Math.min(res, index) : index;\\n        minValue = Math.min(minValue, maxDistance);\\n    }\\n} return res; }\\n```\n```\\nint closestMeetingNode(vector<int>& e, int node1, int node2,int res=-1,int min_dist = INT_MAX) {\\n    int n=e.size();vector<int> m1(n, -1), m2(n, -1);\\n    for (int i = node1, dist = 0; i != -1 && m1[i] == -1; i = e[i]) m1[i] = dist++;\\n    for (int i = node2, dist = 0; i != -1 && m2[i] == -1; i = e[i]) {\\n        m2[i] = dist++;int mx=max(m1[i], m2[i]);\\n        if (m1[i] >= 0 && mx <= min_dist) {\\n            res = mx == min_dist ? min(i, res) : i;\\n            min_dist =mx;\\n        }\\n    } return res; }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3098448,
                "title": "easy-to-understand-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> check1;\\n    vector<int> check2;\\n    \\n    void dfs(int i, int node, vector<int> &check, vector<int> &edges){\\n       if(check[node] !=-2){\\n            return ;\\n        }\\n        check[node] = i;\\n         if(edges[node]==-1){\\n            return;\\n        }\\n        dfs(i+1, edges[node], check, edges);\\n    }\\n    \\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n\\n        check1.resize(edges.size(),-2);\\n        check2.resize(edges.size(),-2);\\n        \\n        dfs(0, node1, check1, edges);\\n        dfs(0, node2, check2, edges);\\n        \\n        int ans = INT_MAX;\\n        int result = -1;\\n        for(int i=0; i<check1.size(); i++){\\n            if(check2[i]!=-2 && check1[i]!=-2){\\n                int maxi = max(check2[i],check1[i]);\\n                if(maxi<ans){\\n                    ans = maxi;\\n                    result = i;\\n                }\\n            }\\n        }\\n       return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> check1;\\n    vector<int> check2;\\n    \\n    void dfs(int i, int node, vector<int> &check, vector<int> &edges){\\n       if(check[node] !=-2){\\n            return ;\\n        }\\n        check[node] = i;\\n         if(edges[node]==-1){\\n            return;\\n        }\\n        dfs(i+1, edges[node], check, edges);\\n    }\\n    \\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n\\n        check1.resize(edges.size(),-2);\\n        check2.resize(edges.size(),-2);\\n        \\n        dfs(0, node1, check1, edges);\\n        dfs(0, node2, check2, edges);\\n        \\n        int ans = INT_MAX;\\n        int result = -1;\\n        for(int i=0; i<check1.size(); i++){\\n            if(check2[i]!=-2 && check1[i]!=-2){\\n                int maxi = max(check2[i],check1[i]);\\n                if(maxi<ans){\\n                    ans = maxi;\\n                    result = i;\\n                }\\n            }\\n        }\\n       return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098385,
                "title": "easy-to-understand-2-bfs-solution",
                "content": "https://github.com/Freeze777/SDE-Interviewer-Notes/blob/main/LeetCodeKotlin/src/main/kotlin/leetcode/medium/graph/FindClosestNodeGivenTwoNodes.kt",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3098008,
                "title": "short-and-intuitive-python",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        if node1 == node2: return node1\\n        seen1 = set()\\n        seen2 = set()\\n        while node1 not in seen1 or node2 not in seen2:\\n            seen1.add(node1)\\n            seen2.add(node2)\\n            if node1 != -1: \\n                node1 = edges[node1]\\n            if node2 != -1: \\n                node2 = edges[node2]\\n            if node1 != -1 and node1 == node2: return node1\\n            if node1 in seen2 and node1 != -1 and node2 in seen1 and node2 != -1:\\n                return min(node1, node2)\\n            if node1 in seen2 and node1 != -1:\\n                return node1\\n            if node2 in seen1 and node2 != -1:\\n                return node2\\n        return -1\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        if node1 == node2: return node1\\n        seen1 = set()\\n        seen2 = set()\\n        while node1 not in seen1 or node2 not in seen2:\\n            seen1.add(node1)\\n            seen2.add(node2)\\n            if node1 != -1: \\n                node1 = edges[node1]\\n            if node2 != -1: \\n                node2 = edges[node2]\\n            if node1 != -1 and node1 == node2: return node1\\n            if node1 in seen2 and node1 != -1 and node2 in seen1 and node2 != -1:\\n                return min(node1, node2)\\n            if node1 in seen2 and node1 != -1:\\n                return node1\\n            if node2 in seen1 and node2 != -1:\\n                return node2\\n        return -1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097074,
                "title": "beginner-friendly-bfs-solution",
                "content": "# Complexity\\n\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int visited1[] = new int[edges.length],visited2[] = new int[edges.length];  \\n        Queue<Integer> q = new LinkedList<>();  \\n        int dis=1,dis1=1;\\n        q.add(node1);\\n        while(q.size()!=0){\\n            if(q.peek()!=-1 && visited1[q.peek()]==0){\\n                visited1[q.peek()]=dis++;\\n                q.add(edges[q.peek()]);\\n            }\\n            q.remove();\\n        } \\n        q.add(node2);\\n        while(q.size()!=0){\\n            if(q.peek()!=-1 && visited2[q.peek()]==0){\\n                visited2[q.peek()]=dis1++;\\n                q.add(edges[q.peek()]);\\n            }\\n            q.remove();\\n        }  \\n        int temp=Integer.MAX_VALUE,ans=-1;\\n        for(int i=0;i<visited1.length;i++){\\n            visited1[i]=(visited1[i]!=0 && visited2[i]!=0)?(visited1[i]>visited2[i])?visited1[i]:visited2[i]:0;\\n        }\\n        for(int i=0;i<visited1.length;i++){\\n            if(temp>visited1[i] && visited1[i]!=0){\\n                temp=visited1[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n```python3 []\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        visited1 = [0 for i in range(len(edges))]\\n        visited2 = [0 for i in range(len(edges))]\\n        q=[]\\n        dis,dis1=1,1\\n        q.append(node1);\\n        while(len(q)!=0):\\n            if(q[0]!=-1 and visited1[q[0]]==0):\\n                visited1[q[0]]=dis\\n                q.append(edges[q[0]])\\n            q.pop(0)\\n            dis+=1\\n        q.append(node2)\\n        while(len(q)!=0):\\n            if(q[0]!=-1 and visited2[q[0]]==0):\\n                visited2[q[0]]=dis1\\n                q.append(edges[q[0]])\\n            q.pop(0)\\n            dis1+=1\\n        temp=999999\\n        ans=-1\\n        for i in range(len(visited1)):\\n            if (visited1[i]!=0 and visited2[i]!=0):\\n                visited1[i]=max(visited1[i],visited2[i])\\n            else:\\n                visited1[i]=0\\n        for i in range(len(visited1)):\\n            if(temp>visited1[i] and visited1[i]!=0):\\n                temp=visited1[i]\\n                ans=i\\n        return ans;\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```Java []\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int visited1[] = new int[edges.length],visited2[] = new int[edges.length];  \\n        Queue<Integer> q = new LinkedList<>();  \\n        int dis=1,dis1=1;\\n        q.add(node1);\\n        while(q.size()!=0){\\n            if(q.peek()!=-1 && visited1[q.peek()]==0){\\n                visited1[q.peek()]=dis++;\\n                q.add(edges[q.peek()]);\\n            }\\n            q.remove();\\n        } \\n        q.add(node2);\\n        while(q.size()!=0){\\n            if(q.peek()!=-1 && visited2[q.peek()]==0){\\n                visited2[q.peek()]=dis1++;\\n                q.add(edges[q.peek()]);\\n            }\\n            q.remove();\\n        }  \\n        int temp=Integer.MAX_VALUE,ans=-1;\\n        for(int i=0;i<visited1.length;i++){\\n            visited1[i]=(visited1[i]!=0 && visited2[i]!=0)?(visited1[i]>visited2[i])?visited1[i]:visited2[i]:0;\\n        }\\n        for(int i=0;i<visited1.length;i++){\\n            if(temp>visited1[i] && visited1[i]!=0){\\n                temp=visited1[i];\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```python3 []\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        visited1 = [0 for i in range(len(edges))]\\n        visited2 = [0 for i in range(len(edges))]\\n        q=[]\\n        dis,dis1=1,1\\n        q.append(node1);\\n        while(len(q)!=0):\\n            if(q[0]!=-1 and visited1[q[0]]==0):\\n                visited1[q[0]]=dis\\n                q.append(edges[q[0]])\\n            q.pop(0)\\n            dis+=1\\n        q.append(node2)\\n        while(len(q)!=0):\\n            if(q[0]!=-1 and visited2[q[0]]==0):\\n                visited2[q[0]]=dis1\\n                q.append(edges[q[0]])\\n            q.pop(0)\\n            dis1+=1\\n        temp=999999\\n        ans=-1\\n        for i in range(len(visited1)):\\n            if (visited1[i]!=0 and visited2[i]!=0):\\n                visited1[i]=max(visited1[i],visited2[i])\\n            else:\\n                visited1[i]=0\\n        for i in range(len(visited1)):\\n            if(temp>visited1[i] and visited1[i]!=0):\\n                temp=visited1[i]\\n                ans=i\\n        return ans;\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096901,
                "title": "leetcode-daily",
                "content": "# Intuition\\nSolving the problem using DFS to find the path for the smallest distance.\\n\\n# Approach\\nPerform a dfs for both given nodes where u do traversal through each node and maintain the steps required to reach the currentNode from root node in a dictionary .\\nCheck the max steps required to reach each point from both node\\nif it is the least i.e ur answer node\\nIn case you have two nodes with equal least no of steps return the one with smaller index\\n(**Why you dont need a stack or queue in this traversal? \\nOnly one branch is from each node so no need to reverse back to check for another branch of one parent node.)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        #this function will traverse the steps required to reach a particular node from each given starting node\\n        def dfs(node):\\n            steps = 0\\n            stepsNeeded = {node: 0} #currNode: stepsRequired\\n            currNode = node\\n            while True:\\n                currNode = edges[currNode] # directed towards\\n                #if we are last node or cycle exists break\\n                if currNode == -1 or currNode in stepsNeeded:\\n                    break\\n                steps+=1; stepsNeeded[currNode] = steps\\n            return stepsNeeded\\n\\n\\n        if node1 == node2:\\n            return node1\\n\\n        pathNode1 = dfs(node1)\\n        pathNode2 = dfs(node2)\\n\\n\\n        smallestNode = -1\\n        distance = None\\n        for node in pathNode1:\\n            if node in pathNode2:\\n                dist = max(pathNode1[node], pathNode2[node])\\n                #if we found a node with smaller ditance or\\n                #a node with same distance but smaller index val\\n                if (distance is None) or (dist < distance) or (dist == distance and node < smallestNode):\\n                    distance = dist\\n                    smallestNode = node\\n        return smallestNode\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        #this function will traverse the steps required to reach a particular node from each given starting node\\n        def dfs(node):\\n            steps = 0\\n            stepsNeeded = {node: 0} #currNode: stepsRequired\\n            currNode = node\\n            while True:\\n                currNode = edges[currNode] # directed towards\\n                #if we are last node or cycle exists break\\n                if currNode == -1 or currNode in stepsNeeded:\\n                    break\\n                steps+=1; stepsNeeded[currNode] = steps\\n            return stepsNeeded\\n\\n\\n        if node1 == node2:\\n            return node1\\n\\n        pathNode1 = dfs(node1)\\n        pathNode2 = dfs(node2)\\n\\n\\n        smallestNode = -1\\n        distance = None\\n        for node in pathNode1:\\n            if node in pathNode2:\\n                dist = max(pathNode1[node], pathNode2[node])\\n                #if we found a node with smaller ditance or\\n                #a node with same distance but smaller index val\\n                if (distance is None) or (dist < distance) or (dist == distance and node < smallestNode):\\n                    distance = dist\\n                    smallestNode = node\\n        return smallestNode\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096754,
                "title": "c-begineer-friendly-easy-understanding-dfs-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/I-X9elNjBkw\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n  O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int>& edges,int node,vector<int>& dist,vector<int>& visited,int distance){\\n        // base condition. (already visited or cannot move forward.)\\n        if(node == -1 || visited[node] == 1 ){return ;}\\n\\n        // make current node visited.\\n        visited[node] = 1;\\n        dist[node] = distance;\\n        // call dfs for other node.\\n        dfs(edges,edges[node],dist,visited,distance+1);\\n\\n    }\\n\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n       vector<int>dist1(n,-1);\\n       vector<int>dist2(n,-1);\\n\\n        vector<int>visited(n,0);\\n        // dfs for 1 node.\\n        dfs(edges,node1,dist1,visited,0);\\n\\n        // dfs for 2 node.\\n        vector<int>visited2(n,0);\\n        dfs(edges,node2,dist2,visited2,0);\\n\\n        // we have both distance vector filled.\\n\\n        int ans = -1;\\n        int value = n;\\n\\n        for(int i=0;i<n;i++){\\n            // if they are reachable .\\n            if(dist1[i] != -1 && dist2[i] != -1){\\n               if(max(dist1[i] , dist2[i]) < value)\\n            {\\n                value = max(dist1[i] , dist2[i]);\\n                ans = i;\\n            }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(vector<int>& edges,int node,vector<int>& dist,vector<int>& visited,int distance){\\n        // base condition. (already visited or cannot move forward.)\\n        if(node == -1 || visited[node] == 1 ){return ;}\\n\\n        // make current node visited.\\n        visited[node] = 1;\\n        dist[node] = distance;\\n        // call dfs for other node.\\n        dfs(edges,edges[node],dist,visited,distance+1);\\n\\n    }\\n\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n       vector<int>dist1(n,-1);\\n       vector<int>dist2(n,-1);\\n\\n        vector<int>visited(n,0);\\n        // dfs for 1 node.\\n        dfs(edges,node1,dist1,visited,0);\\n\\n        // dfs for 2 node.\\n        vector<int>visited2(n,0);\\n        dfs(edges,node2,dist2,visited2,0);\\n\\n        // we have both distance vector filled.\\n\\n        int ans = -1;\\n        int value = n;\\n\\n        for(int i=0;i<n;i++){\\n            // if they are reachable .\\n            if(dist1[i] != -1 && dist2[i] != -1){\\n               if(max(dist1[i] , dist2[i]) < value)\\n            {\\n                value = max(dist1[i] , dist2[i]);\\n                ans = i;\\n            }\\n            }\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096556,
                "title": "java-easy-simple-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic int closestMeetingNode(int[] edges, int n1, int n2) {\\n    int n= edges.length;\\n    int[] A= new int[n]; \\n    int[] B= new int[n];\\n    Arrays.fill(A,Integer.MAX_VALUE);\\n    Arrays.fill(B,Integer.MAX_VALUE);\\n    \\n    bfs(n1,A,edges,n);\\n    bfs(n2,B,edges,n);\\n    \\n    int res= Integer.MAX_VALUE, node=-1;\\n    for(int i=0;i<n;i++){\\n        if(A[i]==Integer.MAX_VALUE || B[i]==Integer.MAX_VALUE) continue;\\n        if(res>Math.max(A[i],B[i])){\\n            node=i; \\n            res= Math.max(A[i],B[i]);\\n        }\\n    }\\n    return node;\\n}\\nvoid bfs(int src, int[] dist,int[] edge,int n){\\n    Queue<Integer> q= new LinkedList<>();\\n    q.add(src);\\n    dist[src]=0;\\n    while(q.size()>0){\\n        var p= q.remove();\\n        if(edge[p]!=-1 && dist[edge[p]]==Integer.MAX_VALUE){\\n            q.add(edge[p]);\\n            dist[edge[p]]= dist[p]+1;\\n        }\\n    }\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int closestMeetingNode(int[] edges, int n1, int n2) {\\n    int n= edges.length;\\n    int[] A= new int[n]; \\n    int[] B= new int[n];\\n    Arrays.fill(A,Integer.MAX_VALUE);\\n    Arrays.fill(B,Integer.MAX_VALUE);\\n    \\n    bfs(n1,A,edges,n);\\n    bfs(n2,B,edges,n);\\n    \\n    int res= Integer.MAX_VALUE, node=-1;\\n    for(int i=0;i<n;i++){\\n        if(A[i]==Integer.MAX_VALUE || B[i]==Integer.MAX_VALUE) continue;\\n        if(res>Math.max(A[i],B[i])){\\n            node=i; \\n            res= Math.max(A[i],B[i]);\\n        }\\n    }\\n    return node;\\n}\\nvoid bfs(int src, int[] dist,int[] edge,int n){\\n    Queue<Integer> q= new LinkedList<>();\\n    q.add(src);\\n    dist[src]=0;\\n    while(q.size()>0){\\n        var p= q.remove();\\n        if(edge[p]!=-1 && dist[edge[p]]==Integer.MAX_VALUE){\\n            q.add(edge[p]);\\n            dist[edge[p]]= dist[p]+1;\\n        }\\n    }\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096458,
                "title": "python3-simulataneous-bfs-from-both-nodes",
                "content": "# Intuition\\nSince we need to find nearest node from given nodes , we can explore\\nlayer by layer and see if we reach a common layer from both nodes.\\nThe first common layer will be nearest from both node.\\n\\n# Approach\\nSince we need to find nearest layer , we can use bfs. We can start bfs from both nodes simulataneously and keep the path stored for both.\\nFor any common node , we reach that will be the answer.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        path1 , path2 = set(),set()\\n        ans = n+1\\n        path1.add(node1)\\n        path2.add(node2)\\n        \\n        while node1 >= 0 or node2 >= 0:\\n            if node1 in path2:  # if node is seen in node2\\'s path \\n                ans = min(ans,node1)\\n            if node2 in path1:# cur node is seen by node1\\'s path\\n                ans = min(ans,node2)\\n            if ans != n+1:\\n                return ans\\n\\n            if node1 >= 0:\\n                node1 = edges[node1] # neighbor node\\n                if node1 in path1:# neighbor is seen,avoid cycle\\n                    node1 = -1\\n                if node1 >= 0 :\\n                    path1.add(node1)\\n            if node2 >= 0:\\n                node2 = edges[node2]\\n                if node2 in path2:\\n                    node2 = -1\\n                if node2 >= 0:\\n                    path2.add(node2)\\n        \\n        return -1\\n\\n\\n          \\n            \\n\\n\\n\\n\\n\\n\\n            \\n                    \\n            \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        path1 , path2 = set(),set()\\n        ans = n+1\\n        path1.add(node1)\\n        path2.add(node2)\\n        \\n        while node1 >= 0 or node2 >= 0:\\n            if node1 in path2:  # if node is seen in node2\\'s path \\n                ans = min(ans,node1)\\n            if node2 in path1:# cur node is seen by node1\\'s path\\n                ans = min(ans,node2)\\n            if ans != n+1:\\n                return ans\\n\\n            if node1 >= 0:\\n                node1 = edges[node1] # neighbor node\\n                if node1 in path1:# neighbor is seen,avoid cycle\\n                    node1 = -1\\n                if node1 >= 0 :\\n                    path1.add(node1)\\n            if node2 >= 0:\\n                node2 = edges[node2]\\n                if node2 in path2:\\n                    node2 = -1\\n                if node2 >= 0:\\n                    path2.add(node2)\\n        \\n        return -1\\n\\n\\n          \\n            \\n\\n\\n\\n\\n\\n\\n            \\n                    \\n            \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096452,
                "title": "java-c-kotlin-100-fast-dual-paths-to-optimized-single-path",
                "content": "Starting at any node, there will only be one path through the graph because each node can only have zero or one edges going out from that node, i.e. there is no multi-way branching so there can only be one path going out from any node.\\n\\nThe code below starts with simultaneously following two paths starting at `node1` and `node2`.  Each time through the first loop, following these paths will result in one of the following:\\n1. One or both paths end at a node with NO edges going out from that node, which is the end of a path.  When a path ends, the loop is exited to continue to a section of the code that is optimized to follow only a single remaining path.  Or if both paths end at the same time, then the code falls through to return a -1 indicating there is no node accessible from both `node1` and `node2`.\\n2. One or both paths loop back on themselves.  If any path loops back onto itself, this is handled the same as an end of the path.  When a path loops back on itself, then a cyclic part of the graph was detected.  If we did NOT end the path, then the path would have continued infinitely in a cyclic loop in the graph.\\n3. One path enters a node already part of the path from the other node.  Return the node number of this node where the two paths intersect.\\n4. Both paths simultaneously enter nodes that are part of the other node\\'s path.  For those two nodes, where both paths intersect at the same distance but at two different nodes, then return the lower numbered node.\\n5. No end-of-path and no path intersecting the other path.  Advance each path to the next node in their respective paths.  Loop back to further process both paths at step #1 above.\\n\\nAfter the first loop that follows both paths simultaneously, if only one path remains, then other loops are used that are optimized to follow only that single path.  One loop optimized to follow the path from `node1`, and the other loop optimized to follow the path from `node2`.\\n\\nTo be able to detmine when paths intersect, the array `visited[]` is used.  The `visited[]` array contains a value for each node of the graph.  When a path enters a node, it sets a bit in the `visited[node]` value.  If the path\\'s bit was already set, then this path had previously gone through this node, and a cyclic part of the graph was detected.  After this path\\'s bit has been set, if the value in `visited[node]` has both bits set, then both paths intersect at this node.  The constants for the bit masks are `VISITED1` for the bit for the path from `node1`, and `VISITED2` for the bit for the path from `node2`.\\n\\nThe code below ran as the fastest code on the runtime graphs in August 2023, for Java (4ms), C++ (91ms), and Kotlin (410ms).\\n\\nIf useful, please upvote.\\n\\n**--- Java ---**\\n```\\nclass Solution {\\n    static final int VISITED1 = 1;\\n    static final int VISITED2 = 2;\\n    static final int VISITED_BOTH = VISITED1 | VISITED2;\\n    \\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        byte[] visited = new byte[n];\\n        int result = Integer.MAX_VALUE;\\n        \\n        // Both paths are still valid.  i.e. node1 and node2 are both valid node numbers.\\n        while (result == Integer.MAX_VALUE && node1 >= 0 && node2 >= 0) {\\n\\n            // Find next in path from node1.\\n            if ((visited[node1] & VISITED1) != 0) \\n                node1 = -1;\\n            else if ((visited[node1] |= VISITED1) == VISITED_BOTH) \\n                result = node1;\\n            else\\n                node1 = edges[node1];\\n\\n            // Find next in path from node2.\\n            if ((visited[node2] & VISITED2) != 0) {\\n                node2 = -1;\\n                break;\\n            }\\n            if ((visited[node2] |= VISITED2) == VISITED_BOTH) {\\n                result = Math.min(result, node2);\\n                break;\\n            }\\n            node2 = edges[node2];\\n        }\\n        if (result != Integer.MAX_VALUE)  return result;\\n        \\n        // If node1 still has a valid path, then node2 has reached the end of its path \\n        // without intersecting the node1 path, so we only need to keep searching along \\n        // the node1 path.\\n        if (node1 >= 0) {\\n            while (node1 >= 0) {\\n                if ((visited[node1] & VISITED1) != 0)  return -1;\\n                if ((visited[node1] |= VISITED1) == VISITED_BOTH)  return node1;\\n                node1 = edges[node1];\\n            }\\n            return -1;\\n        }\\n        \\n        // Node2 still has a valid path, then node1 has reached the end of its path \\n        // without intersecting the node2 path, so we only need to keep searching along \\n        // the node2 path.\\n        while (node2 >= 0) {\\n            if ((visited[node2] & VISITED2) != 0)  return -1;\\n            if ((visited[node2] |= VISITED2) == VISITED_BOTH)  return node2;\\n            node2 = edges[node2];\\n        }\\n        return -1;\\n    }\\n}\\n```\\n**--- C++ ---**\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        const unsigned char VISITED1 = 1;\\n        const unsigned char VISITED2 = 2;\\n        const unsigned char VISITED_BOTH = VISITED1 | VISITED2;\\n        \\n        int n = edges.size();\\n        vector<unsigned char> visited(n);\\n        int result = n;\\n        \\n        // Both paths are still valid.  i.e. node1 and node2 are both valid node numbers.\\n        while (result == n && node1 >= 0 && node2 >= 0) {\\n\\n            // Find next in path from node1.\\n            if ((visited[node1] & VISITED1) != 0) \\n                node1 = -1;\\n            else if ((visited[node1] |= VISITED1) == VISITED_BOTH) \\n                result = node1;\\n            else\\n                node1 = edges[node1];\\n\\n            // Find next in path from node2.\\n            if ((visited[node2] & VISITED2) != 0) {\\n                node2 = -1;\\n                break;\\n            }\\n            if ((visited[node2] |= VISITED2) == VISITED_BOTH)\\n                return min(result, node2);\\n            node2 = edges[node2];\\n        }\\n        if (result != n)  return result;\\n        \\n        // If node1 still has a valid path, then node2 has reached the end of its path \\n        // without intersecting the node1 path, so we only need to keep searching along \\n        // the node1 path.\\n        if (node1 >= 0) {\\n            while (node1 >= 0) {\\n                if ((visited[node1] & VISITED1) != 0)  return -1;\\n                if ((visited[node1] |= VISITED1) == VISITED_BOTH)  return node1;\\n                node1 = edges[node1];\\n            }\\n            return -1;\\n        }\\n        \\n        // Node2 still has a valid path, then node1 has reached the end of its path \\n        // without intersecting the node2 path, so we only need to keep searching along \\n        // the node2 path.\\n        while (node2 >= 0) {\\n            if ((visited[node2] & VISITED2) != 0)  return -1;\\n            if ((visited[node2] |= VISITED2) == VISITED_BOTH)  return node2;\\n            node2 = edges[node2];\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**--- Kotlin ---**\\n```\\nclass Solution {\\n    fun closestMeetingNode(edges: IntArray, node1: Int, node2: Int): Int {\\n        val VISITED1 = 1\\n        val VISITED2 = 2\\n        val VISITED_BOTH = VISITED1 or VISITED2\\n    \\n        var visited = IntArray(edges.size)\\n        var result = Integer.MAX_VALUE\\n        var nod1 = node1;\\n        var nod2 = node2;\\n        \\n        // Both paths are still valid.  i.e. node1 and node2 are both valid node numbers.\\n        while (result == Integer.MAX_VALUE && nod1 >= 0 && nod2 >= 0) {\\n\\n            // Find next in path from node1.\\n            if ((visited[nod1] and VISITED1) != 0) \\n                nod1 = -1\\n            else {\\n                visited[nod1] = visited[nod1] or VISITED1\\n                if (visited[nod1] == VISITED_BOTH) \\n                    result = nod1\\n                else\\n                    nod1 = edges[nod1]\\n            }\\n\\n            // Find next in path from node2.\\n            if ((visited[nod2] and VISITED2) != 0) {\\n                nod2 = -1\\n                break\\n            }\\n            visited[nod2] = visited[nod2] or VISITED2\\n            if (visited[nod2] == VISITED_BOTH) {\\n                result = Math.min(result, nod2)\\n                break\\n            }\\n            nod2 = edges[nod2]\\n        }\\n        if (result != Integer.MAX_VALUE)  return result\\n        \\n        // If node1 still has a valid path, then node2 has reached the end of its path \\n        // without intersecting the node1 path, so we only need to keep searching along \\n        // the node1 path.\\n        if (nod1 >= 0) {\\n            while (nod1 >= 0) {\\n                if ((visited[nod1] and VISITED1) != 0)  return -1\\n                visited[nod1] = visited[nod1] or VISITED1\\n                if (visited[nod1] == VISITED_BOTH)  return nod1\\n                nod1 = edges[nod1]\\n            }\\n            return -1\\n        }\\n        \\n        // Node2 still has a valid path, then node1 has reached the end of its path \\n        // without intersecting the node2 path, so we only need to keep searching along \\n        // the node2 path.\\n        while (nod2 >= 0) {\\n            if ((visited[nod2] and VISITED2) != 0)  return -1\\n            visited[nod2] = visited[nod2] or VISITED2\\n            if (visited[nod2] == VISITED_BOTH)  return nod2\\n            nod2 = edges[nod2]\\n        }\\n        return -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    static final int VISITED1 = 1;\\n    static final int VISITED2 = 2;\\n    static final int VISITED_BOTH = VISITED1 | VISITED2;\\n    \\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        byte[] visited = new byte[n];\\n        int result = Integer.MAX_VALUE;\\n        \\n        // Both paths are still valid.  i.e. node1 and node2 are both valid node numbers.\\n        while (result == Integer.MAX_VALUE && node1 >= 0 && node2 >= 0) {\\n\\n            // Find next in path from node1.\\n            if ((visited[node1] & VISITED1) != 0) \\n                node1 = -1;\\n            else if ((visited[node1] |= VISITED1) == VISITED_BOTH) \\n                result = node1;\\n            else\\n                node1 = edges[node1];\\n\\n            // Find next in path from node2.\\n            if ((visited[node2] & VISITED2) != 0) {\\n                node2 = -1;\\n                break;\\n            }\\n            if ((visited[node2] |= VISITED2) == VISITED_BOTH) {\\n                result = Math.min(result, node2);\\n                break;\\n            }\\n            node2 = edges[node2];\\n        }\\n        if (result != Integer.MAX_VALUE)  return result;\\n        \\n        // If node1 still has a valid path, then node2 has reached the end of its path \\n        // without intersecting the node1 path, so we only need to keep searching along \\n        // the node1 path.\\n        if (node1 >= 0) {\\n            while (node1 >= 0) {\\n                if ((visited[node1] & VISITED1) != 0)  return -1;\\n                if ((visited[node1] |= VISITED1) == VISITED_BOTH)  return node1;\\n                node1 = edges[node1];\\n            }\\n            return -1;\\n        }\\n        \\n        // Node2 still has a valid path, then node1 has reached the end of its path \\n        // without intersecting the node2 path, so we only need to keep searching along \\n        // the node2 path.\\n        while (node2 >= 0) {\\n            if ((visited[node2] & VISITED2) != 0)  return -1;\\n            if ((visited[node2] |= VISITED2) == VISITED_BOTH)  return node2;\\n            node2 = edges[node2];\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        const unsigned char VISITED1 = 1;\\n        const unsigned char VISITED2 = 2;\\n        const unsigned char VISITED_BOTH = VISITED1 | VISITED2;\\n        \\n        int n = edges.size();\\n        vector<unsigned char> visited(n);\\n        int result = n;\\n        \\n        // Both paths are still valid.  i.e. node1 and node2 are both valid node numbers.\\n        while (result == n && node1 >= 0 && node2 >= 0) {\\n\\n            // Find next in path from node1.\\n            if ((visited[node1] & VISITED1) != 0) \\n                node1 = -1;\\n            else if ((visited[node1] |= VISITED1) == VISITED_BOTH) \\n                result = node1;\\n            else\\n                node1 = edges[node1];\\n\\n            // Find next in path from node2.\\n            if ((visited[node2] & VISITED2) != 0) {\\n                node2 = -1;\\n                break;\\n            }\\n            if ((visited[node2] |= VISITED2) == VISITED_BOTH)\\n                return min(result, node2);\\n            node2 = edges[node2];\\n        }\\n        if (result != n)  return result;\\n        \\n        // If node1 still has a valid path, then node2 has reached the end of its path \\n        // without intersecting the node1 path, so we only need to keep searching along \\n        // the node1 path.\\n        if (node1 >= 0) {\\n            while (node1 >= 0) {\\n                if ((visited[node1] & VISITED1) != 0)  return -1;\\n                if ((visited[node1] |= VISITED1) == VISITED_BOTH)  return node1;\\n                node1 = edges[node1];\\n            }\\n            return -1;\\n        }\\n        \\n        // Node2 still has a valid path, then node1 has reached the end of its path \\n        // without intersecting the node2 path, so we only need to keep searching along \\n        // the node2 path.\\n        while (node2 >= 0) {\\n            if ((visited[node2] & VISITED2) != 0)  return -1;\\n            if ((visited[node2] |= VISITED2) == VISITED_BOTH)  return node2;\\n            node2 = edges[node2];\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun closestMeetingNode(edges: IntArray, node1: Int, node2: Int): Int {\\n        val VISITED1 = 1\\n        val VISITED2 = 2\\n        val VISITED_BOTH = VISITED1 or VISITED2\\n    \\n        var visited = IntArray(edges.size)\\n        var result = Integer.MAX_VALUE\\n        var nod1 = node1;\\n        var nod2 = node2;\\n        \\n        // Both paths are still valid.  i.e. node1 and node2 are both valid node numbers.\\n        while (result == Integer.MAX_VALUE && nod1 >= 0 && nod2 >= 0) {\\n\\n            // Find next in path from node1.\\n            if ((visited[nod1] and VISITED1) != 0) \\n                nod1 = -1\\n            else {\\n                visited[nod1] = visited[nod1] or VISITED1\\n                if (visited[nod1] == VISITED_BOTH) \\n                    result = nod1\\n                else\\n                    nod1 = edges[nod1]\\n            }\\n\\n            // Find next in path from node2.\\n            if ((visited[nod2] and VISITED2) != 0) {\\n                nod2 = -1\\n                break\\n            }\\n            visited[nod2] = visited[nod2] or VISITED2\\n            if (visited[nod2] == VISITED_BOTH) {\\n                result = Math.min(result, nod2)\\n                break\\n            }\\n            nod2 = edges[nod2]\\n        }\\n        if (result != Integer.MAX_VALUE)  return result\\n        \\n        // If node1 still has a valid path, then node2 has reached the end of its path \\n        // without intersecting the node1 path, so we only need to keep searching along \\n        // the node1 path.\\n        if (nod1 >= 0) {\\n            while (nod1 >= 0) {\\n                if ((visited[nod1] and VISITED1) != 0)  return -1\\n                visited[nod1] = visited[nod1] or VISITED1\\n                if (visited[nod1] == VISITED_BOTH)  return nod1\\n                nod1 = edges[nod1]\\n            }\\n            return -1\\n        }\\n        \\n        // Node2 still has a valid path, then node1 has reached the end of its path \\n        // without intersecting the node2 path, so we only need to keep searching along \\n        // the node2 path.\\n        while (nod2 >= 0) {\\n            if ((visited[nod2] and VISITED2) != 0)  return -1\\n            visited[nod2] = visited[nod2] or VISITED2\\n            if (visited[nod2] == VISITED_BOTH)  return nod2\\n            nod2 = edges[nod2]\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096432,
                "title": "java-one-pass-solution-no-hashmap-no-queues",
                "content": "# Intuition\\nFirst. This is a BFS approach as we need to find the shortest path.\\nSecond. We don\\'t need a queue here as we\\'ve told there\\'s **at most one** outgoing edge.\\nFinally. Don\\'t need to find shortest path independently and count distance to each node, just move nodes towards to each other until they\\'ll meet.\\n\\n# Approach\\nMove simultaneously from both nodes towards to each other. Keep the track of each node. As soon as you find next node 1 at the track of the node 2 or node 2 at the track 1 - here is the answer. Also you can meet both at the same step, then choose the smallest.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        if (node1 == node2)\\n            return node1;\\n        HashSet<Integer> set1 = new HashSet<>();\\n        set1.add(node1);\\n        HashSet<Integer> set2 = new HashSet<>();\\n        set2.add(node2);\\n        while ((edges[node1] != -1 && !set1.contains(edges[node1])) || (edges[node2] != -1 && !set2.contains(edges[node2]))) {\\n            if (edges[node1] != -1 && !set1.contains(edges[node1])) {\\n                node1 = edges[node1];\\n                set1.add(node1);\\n            }\\n            if (edges[node2] != -1 && !set2.contains(edges[node2])) {\\n                node2 = edges[node2];\\n                set2.add(node2);\\n            }\\n            if (set1.contains(node2) && set2.contains(node1))\\n                return Math.min(node1, node2);\\n            if (set1.contains(node2))\\n                return node2;\\n            if (set2.contains(node1))\\n                return node1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\nPlease upvote the solution if it helps! :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        if (node1 == node2)\\n            return node1;\\n        HashSet<Integer> set1 = new HashSet<>();\\n        set1.add(node1);\\n        HashSet<Integer> set2 = new HashSet<>();\\n        set2.add(node2);\\n        while ((edges[node1] != -1 && !set1.contains(edges[node1])) || (edges[node2] != -1 && !set2.contains(edges[node2]))) {\\n            if (edges[node1] != -1 && !set1.contains(edges[node1])) {\\n                node1 = edges[node1];\\n                set1.add(node1);\\n            }\\n            if (edges[node2] != -1 && !set2.contains(edges[node2])) {\\n                node2 = edges[node2];\\n                set2.add(node2);\\n            }\\n            if (set1.contains(node2) && set2.contains(node1))\\n                return Math.min(node1, node2);\\n            if (set1.contains(node2))\\n                return node2;\\n            if (set2.contains(node1))\\n                return node1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096372,
                "title": "javascript-better-than-leetcode-solution-beats-100",
                "content": "```\\n// Approach #1: Using 2 Sets\\n\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nconst closestMeetingNode = function(edges, node1, node2) {\\n\\tconst neighbours1 = new Set();\\n\\tconst neighbours2 = new Set();\\n\\t\\n\\tlet answer = -1;\\n\\t\\n\\twhile (node1 !== -1 || node2 !== -1) {\\n\\t\\tif (node1 !== -1) {\\t\\t\\n\\t\\t\\tif (neighbours1.has(node1)) // cycle\\n\\t\\t\\t\\tnode1 = -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tneighbours1.add(node1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (node2 !== -1) {\\t\\t\\n\\t\\t\\tif (neighbours2.has(node2)) // cycle\\n\\t\\t\\t\\tnode2 = -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tneighbours2.add(node2);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (neighbours2.has(node1))\\n\\t\\t\\tanswer = node1;\\n\\t\\t\\n\\t\\tif (neighbours1.has(node2))\\n\\t\\t\\tanswer = answer === -1 ? node2 : Math.min(answer, node2);\\n\\t\\t\\n\\t\\tif (node1 !== -1)\\n\\t\\t\\tnode1 = edges[node1];\\n\\t\\t\\n\\t\\tif (node2 !== -1)     \\n\\t\\t\\tnode2 = edges[node2];\\n\\t\\t\\n\\t\\tif (answer !== -1)\\n\\t\\t\\treturn answer;\\n\\t}\\n\\t\\n\\treturn answer;\\n};\\n```\\n\\n**Please upvote if you find this solution useful. Happy Coding!**",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n// Approach #1: Using 2 Sets\\n\\n// Time complexity: O(n)\\n// Space complexity: O(n)\\n\\nconst closestMeetingNode = function(edges, node1, node2) {\\n\\tconst neighbours1 = new Set();\\n\\tconst neighbours2 = new Set();\\n\\t\\n\\tlet answer = -1;\\n\\t\\n\\twhile (node1 !== -1 || node2 !== -1) {\\n\\t\\tif (node1 !== -1) {\\t\\t\\n\\t\\t\\tif (neighbours1.has(node1)) // cycle\\n\\t\\t\\t\\tnode1 = -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tneighbours1.add(node1);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (node2 !== -1) {\\t\\t\\n\\t\\t\\tif (neighbours2.has(node2)) // cycle\\n\\t\\t\\t\\tnode2 = -1;\\n\\t\\t\\telse\\n\\t\\t\\t\\tneighbours2.add(node2);\\n\\t\\t}\\n\\t\\t\\n\\t\\tif (neighbours2.has(node1))\\n\\t\\t\\tanswer = node1;\\n\\t\\t\\n\\t\\tif (neighbours1.has(node2))\\n\\t\\t\\tanswer = answer === -1 ? node2 : Math.min(answer, node2);\\n\\t\\t\\n\\t\\tif (node1 !== -1)\\n\\t\\t\\tnode1 = edges[node1];\\n\\t\\t\\n\\t\\tif (node2 !== -1)     \\n\\t\\t\\tnode2 = edges[node2];\\n\\t\\t\\n\\t\\tif (answer !== -1)\\n\\t\\t\\treturn answer;\\n\\t}\\n\\t\\n\\treturn answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3096291,
                "title": "cpp-soluntion-using-bfs",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach for this solution is to use a modified version of the Breadth-first search (BFS) algorithm. The basic idea is to perform two separate BFS starting from node1 and node2 respectively, and keep track of the distance from each node to the starting node. Once a node is visited from both node1 and node2, we can compare the maximum distance between the two distances, and return the node that minimizes this maximum distance. If there are multiple such nodes, the node with the smallest index should be returned. If no such node is found, -1 should be returned.\\n\\nHere is the algorithm for this solution:\\n\\n- Initialize distance arrays dist1 and dist2, and visited arrays visited1 and visited2 for node1 and node2 respectively.\\n- Perform BFS from node1 and keep track of the distance from each node to node1 and mark the nodes visited.\\n- Perform BFS from node2 and keep track of the distance from each node to node2 and mark the nodes visited.\\n- Iterate through the edges array, if a node is visited from both node1 and node2, compare the maximum distance between the two distances, if it is less than the minimum distance so far, update the minimum distance and store the node.\\n- Return the node with the minimum maximum distance, if no such node is found return -1.\\n\\n*Note that the given graph may contain cycles and that\\'s why keeping track of the visited node is important, otherwise the BFS will stuck in a infinite loop.* \\n\\n# Complexity\\n- Time complexity: The time complexity of this solution is O(n + m), where n is the number of nodes in the graph and m is the number of edges in the graph. This is because we perform two separate BFS and visit each node and edge at most once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: The space complexity of this solution is O(n), where n is the number of nodes in the graph. This is because we use two separate distance arrays and visited arrays, each of which takes O(n) space, and a queue to perform BFS, which takes O(n) space in the worst case scenario.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nIt\\'s worth noting that, if the graph is sparse, that is if the number of edges is much less than the number of possible edges (n^2) , the space complexity would be O(m) and the time complexity would be O(m+n)\\nIn both cases, the space and time complexity of this solution is linear with respect to the number of nodes in the graph, which makes it efficient for large graphs.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        // Initialize distance arrays and visited arrays\\n        vector<int> dist1(edges.size(), -1);\\n        vector<int> dist2(edges.size(), -1);\\n        vector<bool> visited1(edges.size(), false);\\n        vector<bool> visited2(edges.size(), false);\\n        // Perform BFS from node1 and node2\\n        queue<int> q;\\n        q.push(node1);\\n        dist1[node1] = 0;\\n        visited1[node1] = true;\\n        while (!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            if (edges[curr] != -1 && !visited1[edges[curr]]) {\\n                q.push(edges[curr]);\\n                dist1[edges[curr]] = dist1[curr] + 1;\\n                visited1[edges[curr]] = true;\\n            }\\n        }\\n        q.push(node2);\\n        dist2[node2] = 0;\\n        visited2[node2] = true;\\n        while (!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            if (edges[curr] != -1 && !visited2[edges[curr]]) {\\n                q.push(edges[curr]);\\n                dist2[edges[curr]] = dist2[curr] + 1;\\n                visited2[edges[curr]] = true;\\n            }\\n        }\\n    \\n        // Find the node with the minimum maximum distance from node1 and node2\\n        int minDist = INT_MAX;\\n        int minNode = -1;\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (visited1[i] && visited2[i]) {\\n                int maxDist = max(dist1[i], dist2[i]);\\n                if (maxDist < minDist) {\\n                    minDist = maxDist;\\n                    minNode = i;\\n                }\\n            }\\n        }\\n    \\n        return minNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        // Initialize distance arrays and visited arrays\\n        vector<int> dist1(edges.size(), -1);\\n        vector<int> dist2(edges.size(), -1);\\n        vector<bool> visited1(edges.size(), false);\\n        vector<bool> visited2(edges.size(), false);\\n        // Perform BFS from node1 and node2\\n        queue<int> q;\\n        q.push(node1);\\n        dist1[node1] = 0;\\n        visited1[node1] = true;\\n        while (!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            if (edges[curr] != -1 && !visited1[edges[curr]]) {\\n                q.push(edges[curr]);\\n                dist1[edges[curr]] = dist1[curr] + 1;\\n                visited1[edges[curr]] = true;\\n            }\\n        }\\n        q.push(node2);\\n        dist2[node2] = 0;\\n        visited2[node2] = true;\\n        while (!q.empty()) {\\n            int curr = q.front();\\n            q.pop();\\n            if (edges[curr] != -1 && !visited2[edges[curr]]) {\\n                q.push(edges[curr]);\\n                dist2[edges[curr]] = dist2[curr] + 1;\\n                visited2[edges[curr]] = true;\\n            }\\n        }\\n    \\n        // Find the node with the minimum maximum distance from node1 and node2\\n        int minDist = INT_MAX;\\n        int minNode = -1;\\n        for (int i = 0; i < edges.size(); i++) {\\n            if (visited1[i] && visited2[i]) {\\n                int maxDist = max(dist1[i], dist2[i]);\\n                if (maxDist < minDist) {\\n                    minDist = maxDist;\\n                    minNode = i;\\n                }\\n            }\\n        }\\n    \\n        return minNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096290,
                "title": "java-solution-8-ms-beats-99",
                "content": "# Code\\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        if (edges == null || edges.length < 2) {\\n            return -1;\\n        }\\n\\n        int len = edges.length;\\n        int[] visit1 = new int[len];\\n        int[] visit2 = new int[len];\\n\\n        int res = len;\\n        while (node1 != -1 || node2 != -1) {\\n            if (node1 != -1) {\\n                if (visit2[node1] == 1) {\\n                    res = Math.min(res, node1);\\n                }\\n\\n                if (visit1[node1] == 1) {\\n                    node1 = -1;\\n                } else {\\n                    visit1[node1] = 1;\\n                    node1 = edges[node1];\\n                }\\n            }\\n            if (node2 != -1) {\\n                if (visit1[node2] == 1) {\\n                    res = Math.min(res, node2);\\n                }\\n                if (visit2[node2] == 1) {\\n                    node2 = -1;\\n                } else {\\n                    visit2[node2] = 1;\\n                    node2 = edges[node2];\\n                }\\n            }\\n\\n            if (res < len) {\\n                return res;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        if (edges == null || edges.length < 2) {\\n            return -1;\\n        }\\n\\n        int len = edges.length;\\n        int[] visit1 = new int[len];\\n        int[] visit2 = new int[len];\\n\\n        int res = len;\\n        while (node1 != -1 || node2 != -1) {\\n            if (node1 != -1) {\\n                if (visit2[node1] == 1) {\\n                    res = Math.min(res, node1);\\n                }\\n\\n                if (visit1[node1] == 1) {\\n                    node1 = -1;\\n                } else {\\n                    visit1[node1] = 1;\\n                    node1 = edges[node1];\\n                }\\n            }\\n            if (node2 != -1) {\\n                if (visit1[node2] == 1) {\\n                    res = Math.min(res, node2);\\n                }\\n                if (visit2[node2] == 1) {\\n                    node2 = -1;\\n                } else {\\n                    visit2[node2] = 1;\\n                    node2 = edges[node2];\\n                }\\n            }\\n\\n            if (res < len) {\\n                return res;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096127,
                "title": "javascript-9-lines-bfs-time-o-n-space-o-n",
                "content": "# Approach\\n1. Create arrays `visit1` & `visit2` (to store distances from each node to `node1` & `node2`), and vars `min` (to track min distance) and `res` (to store min node index).\\n2. Create a queue beginning with `node1` (distance 0). For each next node `i` in queue:\\n    1. If `edges[i] >= 0` & `visit1[edges[i]]` is not set, set to `visit1[i]+1` & push `edges[i]` to queue.\\n3. Repeat for `node2` with `visit2`.\\n4. Iterate through each node from `0` to `n - 1`. For each node `i`:\\n    1. If `max(visit1[i],visit2[i]) < min`, set `min` to that max and `res = i`.\\n5. Return `res`.\\n\\n# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nconst closestMeetingNode = ( edges, node1, node2 ) => {\\n    let v1 = [], v2 =[], m = 1e5, r = -1, i\\n    for ( let [ v, q ] of [ [v1,[node1]], [v2,[node2]] ] )\\n        for ( v[q[0]] = 0; q.length; )\\n            if ( edges[ i = q.shift() ] >= 0 && !(v[edges[i]]+1) )\\n                v[edges[i]] = v[i]+1, q.push(edges[i])\\n    for ( i = 0; i < edges.length; i++ )\\n        if ( ( n = Math.max(v1[i],v2[i]) ) < m ) \\n            m = n, r = i\\n    return r\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nconst closestMeetingNode = ( edges, node1, node2 ) => {\\n    let v1 = [], v2 =[], m = 1e5, r = -1, i\\n    for ( let [ v, q ] of [ [v1,[node1]], [v2,[node2]] ] )\\n        for ( v[q[0]] = 0; q.length; )\\n            if ( edges[ i = q.shift() ] >= 0 && !(v[edges[i]]+1) )\\n                v[edges[i]] = v[i]+1, q.push(edges[i])\\n    for ( i = 0; i < edges.length; i++ )\\n        if ( ( n = Math.max(v1[i],v2[i]) ) < m ) \\n            m = n, r = i\\n    return r\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3096002,
                "title": "without-dfs-o-n-time-and-space-complexity",
                "content": "# Intuition\\nIt is given that every node has only one child or no child at all, so, we do not need DFS, we just have to traverse every connected node.\\n\\n# Approach\\n1. Create two distance arrays for storing distance.\\n2. Traverse using each given node and store the distance.\\n3. The traversal will be till node is not -1.\\n4. Check for the closest node with given condition.\\n5. Boom! You got the answer!\\n\\n# Complexity\\n- Time complexity:\\nO(n) for first iteration\\nO(n) for second iteration\\nO(n) for checking\\nthus O(n) + O(n) + O(n) = O(3n) = O(n)\\n\\n- Space complexity:\\nO(n) for both the distance arrays\\nthus O(n) + O(n) = O(2n) = O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    private:\\n        void traverse(int node, int dist, vector<int>& edges, vector<int>& distance) {\\n            while (node != -1) {\\n                if (distance[node] != -1) break;\\n                distance[node] = dist++;\\n                if (edges[node] != -1) node = edges[node];\\n            }\\n        }\\n\\n    public:\\n        int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n            int n = edges.size();\\n            vector<int> distance1(n, -1);\\n            traverse(node1, 1, edges, distance1);\\n            vector<int> distance2(n, -1);\\n            traverse(node2, 1, edges, distance2);\\n\\n            int ans = -1;\\n            int minDistance = INT_MAX;\\n            for (int i = 0; i < n; i++) {\\n                if (distance1[i] == -1 || distance2[i] == -1) continue;\\n                int maxi = max(distance1[i], distance2[i]);\\n                if (minDistance > maxi) {\\n                    minDistance = maxi;\\n                    ans = i;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    private:\\n        void traverse(int node, int dist, vector<int>& edges, vector<int>& distance) {\\n            while (node != -1) {\\n                if (distance[node] != -1) break;\\n                distance[node] = dist++;\\n                if (edges[node] != -1) node = edges[node];\\n            }\\n        }\\n\\n    public:\\n        int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n            int n = edges.size();\\n            vector<int> distance1(n, -1);\\n            traverse(node1, 1, edges, distance1);\\n            vector<int> distance2(n, -1);\\n            traverse(node2, 1, edges, distance2);\\n\\n            int ans = -1;\\n            int minDistance = INT_MAX;\\n            for (int i = 0; i < n; i++) {\\n                if (distance1[i] == -1 || distance2[i] == -1) continue;\\n                int maxi = max(distance1[i], distance2[i]);\\n                if (minDistance > maxi) {\\n                    minDistance = maxi;\\n                    ans = i;\\n                }\\n            }\\n\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095814,
                "title": "c-bfs-video-solution",
                "content": "# Intuition & Approach\\nhttps://youtu.be/iO027dE7r34\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        auto dis1 = BFS(node1, n, edges);\\n        auto dis2 = BFS(node2, n, edges);\\n\\n        int node = -1, x = INT_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            if (x > max(dis1[i], dis2[i])) {\\n                node = i;\\n                x = max(dis1[i], dis2[i]);\\n            }\\n        }\\n\\n        return node;\\n    }\\n\\n    vector<int> BFS(int src, int n, vector<int> &edges) {\\n        vector<int> dis(n, INT_MAX);\\n        queue<int> qu;\\n        qu.push(src);\\n        dis[src] = 0;\\n\\n        while (!qu.empty()) {\\n            int node = qu.front();\\n            qu.pop();\\n\\n            if (edges[node] != -1 && dis[edges[node]] == INT_MAX) {\\n                qu.push(edges[node]);\\n                dis[edges[node]] = dis[node] + 1;\\n            }\\n        }\\n\\n        return dis;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        auto dis1 = BFS(node1, n, edges);\\n        auto dis2 = BFS(node2, n, edges);\\n\\n        int node = -1, x = INT_MAX;\\n        for (int i = 0; i < n; ++i) {\\n            if (x > max(dis1[i], dis2[i])) {\\n                node = i;\\n                x = max(dis1[i], dis2[i]);\\n            }\\n        }\\n\\n        return node;\\n    }\\n\\n    vector<int> BFS(int src, int n, vector<int> &edges) {\\n        vector<int> dis(n, INT_MAX);\\n        queue<int> qu;\\n        qu.push(src);\\n        dis[src] = 0;\\n\\n        while (!qu.empty()) {\\n            int node = qu.front();\\n            qu.pop();\\n\\n            if (edges[node] != -1 && dis[edges[node]] == INT_MAX) {\\n                qu.push(edges[node]);\\n                dis[edges[node]] = dis[node] + 1;\\n            }\\n        }\\n\\n        return dis;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095805,
                "title": "python-sol-with-dfs-and-defaultdict",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        reachable1 = defaultdict(int)\\n        reachable2 = defaultdict(int)\\n        reachable1[node1] = 0\\n        curr = node1\\n        steps = 0\\n        while edges[curr] != -1:\\n            curr = edges[curr]\\n            steps += 1\\n            if curr in reachable1:\\n                break\\n            reachable1[curr] = steps\\n        \\n        reachable2[node2] = 0\\n        curr = node2\\n        steps = 0\\n        while edges[curr] != -1:\\n            curr = edges[curr]\\n            steps += 1\\n            if curr in reachable2:\\n                break\\n            reachable2[curr] = steps\\n        result = float(\\'inf\\')\\n        result_node = -1\\n        for node in reachable1.keys():\\n            if node in reachable2:\\n                if result > max(reachable1[node], reachable2[node]):\\n                    result = max(reachable1[node], reachable2[node])\\n                    result_node = node\\n                elif result == max(reachable1[node], reachable2[node]):\\n                    result_node = min(node, result_node)\\n        \\n        return result_node\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        reachable1 = defaultdict(int)\\n        reachable2 = defaultdict(int)\\n        reachable1[node1] = 0\\n        curr = node1\\n        steps = 0\\n        while edges[curr] != -1:\\n            curr = edges[curr]\\n            steps += 1\\n            if curr in reachable1:\\n                break\\n            reachable1[curr] = steps\\n        \\n        reachable2[node2] = 0\\n        curr = node2\\n        steps = 0\\n        while edges[curr] != -1:\\n            curr = edges[curr]\\n            steps += 1\\n            if curr in reachable2:\\n                break\\n            reachable2[curr] = steps\\n        result = float(\\'inf\\')\\n        result_node = -1\\n        for node in reachable1.keys():\\n            if node in reachable2:\\n                if result > max(reachable1[node], reachable2[node]):\\n                    result = max(reachable1[node], reachable2[node])\\n                    result_node = node\\n                elif result == max(reachable1[node], reachable2[node]):\\n                    result_node = min(node, result_node)\\n        \\n        return result_node\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095718,
                "title": "daily-leetcoding-challenge-january-day-25",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 25.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 2512939,
                "title": "python-bfs-solution",
                "content": "```\\ndef closestMeetingNode(self, edges: List[int], n1: int, n2: int) -> int:\\n\\tdef bfs(n):\\n\\t\\tq = deque([n])\\n\\t\\td = [len(edges)+10]*len(edges)\\n\\t\\td[n] = 0\\n\\t\\twhile(q):\\n\\t\\t\\ti = q.popleft()\\n\\t\\t\\tnxt = edges[i]\\n\\t\\t\\tif nxt!=-1 and d[nxt]>len(edges):\\n\\t\\t\\t\\tq.append(nxt)\\n\\t\\t\\t\\td[nxt] = d[i]+1 \\n\\t\\treturn d\\n\\n\\td1, d2 = bfs(n1), bfs(n2)\\n\\tdist, idx = len(edges)+10, -1\\n\\tfor i in range(len(edges)):\\n\\t\\tif dist > max(d1[i], d2[i]):\\n\\t\\t\\tdist, idx = max(d1[i], d2[i]), i\\n\\treturn idx\\n```",
                "solutionTags": [],
                "code": "```\\ndef closestMeetingNode(self, edges: List[int], n1: int, n2: int) -> int:\\n\\tdef bfs(n):\\n\\t\\tq = deque([n])\\n\\t\\td = [len(edges)+10]*len(edges)\\n\\t\\td[n] = 0\\n\\t\\twhile(q):\\n\\t\\t\\ti = q.popleft()\\n\\t\\t\\tnxt = edges[i]\\n\\t\\t\\tif nxt!=-1 and d[nxt]>len(edges):\\n\\t\\t\\t\\tq.append(nxt)\\n\\t\\t\\t\\td[nxt] = d[i]+1 \\n\\t\\treturn d\\n\\n\\td1, d2 = bfs(n1), bfs(n2)\\n\\tdist, idx = len(edges)+10, -1\\n\\tfor i in range(len(edges)):\\n\\t\\tif dist > max(d1[i], d2[i]):\\n\\t\\t\\tdist, idx = max(d1[i], d2[i]), i\\n\\treturn idx\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2387418,
                "title": "bellman-ford-go-fastest-100",
                "content": "Using Bellman Ford algorithm search for distances from **node1** to all nodes and from **node2** to all nodes.\\nIterating resulting distances array and if both **arr1[i]** and **arr2[i]** aren\\'t **MaxInteger** than consider this node as a result.\\n\\n\\n```\\nfunc closestMeetingNode(edges []int, node1 int, node2 int) int {\\n    return bellmanFord(edges, node1,node2)\\n}\\n\\nfunc bellmanFord(edges []int, node1 int, node2 int) int {\\n    bf1 := calculateBellmanFord(node1, edges)\\n    bf2 := calculateBellmanFord(node2,edges)\\n    \\n\\t//max Integer\\n    minPath := 1 << 31\\n    result := -1\\n    for i:=range bf1 {\\n        if bf1[i] == 1 << 31 || bf2[i] == 1 << 31{\\n            continue\\n        }\\n        \\n        v := max(bf1[i],bf2[i])\\n        if v < minPath{\\n            minPath = v\\n            result = i\\n        }\\n    }\\n    \\n    return result\\n}\\n\\nfunc calculateBellmanFord(root int, edges []int) []int{\\n    distances := make([]int, len(edges))\\n    for i:=range distances {\\n        distances[i]=1 << 31\\n    }\\n    distances[root]=0\\n    \\n    node := root\\n    for edges[node] != -1 {\\n        next := edges[node]\\n        if distances[next] > distances[node] + 1 {\\n            distances[next]=distances[node] + 1\\n            node = next\\n        }else{\\n            break\\n        }\\n    }\\n    \\n    return distances\\n}\\n\\nfunc max(a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n\\n/*\\n\\nbellman ford:\\n\\n root as node0:\\n   [0,MaxInt,1,2]\\n   \\n root as node1:\\n   [MaxInt,0,1,2]\\n\\n```\\n",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc closestMeetingNode(edges []int, node1 int, node2 int) int {\\n    return bellmanFord(edges, node1,node2)\\n}\\n\\nfunc bellmanFord(edges []int, node1 int, node2 int) int {\\n    bf1 := calculateBellmanFord(node1, edges)\\n    bf2 := calculateBellmanFord(node2,edges)\\n    \\n\\t//max Integer\\n    minPath := 1 << 31\\n    result := -1\\n    for i:=range bf1 {\\n        if bf1[i] == 1 << 31 || bf2[i] == 1 << 31{\\n            continue\\n        }\\n        \\n        v := max(bf1[i],bf2[i])\\n        if v < minPath{\\n            minPath = v\\n            result = i\\n        }\\n    }\\n    \\n    return result\\n}\\n\\nfunc calculateBellmanFord(root int, edges []int) []int{\\n    distances := make([]int, len(edges))\\n    for i:=range distances {\\n        distances[i]=1 << 31\\n    }\\n    distances[root]=0\\n    \\n    node := root\\n    for edges[node] != -1 {\\n        next := edges[node]\\n        if distances[next] > distances[node] + 1 {\\n            distances[next]=distances[node] + 1\\n            node = next\\n        }else{\\n            break\\n        }\\n    }\\n    \\n    return distances\\n}\\n\\nfunc max(a,b int) int {\\n    if a > b {\\n        return a\\n    }\\n    \\n    return b\\n}\\n\\n\\n/*\\n\\nbellman ford:\\n\\n root as node0:\\n   [0,MaxInt,1,2]\\n   \\n root as node1:\\n   [MaxInt,0,1,2]\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2380057,
                "title": "find-distance-c-easy-to-understand",
                "content": "- **Step 1:** Find the distance of each reachable node from the given two nodes using DFS \\n(Here DFS and BFS mean the same thing as each node points to a single node at max).\\n- **Step 2:** For the all the nodes find the node which is having smallest maximum distance from both the nodes\\n(can sound confusing on first reading, read the PS and this line again you will get it most probably). \\n- *The index (0 BASED) of this particular node is the answer.*\\n\\nFell free to ask any doubts regarding this :)\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector <int> &edges, vector <bool> &vis, vector <int> &path, int ind, int cost)\\n    {\\n        if(ind == -1 || vis[ind]) return ;\\n        vis[ind] = 1;\\n        path[ind] = cost;\\n        dfs(edges, vis, path, edges[ind], cost+1);\\n        return ;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector <int> path1(edges.size(), INT_MAX), path2(edges.size(), INT_MAX);\\n        vector <bool> vis(edges.size(), 0);\\n        dfs(edges, vis, path1, node1, 0);\\n        fill(vis.begin(), vis.end(), 0);\\n        dfs(edges, vis, path2, node2, 0);\\n        int ans = -1;\\n        int cost = INT_MAX;\\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            if(cost > max(path1[i], path2[i]))\\n            {\\n                cost = max(path1[i], path2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector <int> &edges, vector <bool> &vis, vector <int> &path, int ind, int cost)\\n    {\\n        if(ind == -1 || vis[ind]) return ;\\n        vis[ind] = 1;\\n        path[ind] = cost;\\n        dfs(edges, vis, path, edges[ind], cost+1);\\n        return ;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector <int> path1(edges.size(), INT_MAX), path2(edges.size(), INT_MAX);\\n        vector <bool> vis(edges.size(), 0);\\n        dfs(edges, vis, path1, node1, 0);\\n        fill(vis.begin(), vis.end(), 0);\\n        dfs(edges, vis, path2, node2, 0);\\n        int ans = -1;\\n        int cost = INT_MAX;\\n        for(int i = 0; i < edges.size(); i++)\\n        {\\n            if(cost > max(path1[i], path2[i]))\\n            {\\n                cost = max(path1[i], path2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2377924,
                "title": "o-n-solution-using-dfs-c",
                "content": "We can perform DFS separately for node1 and node2 to store their distances from each node. \\nNext, we iterate over each node and check if it is reachable from both node1 and node2. \\nWe return the node which has the minimum value of maximum distance. \\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> &arr,int s,vector<int> &d){\\n        vector<bool> vis(arr.size(),false);\\n        int dist = 0;\\n        while(s!=-1 && !vis[s]){\\n            vis[s] = true;\\n            d[s] = dist++;\\n            s = arr[s];\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& arr, int x, int y) {\\n        int n = arr.size();\\n        vector<int> d1(n,INT_MAX);\\n        vector<int> d2(n,INT_MAX);\\n        dfs(arr,x,d1);\\n        dfs(arr,y,d2);\\n        int minSoFar = INT_MAX;\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(d1[i]!=INT_MAX && d2[i]!=INT_MAX){\\n                int mx = max(d1[i],d2[i]);\\n                if(minSoFar>mx)\\n                    minSoFar = mx, ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<int> &arr,int s,vector<int> &d){\\n        vector<bool> vis(arr.size(),false);\\n        int dist = 0;\\n        while(s!=-1 && !vis[s]){\\n            vis[s] = true;\\n            d[s] = dist++;\\n            s = arr[s];\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& arr, int x, int y) {\\n        int n = arr.size();\\n        vector<int> d1(n,INT_MAX);\\n        vector<int> d2(n,INT_MAX);\\n        dfs(arr,x,d1);\\n        dfs(arr,y,d2);\\n        int minSoFar = INT_MAX;\\n        int ans = -1;\\n        for(int i=0;i<n;i++){\\n            if(d1[i]!=INT_MAX && d2[i]!=INT_MAX){\\n                int mx = max(d1[i],d2[i]);\\n                if(minSoFar>mx)\\n                    minSoFar = mx, ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2361021,
                "title": "c-solution-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>dp[100005];\\n    vector<int>find(int node)\\n    {\\n        vector<int>dis(n,INT_MAX);\\n        dis[node]=0;\\n        queue<int>q;\\n        q.push(node);\\n        int level=0;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto temp=q.front();\\n                dis[temp]=level;\\n                q.pop();\\n                for(auto &it:dp[temp])\\n                {\\n                    if(dis[it]==INT_MAX)\\n                      q.push(it);\\n                }\\n            }\\n            level++;\\n        }\\n        return dis;\\n    }\\n    int closestMeetingNode(vector<int>&nums, int node1, int node2) \\n    {\\n        n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=-1)\\n            {\\n                dp[i].push_back(nums[i]);\\n            }\\n        }\\n        vector<int>dis1=find(node1);\\n        vector<int>dis2=find(node2);\\n        int min_dis=INT_MAX;\\n        int dis=INT_MAX;\\n        int ans=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dis1[i]!=INT_MAX&&dis2[i]!=INT_MAX)\\n            {\\n                dis=min(dis,max(dis1[i],dis2[i]));\\n                if(dis<min_dis)\\n                {\\n                    min_dis=dis;\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<int>dp[100005];\\n    vector<int>find(int node)\\n    {\\n        vector<int>dis(n,INT_MAX);\\n        dis[node]=0;\\n        queue<int>q;\\n        q.push(node);\\n        int level=0;\\n        while(q.size())\\n        {\\n            int size=q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto temp=q.front();\\n                dis[temp]=level;\\n                q.pop();\\n                for(auto &it:dp[temp])\\n                {\\n                    if(dis[it]==INT_MAX)\\n                      q.push(it);\\n                }\\n            }\\n            level++;\\n        }\\n        return dis;\\n    }\\n    int closestMeetingNode(vector<int>&nums, int node1, int node2) \\n    {\\n        n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]!=-1)\\n            {\\n                dp[i].push_back(nums[i]);\\n            }\\n        }\\n        vector<int>dis1=find(node1);\\n        vector<int>dis2=find(node2);\\n        int min_dis=INT_MAX;\\n        int dis=INT_MAX;\\n        int ans=-1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dis1[i]!=INT_MAX&&dis2[i]!=INT_MAX)\\n            {\\n                dis=min(dis,max(dis1[i],dis2[i]));\\n                if(dis<min_dis)\\n                {\\n                    min_dis=dis;\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359681,
                "title": "c-easy-understanding-hashing-explained-code-commented-code",
                "content": "**Before Jumping to solution Let\\'s Understand the question First**\\nWe have two nodes node1 and node2 and we have to find the node in a graph which is reachable from both the nodes and this node will be taken from all the rechable nodes from both the nodes such that we first take the maximum disctance node from both the nodes and from all these maximum distance nodes we need minimum distance one.\\n\\nLet\\'s See Example which will make us easy to understand the question :\\nSuppose we have this graph\\n[9,8,7,0,5,6,1,3,2,2]\\n1\\n6\\nhere node1 = 1 and node2 = 6\\n![image](https://assets.leetcode.com/users/images/bd921527-ebc2-4d1c-b4eb-c31a6321af4e_1659264006.3965914.png)\\n\\nNow what we acctually have to find that common node from node1 and node2 which has minimum distance so we can ans is  1.\\n\\nNow Lets Try to understand how we will solve this\\nwe will try to calculate the distance from node1 to all reachable nodes\\nso by which we can get like\\n![image](https://assets.leetcode.com/users/images/1fdd69fb-ebf3-4be8-8aec-4e7d136c161a_1659264396.142254.png)\\nhere first row contains distance and second row cooresponding node.\\nhow as our source is node1 its distance to itself is zero then it can go to 8 by dist 1 similarly we update the distance to all other nodes \\nNow the stopping condition will be either we reach to end or if there\\'s a loop then we can stop when we see if our distance is already been update or not that we can see is our distance value is >=0 as we will initallise distance vector by -1;\\n\\nSimilary from node2 the distances are \\n![image](https://assets.leetcode.com/users/images/e8e187ef-f726-49fb-ab11-1c694ac02ca9_1659264664.4807918.png)\\n\\nnow we will start traversing dist vector simultaniously \\nif node ie specified by index is rechable by both nodes i.e it have dist >=0 in both vector then we will take maximum of that and keep track of it\\nLike \\nhere we have node 0 with distance 5,6 so we will take dist (6,0) ans we have to take maximum among these two and minimum among this and other distances\\nLike wise other pairs will be\\n(1,1) , (3,2), (5, 3), (4, 7), (2,8), (6, 7) we cant reach 4,5,6 \\nso from these distances we need minimum one which is 1 and it is corresponding to node (\\'1\\') so we return node 1;\\n\\n**Code (Upvote if you like the Explanation and solution)**\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2)\\n    {\\n        int size = edges.size();\\n        vector<int> dist1(size, -1); // will store the distances from node1 to all other nodes\\n        vector<int> dist2(size, -1);// will store the distances from node2 to all other nodes\\n        \\n        int dist = 0;\\n\\t\\t// calculate distance from node1 to other nodes\\n        while(node1 != -1)\\n        {\\n            if(dist1[node1] >= 0)break;   .// stoping condition if there\\'s a loop \\n            dist1[node1] = dist;   // updating dist in dist1 vector from node1\\n            dist++;\\n            node1 = edges[node1];\\n        }\\n        \\n        dist = 0;\\n\\t\\t// calculate distance from node2 to other nodes\\n        while(node2 != -1)\\n        {\\n            if(dist2[node2] >= 0)break;  // stoping condition if there\\'s a loop \\n            dist2[node2] = dist;// updating dist in dist2 vector from node2\\n            dist++;\\n            node2 = edges[node2];\\n        }\\n       \\n        pair<int, int> ans = make_pair(INT_MAX,INT_MAX);    // to keep track of minimum dist and ans node\\n        \\n        for(int i = 0; i < size; i++)\\n        {\\n            if(dist1[i] == -1 || dist2[i] == -1)    // specifies that node is not rechable by any one or both nodes\\n                continue;\\n            if(dist1[i] > dist2[i])   // as we need to take max from both dist rechable by both nodes\\n            {\\n                if(ans.first > dist1[i])  // as we take minimum among all those max distances\\n                {\\n                    ans.first = dist1[i]; // will store minimum dist\\n                    ans.second = i; // will store resultant node\\n                }\\n            }\\n            else\\n            {\\n                if(ans.first > dist2[i])\\n                {\\n                    ans.first = dist2[i];\\n                    ans.second = i;\\n                }\\n            }\\n        }\\n        \\n        if(ans.second == INT_MAX)return -1;  // if we dont have resultant node\\n        return ans.second;\\n    }\\n};\\n```\\n\\n**Upvote if you like**\\nLet me know if i made any mistake\\nthankyou",
                "solutionTags": [
                    "C",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2)\\n    {\\n        int size = edges.size();\\n        vector<int> dist1(size, -1); // will store the distances from node1 to all other nodes\\n        vector<int> dist2(size, -1);// will store the distances from node2 to all other nodes\\n        \\n        int dist = 0;\\n\\t\\t// calculate distance from node1 to other nodes\\n        while(node1 != -1)\\n        {\\n            if(dist1[node1] >= 0)break;   .// stoping condition if there\\'s a loop \\n            dist1[node1] = dist;   // updating dist in dist1 vector from node1\\n            dist++;\\n            node1 = edges[node1];\\n        }\\n        \\n        dist = 0;\\n\\t\\t// calculate distance from node2 to other nodes\\n        while(node2 != -1)\\n        {\\n            if(dist2[node2] >= 0)break;  // stoping condition if there\\'s a loop \\n            dist2[node2] = dist;// updating dist in dist2 vector from node2\\n            dist++;\\n            node2 = edges[node2];\\n        }\\n       \\n        pair<int, int> ans = make_pair(INT_MAX,INT_MAX);    // to keep track of minimum dist and ans node\\n        \\n        for(int i = 0; i < size; i++)\\n        {\\n            if(dist1[i] == -1 || dist2[i] == -1)    // specifies that node is not rechable by any one or both nodes\\n                continue;\\n            if(dist1[i] > dist2[i])   // as we need to take max from both dist rechable by both nodes\\n            {\\n                if(ans.first > dist1[i])  // as we take minimum among all those max distances\\n                {\\n                    ans.first = dist1[i]; // will store minimum dist\\n                    ans.second = i; // will store resultant node\\n                }\\n            }\\n            else\\n            {\\n                if(ans.first > dist2[i])\\n                {\\n                    ans.first = dist2[i];\\n                    ans.second = i;\\n                }\\n            }\\n        }\\n        \\n        if(ans.second == INT_MAX)return -1;  // if we dont have resultant node\\n        return ans.second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359377,
                "title": "dijkstra-algorithm",
                "content": "1. Use a the dijkstra to calculate the distance the between each node, the returned vector contains INT_MAX as a value if there is no path to reach the node and 0 if it is the node itself.\\n2. we store the value of the shortest path from the node1 and node2 to all the nodes.\\n3. Comparing part as we need the minimum of the maximum distance to reach the node. we chack if the maximum of the distance to node1 to the current node and node2 to the current node is smaller than mini , if yes we store the node as a ans and update mini with the max of distances.\\n```\\nclass Solution {\\npublic:\\n    vector<int> dijkstra(int S,vector<vector<pair<int,int>>> &adj,int n)\\n    {\\n\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n\\n\\tvector<int> dist(n,INT_MAX);\\n\\n\\tpq.push({0,S});\\n\\tdist[S]=0;\\n\\n\\twhile(!pq.empty())\\n\\t{\\n\\t\\tauto node=pq.top();\\n\\t\\tpq.pop();\\n\\n\\t\\tint vertex=node.second;\\n\\n\\t\\tfor(auto it: adj[vertex])\\n\\t\\t{\\n\\t\\t\\tif(dist[vertex]+it.second<dist[it.first])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdist[it.first]=dist[vertex]+it.second;\\n\\t\\t\\t\\tpq.push({dist[it.first],it.first});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dist;\\n}\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<vector<pair<int,int>>> adj(n);\\n        for(int i =0;i<n;i++)\\n        {\\n            if(edges[i]!=-1)\\n            adj[i].push_back({edges[i],1});\\n        }\\n        \\n        vector<int> d1 = dijkstra(node1,adj,n);\\n        vector<int> d2 = dijkstra(node2,adj,n);\\n        \\n        int mini = INT_MAX;\\n        int ans;\\n        for(int i =0;i<n;i++)\\n        {\\n             if(mini>max(d1[i],d2[i]))\\n             {\\n                 mini = min(mini,max(d1[i],d2[i]));\\n                 ans=i;\\n             }\\n        }\\n\\t\\t//if there is no smaller value than mini we return -1\\n        if(mini==INT_MAX)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dijkstra(int S,vector<vector<pair<int,int>>> &adj,int n)\\n    {\\n\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n\\n\\tvector<int> dist(n,INT_MAX);\\n\\n\\tpq.push({0,S});\\n\\tdist[S]=0;\\n\\n\\twhile(!pq.empty())\\n\\t{\\n\\t\\tauto node=pq.top();\\n\\t\\tpq.pop();\\n\\n\\t\\tint vertex=node.second;\\n\\n\\t\\tfor(auto it: adj[vertex])\\n\\t\\t{\\n\\t\\t\\tif(dist[vertex]+it.second<dist[it.first])\\n\\t\\t\\t{\\n\\t\\t\\t\\tdist[it.first]=dist[vertex]+it.second;\\n\\t\\t\\t\\tpq.push({dist[it.first],it.first});\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dist;\\n}\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<vector<pair<int,int>>> adj(n);\\n        for(int i =0;i<n;i++)\\n        {\\n            if(edges[i]!=-1)\\n            adj[i].push_back({edges[i],1});\\n        }\\n        \\n        vector<int> d1 = dijkstra(node1,adj,n);\\n        vector<int> d2 = dijkstra(node2,adj,n);\\n        \\n        int mini = INT_MAX;\\n        int ans;\\n        for(int i =0;i<n;i++)\\n        {\\n             if(mini>max(d1[i],d2[i]))\\n             {\\n                 mini = min(mini,max(d1[i],d2[i]));\\n                 ans=i;\\n             }\\n        }\\n\\t\\t//if there is no smaller value than mini we return -1\\n        if(mini==INT_MAX)\\n            return -1;\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359041,
                "title": "dijkstra-s-algorithm-single-source-shortest-path-easy-solution",
                "content": "**Solution-** Using Dijkstra\\'s Algorithm find Single Source Shortest Path (SSSP) for node1 and node2 and then find the **minimum of**( maximum of v1[i] and v2[i]) where *v1 is a minimum distance vector for source node1 and v2 is minimum distance vector for source node2.*\\n\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\tvector<int> dijkstra(int S,vector<vector<pair<int,int>>> &adj,int n)\\n\\t{\\n\\t\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n\\n\\t\\tvector<int> dist(n,INT_MAX);\\n\\n\\t\\tpq.push({0,S});\\n\\t\\tdist[S]=0;\\n\\n\\t\\twhile(!pq.empty())\\n\\t\\t{\\n\\t\\t\\tauto node=pq.top();\\n\\t\\t\\tpq.pop();\\n\\n\\t\\t\\tint vertex=node.second;\\n\\n\\t\\t\\tfor(auto it: adj[vertex])\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(dist[vertex]+it.second<dist[it.first])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdist[it.first]=dist[vertex]+it.second;\\n\\t\\t\\t\\t\\tpq.push({dist[it.first],it.first});\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn dist;\\n\\t}\\n\\tint closestMeetingNode(vector<int>& edges, int node1, int node2) \\n\\t{\\n\\t\\tint n=edges.size();\\n\\t\\tvector<vector<pair<int,int>>> adj(n);\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tif(edges[i]!=-1) adj[i].push_back({edges[i],1});\\n\\t\\t}\\n\\n\\t\\tvector<int> v1=dijkstra(node1,adj,n);\\n\\t\\tvector<int> v2=dijkstra(node2,adj,n);\\n\\t\\tint mini=INT_MAX;\\n\\n\\t\\tint hold=0;\\n\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\n\\t\\t\\tif(mini>max(v1[i],v2[i]))\\n\\t\\t\\t{\\n\\t\\t\\t\\tmini=min(mini,max(v1[i],v2[i]));\\n\\t\\t\\t\\thold=i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn (mini==INT_MAX)?-1:hold;\\n\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\tvector<int> dijkstra(int S,vector<vector<pair<int,int>>> &adj,int n)\\n\\t{\\n\\t\\tpriority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pq;\\n\\n\\t\\tvector<int> dist(n,INT_MAX);\\n\\n\\t\\tpq.push({0,S}",
                "codeTag": "Java"
            },
            {
                "id": 2358195,
                "title": "10ms-100-faster-java-solution",
                "content": "```\\nclass Solution {    \\n    void storePathLen(int[] reach, int startingPoint,int[] edges){\\n        int currPos=startingPoint,prevDistance=0;\\n        while(reach[currPos]==0){\\n            reach[currPos]=++prevDistance;\\n            currPos=edges[currPos];\\n            if(currPos==-1) break;\\n        }\\n    }\\n    \\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        if(node1==node2) return node1;\\n        int n=edges.length,i,res=Integer.MAX_VALUE,ans=-1,maxval;\\n        int reachedBy1[]=new int[n],reachedBy2[]=new int[n];\\n        storePathLen(reachedBy1,node1,edges);\\n        storePathLen(reachedBy2,node2,edges);\\n        for(i=0;i<n;i++){\\n            maxval=Math.max(reachedBy1[i],reachedBy2[i]);\\n            if(res>maxval && Math.min(reachedBy1[i],reachedBy2[i])!=0){\\n                res=maxval;\\n                ans=i;\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {    \\n    void storePathLen(int[] reach, int startingPoint,int[] edges){\\n        int currPos=startingPoint,prevDistance=0;\\n        while(reach[currPos]==0){\\n            reach[currPos]=++prevDistance;\\n            currPos=edges[currPos];\\n            if(currPos==-1) break;\\n        }\\n    }\\n    \\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        if(node1==node2) return node1;\\n        int n=edges.length,i,res=Integer.MAX_VALUE,ans=-1,maxval;\\n        int reachedBy1[]=new int[n],reachedBy2[]=new int[n];\\n        storePathLen(reachedBy1,node1,edges);\\n        storePathLen(reachedBy2,node2,edges);\\n        for(i=0;i<n;i++){\\n            maxval=Math.max(reachedBy1[i],reachedBy2[i]);\\n            if(res>maxval && Math.min(reachedBy1[i],reachedBy2[i])!=0){\\n                res=maxval;\\n                ans=i;\\n            }            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358144,
                "title": "dfs-hashmap-java",
                "content": "```\\nclass Solution {\\n    \\n    public void DFS(int i, int[] edges, HashMap<Integer, Integer> map, boolean[] visited, int dist){\\n        \\n        if(i == -1 || visited[i] == true)    return;\\n        \\n        visited[i] = true;\\n        map.put(i, dist);\\n        DFS(edges[i], edges, map, visited, dist + 1);\\n    }\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        \\n        int n = edges.length;\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        \\n        DFS(node1, edges, map1, new boolean[n], 0);\\n        DFS(node2, edges, map2, new boolean[n], 0);\\n        \\n        int min = Integer.MAX_VALUE;\\n        int res = -1;\\n     \\n        for(int key : map1.keySet()){\\n            \\n            int val1 = map1.get(key);\\n            if(map2.containsKey(key) == false)  continue;\\n            int val2 = map2.get(key);\\n            \\n            if(Math.max(val1, val2) == min){\\n                res = Math.min(res, key);\\n            }\\n            else if(Math.max(val1, val2) < min){\\n                min = Math.max(val1, val2);\\n                res = key;\\n            }\\n           \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public void DFS(int i, int[] edges, HashMap<Integer, Integer> map, boolean[] visited, int dist){\\n        \\n        if(i == -1 || visited[i] == true)    return;\\n        \\n        visited[i] = true;\\n        map.put(i, dist);\\n        DFS(edges[i], edges, map, visited, dist + 1);\\n    }\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        \\n        int n = edges.length;\\n        HashMap<Integer, Integer> map1 = new HashMap<>();\\n        HashMap<Integer, Integer> map2 = new HashMap<>();\\n        \\n        DFS(node1, edges, map1, new boolean[n], 0);\\n        DFS(node2, edges, map2, new boolean[n], 0);\\n        \\n        int min = Integer.MAX_VALUE;\\n        int res = -1;\\n     \\n        for(int key : map1.keySet()){\\n            \\n            int val1 = map1.get(key);\\n            if(map2.containsKey(key) == false)  continue;\\n            int val2 = map2.get(key);\\n            \\n            if(Math.max(val1, val2) == min){\\n                res = Math.min(res, key);\\n            }\\n            else if(Math.max(val1, val2) < min){\\n                min = Math.max(val1, val2);\\n                res = key;\\n            }\\n           \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2358029,
                "title": "o-n-direct-solution-with-explanation",
                "content": "Used two distance arrays for storing distance of each node from the given two nodes then finding the minimum maximum distance of node that is reachable by both nodes.\\n```\\nint closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        int dist1[n],dist2[n];\\n\\t\\t//also works as visited array\\n        for(int i=0;i<n;i++){\\n            dist1[i]=-1;\\n            dist2[i]=-1;\\n        }\\n        int count=1,temp1=node1;\\n        dist1[node1]=0;\\n\\t\\t//terminating condn -> if there is no outgoing edge from that node or the node is already visited\\n        while(edges[temp1]!=-1&&dist1[edges[temp1]]==-1){\\n            dist1[edges[temp1]]=count++;\\n            temp1=edges[temp1];\\n        }\\n        count=1;\\n        dist2[node2]=0;\\n        int temp2=node2;\\n        while(edges[temp2]!=-1&&dist2[edges[temp2]]==-1){\\n            dist2[edges[temp2]]=count++;\\n            temp2=edges[temp2];\\n        }\\n        int mini=INT_MAX, idx;\\n        for(int i=0;i<n;i++){\\n            //if either dist is -1 i.e. the node is not reachable\\n            if(dist1[i]!=-1&&dist2[i]!=-1&&(max(dist1[i],dist2[i])<mini)){\\n                mini=max(dist1[i],dist2[i]);\\n                idx=i;\\n            }\\n        }\\n        return (mini==INT_MAX)?-1:idx;\\n    }```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        int dist1[n],dist2[n];\\n\\t\\t//also works as visited array\\n        for(int i=0;i<n;i++){\\n            dist1[i]=-1;\\n            dist2[i]=-1;\\n        }\\n        int count=1,temp1=node1;\\n        dist1[node1]=0;\\n\\t\\t//terminating condn -> if there is no outgoing edge from that node or the node is already visited\\n        while(edges[temp1]!=-1&&dist1[edges[temp1]]==-1){\\n            dist1[edges[temp1]]=count++;\\n            temp1=edges[temp1];\\n        }\\n        count=1;\\n        dist2[node2]=0;\\n        int temp2=node2;\\n        while(edges[temp2]!=-1&&dist2[edges[temp2]]==-1){\\n            dist2[edges[temp2]]=count++;\\n            temp2=edges[temp2];\\n        }\\n        int mini=INT_MAX, idx;\\n        for(int i=0;i<n;i++){\\n            //if either dist is -1 i.e. the node is not reachable\\n            if(dist1[i]!=-1&&dist2[i]!=-1&&(max(dist1[i],dist2[i])<mini)){\\n                mini=max(dist1[i],dist2[i]);\\n                idx=i;\\n            }\\n        }\\n        return (mini==INT_MAX)?-1:idx;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2357935,
                "title": "faster-than-100-00-of-c-online-submissions-using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void distarray(vector<int>& edges, int node1,vector<int> &dist,vector<int>adj[])\\n    {\\n        queue<int> q;\\n        q.push(node1);\\n        dist[node1] = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i = 0; i<siz; i++)\\n            {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it :adj[node] )\\n            {\\n                if(dist[it]== INT_MAX)\\n                {\\n                    dist[it] = dist[node]+1;\\n                    q.push(it);\\n                }\\n            }\\n            }\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        int n = edges.size();\\n        vector<int> adj[n];\\n        for(int i = 0; i<n ; i++)\\n        {\\n            if(edges[i] != -1)\\n            {\\n            adj[i].push_back(edges[i]);\\n            }\\n        }\\n        vector<int> dist1(n , INT_MAX);\\n        vector<int> dist2(n , INT_MAX);\\n        distarray(edges, node1, dist1,adj);\\n        distarray(edges, node2, dist2,adj);\\n        int w=INT_MAX;\\n        int z=-1;\\n        for(int i=0;i<n;i++){\\n            if(dist1[i]!=INT_MAX&&dist2[i]!=INT_MAX){\\nint p=max(dist1[i],dist2[i]);\\n                if(w>p){\\n                    w=p;\\n                    z=i;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void distarray(vector<int>& edges, int node1,vector<int> &dist,vector<int>adj[])\\n    {\\n        queue<int> q;\\n        q.push(node1);\\n        dist[node1] = 0;\\n        \\n        while(!q.empty())\\n        {\\n            int siz = q.size();\\n            for(int i = 0; i<siz; i++)\\n            {\\n            int node = q.front();\\n            q.pop();\\n            for(auto it :adj[node] )\\n            {\\n                if(dist[it]== INT_MAX)\\n                {\\n                    dist[it] = dist[node]+1;\\n                    q.push(it);\\n                }\\n            }\\n            }\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        int n = edges.size();\\n        vector<int> adj[n];\\n        for(int i = 0; i<n ; i++)\\n        {\\n            if(edges[i] != -1)\\n            {\\n            adj[i].push_back(edges[i]);\\n            }\\n        }\\n        vector<int> dist1(n , INT_MAX);\\n        vector<int> dist2(n , INT_MAX);\\n        distarray(edges, node1, dist1,adj);\\n        distarray(edges, node2, dist2,adj);\\n        int w=INT_MAX;\\n        int z=-1;\\n        for(int i=0;i<n;i++){\\n            if(dist1[i]!=INT_MAX&&dist2[i]!=INT_MAX){\\nint p=max(dist1[i],dist2[i]);\\n                if(w>p){\\n                    w=p;\\n                    z=i;\\n                }\\n            }\\n        }\\n        return z;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357844,
                "title": "java-clean-simple-bfs",
                "content": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int[] vis = new int[edges.length];\\n        Queue<int[]> queue = new LinkedList<>();\\n        int result = Integer.MAX_VALUE;\\n        boolean found = false;\\n\\n        queue.add(new int[] { node1, 1 });\\n        queue.add(new int[] { node2, 2 });\\n\\n        while (!queue.isEmpty() && !found) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n\\n                if (cur[0] == -1 || vis[cur[0]] == cur[1])\\n                    continue;\\n\\n                if (vis[cur[0]] != 0) {\\n                    found = true;\\n                    result = Math.min(result, cur[0]);\\n                    continue;\\n                }\\n\\n                vis[cur[0]] = cur[1];\\n                queue.add(new int[] { edges[cur[0]], cur[1] });\\n            }\\n        }\\n\\n        return found ? result : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int[] vis = new int[edges.length];\\n        Queue<int[]> queue = new LinkedList<>();\\n        int result = Integer.MAX_VALUE;\\n        boolean found = false;\\n\\n        queue.add(new int[] { node1, 1 });\\n        queue.add(new int[] { node2, 2 });\\n\\n        while (!queue.isEmpty() && !found) {\\n            int size = queue.size();\\n\\n            for (int i = 0; i < size; i++) {\\n                int[] cur = queue.poll();\\n\\n                if (cur[0] == -1 || vis[cur[0]] == cur[1])\\n                    continue;\\n\\n                if (vis[cur[0]] != 0) {\\n                    found = true;\\n                    result = Math.min(result, cur[0]);\\n                    continue;\\n                }\\n\\n                vis[cur[0]] = cur[1];\\n                queue.add(new int[] { edges[cur[0]], cur[1] });\\n            }\\n        }\\n\\n        return found ? result : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357692,
                "title": "simple-breadth-first-search-with-explanation",
                "content": "##### Rationale\\n* Run a BFS from `node1` and `node2` to get all the reachable vertices with their distances\\n* Pick all the elements that exists in both and put them in `options` array. These are all our options\\n* If we don\\'t have any options, return `-1`. Otherwise, pick the smallest option\\n\\n```\\nclass Solution:\\n\\tdef get_neighbors(self, start: int, graph) -> Dict[int, int]:\\n\\t\\tdistances = defaultdict(lambda: math.inf)\\n\\n\\t\\tqueue = deque([start])\\n\\t\\tlevel = 0\\n\\n\\t\\twhile queue:\\n\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\tcurr = queue.popleft()\\n\\n\\t\\t\\t\\tif distances[curr] <= level:    \\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tdistances[curr] = level\\n\\n\\t\\t\\t\\tfor neighbor in graph[curr]:\\n\\t\\t\\t\\t\\tqueue.append(neighbor)\\n\\n\\t\\t\\tlevel += 1        \\n\\n\\t\\treturn distances\\n\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        graph = [[] for _ in range(n)]\\n        \\n        for _from, to in enumerate(edges):\\n            if to != -1:\\n                graph[_from].append(to)\\n        \\n        a = self.get_neighbors(node1, graph)\\n        b = self.get_neighbors(node2, graph)\\n                \\n        options = []    \\n        \\n        for idx in range(n):\\n            if a[idx] != math.inf and b[idx] != math.inf:\\n                options.append((max(a[idx], b[idx]), idx))\\n                \\n        if not options:\\n            return -1        \\n        \\n        return min(options)[1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n\\tdef get_neighbors(self, start: int, graph) -> Dict[int, int]:\\n\\t\\tdistances = defaultdict(lambda: math.inf)\\n\\n\\t\\tqueue = deque([start])\\n\\t\\tlevel = 0\\n\\n\\t\\twhile queue:\\n\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\tcurr = queue.popleft()\\n\\n\\t\\t\\t\\tif distances[curr] <= level:    \\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\tdistances[curr] = level\\n\\n\\t\\t\\t\\tfor neighbor in graph[curr]:\\n\\t\\t\\t\\t\\tqueue.append(neighbor)\\n\\n\\t\\t\\tlevel += 1        \\n\\n\\t\\treturn distances\\n\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        graph = [[] for _ in range(n)]\\n        \\n        for _from, to in enumerate(edges):\\n            if to != -1:\\n                graph[_from].append(to)\\n        \\n        a = self.get_neighbors(node1, graph)\\n        b = self.get_neighbors(node2, graph)\\n                \\n        options = []    \\n        \\n        for idx in range(n):\\n            if a[idx] != math.inf and b[idx] != math.inf:\\n                options.append((max(a[idx], b[idx]), idx))\\n                \\n        if not options:\\n            return -1        \\n        \\n        return min(options)[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3117663,
                "title": "java-explained-dfs",
                "content": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int []  dist1 = new int[n];\\n        int [] dist2 = new int[n];\\n        \\n        Arrays.fill(dist1, Integer.MAX_VALUE);\\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n        // making visited array also because of cycles\\n        \\n        boolean [] vis1 = new boolean[n];\\n        boolean [] vis2 = new boolean[n];\\n        \\n        \\n        // now the dfs traversal for the node 1 and node 2     \\n        dfs(edges, node1, vis1, dist1,-1);\\n        dfs(edges, node2, vis2, dist2,-1);\\n        \\n        int min =Integer.MAX_VALUE;\\n        int idx=-1;\\n        \\n        // comparing the max two distance arrays node and also updating the min value found\\n     \\n        int max =0;\\n        for(int i =0 ;i<dist1.length;i++)\\n        {\\n            max = Math.max(dist1[i],dist2[i]);\\n            // storing the index where we get the min\\n            if(max<min)\\n            {\\n                min = max;\\n                idx =i;          \\n            }\\n        }\\n        // returning the index \\n        return idx;\\n    }\\n    \\n    // simple dfs \\n    // no for loop as every node has one child\\n    public void dfs(int [] edges, int node, boolean [] vis, int [] dist, int sum)\\n    {\\n        \\n        if(vis[node] != true)\\n        {\\n           vis[node] = true;\\n            // increase the count as we keep traversing inside the graph\\n           if(dist[node] == Integer.MAX_VALUE)\\n               dist[node] = sum +1;     \\n           \\n           if(edges[node]!=-1)\\n           {\\n                 dfs(edges, edges[node], vis, dist, dist[node]);\\n            }\\n            \\n        }\\n     \\n       \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int []  dist1 = new int[n];\\n        int [] dist2 = new int[n];\\n        \\n        Arrays.fill(dist1, Integer.MAX_VALUE);\\n        Arrays.fill(dist2, Integer.MAX_VALUE);\\n        // making visited array also because of cycles\\n        \\n        boolean [] vis1 = new boolean[n];\\n        boolean [] vis2 = new boolean[n];\\n        \\n        \\n        // now the dfs traversal for the node 1 and node 2     \\n        dfs(edges, node1, vis1, dist1,-1);\\n        dfs(edges, node2, vis2, dist2,-1);\\n        \\n        int min =Integer.MAX_VALUE;\\n        int idx=-1;\\n        \\n        // comparing the max two distance arrays node and also updating the min value found\\n     \\n        int max =0;\\n        for(int i =0 ;i<dist1.length;i++)\\n        {\\n            max = Math.max(dist1[i],dist2[i]);\\n            // storing the index where we get the min\\n            if(max<min)\\n            {\\n                min = max;\\n                idx =i;          \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3104108,
                "title": "code-with-explainatoin-and-comment-in-c-dfs",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the distance from given node \\nThen find min of maximum distance of node i\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//solving using dfs \\n//first find the two dist vec to store the dist of fiven node to particular all n node \\n//then find the max from both and then find the min aming the max of two node \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n       vector<int>dist1(edges.size(),-1);\\n       vector<int>dist2(edges.size(), -1);\\n       vector<bool>vis(edges.size(), false);//visited vec\\n       //to calculate the dist using dfs\\n        dfs(node1, dist1, vis,edges,0);\\n        vis.assign(edges.size(),false);\\n        dfs(node2, dist2, vis,edges,0);\\n        int res = -1;//storing node as answer\\n        int maxi = edges.size();\\n\\n        for(int i = 0; i<edges.size(); i++){\\n            if(dist1[i]!=-1 &&dist2[i]!=-1){\\n            if(max(dist1[i], dist2[i])<maxi){\\n                maxi = max(dist1[i], dist2[i]);\\n                res= i;//storing node value if got min \\n            }\\n            }\\n        }\\n        return res;\\n    }\\n    void dfs(int node,vector<int> &dist, vector<bool>&vis,vector<int>& edges, int curdist  ){\\n        if(node!=-1 &&!vis[node]){\\n            vis[node]= true;\\n            dist[node]=curdist;\\n            //adj node is given in edges \\n            dfs(edges[node], dist, vis, edges,curdist+1);//adding adj node with curdist+1g\\n\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//solving using dfs \\n//first find the two dist vec to store the dist of fiven node to particular all n node \\n//then find the max from both and then find the min aming the max of two node \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n       vector<int>dist1(edges.size(),-1);\\n       vector<int>dist2(edges.size(), -1);\\n       vector<bool>vis(edges.size(), false);//visited vec\\n       //to calculate the dist using dfs\\n        dfs(node1, dist1, vis,edges,0);\\n        vis.assign(edges.size(),false);\\n        dfs(node2, dist2, vis,edges,0);\\n        int res = -1;//storing node as answer\\n        int maxi = edges.size();\\n\\n        for(int i = 0; i<edges.size(); i++){\\n            if(dist1[i]!=-1 &&dist2[i]!=-1){\\n            if(max(dist1[i], dist2[i])<maxi){\\n                maxi = max(dist1[i], dist2[i]);\\n                res= i;//storing node value if got min \\n            }\\n            }\\n        }\\n        return res;\\n    }\\n    void dfs(int node,vector<int> &dist, vector<bool>&vis,vector<int>& edges, int curdist  ){\\n        if(node!=-1 &&!vis[node]){\\n            vis[node]= true;\\n            dist[node]=curdist;\\n            //adj node is given in edges \\n            dfs(edges[node], dist, vis, edges,curdist+1);//adding adj node with curdist+1g\\n\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101211,
                "title": "solution-with-dfs-easy-to-understand",
                "content": "\\n# Approach\\n    using dfs search \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int> dfs(vector<int> edges,int node,unordered_map<int,int>&map,int step){\\n        \\n        //make the distance from first node to itself = 0\\n        if(step == 1)\\n            map[node] = 0;\\n        \\n        //itrate over the whole tree\\n        while(edges[node]!=-1){\\n            //this line check for loops\\n            if(map.find(edges[node])!=map.end())\\n                return map;\\n\\n            map[edges[node]] = step;\\n            node = edges[node];\\n            step++;        \\n        }\\n        return map;  \\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        if(node1 == node2)\\n            return node1;\\n            \\n        unordered_map<int,int>map1;\\n        unordered_map<int,int>map2;\\n\\n        dfs(edges,node1,map1,1);\\n        dfs(edges,node2,map2,1);\\n\\n        int z = INT_MAX;\\n        int number = -1;\\n        int x=0,y=0;\\n        for(int i=0;i<edges.size();i++){\\n            if(map1.find(i)!=map1.end() && map2.find(i)!=map2.end()){\\n                x = map1[i];\\n                y = map2[i];\\n                int r = max(x,y);\\n                if( z > r ){\\n                    z = r;\\n                    number = i;\\n                }\\n            }       \\n        }\\n\\n        return number; \\n    }\\n};\\n```\\n\\n\\n![3830b6d5-453c-437a-abd6-985abdeba827_1674616069.1794453.jpeg](https://assets.leetcode.com/users/images/8cbbfc0a-2b58-4d83-88d8-40b03a0044b0_1674726614.1900887.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int> dfs(vector<int> edges,int node,unordered_map<int,int>&map,int step){\\n        \\n        //make the distance from first node to itself = 0\\n        if(step == 1)\\n            map[node] = 0;\\n        \\n        //itrate over the whole tree\\n        while(edges[node]!=-1){\\n            //this line check for loops\\n            if(map.find(edges[node])!=map.end())\\n                return map;\\n\\n            map[edges[node]] = step;\\n            node = edges[node];\\n            step++;        \\n        }\\n        return map;  \\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        if(node1 == node2)\\n            return node1;\\n            \\n        unordered_map<int,int>map1;\\n        unordered_map<int,int>map2;\\n\\n        dfs(edges,node1,map1,1);\\n        dfs(edges,node2,map2,1);\\n\\n        int z = INT_MAX;\\n        int number = -1;\\n        int x=0,y=0;\\n        for(int i=0;i<edges.size();i++){\\n            if(map1.find(i)!=map1.end() && map2.find(i)!=map2.end()){\\n                x = map1[i];\\n                y = map2[i];\\n                int r = max(x,y);\\n                if( z > r ){\\n                    z = r;\\n                    number = i;\\n                }\\n            }       \\n        }\\n\\n        return number; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099694,
                "title": "a-2-pass-solution-in-python-bfs-loop-once-to-find-common-nodes",
                "content": "# Intuition\\n1. Problem refers to graph (probably BFS/DFS solution)\\n2. Mention of only one direction outedge clarifies we don\\'t need to search for multiple paths\\n3. What we are trying to find here is essentially a mid-point between 2 nodes. \\n4. Two options\\n- Do the 2 pass solution outlined below\\n- Start search from both nodes at the same time, keep track of nodes visited, the first node we see that both search paths have visited, that is the node we want.\\n\\n\\n# Approach\\n1. Collect distances of all nodes from each of the two nodes\\n2. Look for common nodes between these two sets of distances keeping track of best distance so far and the index of node for that best distance.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) : 2 pass to build distance dict, 1 pass to determine best distance\\n\\n\\n# Space complexity:\\nWe use the dictionary to maintain distances, which is also O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n\\n\\n        def collect_distances(next_node):\\n            distance_from_node= dict()        \\n            seen = set()\\n            distance = 0\\n            while True:\\n                seen.add(next_node)\\n                distance_from_node[next_node] = distance\\n                next_node = edges[next_node]\\n                if next_node in seen:\\n                    break\\n                if next_node == -1:\\n                    break\\n                distance += 1\\n            return distance_from_node\\n\\n\\n        distance_from_node_1 = collect_distances(node1)\\n        distance_from_node_2 = collect_distances(node2)\\n\\n        import math\\n        best_distance = math.inf\\n        mid_node = -1\\n        for n in range(0, len(edges)):\\n            if n in distance_from_node_1 and n in distance_from_node_2:\\n                next_distance = max(distance_from_node_1[n], distance_from_node_2[n])\\n                if best_distance > next_distance:\\n                    best_distance = next_distance\\n                    mid_node = n\\n        return mid_node\\n\\n\\n\\n\\n\\n        \\n            \\n\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n\\n\\n        def collect_distances(next_node):\\n            distance_from_node= dict()        \\n            seen = set()\\n            distance = 0\\n            while True:\\n                seen.add(next_node)\\n                distance_from_node[next_node] = distance\\n                next_node = edges[next_node]\\n                if next_node in seen:\\n                    break\\n                if next_node == -1:\\n                    break\\n                distance += 1\\n            return distance_from_node\\n\\n\\n        distance_from_node_1 = collect_distances(node1)\\n        distance_from_node_2 = collect_distances(node2)\\n\\n        import math\\n        best_distance = math.inf\\n        mid_node = -1\\n        for n in range(0, len(edges)):\\n            if n in distance_from_node_1 and n in distance_from_node_2:\\n                next_distance = max(distance_from_node_1[n], distance_from_node_2[n])\\n                if best_distance > next_distance:\\n                    best_distance = next_distance\\n                    mid_node = n\\n        return mid_node\\n\\n\\n\\n\\n\\n        \\n            \\n\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099281,
                "title": "c-easy-to-understand-dfs-map-beginner-friendly",
                "content": "# Intuition\\nvisit all the neighbors of node 1 first, then node 2\\n\\n# Approach\\nFind the maximum of steps covered by node1 and node 2 at the same time using dfs. if it is same for two nodes pick out the minimum one.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nmap<int,int> b;//for storing path of node 1\\nmap<int,int> c;//for storing max values\\nvoid first(int i,vector<int>& dp,vector<int>& edges,int p){\\n    if(i==-1)return;//reached end\\n    if(dp[i]!=-1)return;\\n    dp[i]=0;//marking as visited\\n    b[i]=p;// storing steps for node 1.\\n    first(edges[i],dp,edges,p+1);\\n}\\nvoid second(int i,vector<int>& dp,vector<int>& edges,int p){\\n    if(i==-1)return;\\n    if(dp[i]!=-1)return;\\n    dp[i]=0;\\n    if(b.find(i)!=b.end()){//if path is found for node 1\\n        int d=max(p,b[i]); //max of both the node at same time\\n        if(c.find(d)!=c.end())c[d]=min(i,c[d]);//min nodes for same value at same time\\n        else c[d]=i;\\n    }\\n    second(edges[i],dp,edges,p+1);\\n}\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int>dp (edges.size(),-1);\\n        vector<int>dp1 (edges.size(),-1);\\n        first(node1,dp,edges,0);\\n        second(node2,dp1,edges,0);\\n        int d=c.size();//if empty no common nodes\\n        return d==0?-1:c[c.begin()->first];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nmap<int,int> b;//for storing path of node 1\\nmap<int,int> c;//for storing max values\\nvoid first(int i,vector<int>& dp,vector<int>& edges,int p){\\n    if(i==-1)return;//reached end\\n    if(dp[i]!=-1)return;\\n    dp[i]=0;//marking as visited\\n    b[i]=p;// storing steps for node 1.\\n    first(edges[i],dp,edges,p+1);\\n}\\nvoid second(int i,vector<int>& dp,vector<int>& edges,int p){\\n    if(i==-1)return;\\n    if(dp[i]!=-1)return;\\n    dp[i]=0;\\n    if(b.find(i)!=b.end()){//if path is found for node 1\\n        int d=max(p,b[i]); //max of both the node at same time\\n        if(c.find(d)!=c.end())c[d]=min(i,c[d]);//min nodes for same value at same time\\n        else c[d]=i;\\n    }\\n    second(edges[i],dp,edges,p+1);\\n}\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int>dp (edges.size(),-1);\\n        vector<int>dp1 (edges.size(),-1);\\n        first(node1,dp,edges,0);\\n        second(node2,dp1,edges,0);\\n        int d=c.size();//if empty no common nodes\\n        return d==0?-1:c[c.begin()->first];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099138,
                "title": "easy-bfs-solution-c-o-n",
                "content": "# Intuition\\n 1. We need minimum distance of every node from node 1 and node 2.\\n 2. Dijkstra algorithm is not required here to calculate shortest    distance because distance between every node is 1\\n 3. Use either BFS or DFS to calculate shortest distance. (here, I have used BFS in the code)\\n\\n# Approach\\n1. Calculate distance of every node from node 1 and node 2 using BFS and store the distance in dist1[] and dist2[] respectively.\\n2. Now, for every node i from index 0 to n-1, find the maximum of dist1[i] and dist2[i].\\n3. If dist1[i]=-1 or dist2[i]=-1, it means the node i is unreachable from either or both of node 1 and node 2, so ignore this node.\\n4. Maintain a mini variable to calculate the minimum of max(dist[i], dist2[i]) and return the index for which this distance is minimum.\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> G[100005];\\n    void bfs(int node, int dist[])\\n    {\\n        \\n        queue<int> q;\\n        q.push(node);\\n        dist[node]=0;\\n        while(!q.empty())\\n        {\\n            int temp= q.front();\\n            q.pop();\\n            for(auto x: G[temp])\\n            {\\n                if(dist[x]==-1 || (dist[x]> dist[temp]+1))\\n                {\\n                    dist[x]= dist[temp]+1;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n= edges.size();\\n        int dist1[n], dist2[n];\\n        memset(dist1, -1, sizeof(dist1));\\n        memset(dist2, -1, sizeof(dist2));\\n        \\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            if(edges[i]!=-1)\\n            G[i].push_back(edges[i]);\\n        }\\n        \\n        bfs(node1, dist1);\\n        bfs(node2, dist2);\\n\\n        \\n        int mini=INT_MAX, ans=-1;\\n        for(int i=0; i<n;i++)\\n        {\\n            if(dist1[i]==-1 || dist2[i]==-1)\\n            continue;\\n            \\n            if(mini>(max(dist1[i], dist2[i])))\\n            {\\n                mini= max(dist1[i], dist2[i]);\\n                ans= i;\\n                \\n            }\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> G[100005];\\n    void bfs(int node, int dist[])\\n    {\\n        \\n        queue<int> q;\\n        q.push(node);\\n        dist[node]=0;\\n        while(!q.empty())\\n        {\\n            int temp= q.front();\\n            q.pop();\\n            for(auto x: G[temp])\\n            {\\n                if(dist[x]==-1 || (dist[x]> dist[temp]+1))\\n                {\\n                    dist[x]= dist[temp]+1;\\n                    q.push(x);\\n                }\\n            }\\n        }\\n\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n= edges.size();\\n        int dist1[n], dist2[n];\\n        memset(dist1, -1, sizeof(dist1));\\n        memset(dist2, -1, sizeof(dist2));\\n        \\n\\n        for(int i=0; i<edges.size(); i++)\\n        {\\n            if(edges[i]!=-1)\\n            G[i].push_back(edges[i]);\\n        }\\n        \\n        bfs(node1, dist1);\\n        bfs(node2, dist2);\\n\\n        \\n        int mini=INT_MAX, ans=-1;\\n        for(int i=0; i<n;i++)\\n        {\\n            if(dist1[i]==-1 || dist2[i]==-1)\\n            continue;\\n            \\n            if(mini>(max(dist1[i], dist2[i])))\\n            {\\n                mini= max(dist1[i], dist2[i]);\\n                ans= i;\\n                \\n            }\\n            \\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099137,
                "title": "o-n-single-dfs-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\n    byte[] visited ;\\n    int[] edges;\\n    boolean loop1 = false;\\n    boolean loop2 = false;\\n    private int dfs(int node1, int node2){\\n        if( visited[node1] == 1 && !loop1) {\\n            loop1 = true;\\n            if(loop2) return -1;\\n            else if(visited[node2] == 1) return node2;\\n            else if(edges[node2] == -1) return -1;\\n            visited[node2] = 2;\\n            return dfs(node1,edges[node2]);\\n        }else if(visited[node2] == 2 && !loop2){\\n            loop2 = true;\\n            if(loop1) return -1;\\n            else if(visited[node1] == 2) return node2;\\n            else if(edges[node1] == -1) return -1;\\n            visited[node1] = 1;\\n            return dfs(edges[node1],node2);\\n        }\\n        else if(visited[node1] == 2 && visited[node2] == 1)  return Math.min(node1,node2);\\n        else if(visited[node1] == 2) return node1;\\n        else if(visited[node2] == 1 ) return node2;\\n        else if( node1 == node2 ) return node1;\\n\\n        if(edges[node1] == -1 && edges[node2] == -1) {\\n            return - 1;\\n        }\\n        if(edges[node1] != -1){\\n            visited[node1] = 1;\\n            node1 = edges[node1];\\n        }\\n        if(edges[node2] != -1){\\n            visited[node2] = 2;\\n            node2 = edges[node2];\\n        }\\n        return dfs(node1,node2);\\n    }\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        visited = new byte[edges.length];\\n        this.edges = edges;\\n        return dfs(node1,node2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    byte[] visited ;\\n    int[] edges;\\n    boolean loop1 = false;\\n    boolean loop2 = false;\\n    private int dfs(int node1, int node2){\\n        if( visited[node1] == 1 && !loop1) {\\n            loop1 = true;\\n            if(loop2) return -1;\\n            else if(visited[node2] == 1) return node2;\\n            else if(edges[node2] == -1) return -1;\\n            visited[node2] = 2;\\n            return dfs(node1,edges[node2]);\\n        }else if(visited[node2] == 2 && !loop2){\\n            loop2 = true;\\n            if(loop1) return -1;\\n            else if(visited[node1] == 2) return node2;\\n            else if(edges[node1] == -1) return -1;\\n            visited[node1] = 1;\\n            return dfs(edges[node1],node2);\\n        }\\n        else if(visited[node1] == 2 && visited[node2] == 1)  return Math.min(node1,node2);\\n        else if(visited[node1] == 2) return node1;\\n        else if(visited[node2] == 1 ) return node2;\\n        else if( node1 == node2 ) return node1;\\n\\n        if(edges[node1] == -1 && edges[node2] == -1) {\\n            return - 1;\\n        }\\n        if(edges[node1] != -1){\\n            visited[node1] = 1;\\n            node1 = edges[node1];\\n        }\\n        if(edges[node2] != -1){\\n            visited[node2] = 2;\\n            node2 = edges[node2];\\n        }\\n        return dfs(node1,node2);\\n    }\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        visited = new byte[edges.length];\\n        this.edges = edges;\\n        return dfs(node1,node2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099133,
                "title": "short-clear-solution-for-beginners",
                "content": "```\\nclass Solution {\\npublic:\\n    int inf = 1e9+7;\\n    vector<int> bfs(vector<int> &a, int source){\\n        queue<int> q;\\n        int n = a.size();\\n        vector<int> d(n, inf); // Distance vector to store the distance of each\\n                               // node from given source node.\\n        q.push(source);\\n        int distance = 0; \\n        while(!q.empty()){\\n            int qs = q.size();\\n            while(qs--){\\n                int u = q.front();\\n                q.pop();\\n\\n                if(d[u] != inf) // To avoid cycles\\n                    continue;\\n                    \\n                d[u] = distance;\\n                if(a[u] != -1)\\n                    q.push(a[u]);\\n            }\\n            distance++;\\n        }\\n        return d;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n        vector<int> d1, d2;\\n        d1 = bfs(edges, node1);\\n        d2 = bfs(edges, node2);\\n        \\n        int curr_min = inf, ans = -1;\\n        for(int i = 0; i < n; i++){\\n            int node_max = max(d1[i], d2[i]); // maximum distance between ith node to node1\\n                                              // and ith node to node2.\\n            if(curr_min > node_max){\\n                ans = i;\\n                curr_min = node_max;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int inf = 1e9+7;\\n    vector<int> bfs(vector<int> &a, int source){\\n        queue<int> q;\\n        int n = a.size();\\n        vector<int> d(n, inf); // Distance vector to store the distance of each\\n                               // node from given source node.\\n        q.push(source);\\n        int distance = 0; \\n        while(!q.empty()){\\n            int qs = q.size();\\n            while(qs--){\\n                int u = q.front();\\n                q.pop();\\n\\n                if(d[u] != inf) // To avoid cycles\\n                    continue;\\n                    \\n                d[u] = distance;\\n                if(a[u] != -1)\\n                    q.push(a[u]);\\n            }\\n            distance++;\\n        }\\n        return d;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n        vector<int> d1, d2;\\n        d1 = bfs(edges, node1);\\n        d2 = bfs(edges, node2);\\n        \\n        int curr_min = inf, ans = -1;\\n        for(int i = 0; i < n; i++){\\n            int node_max = max(d1[i], d2[i]); // maximum distance between ith node to node1\\n                                              // and ith node to node2.\\n            if(curr_min > node_max){\\n                ans = i;\\n                curr_min = node_max;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098962,
                "title": "no-bfs-no-dfs-simple-java-solution-for-beginners",
                "content": "class Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n=edges.length;\\n        \\n        int dist1[]=new int[n];\\n        int dist2[]=new int[n];\\n        Arrays.fill(dist1,-1);\\n        Arrays.fill(dist2,-1);\\n        int d=1;\\n        \\n        while(node1!=-1){\\n            \\n            if(dist1[node1]!=-1){\\n                break;\\n            }\\n            \\n            dist1[node1]+=d;\\n            node1=edges[node1];\\n            d++;\\n        }\\n        \\n        d=1;\\n        \\n         while(node2!=-1){\\n            \\n            if(dist2[node2]!=-1){\\n                break;\\n            }\\n            \\n            dist2[node2]+=d;\\n            node2=edges[node2];\\n            d++;\\n        }\\n        \\n        int minD=Integer.MAX_VALUE;\\n        int ans=-1;\\n        for(int i=0;i<n;i++){\\n            if(dist1[i]!=-1 && dist2[i]!=-1){\\n                if(minD>Math.max(dist1[i],dist2[i])){\\n                    minD=Math.max(dist1[i],dist2[i]);\\n                    ans=i;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "class Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n=edges.length;\\n        \\n        int dist1[]=new int[n];\\n        int dist2[]=new int[n];\\n        Arrays.fill(dist1,-1);\\n        Arrays.fill(dist2,-1);\\n        int d=1;\\n        \\n        while(node1!=-1){\\n            \\n            if(dist1[node1]!=-1){\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3098876,
                "title": "c-intutive-solution-easy-to-understand-faster-clean",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we need to find the index of node which is at minimum of maximum distance from both the given nodes.\\nLets say we have edges as [2, 2, 3, -1] and node1 = 0, node2 = 1.\\nWe will calculate distance of each node from each of given nodes and then compare the maximums of each index. The index at which we will be getting the minimum of maximums from both distance array that index would be our resulting node.\\nFor above :\\n```\\nmx = number_of_edges+1\\ndistance_from_node1 = [0, mx, 1, 2]\\ndistance_from_node1 = [mx, 0, 1, 2]\\nmaximums_at_each_Node = [mx, mx, 1, 2]\\n```\\nHence our resulting node will be 2 as we are getting the minimum of all maximums at that node.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Maintain two arrays for distances of each node from 2 given nodes.\\n2. For distance we can do simplified traversal as each node can have at max one outward edges.\\n3. During the traversal if we encounter the child having the edge to its parent i.e the child node of that child has distance less than the max distance, at that instance break the loop.\\n4. After computing distance we can compare them and return the index at which we are getting minimum of maximum distance.\\n# Complexity\\n- Time complexity: $$O(n)$$\\nAs we are iterating over nodes only thrice sepraterly. \\nHence $$O(n)$$ + $$O(n)$$ + $$O(n)$$ = $$O(3n)$$ = $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\nHere we are using two arrays of length n for distance computation.\\nHence $$O(n)$$ + $$O(n)$$ = $$O(2n)$$ = $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> distance_from_node1(n+1, n+1), distance_from_node2(n+1, n+1);\\n        \\n        distance_from_node1[node1] = distance_from_node2[node2] = 0;\\n        \\n        int curr = node1, distance_traversed_sofar = 0;\\n        \\n        while(edges[curr] != -1)\\n        {\\n            curr = edges[curr];\\n            if(distance_from_node1[curr] != n+1)break;\\n            distance_from_node1[curr] = ++distance_traversed_sofar;\\n        }\\n\\n        curr = node2;\\n        distance_traversed_sofar = 0;\\n        \\n        while(edges[curr] != -1)\\n        {\\n            curr = edges[curr];\\n            if(distance_from_node2[curr] != n+1)break;\\n            distance_from_node2[curr] = ++distance_traversed_sofar;\\n        }\\n\\n        int ans = n+1, idx = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(ans > max(distance_from_node1[i],distance_from_node2[i]))\\n            {\\n                idx = i;\\n                ans = max(distance_from_node1[i],distance_from_node2[i]);\\n            }\\n        }\\n\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nmx = number_of_edges+1\\ndistance_from_node1 = [0, mx, 1, 2]\\ndistance_from_node1 = [mx, 0, 1, 2]\\nmaximums_at_each_Node = [mx, mx, 1, 2]\\n```\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> distance_from_node1(n+1, n+1), distance_from_node2(n+1, n+1);\\n        \\n        distance_from_node1[node1] = distance_from_node2[node2] = 0;\\n        \\n        int curr = node1, distance_traversed_sofar = 0;\\n        \\n        while(edges[curr] != -1)\\n        {\\n            curr = edges[curr];\\n            if(distance_from_node1[curr] != n+1)break;\\n            distance_from_node1[curr] = ++distance_traversed_sofar;\\n        }\\n\\n        curr = node2;\\n        distance_traversed_sofar = 0;\\n        \\n        while(edges[curr] != -1)\\n        {\\n            curr = edges[curr];\\n            if(distance_from_node2[curr] != n+1)break;\\n            distance_from_node2[curr] = ++distance_traversed_sofar;\\n        }\\n\\n        int ans = n+1, idx = -1;\\n        for(int i=0; i<n; i++)\\n        {\\n            if(ans > max(distance_from_node1[i],distance_from_node2[i]))\\n            {\\n                idx = i;\\n                ans = max(distance_from_node1[i],distance_from_node2[i]);\\n            }\\n        }\\n\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098660,
                "title": "c-walk-through-graph-from-both-nodes-count-distances-minimize",
                "content": "# Intuition\\nWalk through graph from each node and count steps and generate two sequences of pairs (node, step).\\nFor each node that was visited in both walks (contains in both sequences) find Max(step).\\nReturn the node that has minimal Max(step) value.\\nIf there is no such node that was met in both walks, return -1;\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can use helper function that generates walk sequence of pairs. For convinience (we need to check for loops while walking through graph using hash table) we can generate the resulting sequence in a form of Dictionary (hash map) with Key = node and Value = step.\\nThough it is not necessary. We could also use HashSet to keep track of visited nodes and generate IEnumerable<int> sequence using `yield return`. Then add step counters by using indexed selector before concatenating two sequences.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```c#\\npublic class Solution\\n{\\n    public int ClosestMeetingNode(int[] edges, int node1, int node2)\\n    {\\n        return Walk(node1).Concat(Walk(node2))\\n            .ToLookup(x => x.Key, x => x.Value)\\n            .Where(x => x.Count() > 1)\\n            .Select(x => (x.Key, x.Max(y => y)))\\n            .DefaultIfEmpty((-1, -1))\\n            .Min(x => (maxDistance: x.Item2, node: x.Item1))\\n            .node;\\n\\n        Dictionary<int,int> Walk(int node, int step = 0)\\n        {\\n            var visited = new Dictionary<int, int>();\\n            visited[node] = step++;\\n            while(edges[node] >= 0)\\n            {\\n                node = edges[node];\\n                if(visited.ContainsKey(node))\\n                {\\n                    break;\\n                }\\n                visited[node] = step++;\\n            }\\n            return visited;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```c#\\npublic class Solution\\n{\\n    public int ClosestMeetingNode(int[] edges, int node1, int node2)\\n    {\\n        return Walk(node1).Concat(Walk(node2))\\n            .ToLookup(x => x.Key, x => x.Value)\\n            .Where(x => x.Count() > 1)\\n            .Select(x => (x.Key, x.Max(y => y)))\\n            .DefaultIfEmpty((-1, -1))\\n            .Min(x => (maxDistance: x.Item2, node: x.Item1))\\n            .node;\\n\\n        Dictionary<int,int> Walk(int node, int step = 0)\\n        {\\n            var visited = new Dictionary<int, int>();\\n            visited[node] = step++;\\n            while(edges[node] >= 0)\\n            {\\n                node = edges[node];\\n                if(visited.ContainsKey(node))\\n                {\\n                    break;\\n                }\\n                visited[node] = step++;\\n            }\\n            return visited;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098505,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void distance(int node , int dist , vector<int>& edges , vector<int> &arr){\\n        if(node == -1 || arr[node] != INT_MAX) return;\\n\\n        arr[node] = dist;\\n        distance(edges[node] , dist+1 , edges , arr);\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> arr1(n , INT_MAX) , arr2(n , INT_MAX);\\n\\n        distance(node1 , 0 , edges , arr1);\\n        distance(node2 , 0 , edges , arr2);\\n        int minDis = INT_MAX;\\n        int ans = -1;\\n        for(int i=0 ; i<n ; i++){\\n            if(arr1[i] != INT_MAX && arr2[i] != INT_MAX){\\n                if(minDis > max(arr1[i] , arr2[i])){\\n                    minDis = max(arr1[i] , arr2[i]);\\n                    ans = i;\\n                }     \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void distance(int node , int dist , vector<int>& edges , vector<int> &arr){\\n        if(node == -1 || arr[node] != INT_MAX) return;\\n\\n        arr[node] = dist;\\n        distance(edges[node] , dist+1 , edges , arr);\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> arr1(n , INT_MAX) , arr2(n , INT_MAX);\\n\\n        distance(node1 , 0 , edges , arr1);\\n        distance(node2 , 0 , edges , arr2);\\n        int minDis = INT_MAX;\\n        int ans = -1;\\n        for(int i=0 ; i<n ; i++){\\n            if(arr1[i] != INT_MAX && arr2[i] != INT_MAX){\\n                if(minDis > max(arr1[i] , arr2[i])){\\n                    minDis = max(arr1[i] , arr2[i]);\\n                    ans = i;\\n                }     \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098475,
                "title": "meet-in-the-middle-approach-implemented-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe want to find the first place that two starting locations meet, we can do this by walking forward with both and the first time we arrive at a spot the other direction has already been, this will be the closest location. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can initialize our variables, two sets to keep track of the nodes we have visited from the right and the left side, and values to track our current right and left positions.\\nThen we want to iterate until we have done one of two things:\\n- Found a shared node\\n- Dead ended/cycled from both sides\\n \\n# Complexity\\n**Time complexity:**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) - we will at most look at every node before determining if there is a shared node.\\n\\n**Space complexity:**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - At most we will have to store that we have visited every node.\\n\\n# Notes\\nIn the comment for the code, I mention Dijkstra\\'s but this is not implemented since we only have at most one out going edge for each Node we don\\'t need to track a set of \"current\" nodes. Just the one current node of each side. \\n \\n# Code\\n```\\npublic class Solution {\\n    public int ClosestMeetingNode(int[] edges, int node1, int node2) {\\n        // I think we can run meet in the middle for this pretty well, you do one step of Dijkstra\\'s on each side until you hit a node you have both seen\\n        // We could have cycles so we want to keep a visted graph for both sides so we don\\'t just run infinatly\\n        int leftCur = node1;\\n        int rightCur = node2;\\n        HashSet<int> leftVisted = new HashSet<int>();\\n        HashSet<int> rightVisted = new HashSet<int>();\\n        while(leftCur != -1 || rightCur != -1){\\n            int leftSolve = -1;\\n            int rightSolve = -1;\\n            if(leftVisted.Contains(leftCur)){\\n                leftCur = -1;\\n            }\\n            if(leftCur != -1 ){\\n                if(rightVisted.Contains(leftCur)){\\n                    leftSolve = leftCur;\\n                }\\n                leftVisted.Add(leftCur);\\n                leftCur = edges[leftCur];\\n            }\\n            if(rightVisted.Contains(rightCur)){\\n                rightCur = -1;\\n            }\\n            if(rightCur != -1){\\n                if(leftVisted.Contains(rightCur)){\\n                    rightSolve = rightCur;\\n                }\\n                rightVisted.Add(rightCur);\\n                rightCur = edges[rightCur];\\n            }\\n            if(leftSolve > -1 && rightSolve > -1){\\n                return Math.Min(leftSolve,rightSolve);\\n            }\\n            if(leftSolve > -1 || rightSolve > -1){\\n                return Math.Max(leftSolve,rightSolve);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n# Further Reading\\nI found this video on this technique very helpful:\\nhttps://www.youtube.com/watch?v=wL3uWO-KLUE&t=1s&ab_channel=polylog\\n\\n",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int ClosestMeetingNode(int[] edges, int node1, int node2) {\\n        // I think we can run meet in the middle for this pretty well, you do one step of Dijkstra\\'s on each side until you hit a node you have both seen\\n        // We could have cycles so we want to keep a visted graph for both sides so we don\\'t just run infinatly\\n        int leftCur = node1;\\n        int rightCur = node2;\\n        HashSet<int> leftVisted = new HashSet<int>();\\n        HashSet<int> rightVisted = new HashSet<int>();\\n        while(leftCur != -1 || rightCur != -1){\\n            int leftSolve = -1;\\n            int rightSolve = -1;\\n            if(leftVisted.Contains(leftCur)){\\n                leftCur = -1;\\n            }\\n            if(leftCur != -1 ){\\n                if(rightVisted.Contains(leftCur)){\\n                    leftSolve = leftCur;\\n                }\\n                leftVisted.Add(leftCur);\\n                leftCur = edges[leftCur];\\n            }\\n            if(rightVisted.Contains(rightCur)){\\n                rightCur = -1;\\n            }\\n            if(rightCur != -1){\\n                if(leftVisted.Contains(rightCur)){\\n                    rightSolve = rightCur;\\n                }\\n                rightVisted.Add(rightCur);\\n                rightCur = edges[rightCur];\\n            }\\n            if(leftSolve > -1 && rightSolve > -1){\\n                return Math.Min(leftSolve,rightSolve);\\n            }\\n            if(leftSolve > -1 || rightSolve > -1){\\n                return Math.Max(leftSolve,rightSolve);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098371,
                "title": "python3-915-ms-faster-than-98-28-of-python3",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        curr = [(node1 , 1), (node2 , 2)]\\n        v = [0] * len(edges)\\n        node = inf \\n        while curr:\\n            new = []\\n            f = False\\n            for a,w in curr:\\n                if v[a] == 0:\\n                    if edges[a] != -1:\\n                        new.append((edges[a] , w))\\n                    v[a] = w \\n                elif v[a] != w:\\n                    f = True\\n                    node = min(a,node)\\n            if f:\\n                return node\\n            curr = new \\n\\n        return -1 \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        curr = [(node1 , 1), (node2 , 2)]\\n        v = [0] * len(edges)\\n        node = inf \\n        while curr:\\n            new = []\\n            f = False\\n            for a,w in curr:\\n                if v[a] == 0:\\n                    if edges[a] != -1:\\n                        new.append((edges[a] , w))\\n                    v[a] = w \\n                elif v[a] != w:\\n                    f = True\\n                    node = min(a,node)\\n            if f:\\n                return node\\n            curr = new \\n\\n        return -1 \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098127,
                "title": "c-solution-using-dfs-from-both-nodes",
                "content": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& ed, int n1, int n2) {\\n        //dfs on node1\\n        unordered_map<int,int> m1;\\n        unordered_set<int> vis1;\\n        vis1.insert(n1);\\n        int count=0;\\n        while(true){\\n            m1[n1]= count;\\n            count++;\\n            if(ed[n1]==-1 || vis1.count(ed[n1]))break;\\n            n1= ed[n1];\\n            vis1.insert(n1);\\n        }\\n        \\n        //dfs on node2\\n        count=0;\\n        unordered_set<int> vis;\\n        vis.insert(n2);\\n        int ans= INT_MAX, dis= INT_MAX;\\n        while(true){\\n            if(m1.find(n2)!= m1.end()){\\n                if(max(count,m1[n2]) < dis){\\n                    dis= max(count,m1[n2]);\\n                    ans= n2;\\n                }\\n                else if(max(count,m1[n2]) == dis) ans= min(ans,n2);\\n            }\\n            count++;\\n            if(ed[n2]==-1 || vis.count(ed[n2])) break;\\n            n2= ed[n2];\\n            vis.insert(n2);\\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& ed, int n1, int n2) {\\n        //dfs on node1\\n        unordered_map<int,int> m1;\\n        unordered_set<int> vis1;\\n        vis1.insert(n1);\\n        int count=0;\\n        while(true){\\n            m1[n1]= count;\\n            count++;\\n            if(ed[n1]==-1 || vis1.count(ed[n1]))break;\\n            n1= ed[n1];\\n            vis1.insert(n1);\\n        }\\n        \\n        //dfs on node2\\n        count=0;\\n        unordered_set<int> vis;\\n        vis.insert(n2);\\n        int ans= INT_MAX, dis= INT_MAX;\\n        while(true){\\n            if(m1.find(n2)!= m1.end()){\\n                if(max(count,m1[n2]) < dis){\\n                    dis= max(count,m1[n2]);\\n                    ans= n2;\\n                }\\n                else if(max(count,m1[n2]) == dis) ans= min(ans,n2);\\n            }\\n            count++;\\n            if(ed[n2]==-1 || vis.count(ed[n2])) break;\\n            n2= ed[n2];\\n            vis.insert(n2);\\n        }\\n        \\n        return ans==INT_MAX?-1:ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098055,
                "title": "java-made-easy",
                "content": "First calculate minimum distance from the given node to all other nodes, and store the result in an array.\\nThen you can calculate the result using a simple for loop :)\\n```\\nclass Solution \\n{\\n    public int closestMeetingNode(int[] edges, int node1, int node2)\\n    {\\n        int n = edges.length;\\n        int[] dist1 = minDist(edges, node1, n);\\n        int[] dist2 = minDist(edges, node2, n);\\n        \\n        int minDist = Integer.MAX_VALUE, res = -1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dist1[i] > -1 && dist2[i] > -1 && Math.max(dist1[i], dist2[i]) < minDist){\\n                minDist = Math.max(dist1[i], dist2[i]);\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int[] minDist(int[] edges, int node, int n)\\n    {\\n        int[] ar = new int[n];\\n        Arrays.fill(ar, -1);\\n        ar[node] = 0;\\n\\n        if(edges[node] != -1) node = edges[node];\\n        \\n        int steps = 1;\\n        while(node != -1)\\n        {\\n            if(ar[node] == -1)\\n            {\\n                ar[node] = steps++;\\n                node = edges[node];\\n            }\\n            else\\n                node = -1;\\n        }\\n        return ar;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int closestMeetingNode(int[] edges, int node1, int node2)\\n    {\\n        int n = edges.length;\\n        int[] dist1 = minDist(edges, node1, n);\\n        int[] dist2 = minDist(edges, node2, n);\\n        \\n        int minDist = Integer.MAX_VALUE, res = -1;\\n        for(int i = 0; i < n; i++)\\n        {\\n            if(dist1[i] > -1 && dist2[i] > -1 && Math.max(dist1[i], dist2[i]) < minDist){\\n                minDist = Math.max(dist1[i], dist2[i]);\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    int[] minDist(int[] edges, int node, int n)\\n    {\\n        int[] ar = new int[n];\\n        Arrays.fill(ar, -1);\\n        ar[node] = 0;\\n\\n        if(edges[node] != -1) node = edges[node];\\n        \\n        int steps = 1;\\n        while(node != -1)\\n        {\\n            if(ar[node] == -1)\\n            {\\n                ar[node] = steps++;\\n                node = edges[node];\\n            }\\n            else\\n                node = -1;\\n        }\\n        return ar;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097843,
                "title": "js-dfs-short-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn order to find intersecting node from 2 nodes solution, we will need to visit all nodes from `node1` and `node2`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDFS from both nodes, iterate over all visited nodes and check if it\\'s visited by both nodes. If so take optimal one described in the Description\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} edges\\n * @param {number} node1\\n * @param {number} node2\\n * @return {number}\\n */\\nvar closestMeetingNode = function(edges, node1, node2) {\\n    const dfs = (node, obj, cnt = 0) => {\\n        // Check if it\\'s already visited - i.e. cyclic\\n        if(node === -1 || typeof(obj[node]) !== \"undefined\"){return;}\\n        obj[node] = cnt;\\n\\n        dfs(edges[node], obj, cnt+1);\\n    }\\n\\n    const from1 = {}\\n    const from2 = {};\\n    dfs(node1, from1)\\n    dfs(node2, from2)\\n\\n    let mx = 0, ind = -1;\\n    Object.keys(from1).forEach(key=>{\\n        const costFrom1 = from1[key];\\n        const costFrom2 = from2[key];\\n\\n        // check if `key` node is visited by node2 as well\\n        if(typeof costFrom2 !== \"undefined\"){\\n            if(ind===-1 \\n                || mx > Math.max(costFrom1, costFrom2) \\n                || (mx === Math.max(costFrom1, costFrom2) && ind>key)\\n                ){\\n                mx = Math.max(costFrom1, costFrom2);\\n                ind = key;\\n            }\\n        }\\n    })\\n\\n    return ind;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} edges\\n * @param {number} node1\\n * @param {number} node2\\n * @return {number}\\n */\\nvar closestMeetingNode = function(edges, node1, node2) {\\n    const dfs = (node, obj, cnt = 0) => {\\n        // Check if it\\'s already visited - i.e. cyclic\\n        if(node === -1 || typeof(obj[node]) !== \"undefined\"){return;}\\n        obj[node] = cnt;\\n\\n        dfs(edges[node], obj, cnt+1);\\n    }\\n\\n    const from1 = {}\\n    const from2 = {};\\n    dfs(node1, from1)\\n    dfs(node2, from2)\\n\\n    let mx = 0, ind = -1;\\n    Object.keys(from1).forEach(key=>{\\n        const costFrom1 = from1[key];\\n        const costFrom2 = from2[key];\\n\\n        // check if `key` node is visited by node2 as well\\n        if(typeof costFrom2 !== \"undefined\"){\\n            if(ind===-1 \\n                || mx > Math.max(costFrom1, costFrom2) \\n                || (mx === Math.max(costFrom1, costFrom2) && ind>key)\\n                ){\\n                mx = Math.max(costFrom1, costFrom2);\\n                ind = key;\\n            }\\n        }\\n    })\\n\\n    return ind;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3097793,
                "title": "simple-solution",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGet the distance from node1 and node2 to all other nodes, visit  every node and get the minimum distance so far\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> v1(n, INT_MAX), v2(n, INT_MAX);\\n        for(int i = node1, dis = 0; i != -1; i = edges[i], ++dis){\\n            if(v1[i] != INT_MAX) break; // cycle\\n            v1[i] = dis;\\n        }\\n        for(int i = node2, dis = 0; i != -1; i = edges[i], ++dis){\\n            if(v2[i] != INT_MAX) break; // cycle\\n            v2[i] = dis;\\n        }\\n        int minDis = INT_MAX, ans = -1;\\n        for(int i = 0; i < n; ++i){\\n            int t = max(v1[i], v2[i]);\\n            if(t < minDis) minDis = t, ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> v1(n, INT_MAX), v2(n, INT_MAX);\\n        for(int i = node1, dis = 0; i != -1; i = edges[i], ++dis){\\n            if(v1[i] != INT_MAX) break; // cycle\\n            v1[i] = dis;\\n        }\\n        for(int i = node2, dis = 0; i != -1; i = edges[i], ++dis){\\n            if(v2[i] != INT_MAX) break; // cycle\\n            v2[i] = dis;\\n        }\\n        int minDis = INT_MAX, ans = -1;\\n        for(int i = 0; i < n; ++i){\\n            int t = max(v1[i], v2[i]);\\n            if(t < minDis) minDis = t, ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097757,
                "title": "ruby-solution",
                "content": "# Code\\n```ruby []\\n# @param {Integer[]} edges\\n# @param {Integer} node1\\n# @param {Integer} node2\\n# @return {Integer}\\ndef closest_meeting_node(edges, node1, node2)\\n  return node1 if node1 == node2\\n\\n  Graph.new(edges).find_min_distance(node1, node2)\\nend\\n\\nclass Graph\\n  attr_reader :nodes\\n  def initialize(edges)\\n    @nodes = edges.map.with_index do |_, index|\\n      GraphNode.new(index)\\n    end\\n    \\n    edges.each_with_index do |edge2, edge1| \\n      next if edge2 == -1 \\n      \\n      @nodes[edge1].next = @nodes[edge2]\\n    end\\n  end\\n\\n  def find_min_distance(node1, node2)\\n    step = 1\\n    branches = [Branch.new(:first, nodes[node1]), Branch.new(:second, nodes[node2])]\\n    branches_count = branches.size\\n    result = []\\n    \\n    until branches.all?(&:nodes_empty?)\\n      \\n      branches.each {|branch| branch.check_nodes(result, branches_count, step) }\\n\\n      break min_distance_node = result.min unless result.empty?\\n      \\n      step += 1\\n    end\\n\\n    min_distance_node || -1\\n  end\\n\\n\\nend\\n\\nclass GraphNode\\n  attr_accessor :next\\n  attr_reader :val, :distances\\n  \\n  def initialize(val)\\n    @val = val\\n    @next = nil\\n    @distances = {}\\n  end\\nend\\n\\nclass Branch\\n  attr_accessor :nodes\\n  attr_reader :name\\n  \\n  def initialize(name, first_node)\\n    @name = name\\n    @nodes = [first_node]\\n    first_node.distances[name] = 0\\n  end\\n  \\n  def nodes_empty? \\n    nodes.empty?\\n  end\\n\\n  def check_nodes(result, branches_count, step)\\n    nodes.map! { |node| node.next }.compact!\\n    \\n    nodes.each do |node| \\n      next nodes.delete(node) if node.distances[name] \\n        \\n      node.distances[name] = step\\n      result << node.val if node.distances.size == branches_count\\n      \\n    end\\n    \\n  end\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby []\\n# @param {Integer[]} edges\\n# @param {Integer} node1\\n# @param {Integer} node2\\n# @return {Integer}\\ndef closest_meeting_node(edges, node1, node2)\\n  return node1 if node1 == node2\\n\\n  Graph.new(edges).find_min_distance(node1, node2)\\nend\\n\\nclass Graph\\n  attr_reader :nodes\\n  def initialize(edges)\\n    @nodes = edges.map.with_index do |_, index|\\n      GraphNode.new(index)\\n    end\\n    \\n    edges.each_with_index do |edge2, edge1| \\n      next if edge2 == -1 \\n      \\n      @nodes[edge1].next = @nodes[edge2]\\n    end\\n  end\\n\\n  def find_min_distance(node1, node2)\\n    step = 1\\n    branches = [Branch.new(:first, nodes[node1]), Branch.new(:second, nodes[node2])]\\n    branches_count = branches.size\\n    result = []\\n    \\n    until branches.all?(&:nodes_empty?)\\n      \\n      branches.each {|branch| branch.check_nodes(result, branches_count, step) }\\n\\n      break min_distance_node = result.min unless result.empty?\\n      \\n      step += 1\\n    end\\n\\n    min_distance_node || -1\\n  end\\n\\n\\nend\\n\\nclass GraphNode\\n  attr_accessor :next\\n  attr_reader :val, :distances\\n  \\n  def initialize(val)\\n    @val = val\\n    @next = nil\\n    @distances = {}\\n  end\\nend\\n\\nclass Branch\\n  attr_accessor :nodes\\n  attr_reader :name\\n  \\n  def initialize(name, first_node)\\n    @name = name\\n    @nodes = [first_node]\\n    first_node.distances[name] = 0\\n  end\\n  \\n  def nodes_empty? \\n    nodes.empty?\\n  end\\n\\n  def check_nodes(result, branches_count, step)\\n    nodes.map! { |node| node.next }.compact!\\n    \\n    nodes.each do |node| \\n      next nodes.delete(node) if node.distances[name] \\n        \\n      node.distances[name] = step\\n      result << node.val if node.distances.size == branches_count\\n      \\n    end\\n    \\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097737,
                "title": "straightforward-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n\\n\\n     int[] dist1 = new int[edges.length];\\n     int[] dist2 = new int[edges.length];\\n     Arrays.fill(dist1,-1);\\n     Arrays.fill(dist2,-1);\\n    boolean[] visited =new boolean[edges.length];\\n     //distance from 1 \\n\\n        int d=0;\\n        int i=node1;\\n\\n       while(edges[i]!=-1)\\n        {\\n            if(visited[i])\\n                break;\\n            visited[i]=true;\\n            dist1[i]=d;\\n            i=edges[i];\\n            d++;\\n        }\\n        if(edges[i]==-1)\\n            dist1[i]=d;\\n\\n        //distance from 2\\n\\n        d=0;\\n        i=node2;\\n        dist2[i]=0;\\n        visited =new boolean[edges.length];\\n        while(edges[i]!=-1)\\n        {\\n            if(visited[i])\\n                break;\\n            visited[i]=true;\\n            dist2[i]=d;\\n            i=edges[i];\\n            d++;\\n        }\\n        if(edges[i]==-1)\\n            dist2[i]=d;\\n\\n     int min=Integer.MAX_VALUE;\\n\\n     i=0;\\n     int ret=-1;\\n\\n     for(;i<edges.length;i++)\\n     {\\n        \\n        int n1=dist1[i];\\n        int n2=dist2[i];\\n        if(n1==-1 || n2==-1)\\n            continue;\\n        int dist =Math.max(n1,n2);\\n        if(dist<min)\\n            {\\n                min=dist;\\n                ret=i;\\n            }\\n\\n     }\\n\\n     return ret;\\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n\\n\\n     int[] dist1 = new int[edges.length];\\n     int[] dist2 = new int[edges.length];\\n     Arrays.fill(dist1,-1);\\n     Arrays.fill(dist2,-1);\\n    boolean[] visited =new boolean[edges.length];\\n     //distance from 1 \\n\\n        int d=0;\\n        int i=node1;\\n\\n       while(edges[i]!=-1)\\n        {\\n            if(visited[i])\\n                break;\\n            visited[i]=true;\\n            dist1[i]=d;\\n            i=edges[i];\\n            d++;\\n        }\\n        if(edges[i]==-1)\\n            dist1[i]=d;\\n\\n        //distance from 2\\n\\n        d=0;\\n        i=node2;\\n        dist2[i]=0;\\n        visited =new boolean[edges.length];\\n        while(edges[i]!=-1)\\n        {\\n            if(visited[i])\\n                break;\\n            visited[i]=true;\\n            dist2[i]=d;\\n            i=edges[i];\\n            d++;\\n        }\\n        if(edges[i]==-1)\\n            dist2[i]=d;\\n\\n     int min=Integer.MAX_VALUE;\\n\\n     i=0;\\n     int ret=-1;\\n\\n     for(;i<edges.length;i++)\\n     {\\n        \\n        int n1=dist1[i];\\n        int n2=dist2[i];\\n        if(n1==-1 || n2==-1)\\n            continue;\\n        int dist =Math.max(n1,n2);\\n        if(dist<min)\\n            {\\n                min=dist;\\n                ret=i;\\n            }\\n\\n     }\\n\\n     return ret;\\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097645,
                "title": "two-friends-on-a-trip-bfs-and-modified-bfs-beats-100",
                "content": "# Intuition\\n###### Goal is to find a place for two friends to meet and go on a trip together. Friend 1 starting from node1 and Friend 2 starting from node2. Both are travelling from different paths with different road signs. Now they want to find the closest point where they can meet and do whatever they want to. We need a code to help them find the closest point where they can meet. \\n###### So, make two lists for both of them and keep track of how far they will travel to each node/road sign. Then compare distances for both friends to reach any particular node  only if its possible for each of them to reach that particular node. When you find some node keep track of which one is the closest meeting point and return that node as answer. Again, I thought of it as the closest place for two friends to meet.\\n\\n# Approach\\n1. Create two arrays ***p1*** and ***p2*** to keep track of distance of each node in the path from **node1** and **node2**.\\n2. Fill both arrays with -1 to indicate that distance is not defined as the node is not accessible.\\n3. Fill the array ***p1*** for **node1**.\\n4. Now while filling the array ***p2*** for **node2**, check if the current node ***i*** is accessible by **node1** or not.\\n5. If it is accessible by node1 and **node2**, compare the total distance from node1 and **node2** to the current node and if it shorter than the previous distance assign the node to result and if it is equal assign the node with smaller index to the answer(As per the problem statement).\\n6. Finally return the shortest distance node.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity for this code is $$O(n)$$. Since it traverses the entire path once in both the iterations. Or you can say that time take by the code increases linearly depending on ``n`` or the size of ``edges`` array.\\n\\n- Space complexity:\\nSpace complexity is clearly $$O(n)$$ since we need two arrays ``p1``and ``p2`` to store the distances from each node.\\n\\n# Code\\n```\\nclass Solution {\\n    \\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n\\n        //Store path distances for every node from node1 and node2 \\n        int[] p1 = new int[n];\\n        int[] p2 = new int[n];\\n\\n        //Fill array with -1, if any node is inaccessible by any of the two nodes, its distance is undefined(-1 here)\\n        Arrays.fill(p1, -1);\\n        Arrays.fill(p2, -1); \\n\\n        int res = -1; // -1 if no two common paths found\\n        int l_min = n; // Local Minima for every path to a common node\\n        \\n        //Storing path distances from node1 in p1 terminate the loop when the final node is reached i.e. edges[current] == -1\\n        for(int i = node1, d = 0; i != -1 && p1[i] == -1; i = edges[i], d++){\\n\\n            p1[i] = d; \\n\\n        }\\n    \\t//Storing path distances from node2 in p2 terminate the loop when the final node is reached i.e. edges[current] == -1\\n        //Also comparing path distances to the current node from node1 and node2 if the node is accessible by both node1 and node2\\n        for(int i = node2, d = 0; i != -1 && p2[i] == -1; i = edges[i], d++){\\n\\n            p2[i] = d;\\n\\n            if(p1[i] != -1 && l_min >= Math.max(p1[i], p2[i])){\\n\\n                res = Math.max(p1[i], p2[i]) == l_min ? Math.min(res, i) : i; // if equal return the node with smaller index\\n                l_min = Math.min(l_min, Math.max(p1[i], p2[i])); // compare and assign the local minimum value\\n\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n# Similarity to BFS \\n\\n###### This code uses a modified version of BFS algorithm. BFS is an algorithm which traverses all the nodes at the current level before moving on to the next level. The algorithm starts at a particular node and explores all the neighboring nodes at the current depth level before moving to the next level.\\n\\n###### In this code the graph is represented by an array of integers `edges` where each element `edges[i]` represents the next node in the graph from the current node which can be atmost 1 node(As per the problem statement). The code stores distances of node1/node2 from each node. It is like a combination of traversing the path and storing the distance in an array(like BFS) and comparing the values to find the closest meeting point(Which is not a traditional step in BFS).\\n\\n# BFS Approach \\n###### You can find explanation for this code and if you don\\'t understand why or how this works I suggest you should watch Graph theory videos by William Fiset on YouTube. That guy is helping me a lot right now. I started learning graph theory from his videos last week only and its good, I can see improvement in my thinking and approach to problems related to graphs.\\n```\\nclass Solution {\\n    int[] arr;\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        arr = edges;\\n        int[] paths1 = solve(node1);\\n        int[] paths2 = solve(node2);\\n        int minDist = -1;\\n        int minDistTillNow = Integer.MAX_VALUE;\\n\\n        for(int curr = 0; curr < edges.length; curr++){\\n            if(minDistTillNow > Math.max(paths1[curr], paths2[curr])) {\\n                minDist = curr;\\n                minDistTillNow = Math.max(paths1[curr],paths2[curr]);\\n            }\\n        }\\n        return minDist;\\n    }\\n    private int[] solve(int s){\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[arr.length];\\n        int[] paths = new int[arr.length];\\n        Arrays.fill(paths, Integer.MAX_VALUE);\\n        paths[s] = 0;\\n        q.offer(s);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n            if(visited[curr]){\\n                continue;\\n            }\\n            visited[curr] = true;\\n            int neighbour = arr[curr];\\n            if(neighbour != -1 && !visited[neighbour]){\\n                paths[neighbour] = 1 + paths[curr];\\n                q.offer(neighbour);\\n            }\\n            \\n        }\\n        return paths;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n\\n        //Store path distances for every node from node1 and node2 \\n        int[] p1 = new int[n];\\n        int[] p2 = new int[n];\\n\\n        //Fill array with -1, if any node is inaccessible by any of the two nodes, its distance is undefined(-1 here)\\n        Arrays.fill(p1, -1);\\n        Arrays.fill(p2, -1); \\n\\n        int res = -1; // -1 if no two common paths found\\n        int l_min = n; // Local Minima for every path to a common node\\n        \\n        //Storing path distances from node1 in p1 terminate the loop when the final node is reached i.e. edges[current] == -1\\n        for(int i = node1, d = 0; i != -1 && p1[i] == -1; i = edges[i], d++){\\n\\n            p1[i] = d; \\n\\n        }\\n    \\t//Storing path distances from node2 in p2 terminate the loop when the final node is reached i.e. edges[current] == -1\\n        //Also comparing path distances to the current node from node1 and node2 if the node is accessible by both node1 and node2\\n        for(int i = node2, d = 0; i != -1 && p2[i] == -1; i = edges[i], d++){\\n\\n            p2[i] = d;\\n\\n            if(p1[i] != -1 && l_min >= Math.max(p1[i], p2[i])){\\n\\n                res = Math.max(p1[i], p2[i]) == l_min ? Math.min(res, i) : i; // if equal return the node with smaller index\\n                l_min = Math.min(l_min, Math.max(p1[i], p2[i])); // compare and assign the local minimum value\\n\\n            }\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    int[] arr;\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        arr = edges;\\n        int[] paths1 = solve(node1);\\n        int[] paths2 = solve(node2);\\n        int minDist = -1;\\n        int minDistTillNow = Integer.MAX_VALUE;\\n\\n        for(int curr = 0; curr < edges.length; curr++){\\n            if(minDistTillNow > Math.max(paths1[curr], paths2[curr])) {\\n                minDist = curr;\\n                minDistTillNow = Math.max(paths1[curr],paths2[curr]);\\n            }\\n        }\\n        return minDist;\\n    }\\n    private int[] solve(int s){\\n        Queue<Integer> q = new LinkedList<>();\\n        boolean[] visited = new boolean[arr.length];\\n        int[] paths = new int[arr.length];\\n        Arrays.fill(paths, Integer.MAX_VALUE);\\n        paths[s] = 0;\\n        q.offer(s);\\n        while(!q.isEmpty()){\\n            int curr = q.poll();\\n            if(visited[curr]){\\n                continue;\\n            }\\n            visited[curr] = true;\\n            int neighbour = arr[curr];\\n            if(neighbour != -1 && !visited[neighbour]){\\n                paths[neighbour] = 1 + paths[curr];\\n                q.offer(neighbour);\\n            }\\n            \\n        }\\n        return paths;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097598,
                "title": "c-super-easy-no-bfs-no-dfs-simple-bruteforce-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<int>a1(n,-2);\\n        vector<int>a2(n,-2);\\n\\n        int cnt=0;\\n        a1[node1]=0;\\n        int d=edges[node1];\\n        while(true)\\n        {\\n            if(d!=-1&&a1[d]==-2)\\n            {\\n                 cnt++;\\n                a1[d]=cnt;\\n                    d=edges[d];\\n            }\\n            else{\\n                break;\\n            } \\n        }\\n        cnt=0;\\n        a2[node2]=0;\\n         d=edges[node2];\\n        while(true)\\n        {\\n            if(d!=-1&&a2[d]==-2)\\n            {\\n                 cnt++;\\n                a2[d]=cnt;\\n                 d=edges[d];\\n            }\\n            else{\\n                break;\\n            } \\n        }\\n        int ans=INT_MAX;\\n        int sol=-1;\\n        for(int k=0;k<n;k++)\\n        {\\n            if(a1[k]!=-2&&a2[k]!=-2)\\n            {\\n                if(max(a1[k],a2[k])<ans)\\n                {\\n                    ans=max(a1[k],a2[k]);\\n                    sol=k;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```\\nwe travel the nodes from the source node1 and keep the distance of that particular node from the node 1 in a1 vector and do the same thing for node2 and store it\\'s distance in vector a2. \\n\\nIf we can reach a particular node from both the given nodes node1 and node than we take the minimum of their max distance and store the x in sol and finally return the sol.\\n\\nHere a1[i] and a2[i] represents the distance to node with value i from node1 and node2 respectively.",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<int>a1(n,-2);\\n        vector<int>a2(n,-2);\\n\\n        int cnt=0;\\n        a1[node1]=0;\\n        int d=edges[node1];\\n        while(true)\\n        {\\n            if(d!=-1&&a1[d]==-2)\\n            {\\n                 cnt++;\\n                a1[d]=cnt;\\n                    d=edges[d];\\n            }\\n            else{\\n                break;\\n            } \\n        }\\n        cnt=0;\\n        a2[node2]=0;\\n         d=edges[node2];\\n        while(true)\\n        {\\n            if(d!=-1&&a2[d]==-2)\\n            {\\n                 cnt++;\\n                a2[d]=cnt;\\n                 d=edges[d];\\n            }\\n            else{\\n                break;\\n            } \\n        }\\n        int ans=INT_MAX;\\n        int sol=-1;\\n        for(int k=0;k<n;k++)\\n        {\\n            if(a1[k]!=-2&&a2[k]!=-2)\\n            {\\n                if(max(a1[k],a2[k])<ans)\\n                {\\n                    ans=max(a1[k],a2[k]);\\n                    sol=k;\\n                }\\n            }\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097480,
                "title": "easy-intuitive-c-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSince each node has one outgoing edge we can simply calculate distance of each node from the given two nodes and compare the maximum distance\\nSince each node has one outgoing we can use the distance vector only to check for cycles , if distance has been calculated already then cycle exists \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(int s,vector<int>& edges,vector<int>& dist)\\n    {\\n        if(edges[s]!=-1){\\n            if(dist[edges[s]]!=-1) //checks for loops\\n            return;\\n            dist[edges[s]]=dist[s]+1;\\n            solve(edges[s],edges,dist);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n       \\n        pair<int,int> ans={-1,INT_MAX};\\n        //first element will represent the answer node\\n        //second element is max distance that is to be minimized\\n\\n        int n=edges.size();\\n        vector<int> dist1(n,-1);\\n        dist1[node1]=0;\\n        vector<int> dist2(n,-1);\\n        dist2[node2]=0;\\n        solve(node1,edges,dist1);\\n        solve(node2,edges,dist2);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dist1[i]!=-1 && dist2[i]!=-1)\\n            {\\n                if(ans.second>max(dist1[i],dist2[i]))\\n                {\\n                    ans.first=i;\\n                    ans.second=max(dist1[i],dist2[i]);\\n                }\\n            }\\n        }\\n        return ans.first;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(int s,vector<int>& edges,vector<int>& dist)\\n    {\\n        if(edges[s]!=-1){\\n            if(dist[edges[s]]!=-1) //checks for loops\\n            return;\\n            dist[edges[s]]=dist[s]+1;\\n            solve(edges[s],edges,dist);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n       \\n        pair<int,int> ans={-1,INT_MAX};\\n        //first element will represent the answer node\\n        //second element is max distance that is to be minimized\\n\\n        int n=edges.size();\\n        vector<int> dist1(n,-1);\\n        dist1[node1]=0;\\n        vector<int> dist2(n,-1);\\n        dist2[node2]=0;\\n        solve(node1,edges,dist1);\\n        solve(node2,edges,dist2);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dist1[i]!=-1 && dist2[i]!=-1)\\n            {\\n                if(ans.second>max(dist1[i],dist2[i]))\\n                {\\n                    ans.first=i;\\n                    ans.second=max(dist1[i],dist2[i]);\\n                }\\n            }\\n        }\\n        return ans.first;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097321,
                "title": "python-bfs-solution-fully-commented",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse **Breadth First Search** twice to figure out the minimum distance from both ```node1``` and ```node2``` to every node.\\n# Complexity\\nLet $$n$$ be the number of nodes.\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import deque\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        # run bfs on with starting nodes on node1 and node2\\n        # record the min distance using cost1 and cost2\\n        def bfs(root, cost):\\n            queue = deque([(root, 0)])\\n            seen = {root} # to mark visited nodes\\n            while queue:\\n                node, step = queue.popleft()\\n                cost[node] = min(cost[node], step) # record min distance between root and node\\n                if edges[node] != -1 and edges[node] not in seen:\\n                    seen.add(edges[node])\\n                    queue.append((edges[node], step + 1))\\n        # initialise with large number\\n        cost1 = [100000]*n \\n        cost2 = [100000]*n\\n        bfs(node1, cost1)\\n        bfs(node2, cost2)\\n        # calculate the max of the two distances\\n        # find the minimum among them and return the node value\\n        ans = -1 # initialise with -1 so if there is no possible answer, return -1\\n        cost = 100000\\n        for i in range(n):\\n            if cost > max(cost1[i], cost2[i]):\\n                cost = max(cost1[i], cost2[i])\\n                ans = i\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```node1```\n```node2```\n```\\nfrom collections import deque\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        # run bfs on with starting nodes on node1 and node2\\n        # record the min distance using cost1 and cost2\\n        def bfs(root, cost):\\n            queue = deque([(root, 0)])\\n            seen = {root} # to mark visited nodes\\n            while queue:\\n                node, step = queue.popleft()\\n                cost[node] = min(cost[node], step) # record min distance between root and node\\n                if edges[node] != -1 and edges[node] not in seen:\\n                    seen.add(edges[node])\\n                    queue.append((edges[node], step + 1))\\n        # initialise with large number\\n        cost1 = [100000]*n \\n        cost2 = [100000]*n\\n        bfs(node1, cost1)\\n        bfs(node2, cost2)\\n        # calculate the max of the two distances\\n        # find the minimum among them and return the node value\\n        ans = -1 # initialise with -1 so if there is no possible answer, return -1\\n        cost = 100000\\n        for i in range(n):\\n            if cost > max(cost1[i], cost2[i]):\\n                cost = max(cost1[i], cost2[i])\\n                ans = i\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097268,
                "title": "short-concise-dfs-c",
                "content": "```\\nclass Solution {\\n    void dfs(int node, int dis, vector<int> &adj, vector<int> &d) {\\n        d[node] = dis;\\n        if(adj[node] != -1 && d[adj[node]] == 1e9) dfs(adj[node], dis + 1, adj, d); \\n    }\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size(), ans = -1, mn = 1e9;\\n        vector<int> d1(n, 1e9), d2(n, 1e9);\\n        dfs(node1, 0, edges, d1);\\n        dfs(node2, 0, edges, d2);\\n\\n        for(int i=0; i<n; i++) {\\n            if(max(d1[i], d2[i]) != 1e9 && max(d1[i], d2[i]) < mn) ans = i, mn = max(d1[i], d2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    void dfs(int node, int dis, vector<int> &adj, vector<int> &d) {\\n        d[node] = dis;\\n        if(adj[node] != -1 && d[adj[node]] == 1e9) dfs(adj[node], dis + 1, adj, d); \\n    }\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size(), ans = -1, mn = 1e9;\\n        vector<int> d1(n, 1e9), d2(n, 1e9);\\n        dfs(node1, 0, edges, d1);\\n        dfs(node2, 0, edges, d2);\\n\\n        for(int i=0; i<n; i++) {\\n            if(max(d1[i], d2[i]) != 1e9 && max(d1[i], d2[i]) < mn) ans = i, mn = max(d1[i], d2[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097259,
                "title": "simple-loop-no-queue-beginner-friendly-bfs-fast-clean-short-beats-95",
                "content": "# Intuition\\nTypical shortest distance problem with a variation - atmost 1 outgoing edge. Thats why we dont need a queue. Just a single variable will do .\\n\\n*UPVOTE!*\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> bfs(const vector<int>& edges,const int& node)\\n    {\\n        vector<int> v(edges.size(),-1);\\n        int x = node , dist = 0;\\n        v[node] = 0;\\n        while(true)\\n        {\\n            if(edges[x]==-1 || v[edges[x]]!=-1)break;\\n            v[edges[x]] = ++dist,x = edges[x];\\n        }\\n        return v;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int> v1 = bfs(edges,node1) , v2 = bfs(edges,node2);\\n        int mn = INT_MAX , ans=-1;\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            if(v1[i]==-1 || v2[i]==-1)continue;\\n            int mx = max(v1[i],v2[i]);\\n            if( mx < mn ) mn = mx , ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> bfs(const vector<int>& edges,const int& node)\\n    {\\n        vector<int> v(edges.size(),-1);\\n        int x = node , dist = 0;\\n        v[node] = 0;\\n        while(true)\\n        {\\n            if(edges[x]==-1 || v[edges[x]]!=-1)break;\\n            v[edges[x]] = ++dist,x = edges[x];\\n        }\\n        return v;\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int> v1 = bfs(edges,node1) , v2 = bfs(edges,node2);\\n        int mn = INT_MAX , ans=-1;\\n        for(int i = 0 ; i < edges.size() ; i++)\\n        {\\n            if(v1[i]==-1 || v2[i]==-1)continue;\\n            int mx = max(v1[i],v2[i]);\\n            if( mx < mn ) mn = mx , ans = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097240,
                "title": "simple-dfs",
                "content": "# Approach\\nTraverse the graph two times to compute cost to reach each node, take max of two nodes and minimum from all the vertex.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int> c1( edges.size(),-1), c2( edges.size(),-1);\\n        vector<bool> v1(edges.size(),false), v2( edges.size(),false);\\n        DFS(node1,v1,c1,edges,0);\\n        DFS(node2,v2,c2,edges,0);\\n\\n        int ans = edges.size(), res=-1;\\n        for (int i=0; i < edges.size(); i++){\\n            if (c1[i] == -1 || c2[i] == -1) continue;\\n            if (max(c1[i],c2[i]) < ans){\\n                ans = max(c1[i],c2[i]);\\n                res =i;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    void DFS(int startNode, vector<bool>& v, vector<int>& cv,vector<int>& e, int cost)\\n    {\\n        if (startNode < e.size() && startNode != -1 && v[startNode] == false){\\n            cv[startNode] = cost;\\n            v[startNode] = true;\\n            DFS(e[startNode], v, cv, e, cost+1);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int> c1( edges.size(),-1), c2( edges.size(),-1);\\n        vector<bool> v1(edges.size(),false), v2( edges.size(),false);\\n        DFS(node1,v1,c1,edges,0);\\n        DFS(node2,v2,c2,edges,0);\\n\\n        int ans = edges.size(), res=-1;\\n        for (int i=0; i < edges.size(); i++){\\n            if (c1[i] == -1 || c2[i] == -1) continue;\\n            if (max(c1[i],c2[i]) < ans){\\n                ans = max(c1[i],c2[i]);\\n                res =i;\\n            }\\n        }\\n        return res;\\n    }\\n\\n    void DFS(int startNode, vector<bool>& v, vector<int>& cv,vector<int>& e, int cost)\\n    {\\n        if (startNode < e.size() && startNode != -1 && v[startNode] == false){\\n            cv[startNode] = cost;\\n            v[startNode] = true;\\n            DFS(e[startNode], v, cv, e, cost+1);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097233,
                "title": "c-95-fast-simple-bfs-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // void bfs(int source,vector<int>&dis,vector<int>&edges) {\\n    //     queue<int>q;\\n    //     q.push(source);\\n    //     dis[source]=0;\\n    //     while(not q.empty()) {\\n    //         int temp=q.front();\\n    //         q.pop();\\n    //         if(edges[temp]!=-1 and dis[edges[temp]]==-1) {\\n    //             dis[edges[temp]]=dis[temp]+1;\\n    //             q.push(edges[temp]);\\n    //         }\\n    //     }\\n    // }\\n\\n    void dfs(int curr_node,vector<int>&dis,vector<int>&edges) {\\n        if(edges[curr_node]!=-1 and dis[edges[curr_node]]==-1) {\\n            dis[edges[curr_node]]=dis[curr_node]+1;\\n            dfs(edges[curr_node],dis,edges);\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<int>dis1(n,-1),dis2(n,-1);\\n        // bfs(node1,dis1,edges);\\n        // bfs(node2,dis2,edges);\\n        dis1[node1]=0;         \\n        dis2[node2]=0;\\n        dfs(node1,dis1,edges);\\n        dfs(node2,dis2,edges);\\n        int ans=-1,min_distance=INT_MAX;\\n        for(int i=n-1;i>=0;i--) {\\n            if(dis1[i]==-1 or dis2[i]==-1) continue;\\n            if(max(dis1[i],dis2[i])<=min_distance) {\\n                ans=i;\\n                min_distance=max(dis1[i],dis2[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // void bfs(int source,vector<int>&dis,vector<int>&edges) {\\n    //     queue<int>q;\\n    //     q.push(source);\\n    //     dis[source]=0;\\n    //     while(not q.empty()) {\\n    //         int temp=q.front();\\n    //         q.pop();\\n    //         if(edges[temp]!=-1 and dis[edges[temp]]==-1) {\\n    //             dis[edges[temp]]=dis[temp]+1;\\n    //             q.push(edges[temp]);\\n    //         }\\n    //     }\\n    // }\\n\\n    void dfs(int curr_node,vector<int>&dis,vector<int>&edges) {\\n        if(edges[curr_node]!=-1 and dis[edges[curr_node]]==-1) {\\n            dis[edges[curr_node]]=dis[curr_node]+1;\\n            dfs(edges[curr_node],dis,edges);\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<int>dis1(n,-1),dis2(n,-1);\\n        // bfs(node1,dis1,edges);\\n        // bfs(node2,dis2,edges);\\n        dis1[node1]=0;         \\n        dis2[node2]=0;\\n        dfs(node1,dis1,edges);\\n        dfs(node2,dis2,edges);\\n        int ans=-1,min_distance=INT_MAX;\\n        for(int i=n-1;i>=0;i--) {\\n            if(dis1[i]==-1 or dis2[i]==-1) continue;\\n            if(max(dis1[i],dis2[i])<=min_distance) {\\n                ans=i;\\n                min_distance=max(dis1[i],dis2[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3097129,
                "title": "python3-beats-95-easy-to-understand-logic",
                "content": "**Approach-**\\n\\tTo solve this problem, we can perform a breadth-first search (BFS) starting from both node1 and node2. Keep track of the distances from node1 and node2 to each node, and also keep track of the nodes that have been visited from both BFS traversals. Once a node is visited from both BFS traversals, calculate the maximum distance between the node and node1 or node2, and compare it to the minimum distance found so far. If the current node has a shorter maximum distance, update the minimum distance and the node index. Return the node index with the minimum distance, or -1 if no such node exists.\\n\\t\\n```py\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        num1 = []\\n        num2 = []\\n        \\n        st = set()\\n        \\n        while node1 not in st:\\n            if node1 == -1:\\n                break \\n            num1.append(node1)\\n            st.add(node1)\\n            node1 = edges[node1]\\n            \\n        st = set()\\n        \\n        while node2 not in st:\\n            if node2 == -1:\\n                break\\n            num2.append(node2)\\n            st.add(node2)\\n            node2 = edges[node2]\\n            \\n        st2 = set(num2)\\n        st1 = set(num1)\\n        \\n        ans1 = -1\\n        l1 = 0\\n        \\n        for z in num1:\\n            if z in st2:\\n                ans1 = z \\n                i = num1.index(z)\\n                j = num2.index(z)\\n                l1 = max(i,j)\\n                break \\n                \\n        ans2 = -1\\n        l2 = 0\\n        \\n        for z in num2:\\n            if z in st1:\\n                ans2 = z \\n                i = num1.index(z)\\n                j = num2.index(z)\\n                l2 = max(i,j)\\n                break \\n        \\n        if ans1 == -1:\\n            return ans2 \\n        if ans2 == -1:\\n            return ans1 \\n        \\n        if l1 < l2:\\n            return ans1\\n        if l2 < l1:\\n            return ans2\\n        return min(ans1, ans2)\\n\\t\\t\\n",
                "solutionTags": [
                    "Python3",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "**Approach-**\\n\\tTo solve this problem, we can perform a breadth-first search (BFS) starting from both node1 and node2. Keep track of the distances from node1 and node2 to each node, and also keep track of the nodes that have been visited from both BFS traversals. Once a node is visited from both BFS traversals, calculate the maximum distance between the node and node1 or node2, and compare it to the minimum distance found so far. If the current node has a shorter maximum distance, update the minimum distance and the node index. Return the node index with the minimum distance, or -1 if no such node exists.\\n\\t\\n```py\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        num1 = []\\n        num2 = []\\n        \\n        st = set()\\n        \\n        while node1 not in st:\\n            if node1 == -1:\\n                break \\n            num1.append(node1)\\n            st.add(node1)\\n            node1 = edges[node1]\\n            \\n        st = set()\\n        \\n        while node2 not in st:\\n            if node2 == -1:\\n                break\\n            num2.append(node2)\\n            st.add(node2)\\n            node2 = edges[node2]\\n            \\n        st2 = set(num2)\\n        st1 = set(num1)\\n        \\n        ans1 = -1\\n        l1 = 0\\n        \\n        for z in num1:\\n            if z in st2:\\n                ans1 = z \\n                i = num1.index(z)\\n                j = num2.index(z)\\n                l1 = max(i,j)\\n                break \\n                \\n        ans2 = -1\\n        l2 = 0\\n        \\n        for z in num2:\\n            if z in st1:\\n                ans2 = z \\n                i = num1.index(z)\\n                j = num2.index(z)\\n                l2 = max(i,j)\\n                break \\n        \\n        if ans1 == -1:\\n            return ans2 \\n        if ans2 == -1:\\n            return ans1 \\n        \\n        if l1 < l2:\\n            return ans1\\n        if l2 < l1:\\n            return ans2\\n        return min(ans1, ans2)\\n\\t\\t\\n",
                "codeTag": "Java"
            },
            {
                "id": 3097038,
                "title": "easy-python-solution-bfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n=len(edges)\\n        dst1=[float(\"infinity\")]*n\\n        dst2=[float(\"infinity\")]*n\\n\\n        dst1[node1]=0\\n        st=[(node1,0)]\\n        while st:\\n            x,d=st.pop(0)\\n            v=edges[x]\\n            if v!=-1 and dst1[v]==float(\"infinity\"):\\n                dst1[v]=d+1\\n                st.append((v,d+1))\\n\\n        dst2[node2]=0\\n        st=[(node2,0)]\\n        while st:\\n            x,d=st.pop(0)\\n            v=edges[x]\\n            if v!=-1 and dst2[v]==float(\"infinity\"):\\n                dst2[v]=d+1\\n                st.append((v,d+1))\\n        \\n        lst=[max(dst1[i],dst2[i]) for i in range(n)]\\n        mn=0\\n        for i in range(n):\\n            if lst[i]<lst[mn]:\\n                mn=i\\n        if lst[mn]==float(\"infinity\"):\\n            return -1\\n        return mn\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n=len(edges)\\n        dst1=[float(\"infinity\")]*n\\n        dst2=[float(\"infinity\")]*n\\n\\n        dst1[node1]=0\\n        st=[(node1,0)]\\n        while st:\\n            x,d=st.pop(0)\\n            v=edges[x]\\n            if v!=-1 and dst1[v]==float(\"infinity\"):\\n                dst1[v]=d+1\\n                st.append((v,d+1))\\n\\n        dst2[node2]=0\\n        st=[(node2,0)]\\n        while st:\\n            x,d=st.pop(0)\\n            v=edges[x]\\n            if v!=-1 and dst2[v]==float(\"infinity\"):\\n                dst2[v]=d+1\\n                st.append((v,d+1))\\n        \\n        lst=[max(dst1[i],dst2[i]) for i in range(n)]\\n        mn=0\\n        for i in range(n):\\n            if lst[i]<lst[mn]:\\n                mn=i\\n        if lst[mn]==float(\"infinity\"):\\n            return -1\\n        return mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096953,
                "title": "c-easy-solution-faster-than-80-less-memory-use-than-90-dfs",
                "content": "```\\nvoid solve(int node,int start,vector<int>& edges,vector<int>& arr)\\n    {\\n        if(node!=-1 && arr[node]==-1)\\n        {\\n            arr[node] = start;\\n            solve(edges[node],start+1,edges,arr);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        // we have to make two array for calculating distance \\n        int n = edges.size();\\n        \\n        vector<int> arr1(n,-1);\\n        vector<int> arr2(n,-1);\\n        int ans  =-1;\\n        solve(node1,0,edges,arr1);\\n        solve(node2,0,edges,arr2);\\n        \\n        //for loop calculate distances store in  array\\n        int maxx = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr2[i]!=-1 && arr1[i]!=-1)\\n            {\\n                if(maxx > max(arr1[i],arr2[i]))\\n                {\\n                    maxx = max(arr1[i],arr2[i]);\\n                    ans = i;\\n                }\\n                \\n            }\\n        \\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nvoid solve(int node,int start,vector<int>& edges,vector<int>& arr)\\n    {\\n        if(node!=-1 && arr[node]==-1)\\n        {\\n            arr[node] = start;\\n            solve(edges[node],start+1,edges,arr);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        // we have to make two array for calculating distance \\n        int n = edges.size();\\n        \\n        vector<int> arr1(n,-1);\\n        vector<int> arr2(n,-1);\\n        int ans  =-1;\\n        solve(node1,0,edges,arr1);\\n        solve(node2,0,edges,arr2);\\n        \\n        //for loop calculate distances store in  array\\n        int maxx = INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(arr2[i]!=-1 && arr1[i]!=-1)\\n            {\\n                if(maxx > max(arr1[i],arr2[i]))\\n                {\\n                    maxx = max(arr1[i],arr2[i]);\\n                    ans = i;\\n                }\\n                \\n            }\\n        \\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3096944,
                "title": "bidirectional-bfs-java-solution-new-approach",
                "content": "# Approach\\nInstead of using a single node in start for bfs use 2 nodes simultaneously then automatically common node in both will come in path having minimum distance from both.\\nSee code for better understanding!\\n\\n# Code\\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        List<List<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<edges.length;i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int u=0;u<edges.length;u++) {\\n            if(edges[u]!=-1)\\n                graph.get(u).add(edges[u]);\\n        }\\n        Queue<Integer> queue1=new LinkedList<>();\\n        Queue<Integer> queue2=new LinkedList<>();\\n        boolean visited1[]=new boolean[edges.length];\\n        boolean visited2[]=new boolean[edges.length];\\n        queue1.offer(node1);\\n        queue2.offer(node2);\\n        visited1[node1]=visited2[node2]=true;\\n        int steps=0;\\n        int ans=Integer.MAX_VALUE;\\n        while(!queue1.isEmpty() && !queue2.isEmpty()) {\\n            int size=Math.max(queue1.size(), queue2.size());\\n            while(size-->0) {\\n                int cur1=-1, cur2=-1;\\n                if(!queue1.isEmpty())\\n                    cur1=queue1.poll();\\n                if(!queue2.isEmpty())\\n                    cur2=queue2.poll();\\n                \\n                if(visited1[cur2] && visited2[cur1]) {\\n                    ans=Math.min(ans, cur1);\\n                    ans=Math.min(ans, cur2);\\n                    return ans;\\n                }\\n                if(cur1==cur2) {\\n                    return cur1;\\n                }\\n                if(visited1[cur2]) {\\n                    return cur2;\\n                }\\n                if(visited2[cur1]){\\n                    return cur1;\\n                }\\n\\n                if(cur1!=-1) {\\n                    for(int n: graph.get(cur1)) {\\n                        if(!visited1[n]) {\\n                            visited1[n]=true;\\n                            queue1.add(n);\\n                        }\\n                    }\\n                }\\n                if(cur2!=-1) {\\n                    for(int n: graph.get(cur2)) {\\n                        if(!visited2[n]) {\\n                            visited2[n]=true;\\n                            queue2.add(n);\\n                        }\\n                    }\\n                }\\n                steps++;\\n            }\\n        }\\n        while(!queue1.isEmpty()) {\\n            int cur1=queue1.poll();\\n            if(cur1==node2 || visited2[cur1]) {\\n                return cur1;\\n            }\\n            \\n            for(int n: graph.get(cur1)) {\\n                if(!visited1[n]) {\\n                    visited1[n]=true;\\n                    queue1.add(n);\\n                }\\n            }\\n        }\\n        while(!queue2.isEmpty()) {\\n            int cur2=queue2.poll();\\n            if(cur2==node1 || visited1[cur2]) {\\n                return cur2;\\n            }\\n            for(int n: graph.get(cur2)) {\\n                if(!visited2[n]) {\\n                    visited2[n]=true;\\n                    queue2.add(n);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        List<List<Integer>> graph=new ArrayList<>();\\n        for(int i=0;i<edges.length;i++) {\\n            graph.add(new ArrayList<>());\\n        }\\n        for(int u=0;u<edges.length;u++) {\\n            if(edges[u]!=-1)\\n                graph.get(u).add(edges[u]);\\n        }\\n        Queue<Integer> queue1=new LinkedList<>();\\n        Queue<Integer> queue2=new LinkedList<>();\\n        boolean visited1[]=new boolean[edges.length];\\n        boolean visited2[]=new boolean[edges.length];\\n        queue1.offer(node1);\\n        queue2.offer(node2);\\n        visited1[node1]=visited2[node2]=true;\\n        int steps=0;\\n        int ans=Integer.MAX_VALUE;\\n        while(!queue1.isEmpty() && !queue2.isEmpty()) {\\n            int size=Math.max(queue1.size(), queue2.size());\\n            while(size-->0) {\\n                int cur1=-1, cur2=-1;\\n                if(!queue1.isEmpty())\\n                    cur1=queue1.poll();\\n                if(!queue2.isEmpty())\\n                    cur2=queue2.poll();\\n                \\n                if(visited1[cur2] && visited2[cur1]) {\\n                    ans=Math.min(ans, cur1);\\n                    ans=Math.min(ans, cur2);\\n                    return ans;\\n                }\\n                if(cur1==cur2) {\\n                    return cur1;\\n                }\\n                if(visited1[cur2]) {\\n                    return cur2;\\n                }\\n                if(visited2[cur1]){\\n                    return cur1;\\n                }\\n\\n                if(cur1!=-1) {\\n                    for(int n: graph.get(cur1)) {\\n                        if(!visited1[n]) {\\n                            visited1[n]=true;\\n                            queue1.add(n);\\n                        }\\n                    }\\n                }\\n                if(cur2!=-1) {\\n                    for(int n: graph.get(cur2)) {\\n                        if(!visited2[n]) {\\n                            visited2[n]=true;\\n                            queue2.add(n);\\n                        }\\n                    }\\n                }\\n                steps++;\\n            }\\n        }\\n        while(!queue1.isEmpty()) {\\n            int cur1=queue1.poll();\\n            if(cur1==node2 || visited2[cur1]) {\\n                return cur1;\\n            }\\n            \\n            for(int n: graph.get(cur1)) {\\n                if(!visited1[n]) {\\n                    visited1[n]=true;\\n                    queue1.add(n);\\n                }\\n            }\\n        }\\n        while(!queue2.isEmpty()) {\\n            int cur2=queue2.poll();\\n            if(cur2==node1 || visited1[cur2]) {\\n                return cur2;\\n            }\\n            for(int n: graph.get(cur2)) {\\n                if(!visited2[n]) {\\n                    visited2[n]=true;\\n                    queue2.add(n);\\n                }\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096916,
                "title": "easiest-dfs-traversal-java",
                "content": "\\nclass Solution {\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2){\\n        int path1 []= findNodePath(node1,edges);\\n        int path2 []= findNodePath(node2,edges);\\n\\n        int minDistance = Integer.MAX_VALUE;\\n        int ans = -1;\\n        for(int i = 0;i < edges.length;i++){\\n            if(path1[i] == -1 || path2[i] == -1) continue;\\n\\n            if(minDistance > Math.max(path1[i],path2[i]) ){\\n                ans = i;\\n                minDistance = Math.max(path1[i],path2[i]);\\n            }\\n        }\\n        return ans;\\n\\n    public int[] findNodePath(int node,int []edges){\\n        int [] dist = new int[edges.length];\\n        Arrays.fill(dist,-1);\\n\\n        int distance = 0;\\n        while(node != -1 && dist[node] == -1){\\n            dist[node] = distance++;\\n            node = edges[node];\\n        }\\n        return dist;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n\\n    public int closestMeetingNode(int[] edges, int node1, int node2){\\n        int path1 []= findNodePath(node1,edges);\\n        int path2 []= findNodePath(node2,edges);\\n\\n        int minDistance = Integer.MAX_VALUE;\\n        int ans = -1;\\n        for(int i = 0;i < edges.length;i++){\\n            if(path1[i] == -1 || path2[i] == -1) continue;\\n\\n            if(minDistance > Math.max(path1[i],path2[i]) ){\\n                ans = i;\\n                minDistance = Math.max(path1[i],path2[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3096823,
                "title": "bfs-dfs",
                "content": "# \\uD83D\\uDC77\\u200D\\u2642\\uFE0F Approach\\n![image.png](https://assets.leetcode.com/users/images/eb2d5b0d-46b8-459a-be2f-bb487d6634e5_1674632351.4571435.png)\\n\\n# Complexity\\n- Time complexity: `O(len(edges))`\\n- Space complexity: `O(len(edges))`\\n# Code\\n```python\\n# /2359. Find Closest Node to Given Two Nodes\\n# cio\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        adj = collections.defaultdict(list)\\n        for i, dst in enumerate(edges):\\n            adj[i].append(dst)\\n\\n        def bfs(Node, distMap):\\n            q = collections.deque()\\n            q.append([Node,0])\\n            distMap[Node] = 0\\n            while q:\\n                node, dist = q.popleft()\\n                for nei in adj[node]:\\n                    if nei not in distMap:\\n                        q.append([nei, dist + 1])\\n                        distMap[nei] = dist + 1\\n        node1Dist, node2Dist = {}, {}\\n        bfs(node1,node1Dist); bfs(node2,node2Dist)\\n\\n        print(node1Dist,node2Dist)\\n\\n        res = -1\\n        resDist = float(\"inf\")\\n        for i in range(len(edges)):\\n            if i in node1Dist and i in node2Dist:\\n                dist = max(node1Dist[i],node2Dist[i])\\n                if dist < resDist:\\n                    res = i\\n                    resDist = dist\\n\\n        return res\\n```\\n# Code 2\\n```python\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        #These sets will keep track of its respective node; like browsing history ;)\\n        visited_1=set()\\n        visited_2=set()\\n        \\n        while node1!=-1 or node2!=-1:\\n            #record only if node is not cyclic or not at its destination\\n            if node1!=-1 and node1 not in visited_1:\\n                if node1 in visited_2:\\n                    if node2 in visited_1:\\n                        #if the code is here,there are 2 common values so return minimum\\n                        return min(node1,node2)\\n                    #if code is here then node2 NOT in visited_1 so just return node1\\n                    return node1\\n                #here we record our existing node value and move to the next node\\n                visited_1.add(node1)\\n                node1=edges[node1]\\n            \\n\\n            if node2!=-1 and node2 not in visited_2:\\n                if node2 in visited_1:\\n                    #if the code is here,it means that node1 was not in visited2 (or it would have gone to ther other loop)\\n                    return node2\\n                visited_2.add(node2)\\n                node2=edges[node2]\\n            if (node1 in visited_1 or node1==-1) and (node2 in visited_2 or node2==-1):\\n                break\\n        #if code is here, both paths have terminated with no common node\\n        return -1\\n```\\nYou Can also Look At My SDE Prep Repo [\\uD83E\\uDDE2 GitHub](https://github.com/Ayon-SSP/The-SDE-Prep)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\n# /2359. Find Closest Node to Given Two Nodes\\n# cio\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        adj = collections.defaultdict(list)\\n        for i, dst in enumerate(edges):\\n            adj[i].append(dst)\\n\\n        def bfs(Node, distMap):\\n            q = collections.deque()\\n            q.append([Node,0])\\n            distMap[Node] = 0\\n            while q:\\n                node, dist = q.popleft()\\n                for nei in adj[node]:\\n                    if nei not in distMap:\\n                        q.append([nei, dist + 1])\\n                        distMap[nei] = dist + 1\\n        node1Dist, node2Dist = {}, {}\\n        bfs(node1,node1Dist); bfs(node2,node2Dist)\\n\\n        print(node1Dist,node2Dist)\\n\\n        res = -1\\n        resDist = float(\"inf\")\\n        for i in range(len(edges)):\\n            if i in node1Dist and i in node2Dist:\\n                dist = max(node1Dist[i],node2Dist[i])\\n                if dist < resDist:\\n                    res = i\\n                    resDist = dist\\n\\n        return res\\n```\n```python\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        #These sets will keep track of its respective node; like browsing history ;)\\n        visited_1=set()\\n        visited_2=set()\\n        \\n        while node1!=-1 or node2!=-1:\\n            #record only if node is not cyclic or not at its destination\\n            if node1!=-1 and node1 not in visited_1:\\n                if node1 in visited_2:\\n                    if node2 in visited_1:\\n                        #if the code is here,there are 2 common values so return minimum\\n                        return min(node1,node2)\\n                    #if code is here then node2 NOT in visited_1 so just return node1\\n                    return node1\\n                #here we record our existing node value and move to the next node\\n                visited_1.add(node1)\\n                node1=edges[node1]\\n            \\n\\n            if node2!=-1 and node2 not in visited_2:\\n                if node2 in visited_1:\\n                    #if the code is here,it means that node1 was not in visited2 (or it would have gone to ther other loop)\\n                    return node2\\n                visited_2.add(node2)\\n                node2=edges[node2]\\n            if (node1 in visited_1 or node1==-1) and (node2 in visited_2 or node2==-1):\\n                break\\n        #if code is here, both paths have terminated with no common node\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096734,
                "title": "python-dfs",
                "content": "\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        visited1 = set()\\n        visited2 = set()\\n        ans = set()\\n        \\n        while node1 != -1 or node2 != -1:\\n            if node1 != -1 and ((node1 in visited2) or node1 == node2):\\n                ans.add(node1)\\n            if node2 != -1 and ((node2 in visited1) or node1 == node2):\\n                ans.add(node2)\\n            if ans:\\n                return min(ans)\\n            if node1 != -1 and node1 not in visited1:\\n                visited1.add(node1)\\n                node1 = edges[node1]\\n            else:\\n                node1 = -1\\n            if node2 != -1 and node2 not in visited2:\\n                visited2.add(node2)\\n                node2 = edges[node2]\\n            else:\\n                node2 = -1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        visited1 = set()\\n        visited2 = set()\\n        ans = set()\\n        \\n        while node1 != -1 or node2 != -1:\\n            if node1 != -1 and ((node1 in visited2) or node1 == node2):\\n                ans.add(node1)\\n            if node2 != -1 and ((node2 in visited1) or node1 == node2):\\n                ans.add(node2)\\n            if ans:\\n                return min(ans)\\n            if node1 != -1 and node1 not in visited1:\\n                visited1.add(node1)\\n                node1 = edges[node1]\\n            else:\\n                node1 = -1\\n            if node2 != -1 and node2 not in visited2:\\n                visited2.add(node2)\\n                node2 = edges[node2]\\n            else:\\n                node2 = -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096676,
                "title": "c-2-dfs-graph-easy-to-understand",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.Find distance of all node from node1 and store in a vector\\n2.Find distance of all node from node2 and store in a vector\\n3.Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n    remember to store -1 initially while defining the distance vector\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int curr_node,vector<int>& edges,vector<int>& dist,vector<bool>& visited)\\n    {\\n        int distance = 0;\\n\\n        while(curr_node != -1)\\n        {\\n            if(visited[curr_node]) break;\\n\\n            dist[curr_node] = distance;\\n            visited[curr_node] = true;\\n            distance++;\\n            curr_node = edges[curr_node];\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) \\n    {\\n        int n = edges.size();\\n        int ans = -1; // index \\n        int minDist = INT_MAX;\\n        vector<int> dist1(n,-1);\\n        vector<int> dist2(n,-1);\\n        vector<bool> visited1(n,false);\\n        vector<bool> visited2(n,false);\\n\\n        dfs(node1,edges,dist1,visited1);\\n        dfs(node2,edges,dist2,visited2);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dist1[i] == -1 || dist2[i] == -1) continue;\\n            if(minDist > max(dist1[i],dist2[i]))\\n            {\\n                minDist = max(dist1[i],dist2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int curr_node,vector<int>& edges,vector<int>& dist,vector<bool>& visited)\\n    {\\n        int distance = 0;\\n\\n        while(curr_node != -1)\\n        {\\n            if(visited[curr_node]) break;\\n\\n            dist[curr_node] = distance;\\n            visited[curr_node] = true;\\n            distance++;\\n            curr_node = edges[curr_node];\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) \\n    {\\n        int n = edges.size();\\n        int ans = -1; // index \\n        int minDist = INT_MAX;\\n        vector<int> dist1(n,-1);\\n        vector<int> dist2(n,-1);\\n        vector<bool> visited1(n,false);\\n        vector<bool> visited2(n,false);\\n\\n        dfs(node1,edges,dist1,visited1);\\n        dfs(node2,edges,dist2,visited2);\\n\\n        for(int i=0;i<n;i++)\\n        {\\n            if(dist1[i] == -1 || dist2[i] == -1) continue;\\n            if(minDist > max(dist1[i],dist2[i]))\\n            {\\n                minDist = max(dist1[i],dist2[i]);\\n                ans = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096632,
                "title": "c-dfs-o-n-simple",
                "content": "# Approach\\nDo DFS, Find Common Nodes, look for distances to reach those common nodes with map. Update The Answer accordingly.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) \\n    {\\n        unordered_set<int>encountered1,encountered2;\\n        int count=1,mindist=INT_MAX,ans;\\n        unordered_map<int,int>distto1,distto2;\\n        distto1[node1]=0;\\n        distto2[node2]=0;\\n        pair<int,int>curredge1={node1,edges[node1]},curredge2={node2,edges[node2]};\\n        encountered1.insert(node1);\\n        encountered2.insert(node2);\\n        while(encountered1.count(curredge1.second)==0 && curredge1.second!=(-1))\\n        {\\n            encountered1.insert(curredge1.second);\\n            distto1[curredge1.second]=count;\\n            count++;\\n            curredge1={curredge1.second,edges[curredge1.second]};\\n        }\\n        encountered1.insert(curredge1.second);\\n        count=1;\\n        while(encountered2.count(curredge2.second)==0 && curredge2.second!=(-1))\\n        {\\n            encountered2.insert(curredge2.second);\\n            distto2[curredge2.second]=count;\\n            count++;\\n            curredge2={curredge2.second,edges[curredge2.second]};\\n        }\\n        encountered2.insert(curredge2.second);\\n        for(auto j:encountered1)\\n        {\\n            if(encountered2.count(j)!=0 && j!=(-1))\\n            {\\n                if(max(distto1[j],distto2[j])<mindist)\\n                {\\n                    mindist=max(distto1[j],distto2[j]);\\n                    ans=j;\\n                }\\n                else if(max(distto1[j],distto2[j])==mindist)\\n                {\\n                    ans=min(ans,j);\\n                }\\n            }\\n        }\\n        if(mindist==INT_MAX)\\n        {\\n            ans=-1;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) \\n    {\\n        unordered_set<int>encountered1,encountered2;\\n        int count=1,mindist=INT_MAX,ans;\\n        unordered_map<int,int>distto1,distto2;\\n        distto1[node1]=0;\\n        distto2[node2]=0;\\n        pair<int,int>curredge1={node1,edges[node1]},curredge2={node2,edges[node2]};\\n        encountered1.insert(node1);\\n        encountered2.insert(node2);\\n        while(encountered1.count(curredge1.second)==0 && curredge1.second!=(-1))\\n        {\\n            encountered1.insert(curredge1.second);\\n            distto1[curredge1.second]=count;\\n            count++;\\n            curredge1={curredge1.second,edges[curredge1.second]};\\n        }\\n        encountered1.insert(curredge1.second);\\n        count=1;\\n        while(encountered2.count(curredge2.second)==0 && curredge2.second!=(-1))\\n        {\\n            encountered2.insert(curredge2.second);\\n            distto2[curredge2.second]=count;\\n            count++;\\n            curredge2={curredge2.second,edges[curredge2.second]};\\n        }\\n        encountered2.insert(curredge2.second);\\n        for(auto j:encountered1)\\n        {\\n            if(encountered2.count(j)!=0 && j!=(-1))\\n            {\\n                if(max(distto1[j],distto2[j])<mindist)\\n                {\\n                    mindist=max(distto1[j],distto2[j]);\\n                    ans=j;\\n                }\\n                else if(max(distto1[j],distto2[j])==mindist)\\n                {\\n                    ans=min(ans,j);\\n                }\\n            }\\n        }\\n        if(mindist==INT_MAX)\\n        {\\n            ans=-1;            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096607,
                "title": "simple-dijkstra-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<int> adj[n],in(n,0);\\n        for(int i=0;i<n;i++){\\n            if(edges[i]!=-1){\\n                adj[i].push_back(edges[i]);\\n                in[edges[i]]++;\\n            }\\n        }\\n        auto dijkstra=[&](int node,vector<int> &dp,vector<int> adj[]){\\n            dp[node]=0;\\n            priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> mn_h;\\n            mn_h.push({0,node});\\n            while(!mn_h.empty()){\\n                auto curr=mn_h.top();mn_h.pop();\\n                int d=curr.first,u=curr.second;\\n                if(d>dp[u]) continue;\\n                for(auto v:adj[u]){\\n                    if(d+1<dp[v]){\\n                        dp[v]=1+d;\\n                        mn_h.push({dp[v],v});\\n                    }\\n                }\\n            }\\n        };\\n        vector<int> dp1(n,INT_MAX),dp2(n,INT_MAX);\\n        dijkstra(node1,dp1,adj);\\n        dijkstra(node2,dp2,adj);\\n        int dist=INT_MAX,target_node=-1;\\n        for(int i=0;i<n;i++){\\n            int temp=max(dp1[i],dp2[i]);\\n            if(temp<dist){\\n                dist=temp;\\n                target_node=i;\\n            }\\n        }\\n        return target_node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<int> adj[n],in(n,0);\\n        for(int i=0;i<n;i++){\\n            if(edges[i]!=-1){\\n                adj[i].push_back(edges[i]);\\n                in[edges[i]]++;\\n            }\\n        }\\n        auto dijkstra=[&](int node,vector<int> &dp,vector<int> adj[]){\\n            dp[node]=0;\\n            priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> mn_h;\\n            mn_h.push({0,node});\\n            while(!mn_h.empty()){\\n                auto curr=mn_h.top();mn_h.pop();\\n                int d=curr.first,u=curr.second;\\n                if(d>dp[u]) continue;\\n                for(auto v:adj[u]){\\n                    if(d+1<dp[v]){\\n                        dp[v]=1+d;\\n                        mn_h.push({dp[v],v});\\n                    }\\n                }\\n            }\\n        };\\n        vector<int> dp1(n,INT_MAX),dp2(n,INT_MAX);\\n        dijkstra(node1,dp1,adj);\\n        dijkstra(node2,dp2,adj);\\n        int dist=INT_MAX,target_node=-1;\\n        for(int i=0;i<n;i++){\\n            int temp=max(dp1[i],dp2[i]);\\n            if(temp<dist){\\n                dist=temp;\\n                target_node=i;\\n            }\\n        }\\n        return target_node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096576,
                "title": "c-bfs-dfs-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\n# BFS\\n# Complexity\\n- Time complexity:$$O(V+E)$$\\n\\n- Space complexity:$$O(V)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int>v(edges.size(), -1), v1(edges.size(), -1);\\n        int cnt=-1, maxi=INT_MAX;\\n        queue<pair<int, int>>q, q1;\\n        q.push({node1, 0});\\n        q1.push({node2, 0});\\n        while(!q.empty()){\\n            int pos=q.front().first, cnt1=q.front().second;\\n            q.pop();\\n            if(pos!=-1 && v[pos]==-1){\\n                v[pos]=cnt1;\\n                q.push({edges[pos], cnt1+1});\\n            }\\n        }\\n        while(!q1.empty()){\\n            int pos=q1.front().first, cnt1=q1.front().second;\\n            q1.pop();\\n            if(pos!=-1 && v1[pos]==-1){\\n                v1[pos]=cnt1;\\n                q1.push({edges[pos], cnt1+1});\\n            }\\n        }\\n        for(int i=0; i<edges.size(); i++){\\n            if(min(v[i], v1[i])!=-1 && max(v[i], v1[i])<maxi){\\n                maxi=max(v[i], v1[i]);\\n                cnt=i;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n# DFS\\n# Complexity\\n- Time complexity:$$O(V+E)$$\\n\\n- Space complexity:$$O(V)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i, int cnt, vector<int>& edges, vector<int>& v){\\n        if(i!=-1 && v[i]==-1){\\n            v[i]=cnt;\\n            dfs(edges[i], cnt+1, edges, v);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int>v(edges.size(), -1), v1(edges.size(), -1);\\n        int cnt=-1, maxi=INT_MAX;\\n        dfs(node1, 0, edges, v);\\n        dfs(node2, 0, edges, v1);\\n        for(int i=0; i<edges.size(); i++){\\n            if(min(v[i], v1[i])!=-1 && max(v[i], v1[i])<maxi){\\n                maxi=max(v[i], v1[i]);\\n                cnt=i;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int>v(edges.size(), -1), v1(edges.size(), -1);\\n        int cnt=-1, maxi=INT_MAX;\\n        queue<pair<int, int>>q, q1;\\n        q.push({node1, 0});\\n        q1.push({node2, 0});\\n        while(!q.empty()){\\n            int pos=q.front().first, cnt1=q.front().second;\\n            q.pop();\\n            if(pos!=-1 && v[pos]==-1){\\n                v[pos]=cnt1;\\n                q.push({edges[pos], cnt1+1});\\n            }\\n        }\\n        while(!q1.empty()){\\n            int pos=q1.front().first, cnt1=q1.front().second;\\n            q1.pop();\\n            if(pos!=-1 && v1[pos]==-1){\\n                v1[pos]=cnt1;\\n                q1.push({edges[pos], cnt1+1});\\n            }\\n        }\\n        for(int i=0; i<edges.size(); i++){\\n            if(min(v[i], v1[i])!=-1 && max(v[i], v1[i])<maxi){\\n                maxi=max(v[i], v1[i]);\\n                cnt=i;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(int i, int cnt, vector<int>& edges, vector<int>& v){\\n        if(i!=-1 && v[i]==-1){\\n            v[i]=cnt;\\n            dfs(edges[i], cnt+1, edges, v);\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        vector<int>v(edges.size(), -1), v1(edges.size(), -1);\\n        int cnt=-1, maxi=INT_MAX;\\n        dfs(node1, 0, edges, v);\\n        dfs(node2, 0, edges, v1);\\n        for(int i=0; i<edges.size(); i++){\\n            if(min(v[i], v1[i])!=-1 && max(v[i], v1[i])<maxi){\\n                maxi=max(v[i], v1[i]);\\n                cnt=i;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096461,
                "title": "closest-node-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n         n = len(edges)\\n\\n         def bfs(u):\\n            d = {u: 0}\\n            i = 0\\n            visited = [False] * n\\n            while u != -1:\\n                visited[u] = True\\n                d[u] = i\\n                i += 1\\n                if not visited[edges[u]]:\\n                    u = edges[u]\\n                else:\\n                    break\\n            return d\\n\\n         d1, d2 = bfs(node1), bfs(node2)\\n         res = [float(\"inf\"), None]\\n         for v in d1:\\n            if v in d2:\\n                dis = max(d1[v], d2[v])\\n                if dis < res[0] or (dis == res[0] and v < res[1]):\\n                    res = [dis, v]\\n         return res[1] if res[1] is not None else -1\\n          \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n         n = len(edges)\\n\\n         def bfs(u):\\n            d = {u: 0}\\n            i = 0\\n            visited = [False] * n\\n            while u != -1:\\n                visited[u] = True\\n                d[u] = i\\n                i += 1\\n                if not visited[edges[u]]:\\n                    u = edges[u]\\n                else:\\n                    break\\n            return d\\n\\n         d1, d2 = bfs(node1), bfs(node2)\\n         res = [float(\"inf\"), None]\\n         for v in d1:\\n            if v in d2:\\n                dis = max(d1[v], d2[v])\\n                if dis < res[0] or (dis == res[0] and v < res[1]):\\n                    res = [dis, v]\\n         return res[1] if res[1] is not None else -1\\n          \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096460,
                "title": "c-easy-dfs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>g[100001];\\n    int vis[100001];\\n    int vis1[100001];\\n    int dis[100001];\\n    int dis1[100001];\\n    void dfs(int node) {\\n        vis[node]=1;\\n        for(int child:g[node]) {\\n            if(!vis[child]) {\\n                dis[child]=dis[node]+1;\\n                dfs(child);\\n            }\\n        }\\n    }\\n    void dfs1(int node) {\\n        vis1[node]=1;\\n        for(int child:g[node]) {\\n            if(!vis1[child]) {\\n                dis1[child]=dis1[node]+1;\\n                dfs1(child);\\n            }\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& e, int n1, int n2) {\\n        for(int i=0; i<e.size(); i++) {\\n            if(e[i]==-1) continue;\\n            g[i].push_back(e[i]);\\n        }\\n        // memset(dis,-1,sizeof(dis));\\n        // memset(dis,-1,sizeof(dis1));\\n        dis[n1]=0;\\n        dis[n2]=0;\\n        dfs(n1);\\n        dfs1(n2);\\n        int a=0,b=0,mx=1e9,ans=-1;\\n        for(int i=0; i<e.size(); i++) {\\n          //  cout<<vis[i]<<\" \"<<vis1[i]<<endl;\\n            if(vis[i]==1 && vis1[i]==1) {\\n                int p=max(dis[i],dis1[i]);\\n                //cout<<p<<endl;\\n                if(p<mx) mx=p,ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>g[100001];\\n    int vis[100001];\\n    int vis1[100001];\\n    int dis[100001];\\n    int dis1[100001];\\n    void dfs(int node) {\\n        vis[node]=1;\\n        for(int child:g[node]) {\\n            if(!vis[child]) {\\n                dis[child]=dis[node]+1;\\n                dfs(child);\\n            }\\n        }\\n    }\\n    void dfs1(int node) {\\n        vis1[node]=1;\\n        for(int child:g[node]) {\\n            if(!vis1[child]) {\\n                dis1[child]=dis1[node]+1;\\n                dfs1(child);\\n            }\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& e, int n1, int n2) {\\n        for(int i=0; i<e.size(); i++) {\\n            if(e[i]==-1) continue;\\n            g[i].push_back(e[i]);\\n        }\\n        // memset(dis,-1,sizeof(dis));\\n        // memset(dis,-1,sizeof(dis1));\\n        dis[n1]=0;\\n        dis[n2]=0;\\n        dfs(n1);\\n        dfs1(n2);\\n        int a=0,b=0,mx=1e9,ans=-1;\\n        for(int i=0; i<e.size(); i++) {\\n          //  cout<<vis[i]<<\" \"<<vis1[i]<<endl;\\n            if(vis[i]==1 && vis1[i]==1) {\\n                int p=max(dis[i],dis1[i]);\\n                //cout<<p<<endl;\\n                if(p<mx) mx=p,ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3096453,
                "title": "c-o-n-two-pass-no-need-to-use-queue-recursion-bfs-and-dfs-are-same",
                "content": "- For calculating distances in an unweigted graph BFS is enough. You can use DFS as well but runtime will be higher.\\n- For this question in particular its mentioned that any node can have atmost one outgoing edge. How does this help us ? Well this essentially means the its more like a linked list and you don\\'t need to use queue(BFS) or stack(DFS) because we have atmost one choice at every node to move forward (there is no branching).\\n- Gist of below algo - Tranverse from node1 and store distances to all nodes it can reach in a vector. Then start travelling from node2 and cross check if current node was visitable from node1 and compare distances.\\n- Another thing we need to take care of is loops. We could use a special visited array buy why waste memory right, so we\\'ll use the distance array itself to check for visit.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        // special case, if node1 and node2 are same the answer will be itself\\n        if(node1 == node2)\\n            return node1;\\n\\n        int n = edges.size();\\n        // distance vectors for node1 and node2\\n        vector<int> m1(n, -1);\\n        vector<int> m2(n, -1);\\n        int ans = -1;\\n        int maxD = n + 1;\\n\\n        int node = node1;\\n        int dist = 0;\\n        // calculate distance from node1       \\n        while(node != -1 && m1[node] == -1)\\n        {\\n            m1[node] = dist;\\n            dist++;\\n            node = edges[node];   \\n        }\\n\\n        node = node2;\\n        dist = 0;\\n        // calculate distance from node2 while checking for the same node in distance vector for node1\\n        while(node != -1 && m2[node] == -1)\\n        {\\n            if(m1[node] != -1)\\n            {\\n                if(maxD > max(dist, m1[node]))\\n                {\\n                    ans = node;\\n                    maxD = max(dist, m1[node]);\\n                }\\n                else if(maxD == max(dist, m1[node]))\\n                {\\n                    if(ans > node)\\n                        ans = node;\\n                }\\n            }\\n\\n            m2[node] = dist;\\n            dist++;\\n            node = edges[node];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        // special case, if node1 and node2 are same the answer will be itself\\n        if(node1 == node2)\\n            return node1;\\n\\n        int n = edges.size();\\n        // distance vectors for node1 and node2\\n        vector<int> m1(n, -1);\\n        vector<int> m2(n, -1);\\n        int ans = -1;\\n        int maxD = n + 1;\\n\\n        int node = node1;\\n        int dist = 0;\\n        // calculate distance from node1       \\n        while(node != -1 && m1[node] == -1)\\n        {\\n            m1[node] = dist;\\n            dist++;\\n            node = edges[node];   \\n        }\\n\\n        node = node2;\\n        dist = 0;\\n        // calculate distance from node2 while checking for the same node in distance vector for node1\\n        while(node != -1 && m2[node] == -1)\\n        {\\n            if(m1[node] != -1)\\n            {\\n                if(maxD > max(dist, m1[node]))\\n                {\\n                    ans = node;\\n                    maxD = max(dist, m1[node]);\\n                }\\n                else if(maxD == max(dist, m1[node]))\\n                {\\n                    if(ans > node)\\n                        ans = node;\\n                }\\n            }\\n\\n            m2[node] = dist;\\n            dist++;\\n            node = edges[node];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096364,
                "title": "optimized-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int n1, int n2) {\\n        int n=edges.size();\\n        vector<pair<int,int>>st(n,{-1,-1});\\n        int i=0;\\n        while(n1!=-1 && st[n1].first==-1){\\n            st[n1].first=i;\\n            i++;\\n            n1=edges[n1];\\n        }\\n        i=0;\\n        while(n2!=-1 && st[n2].second==-1){\\n            st[n2].second=i;\\n            i++;\\n            n2=edges[n2];\\n        }\\n        int mini=INT_MAX,node;\\n        for(int i=0;i<n;i++){\\n            if(st[i].first!=-1 && st[i].second!=-1){\\n                \\n                if(max(st[i].first,st[i].second)<mini)\\n                {\\n                    mini=max(st[i].first,st[i].second);\\n                    node=i;\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX)return -1;\\n        return node;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int n1, int n2) {\\n        int n=edges.size();\\n        vector<pair<int,int>>st(n,{-1,-1});\\n        int i=0;\\n        while(n1!=-1 && st[n1].first==-1){\\n            st[n1].first=i;\\n            i++;\\n            n1=edges[n1];\\n        }\\n        i=0;\\n        while(n2!=-1 && st[n2].second==-1){\\n            st[n2].second=i;\\n            i++;\\n            n2=edges[n2];\\n        }\\n        int mini=INT_MAX,node;\\n        for(int i=0;i<n;i++){\\n            if(st[i].first!=-1 && st[i].second!=-1){\\n                \\n                if(max(st[i].first,st[i].second)<mini)\\n                {\\n                    mini=max(st[i].first,st[i].second);\\n                    node=i;\\n                }\\n            }\\n        }\\n        if(mini==INT_MAX)return -1;\\n        return node;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096341,
                "title": "c-dfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, int dist, vector<int> edges, vector<int>& dis) {\\n        while (node != -1 && dis[node] == -1) {\\n            dis[node] = dist++;\\n            node = edges[node];\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int res = -1, min_dist = INT_MAX, n = edges.size();\\n        vector<int> dist1(n, -1), dist2(n, -1);\\n        dfs(node1, 0, edges, dist1);\\n        dfs(node2, 0, edges, dist2);\\n        for (int i = 0; i < n; ++i) {\\n            if (min(dist1[i], dist2[i]) >= 0 && max(dist1[i], dist2[i]) < min_dist) {\\n                min_dist = max(dist1[i], dist2[i]);\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, int dist, vector<int> edges, vector<int>& dis) {\\n        while (node != -1 && dis[node] == -1) {\\n            dis[node] = dist++;\\n            node = edges[node];\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int res = -1, min_dist = INT_MAX, n = edges.size();\\n        vector<int> dist1(n, -1), dist2(n, -1);\\n        dfs(node1, 0, edges, dist1);\\n        dfs(node2, 0, edges, dist2);\\n        for (int i = 0; i < n; ++i) {\\n            if (min(dist1[i], dist2[i]) >= 0 && max(dist1[i], dist2[i]) < min_dist) {\\n                min_dist = max(dist1[i], dist2[i]);\\n                res = i;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096337,
                "title": "c-dfs-official-version",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& edges, vector<int>& dist, vector<bool>& visit) {\\n        visit[node] = true;\\n        int neighbor = edges[node];\\n        if (neighbor != -1 && !visit[neighbor]) {\\n            dist[neighbor] = 1 + dist[node];\\n            dfs(neighbor, edges, dist, visit);\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> dist1(n, numeric_limits<int>::max()), dist2(n, numeric_limits<int>::max());\\n        vector<bool> visit1(n), visit2(n);\\n        dist1[node1] = 0, dist2[node2] = 0;\\n\\n        dfs(node1, edges, dist1, visit1);\\n        dfs(node2, edges, dist2, visit2);\\n\\n        int minDistNode = -1, minDistTillNow = numeric_limits<int>::max();\\n        for (int currNode = 0; currNode < n; currNode++) {\\n            if (minDistTillNow > max(dist1[currNode], dist2[currNode])) {\\n                minDistNode = currNode;\\n                minDistTillNow = max(dist1[currNode], dist2[currNode]);\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node, vector<int>& edges, vector<int>& dist, vector<bool>& visit) {\\n        visit[node] = true;\\n        int neighbor = edges[node];\\n        if (neighbor != -1 && !visit[neighbor]) {\\n            dist[neighbor] = 1 + dist[node];\\n            dfs(neighbor, edges, dist, visit);\\n        }\\n    }\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        vector<int> dist1(n, numeric_limits<int>::max()), dist2(n, numeric_limits<int>::max());\\n        vector<bool> visit1(n), visit2(n);\\n        dist1[node1] = 0, dist2[node2] = 0;\\n\\n        dfs(node1, edges, dist1, visit1);\\n        dfs(node2, edges, dist2, visit2);\\n\\n        int minDistNode = -1, minDistTillNow = numeric_limits<int>::max();\\n        for (int currNode = 0; currNode < n; currNode++) {\\n            if (minDistTillNow > max(dist1[currNode], dist2[currNode])) {\\n                minDistNode = currNode;\\n                minDistTillNow = max(dist1[currNode], dist2[currNode]);\\n            }\\n        }\\n\\n        return minDistNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096318,
                "title": "c-easy-bfs-approach-with-explanation",
                "content": "# Intuition\\n\\nStart BFS traversal in graph from `node1` and `node2`. We will maintain a `visitor` vector for storing visitor of node. At some point when the node is already visited but by someone else then this is one of our solution. \\n\\nSince its BFS traversal, we have to check for all nodes which are currently at the same level in queue and after that we will return the minimum index from them if exisits or -1.\\n# Approach\\n\\n- Step 1 - Check if `node1` and `node2` are same then return any of them\\n- Step 2 - Initialize queue, visitor vector, ans and minStep.\\n- Step 3 - Start BFS traversal and store solution.\\n- Step 4 - Return minimum index if ans found otherwise return -1\\n- (See comments written in the code for better understanding)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();   // total nodes\\n        int ans = n+1;          // set to max value of index\\n        int minStep = -1;       // minStep required for ans\\n\\n        vector<int> visitor(n, -1); // For storing visitor of node\\n        queue<pair<int,int>> q;     // For storing node and its level\\n\\n        // {node-index, level}\\n        q.push({node1, 0}); \\n        q.push({node2, 0});\\n\\n        visitor[node1] = node1;\\n        visitor[node2] = node2;\\n\\n        // BFS \\n        while(!q.empty()) {\\n            int node = q.front().first;\\n            int step = q.front().second;\\n            q.pop();\\n            \\n            // neighbour of current node\\n            int next = edges[node];\\n            if(next != -1) {\\n                // if next is not visited then\\n                if(visitor[next] == -1) {\\n                    // Store (visitor of node) as its visitor\\n                    visitor[next] = visitor[node];\\n                    // Push next and its level to the queue\\n                    q.push({next, step + 1});\\n                } \\n                // if next is visited but by someone else then check\\n                else if(visitor[next] != visitor[node] && \\n                    (minStep == -1 || step == minStep)) {\\n                    // If its first node for ans then update minStep \\n                    // and check all other nodes for same level\\n                    if(minStep == -1) minStep = step;\\n                    ans = min(ans, next);\\n                }\\n            }\\n        }\\n        // return ans\\n        if(ans == n+1) return -1;\\n        return ans;\\n    }\\n};\\n```\\n\\n![image.png](https://assets.leetcode.com/users/images/eb9d8ea9-4ef5-4c6d-9e7c-d5d067c6bf85_1674624335.5757682.png)\\n",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();   // total nodes\\n        int ans = n+1;          // set to max value of index\\n        int minStep = -1;       // minStep required for ans\\n\\n        vector<int> visitor(n, -1); // For storing visitor of node\\n        queue<pair<int,int>> q;     // For storing node and its level\\n\\n        // {node-index, level}\\n        q.push({node1, 0}); \\n        q.push({node2, 0});\\n\\n        visitor[node1] = node1;\\n        visitor[node2] = node2;\\n\\n        // BFS \\n        while(!q.empty()) {\\n            int node = q.front().first;\\n            int step = q.front().second;\\n            q.pop();\\n            \\n            // neighbour of current node\\n            int next = edges[node];\\n            if(next != -1) {\\n                // if next is not visited then\\n                if(visitor[next] == -1) {\\n                    // Store (visitor of node) as its visitor\\n                    visitor[next] = visitor[node];\\n                    // Push next and its level to the queue\\n                    q.push({next, step + 1});\\n                } \\n                // if next is visited but by someone else then check\\n                else if(visitor[next] != visitor[node] && \\n                    (minStep == -1 || step == minStep)) {\\n                    // If its first node for ans then update minStep \\n                    // and check all other nodes for same level\\n                    if(minStep == -1) minStep = step;\\n                    ans = min(ans, next);\\n                }\\n            }\\n        }\\n        // return ans\\n        if(ans == n+1) return -1;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096313,
                "title": "easily-understood-c-dfs-dijkstra",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int currNode, vector<int>& edges, vector<int> &dist, \\n                    vector<bool> &vis) \\n    {\\n        vis[currNode] = true;\\n\\n        if(edges[currNode] != -1 && !vis[edges[currNode]]) \\n        {\\n            dist[edges[currNode]] = dist[currNode] + 1;\\n            dfs(edges[currNode], edges, dist, vis);\\n        }\\n    }\\n\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        vector<int> dist1(edges.size(), INT_MAX);\\n        vector<int> dist2(edges.size(), INT_MAX);\\n\\n        vector<bool> vis1(edges.size(), false);\\n        vector<bool> vis2(edges.size(), false);\\n\\n        dist1[node1] = 0;\\n        dist2[node2] = 0;\\n\\n        dfs(node1, edges, dist1, vis1);\\n        dfs(node2, edges, dist2, vis2);\\n\\n        int ans = -1;\\n        int mindist = INT_MAX;\\n\\n        for(int i=0; i<dist1.size(); i++) \\n        {\\n            if(max(dist1[i], dist2[i]) < mindist) \\n            {\\n                mindist = max(dist1[i], dist2[i]);\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    void dfs(int currNode, vector<int>& edges, vector<int> &dist, \\n                    vector<bool> &vis) \\n    {\\n        vis[currNode] = true;\\n\\n        if(edges[currNode] != -1 && !vis[edges[currNode]]) \\n        {\\n            dist[edges[currNode]] = dist[currNode] + 1;\\n            dfs(edges[currNode], edges, dist, vis);\\n        }\\n    }\\n\\n\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        \\n        vector<int> dist1(edges.size(), INT_MAX);\\n        vector<int> dist2(edges.size(), INT_MAX);\\n\\n        vector<bool> vis1(edges.size(), false);\\n        vector<bool> vis2(edges.size(), false);\\n\\n        dist1[node1] = 0;\\n        dist2[node2] = 0;\\n\\n        dfs(node1, edges, dist1, vis1);\\n        dfs(node2, edges, dist2, vis2);\\n\\n        int ans = -1;\\n        int mindist = INT_MAX;\\n\\n        for(int i=0; i<dist1.size(); i++) \\n        {\\n            if(max(dist1[i], dist2[i]) < mindist) \\n            {\\n                mindist = max(dist1[i], dist2[i]);\\n                ans = i;\\n            }\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096294,
                "title": "java-graph-path",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    \\n    public void path(int[] paths,int node,int[] edges){\\n        \\n        PriorityQueue<Pair<Integer,Integer>> pq;\\n        pq = new PriorityQueue<>((a,b)->a.getKey()-b.getKey());\\n        pq.offer(new Pair(0,node));\\n        paths[node] = 0;\\n        while(!pq.isEmpty()){\\n            int steps = (int) pq.peek().getKey();\\n            int nod = (int) pq.peek().getValue();\\n            pq.remove();\\n            \\n            if(edges[nod]==-1)\\n                continue;\\n            \\n            int num = edges[nod];\\n            if(paths[num]==-1){\\n                paths[num]=steps+1;\\n            \\n                pq.add(new Pair(steps+1,num));\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] patha = new int[n];\\n        int[] pathb = new int[n];\\n        Arrays.fill(patha,-1);\\n        Arrays.fill(pathb,-1);\\n        \\n        path(patha,node1,edges);\\n        path(pathb,node2,edges);\\n        \\n        int ans = -1,mn = Integer.MAX_VALUE;\\n        for(int i = 0;i<n;i++){\\n            int a = patha[i], b=  pathb[i];\\n            if(a==-1 || b==-1)\\n                continue;\\n            \\n            if(mn>Math.max(a,b)){\\n                mn = Math.max(a,b);\\n                ans = i;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Graph"
                ],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    \\n    public void path(int[] paths,int node,int[] edges){\\n        \\n        PriorityQueue<Pair<Integer,Integer>> pq;\\n        pq = new PriorityQueue<>((a,b)->a.getKey()-b.getKey());\\n        pq.offer(new Pair(0,node));\\n        paths[node] = 0;\\n        while(!pq.isEmpty()){\\n            int steps = (int) pq.peek().getKey();\\n            int nod = (int) pq.peek().getValue();\\n            pq.remove();\\n            \\n            if(edges[nod]==-1)\\n                continue;\\n            \\n            int num = edges[nod];\\n            if(paths[num]==-1){\\n                paths[num]=steps+1;\\n            \\n                pq.add(new Pair(steps+1,num));\\n                \\n            }\\n            \\n        }\\n        \\n    }\\n    \\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] patha = new int[n];\\n        int[] pathb = new int[n];\\n        Arrays.fill(patha,-1);\\n        Arrays.fill(pathb,-1);\\n        \\n        path(patha,node1,edges);\\n        path(pathb,node2,edges);\\n        \\n        int ans = -1,mn = Integer.MAX_VALUE;\\n        for(int i = 0;i<n;i++){\\n            int a = patha[i], b=  pathb[i];\\n            if(a==-1 || b==-1)\\n                continue;\\n            \\n            if(mn>Math.max(a,b)){\\n                mn = Math.max(a,b);\\n                ans = i;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096274,
                "title": "easy-solution-using-two-bfs-optimal-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<int>& edges,vector<long long>& dist,int src,int n){\\n        vector<bool> vis(n,false);\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        vis[src]=true;\\n        while(!q.empty()){\\n            int node=q.front().first;\\n            long long dis=q.front().second;\\n            dist[node]=dis;\\n            q.pop();\\n            int adj=edges[node];\\n            if(adj!=-1 && !vis[adj]){\\n                vis[adj]=true;\\n                q.push({adj,dis+1});\\n            }\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size(),ans=-1,mini=INT_MAX;\\n        vector<long long> dist1(n,INT_MAX),dist2(n,INT_MAX);\\n        bfs(edges,dist1,node1,n);\\n        bfs(edges,dist2,node2,n);\\n        for(int i=0;i<n;i++){\\n            if(max(dist1[i],dist2[i])<mini ){\\n                mini=max(dist1[i],dist2[i]);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void bfs(vector<int>& edges,vector<long long>& dist,int src,int n){\\n        vector<bool> vis(n,false);\\n        queue<pair<int,int>> q;\\n        q.push({src,0});\\n        vis[src]=true;\\n        while(!q.empty()){\\n            int node=q.front().first;\\n            long long dis=q.front().second;\\n            dist[node]=dis;\\n            q.pop();\\n            int adj=edges[node];\\n            if(adj!=-1 && !vis[adj]){\\n                vis[adj]=true;\\n                q.push({adj,dis+1});\\n            }\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size(),ans=-1,mini=INT_MAX;\\n        vector<long long> dist1(n,INT_MAX),dist2(n,INT_MAX);\\n        bfs(edges,dist1,node1,n);\\n        bfs(edges,dist2,node2,n);\\n        for(int i=0;i<n;i++){\\n            if(max(dist1[i],dist2[i])<mini ){\\n                mini=max(dist1[i],dist2[i]);\\n                ans=i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096263,
                "title": "c-easy-to-understand-solution-using-two-bfs-traversals-simultaneously",
                "content": "Code Explanation in comments.\\n\\nDO UPVOTE :)\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n\\tint closestMeetingNode(vector<int> &edges, int node1, int node2)\\n\\t{\\n\\t\\tint n = edges.size();\\n\\t\\tqueue<int> q1, q2; // create two queues for each starting node\\n\\t\\tint ans = n;\\n\\t\\tif (node1 == node2)\\n\\t\\t\\treturn node1; // if the nodes are the same, return that node\\n\\t\\tq1.push(node1);\\n\\t\\tq2.push(node2);\\n\\t\\tvector<bool> vis1(n, 0), vis2(n, 0); // create two visited arrays to keep track of visited nodes\\n\\t\\tvis1[node1] = 1;\\n\\t\\tvis2[node2] = 1;\\n\\t\\twhile (q1.size() or q2.size())\\n\\t\\t{\\n\\t\\t\\tint x = -1, y = -1;\\n\\t\\t\\tif (q1.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tx = edges[q1.front()]; // get the next node from the queue\\n\\t\\t\\t\\tq1.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (q2.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\ty = edges[q2.front()]; // get the next node from the queue\\n\\t\\t\\t\\tq2.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (x != -1 and x == y)\\n\\t\\t\\t\\tans = min(ans, x); // check if the current nodes from each queue are the same\\n\\t\\t\\tif (x != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vis2[x])\\n\\t\\t\\t\\t\\tans = min(ans, x); // check if the current node from queue 1 has already been visited by queue 2\\n\\t\\t\\t\\tif (!vis1[x])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvis1[x] = 1;\\n\\t\\t\\t\\t\\tq1.push(x);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (y != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vis1[y])\\n\\t\\t\\t\\t\\tans = min(ans, y); // check if the current node from queue 2 has already been visited by queue 1\\n\\t\\t\\t\\tif (!vis2[y])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvis2[y] = 1;\\n\\t\\t\\t\\t\\tq2.push(y);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (ans != n)\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n\\tint closestMeetingNode(vector<int> &edges, int node1, int node2)\\n\\t{\\n\\t\\tint n = edges.size();\\n\\t\\tqueue<int> q1, q2; // create two queues for each starting node\\n\\t\\tint ans = n;\\n\\t\\tif (node1 == node2)\\n\\t\\t\\treturn node1; // if the nodes are the same, return that node\\n\\t\\tq1.push(node1);\\n\\t\\tq2.push(node2);\\n\\t\\tvector<bool> vis1(n, 0), vis2(n, 0); // create two visited arrays to keep track of visited nodes\\n\\t\\tvis1[node1] = 1;\\n\\t\\tvis2[node2] = 1;\\n\\t\\twhile (q1.size() or q2.size())\\n\\t\\t{\\n\\t\\t\\tint x = -1, y = -1;\\n\\t\\t\\tif (q1.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tx = edges[q1.front()]; // get the next node from the queue\\n\\t\\t\\t\\tq1.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (q2.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\ty = edges[q2.front()]; // get the next node from the queue\\n\\t\\t\\t\\tq2.pop();\\n\\t\\t\\t}\\n\\t\\t\\tif (x != -1 and x == y)\\n\\t\\t\\t\\tans = min(ans, x); // check if the current nodes from each queue are the same\\n\\t\\t\\tif (x != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vis2[x])\\n\\t\\t\\t\\t\\tans = min(ans, x); // check if the current node from queue 1 has already been visited by queue 2\\n\\t\\t\\t\\tif (!vis1[x])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvis1[x] = 1;\\n\\t\\t\\t\\t\\tq1.push(x);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (y != -1)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (vis1[y])\\n\\t\\t\\t\\t\\tans = min(ans, y); // check if the current node from queue 2 has already been visited by queue 1\\n\\t\\t\\t\\tif (!vis2[y])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tvis2[y] = 1;\\n\\t\\t\\t\\t\\tq2.push(y);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif (ans != n)\\n\\t\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t\\treturn -1;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096256,
                "title": "simple-graph-traversal-like-a-linked-list-no-bfs-dfs-needed",
                "content": "# Intuition\\nAs each node has at most 1 outgoing edge, from a given node there is only 1 path until a circle is formed or the end of the path. So all we need is a simple traversal as if the graph is a linked list to calculate the distance from node1 & node2 to each distinct node that could be arrived.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] distance1 = new int[n];\\n        int[] distance2 = new int[n];\\n        Arrays.fill(distance1, -1);\\n        Arrays.fill(distance2, -1);\\n        getDistance(distance1, node1, edges);\\n        getDistance(distance2, node2, edges);\\n        int res = -1, max = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (distance1[i] != -1 && distance2[i] != -1) {\\n                if (max > Math.max(distance1[i], distance2[i])) {\\n                    max = Math.max(distance1[i], distance2[i]);\\n                    res = i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public void getDistance(int[] distance, int node, int[] edges) {\\n        int cur = node;\\n        int step = 0;\\n        while (cur != -1 && distance[cur] == -1) {\\n            distance[cur] = step++;\\n            cur = edges[cur];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int closestMeetingNode(int[] edges, int node1, int node2) {\\n        int n = edges.length;\\n        int[] distance1 = new int[n];\\n        int[] distance2 = new int[n];\\n        Arrays.fill(distance1, -1);\\n        Arrays.fill(distance2, -1);\\n        getDistance(distance1, node1, edges);\\n        getDistance(distance2, node2, edges);\\n        int res = -1, max = Integer.MAX_VALUE;\\n        for (int i = 0; i < n; i++) {\\n            if (distance1[i] != -1 && distance2[i] != -1) {\\n                if (max > Math.max(distance1[i], distance2[i])) {\\n                    max = Math.max(distance1[i], distance2[i]);\\n                    res = i;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public void getDistance(int[] distance, int node, int[] edges) {\\n        int cur = node;\\n        int step = 0;\\n        while (cur != -1 && distance[cur] == -1) {\\n            distance[cur] = step++;\\n            cur = edges[cur];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096253,
                "title": "easy-c-solution-simple-dfs",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Simply solve out the distance of every nodes from these two given nodes.\\n2. Initialise the index variable idx = -1 and mn variable for storing the minimum of the maximum distance value. \\n3. Then, simply store the minimum value of distance and its correseponding index.\\n4. Then if the curr value is lower than the mn value, then update the value and also its coreesponding index.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int dist[2][100005];\\n\\n    void dfs(int node, int i, vector<int>& edges, int d){\\n        dist[i][node] = d;\\n        if(edges[node] != -1 && dist[i][edges[node]] == -1){\\n           dfs(edges[node], i, edges, d+1);\\n        }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        memset(dist,-1,sizeof(dist));\\n        dfs(node1, 0, edges, 0);\\n        dfs(node2, 1, edges, 0);\\n        int mn = INT_MAX;\\n        int idx = -1;\\n        for(int i=0;i<n;i++){\\n            if(dist[0][i] == -1 || dist[1][i] == -1) continue;\\n            if(max(dist[0][i], dist[1][i]) < mn) {\\n                mn = max(dist[0][i], dist[1][i]);\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dist[2][100005];\\n\\n    void dfs(int node, int i, vector<int>& edges, int d){\\n        dist[i][node] = d;\\n        if(edges[node] != -1 && dist[i][edges[node]] == -1){\\n           dfs(edges[node], i, edges, d+1);\\n        }\\n    }\\n    \\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        memset(dist,-1,sizeof(dist));\\n        dfs(node1, 0, edges, 0);\\n        dfs(node2, 1, edges, 0);\\n        int mn = INT_MAX;\\n        int idx = -1;\\n        for(int i=0;i<n;i++){\\n            if(dist[0][i] == -1 || dist[1][i] == -1) continue;\\n            if(max(dist[0][i], dist[1][i]) < mn) {\\n                mn = max(dist[0][i], dist[1][i]);\\n                idx = i;\\n            }\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096217,
                "title": "easy-video-explanation-dfs-o-n-c-beginner-friendly",
                "content": "# Intuition and Approach\\n https://youtu.be/RgrnYmoJ1z0 \\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int node1,vector<int>& a,vector<int>& edges){\\n         while(edges[node1]!=-1 && a[edges[node1]]==-1)\\n        {\\n            int node=edges[node1];\\n            a[node]=a[node1]+1;\\n            node1=node;\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<int> a(n,-1),b(n,-1);\\n        a[node1]=0;\\n        b[node2]=0;\\n        int res=INT_MAX;\\n        int resNode=-1;\\n\\n        dfs(node1,a,edges);\\n        dfs(node2,b,edges);\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]!=-1 && b[i]!=-1 && max(a[i],b[i])<res)\\n            {\\n                res=max(a[i],b[i]);\\n                resNode=i;\\n            }\\n        }\\n        return resNode;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int node1,vector<int>& a,vector<int>& edges){\\n         while(edges[node1]!=-1 && a[edges[node1]]==-1)\\n        {\\n            int node=edges[node1];\\n            a[node]=a[node1]+1;\\n            node1=node;\\n        }\\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        vector<int> a(n,-1),b(n,-1);\\n        a[node1]=0;\\n        b[node2]=0;\\n        int res=INT_MAX;\\n        int resNode=-1;\\n\\n        dfs(node1,a,edges);\\n        dfs(node2,b,edges);\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            if(a[i]!=-1 && b[i]!=-1 && max(a[i],b[i])<res)\\n            {\\n                res=max(a[i],b[i]);\\n                resNode=i;\\n            }\\n        }\\n        return resNode;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3096144,
                "title": "javascript-very-easy-to-understand-solution-using-dfs-with-comments",
                "content": "\\n```\\n/**\\n * @param {number[]} edges\\n * @param {number} node1\\n * @param {number} node2\\n * @return {number}\\n */\\nvar closestMeetingNode = function (edges, node1, node2) {\\n    const distanceFromNode1 = new Array(edges.length);\\n    const distanceFromNode2 = new Array(edges.length);\\n   \\n    const dfs = (index, count, arr) => {\\n        arr[index] = count;\\n        // if current node is not connected to any node, or its next connection has already been visited\\n        // in case of cycle, then return\\n        if (edges[index] === -1 || arr[edges[index]] !== undefined) return\\n        dfs(edges[index], count + 1, arr);\\n    }\\n    dfs(node1, 0, distanceFromNode1);\\n    dfs(node2, 0, distanceFromNode2);\\n    \\n    let min = Infinity, index = -1;\\n    for (let i = 0; i < distanceFromNode1.length; i++) {\\n        if (distanceFromNode1[i] !== undefined && distanceFromNode2[i] !== undefined) {\\n            let currMax = Math.max(distanceFromNode1[i], distanceFromNode2[i])\\n            if (currMax < min) {\\n                min = currMax;\\n                index = i;\\n            }\\n        }\\n    }\\n    return index;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * @param {number[]} edges\\n * @param {number} node1\\n * @param {number} node2\\n * @return {number}\\n */\\nvar closestMeetingNode = function (edges, node1, node2) {\\n    const distanceFromNode1 = new Array(edges.length);\\n    const distanceFromNode2 = new Array(edges.length);\\n   \\n    const dfs = (index, count, arr) => {\\n        arr[index] = count;\\n        // if current node is not connected to any node, or its next connection has already been visited\\n        // in case of cycle, then return\\n        if (edges[index] === -1 || arr[edges[index]] !== undefined) return\\n        dfs(edges[index], count + 1, arr);\\n    }\\n    dfs(node1, 0, distanceFromNode1);\\n    dfs(node2, 0, distanceFromNode2);\\n    \\n    let min = Infinity, index = -1;\\n    for (let i = 0; i < distanceFromNode1.length; i++) {\\n        if (distanceFromNode1[i] !== undefined && distanceFromNode2[i] !== undefined) {\\n            let currMax = Math.max(distanceFromNode1[i], distanceFromNode2[i])\\n            if (currMax < min) {\\n                min = currMax;\\n                index = i;\\n            }\\n        }\\n    }\\n    return index;\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1773266,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773356,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773772,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773300,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1774105,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773349,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773368,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773420,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773298,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773271,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773266,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773356,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773772,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773300,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1774105,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773349,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773368,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773420,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773298,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773271,
                "content": [
                    {
                        "username": "kenzoengineer",
                        "content": "I used this algorithm when my parents divorced"
                    },
                    {
                        "username": "shivamgcodes",
                        "content": "[@bk_3497](/bk_3497) i think he is joking"
                    },
                    {
                        "username": "bk_3497",
                        "content": "ohh sorry, but why your parents divorced ?"
                    },
                    {
                        "username": "santanusen",
                        "content": "And found all your siblings were closer than you! "
                    },
                    {
                        "username": "thaile071",
                        "content": "[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nexpected answer is 1\\nwhy? \\nmy output is 4"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@rosie-i](/rosie-i) This issue seems to be an artifact of doing both traversals at the same time so once it finds a common (visited) node the code assumes that all matches are the minimized path from *node1 to a common node* and from *node2 to a common node*.\\n\\nIn reality it found the minimum **required** steps/distance to get from **EITHER** node1 **OR** node2 to reach **A** common node where only one of those path has to be the minimized path of node1 to the common node and node2 to the common node.\\n\\nProblem:\\nedges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nHere the logic that you explained where it finds both common nodes 1 and 4:\\n\\nt0:\\n  n1: ( ) -> 5  (seen [5])\\n  n2: ( ) -> 6  (seen [6])\\n\\nt1:\\n  n1:(5) -> 8 (seen [5, 8])\\n  n2:(6) -> 4 (seen [6, 4])\\n\\nt2:\\n  n1:(8) -> 1 (seen [5, 8, 1])\\n  n2(4)  -> 9 (seen [6, 4, 9])\\n\\nt3:\\n  n1: (1) -> 4 (seen [5, 8, 1, 4])\\n  n2: (9) -> 1 (seen [6, 4, 9, 1])\\n\\nCommons matches are **4** and **1** and choosing the minimum index picks *1*\\n\\nBut to get to ***1*** requires this traversal:\\n\\nn1 (5) -> 8 -> 1 = 2\\nn2 (6) -> 4 -> 9 -> 1 = **3**\\nTotal distance is 2 + 3 = 5 nodes in between\\n\\nAnd to get to node ***4*** requires this minimized traversal:\\nn1 (5) -> 8 -> 1-> 4 = **3**\\nn2 (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nReaching node **4** has the minimized path from node1 to the common node and from node2 to the common node."
                    },
                    {
                        "username": "gregoryinouye",
                        "content": "rather than minimizing the SUM of the distances from node1/node2 to the common node (`min(sum(node1_common, node2_common))`), we are minimizing/considering only the larger of the two distances (`min(max(node1_common, node2_common))`)"
                    },
                    {
                        "username": "chees-e",
                        "content": "When reading the question I was wondering how can there be multiple solutions if every node only branch out once... This is actually a great example to demonstrate."
                    },
                    {
                        "username": "samc123",
                        "content": "I agree, this also caught me out - I definitely think the question could be worded more clearly. Thank you to the people who cleared it up - I thought I was the silly one! \\uD83D\\uDE04"
                    },
                    {
                        "username": "Vecna_7",
                        "content": "[@Nelson_Perez](/Nelson_Perez)  same issue!!"
                    },
                    {
                        "username": "rosie-i",
                        "content": "[@in3pid](/in3pid) Ok, thank you! Such a confusingly worded question, I think I finally get it!! \\n\\nIf anyone else is confused, I am mentally thinking of it like two people are walking a path, one starting on node1 and one on node2. They both take one step at the same time to their next node. When they get to a node the other person has been at, they can stop. \\n\\nBut in this example, they\\'ll both reach a node the other has been to before at the same time (Node 1 and Node 4). It doesn\\'t matter about how long it took the other person to get there before, it only matters about this final step - so now they\\'ve both reached a place the other\\'s been to at the same time, just take the smallest index.\\n\\nI hope that helps visualise it a bit more for someone else!"
                    },
                    {
                        "username": "chaosdevil1994",
                        "content": "[@Nelson_Perez](/Nelson_Perez) I think I agree with you. If we want to find the shortest path to meet between 2 nodes, we will meet at node 4 when the first distance is 3 and the second is 1.\\n\\nThinking of more than 4-node path, I found it a bit ridiculous.\\n\\nPlease clarify if I am wrong."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st index. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "M1saka10010",
                        "content": "[@in3pid](/in3pid) WOW, such a fucking problem. Thanks"
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "[@in3pid](/in3pid) Problem states: \"such that the maximum between the distance from node1 to that node, **and** from node2 to that node is **minimized**.\n\nWhen choosing Node: 1 is the distance from node1 to that node, **and** from node2 to that node is **NOT minimized**\n\nMaybe the wording is not correct or very misleading but the answer doesn't make sense."
                    },
                    {
                        "username": "NHMoon",
                        "content": "[@in3pid](/in3pid) I was also stuck in this case. Thanks for the clarification."
                    },
                    {
                        "username": "Nelson_Perez",
                        "content": "edges = [4,4,8,-1,9,8,4,4,1,1]\\nnode1 = 5\\nnode2 = 6\\n\\nOutput 4\\nExpected 1\\n\\nI have the same problem where expected answer of 1 is has a disntance of 5 and the actual output answer that I get is 4 with distance of 4\\n\\nBellow is the explanation:\\n\\nExpected Answer of 1\\n      (5) -> 8 -> 1 = 2\\n      (6) -> 4 -> 9 -> 1 = 3\\nTotal distance is 2 + 3 = 5 nodes in between \\n\\nOutput Answer of 4:\\n     (5) -> 8 -> 1-> 4 = 3\\n     (6) -> 4 = 1\\nTotal distance is 3 + 1 = 4 nodes in between\\n\\nAm I crazy?"
                    },
                    {
                        "username": "Hyperzsb",
                        "content": "[@in3pid](/in3pid) Oh I just get it..."
                    },
                    {
                        "username": "in3pid",
                        "content": "The problem states : \"such that the __maximum__ between the distance from node1 to that node, and from node2 to that node is minimized\".\\n\\n* Node 1 is at distances 2 & 3 from nodes 5 & 6 respectively, and\\n* Node 4 is at distances 3 & 1 from nodes 5 & 6 respectively.\\n\\nNow, the key point here is that we only have to consider the _maximum_ of the 2 distances for every node (not the minimum of _total_), which, in this case, is 3 for both nodes 1 & 4.\\nThus, we pick the smallest index (per: \"If there are multiple answers, return the node with the smallest index\").\\n\\nHTH"
                    },
                    {
                        "username": "PengpengWei",
                        "content": "\"If there are multiple answers, return the smallest\""
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro same problem this problem is really depressing..."
                    },
                    {
                        "username": "gabrielkf",
                        "content": "Had the same problem. By any criteria of minimizing the the maximum path (both have a max of 3) but with 4 the sum is smaller."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Useful problem to improve your <b>reading skills<b>"
                    },
                    {
                        "username": "harshsaini",
                        "content": "yea, very ambiguous question."
                    },
                    {
                        "username": "conanjoey",
                        "content": "so true lol"
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "True, once you actually read the entire thing, it becomes more of an array question than graph one"
                    },
                    {
                        "username": "dan_kerna",
                        "content": "i felt that"
                    },
                    {
                        "username": "DexterHines",
                        "content": "Such a weird problem lmao"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@ajesk](/ajesk) Please read the above comment by me. I am sure you will be able to understand what the question is asking for?\\n\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@DexterHines](/DexterHines) We need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and \\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y \\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "ajesk",
                        "content": "[@Brent_Pappas](/Brent_Pappas) I read this prompt like 5 times now and I still don\\'t quite understand what it is asking for."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I know right! At first I tried finding the node such that the total distance between it and the two other nodes was minimized, but then I reread it and realized that that was not quite what the problem was asking for."
                    },
                    {
                        "username": "mrcoderrm1",
                        "content": "# Watch this video(in Hindi) for the better explanation of the code\\nhttps://youtu.be/07WfuUJ7Dxw\\n # SUBSCRIBE \\uD83E\\uDC81 \\uD83E\\uDC81 \\uD83E\\uDC81 this channel for the leetcode daily challange solution."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was helpful"
                    },
                    {
                        "username": "luihsuan",
                        "content": "It's been a couple of months since I started to do leetcode questions often, and this is no doubt one of the most confusing ones."
                    },
                    {
                        "username": "kartikayk8",
                        "content": "[@strive_hard](/strive_hard) Thank you for the explanation!"
                    },
                    {
                        "username": "sorokus-dev",
                        "content": "Dear colleague, I have bad news - it\\'s a very normal problem with good description and a common sense. Check the problems with the most downvotes - you\\'ll understand how pretty this one is :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Henry Lu](/luihsuan) Please go through this explanation, you will find it easy to understand the problem and develop the logic.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "strive_hard",
                        "content": "In order to understand the logic to solve this problem, please go through the below steps:\n\n1. Create two dictionaries named \n    reachable_from_1 and reachable_from_2.\n    reachable_from_1[a] = b means minimum \n    distance of node a from node1 is b.\n    Similarly reachable_from_2[c] = d means \n    minimum distance of node c from node2 is d. \n2. If we observe carefully, we don't need to \n    apply dijkstra to find the shortest distance \n    from node1 or node2 to all other nodes  \n    because weights of all edges are 1.  So, we \n    can use BFS to find the minimum distance of \n    all reachable nodes from node1 and node2.\n3. After finding the nodes reachable from node1 \n    and node2, find all the nodes which is \n    reachable from both node1 and node2.\n4. After finding all the nodes reachable from \n    both node1 and node2, we have to find the \n    node for which max(reachable_from_1[node], \n    reachable_from_2[node]) is minimum.\n    Note : \"node\" is the node reachable from \n    both node1 and node2\n5. If there are more than one nodes which are \n     reachable from both node1 and node2 and \n     have minimum distance, return the node with \n     minimum index.\n\nPlease look at the below code with comments in order to understand better.\n\nhttps://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3095884/bfs-no-dijkstra-short-clean-well-commented-code/\n\nFeel free to comment if you are unable to understand any steps. \n\nPlease upvote if it helps.\nThanks :)\n\n\n"
                    },
                    {
                        "username": "polyp",
                        "content": "There is actually a faster and simpler algorithm to solve this problem. Since there can be at most one outgoing edge we can do two searches in the same loop keeping track of paths from both node1 and node2 at the same time. If one search finds a node already visited by the other search then we have a solution and we can return directly. If we find two solutions in the same iteration we just choose the lowest one. Also, there is no need for any queues when doing the searches for the same reason, the searches are basically just hopping from one node to the next. There is only one path from each node."
                    },
                    {
                        "username": "xeniawann",
                        "content": "Is there some typos with step 3, or am I missing something?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "Please go through the explanation below with example to understand the question more clearly and handle the edge cases.\\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nThanks :)"
                    },
                    {
                        "username": "sepac",
                        "content": "The question description is so confusing."
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Shane Sepac](/sepac) I think the below explanation may help you. \\n\\nWe need to find the node which is reachable from both node1 and node2 and having minimum distance. In order to understand better please look at the below explanation with example:\\n\\nSuppose there is a graph with n nodes and some edges. Suppose nodes x, y are reachable from both node1 and node2 and\\n\\nmin distance of node x from node1 is a\\nmin distance of node x from node2 is b\\n\\nmin distance of node y from node1 is c\\nmin distance of node y from node2 is d\\n\\nSo, if max(a, b) < max(c, d) we need to return x.\\nelse if max(c, d) < max(a, b) we need to return y\\nelse if max(c, d) == max(a, b) then we need to return min(x, y)\\n\\nAlso, if no nodes are reachable from both node1 and node2 we need to return -1.\\n\\nHope this helps.\\nFeel free to comment if you need more clarity.\\nPlease upvote if it helps.\\nThanks :)"
                    },
                    {
                        "username": "user2242s",
                        "content": "Can someone explain why the answer for this TC is 3 and not 2?\\n\\n `[5,3,1,0,2,4,5]`\\n\\nMy present code: \\n\\n    public static int closestMeetingNode(int[] edges, int node1, int node2) {\\n        Set<Integer> set = new HashSet<>();\\n        getAllElementsPossible(set, edges, node1);\\n        return getAllElementsPossible(set, edges, node2);\\n    }    private static int getAllElementsPossible(Set<Integer> set, int[] edges, int node) {\\n        if (node == -1 || set.contains(node)) {\\n            return node;\\n        }\\n        set.add(node);\\n        return getAllElementsPossible(set, edges, edges[node]);\\n    }"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "There was a wrong `d1` array. Thank you for spotting it.\n[@xaosxaos](/xaosxaos)"
                    },
                    {
                        "username": "xaosxaos",
                        "content": "[@dmitryartux](/dmitryartux) \\u0432\\u044B \\u043D\\u0430 \\u0447\\u0442\\u043E \\u0442\\u043E \\u0434\\u0440\\u0443\\u0433\\u043E\\u0435 \\u043E\\u0442\\u0432\\u0435\\u0442\\u0438\\u043B\\u0438. \\u043D\\u043E\\u0434\\u0430 \\u0434\\u0432\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437 \\u043D\\u043E\\u0434\\u0443 \\u043E\\u0434\\u0438\\u043D \\u043F\\u043E\\u043F\\u0430\\u0434\\u0430\\u0435\\u0442 \\u0432 \\u043D\\u043E\\u0434\\u0443 3 \\u0442\\u043E \\u0435\\u0441\\u0442\\u044C \\u0434\\u0438\\u0441\\u0442\\u0430\\u043D\\u0446\\u0438\\u044F 2 \\u0438 \\u0435\\u0441\\u0442\\u044C \\u043F\\u0440\\u0430\\u0432\\u0438\\u043B\\u044C\\u043D\\u044B\\u0439 \\u043E\\u0442\\u0432\\u0435\\u0442, \\u0434\\u043B\\u044F \\u044D\\u0442\\u043E\\u0433\\u043E \\u0435\\u0441\\u0442\\u044C \\u0432\\u0442\\u043E\\u0440\\u043E\\u0439 \\u043F\\u0440\\u0438\\u043C\\u0435\\u0440 \\u0432 \\u043E\\u043F\\u0438\\u0441\\u0430\\u043D\\u0438\\u0438."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, -1]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `-1` is a value to show there is no path from node1 or node2 to ith node.\n[@Adithya Madas](/user2242s) [@mitulnagani8](/mitulnagani8)"
                    },
                    {
                        "username": "ved20",
                        "content": "You need to provide the values of node1 and node2"
                    },
                    {
                        "username": "mitulnagani8",
                        "content": "yes same question please explain"
                    },
                    {
                        "username": "user2242s",
                        "content": "Got it. Thank you. If anyone else was wondering... \\'maximum between the distance from node1 to that node, and from node2 to that node is minimized\\'"
                    },
                    {
                        "username": "zarif98sjs",
                        "content": "More like an **easy** problem if you know how to calculate the *shortest distance from a node*. As the weight of the edges is `1`, we don\\'t even need to do Dijkstra, a simple BFS suffices.\\n\\nThe idea is that - you run two BFS from the two nodes. Then calculate the answer by comparing it to $max(d1[i],d2[i])$. The node with the minimum of this value will be the answer."
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@nonchalant-enthusiast](/nonchalant-enthusiast) a good analogy is a \"it\\'s 2 linked lists problem rather than a graph\". the analogy is not mine, saw it somewhere here in the discussion"
                    },
                    {
                        "username": "nonchalant-enthusiast",
                        "content": "[@jobless_lm10](/jobless_lm10) you can check my solution: https://leetcode.com/problems/find-closest-node-to-given-two-nodes/solutions/3099358/python-fast-and-simple-iterative-solution-one-pass-o-n-100/\\nthe basic idea is to keep visited nodes of path1 (starting at node1) and path2 (starting at node2) separately. it allows you to check, if path1 and path2 crossed already. as soon as they cross, return the current node"
                    },
                    {
                        "username": "Electron1997",
                        "content": "If you have some experience with algorithm design and/or competitive programming chances are that most leetcode problems are quite easy for you. But this one is definitely harder than most medium problems here on leetcode. So no, it definitiely should not be easy to keep the categories at least somewhat consistent!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@aalmos](/aalmos) Can you explain your intuition and process of solving this without running BFS on the two given nodes."
                    },
                    {
                        "username": "aalmos",
                        "content": "Dude... This problem doesn\\'t even require BFS..."
                    },
                    {
                        "username": "rohit__27",
                        "content": "Agreed ..this is the simplest and most intuitive approach \\n"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@Md Zarif Ul Alam](/zarif98sjs) I think you forgot to mention that if there will be more than one node having minimum(max(d1[i], d2[i])) then we have to take the node with minimum value."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "I agree that the problem is easy if one knows how to perform a BFS on a graph.\nHowever, I think that requisite knowledge alone is enough to warrant a medium rating.\nA lot of people on LeetCode either don't have computer science degrees, aren't far enough in their CS programs to learn about BFS, or simply aren't that skilled in algorithms.\nSo I think this problem is worthy of the medium difficulty; besides, even if one knows how to do a BFS they still have to see the insight of how to use the shortest distance from each node to solve the problem.\n\nAlso I think you should submit a solution! You seem to understand the core insight behind this problem well and could help others understand it."
                    }
                ]
            },
            {
                "id": 1773322,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1774437,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1774612,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1774467,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1774076,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1773962,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1773747,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1773290,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1714102,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1672382,
                "content": [
                    {
                        "username": "XiaoChow",
                        "content": "This question is asking to find the index of the node (1) reachable from both node1 and node2, and (2) and the maximum of distances from which to both node1 and node2 is minimized (not the difference between the distance).\\n\\nIf there are multiple answers return the smallest index."
                    },
                    {
                        "username": "abrahem",
                        "content": "Hi all \\ncan anyone explain to me why this test case 4 not 1?\\nedges =[4,3,0,5,3,-1]\\nnode1 =4\\nnode2 =0\\nthis an image of the graph \\n[image](https://ibb.co/7z7fVpW)\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Murtada8](/Murtada8) 4 is the answer since node 4 is reachable from both 0 and 4 with the longest of the two distances being minimal (1)."
                    },
                    {
                        "username": "maltarouti",
                        "content": "[@polyp](/polyp) You\\'re absolutely right and that\\'s what abrahem was asking for, he was returning 1 but the test case fails and expect 4 instead of 1"
                    },
                    {
                        "username": "polyp",
                        "content": "[@Spukas](/Spukas) there is no summing in this problem"
                    },
                    {
                        "username": "polyp",
                        "content": "Distance from 4 to 4: 0\nDistance from 0 to 4: 1\nMax of 0 and 1 is 1. And no other node than 4 has lower distance than 1."
                    },
                    {
                        "username": "whuang8",
                        "content": "maximum of the minimum of the maximum\\'s maximum and minimum\\n![](https://media3.giphy.com/media/WRQBXSCnEFJIuxktnw/giphy.gif)"
                    },
                    {
                        "username": "zebra-f",
                        "content": "Tip: treat this problem as having two heads of a Linked-List instead of a Graph."
                    },
                    {
                        "username": "ignasialemany15",
                        "content": "edges = [2,0,0]\nexpected = 0\nnode1 = 2\nnode2 = 0\n\nthe solution could be either 0 or 2 no?"
                    },
                    {
                        "username": "polyp",
                        "content": "If more than one solution exists then the solution with the lowest index should be returned according to the problem description."
                    },
                    {
                        "username": "nanda_8",
                        "content": "99% Of the leetcoders didn\\'t get the question in just one read...\\nCorrect me if I am wrong :}"
                    },
                    {
                        "username": "aryan112345",
                        "content": "yes u r absolutely right lmao"
                    },
                    {
                        "username": "_drigger",
                        "content": "Basically what we need to do is minimize the max distance so this means, let\\'s say there is a node which is at dist. 10 from node1 and dist.2 from node 2 so reaching tho that node from node1,node2 will take 10 unit and if that node is dist. 9 from both node then it will take 9 unit of time, so obviously we need to return 9.\\neg. nodex dist. from node1=10 and node2=1\\n    nodey dist. from node1=9 and node2=9\\nthen ans is 9."
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "Thank you made little bit clear"
                    },
                    {
                        "username": "orbuluh",
                        "content": "Hint: When there is cycle, the problem want you to calculate the distance as the first time you travel to it. For example:  \n\n```txt\n1->2->3\n^_____/\n```\nthen 1 to 2 distance is 1,\n        1 to 3 distance is 2"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "[@JiayingGao](/JiayingGao) There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "JiayingGao",
                        "content": "yeah, but if there are two paths from a to b, which path is satisfied?"
                    },
                    {
                        "username": "strive_hard",
                        "content": "[@orbuluh](/orbuluh) Also we don\\'t need to apply Dijkstra algorithm to find the minimum distance from node1 or node2 to all other nodes as weights of all edges are 1. Hence, Simple BFS will serve our purpose."
                    },
                    {
                        "username": "Brent_Pappas",
                        "content": "Good point. I think one could solve this issue using Dijkstra\\'s algorithm,"
                    },
                    {
                        "username": "yogeshwarb",
                        "content": "Question is asking the node X which is reachable from both given nodes and is the\nMinimum of (all maximum of (dist between node1 and node X , dist between node2 and node X) )"
                    },
                    {
                        "username": "rick_014",
                        "content": "Yes"
                    },
                    {
                        "username": "ashishkumar26_-",
                        "content": "class Solution {\\npublic:\\n    void solve(int i,int dist,vector<int>&edges,vector<int>&path){\\n    if(path[i]==-1&&i!=-1){\\n        path[i]=dist;\\n        solve(edges[i],dist+1,edges,path);\\n    }                     \\n    }\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n=edges.size();\\n        int mini=INT_MAX;\\n        //mske two arrayand store distance of node 1  and node2\\n        vector<int>dist1(n,-1),dist2(n,-1);\\n        //vector<bool>vis(n,false);\\n        int ans=-1;\\n        //to filling array\\n        \\n        solve(node1,0,edges,dist1);\\n        solve(node2,0,edges,dist2);\\n        //now iterate\\n        for(int i=0;i<n;i++){\\n            if((min(dist1[i],dist2[i]))>=0&&max(dist1[i],dist2[i])<mini){\\n            \\n                    mini=max(dist1[i],dist2[i]);\\n                    ans=i;\\n                \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\nwhy runtime error??"
                    },
                    {
                        "username": "denmatfoton",
                        "content": "When node1 == node2 we should have same results. Basically I expect it to be 0 for any graph. Hower the test cases below expect different results.\\n[5,-1,3,4,5,6,-1,-1,4,3]\\n0\\n0\\nexpect 0\\n\\n[4,4,4,5,1,2,2]\\n1\\n1\\nexpect 1"
                    },
                    {
                        "username": "DrMario",
                        "content": "\"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "heg816",
                        "content": "Make sure your bounds conditions occur before your other conditions. In this case that means it should call 'if (i != -1 && path[i] == -1)' in that order. Otherwise it will try calling path[-1] before realizing it can't."
                    }
                ]
            },
            {
                "id": 1951020,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1847432,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1846789,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1845719,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1785127,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1781345,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1776350,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1776193,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1775704,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1775570,
                "content": [
                    {
                        "username": "CalCreate",
                        "content": "I think I misunderstood the question: I thought when the question stated maximum between n1 and n2, that we were trying to find the minimum of the sum of node from n1 and node from n2. \\n\\nI should have read the \"between\\' part. \\n\\nmaximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n"
                    },
                    {
                        "username": "user0463au",
                        "content": "This question is not asking about a node such that the sum of distances to node1 and node2 is the smallest.\nCould be explained by using pronouns to avoid ambiguity\n\"the **maximum** between the distance from `node1` to that node, and from `node2` to that node is **minimized**\" =>\nSuppose distance from `node1` to that common `node_i` = `distance1`, and distance from `node2` to that common `node_i` = `distance2`, let `max_i` be the maximum of `distance1` and `distance2`;\nFind a common `node_i` such that `max_i` be minimized among all the common nodes that can be reached both by `node1` and `node2`, and if there are multiple answers, return the smallest index of `node_i`."
                    },
                    {
                        "username": "IncestHunter",
                        "content": "should be return the value of the node... not the index. "
                    },
                    {
                        "username": "assq",
                        "content": "I don\\'t get it, this graph for each node it only has one outgoing edge, what\\'s the point of bfs, can\\'t I just iterate through the edge for node 1 and node 2, and find distance between each node_x to node 1/node 2?"
                    },
                    {
                        "username": "linhhlp",
                        "content": "I guess if using BFS, we iterate both from node1 & node 2 simultaneously, so we stop as soon as meeting a common node. If you iterate everything, say, 1000 nodes, but node1 & node2 are very close => waste time to loop all the nodes."
                    },
                    {
                        "username": "pzzo",
                        "content": "> Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\nHonestly, the hardest part of the problem is understanding what this sentence means. Let me try to frame it differently:\\n\\n1. We\\'re returning the index of a node that can be reached from both node1 and node2.\\n2. Calculate the maximum distance from node1 to that node, and from node2 to that node\\n\\nThe node index to return (1) has the minimum distance of these calculated maximum distances (2).\\n\\nHope this helps someone!"
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this one is easy to understand:\\nAlice is at node1 and Bob is at node2. They want to meet and they want to choose a node to meet at such that the walking distance for the one of them who has to walk the longest is minimized. Which node should they choose?"
                    },
                    {
                        "username": "urmichm",
                        "content": "worst description i have ever seen"
                    },
                    {
                        "username": "SrB30",
                        "content": "It once again reminded me that problem statement should be read very carefully. Liked the problem."
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I get MLE for the below code in the test case !! How can I optimize the code? Please reply .\n\nclass Solution {\npublic:\n\n    void dfs(vector<int>&edges,vector<int>&dist,vector<int>visited,int node,int d){\n        visited[node]=1;\n        dist[node]=d;\n        if(edges[node]!=-1 && !visited[edges[node]]) dfs(edges,dist,visited,edges[node],d+1);\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n=edges.size();\n        vector<int>dist1(n,-1);\n        vector<int>dist2(n,-1);\n        vector<int>visited(n,0);\n\n        dfs(edges,dist1,visited,node1,0);\n        dfs(edges,dist2,visited,node2,0);\n\n        int res=-1,maxDist=INT_MAX;\n        for(int i=0;i<n;i++){\n            if(dist1[i]!=-1 && dist2[i]!=-1){\n                if(max(dist1[i],dist2[i])<maxDist){\n                    res=i;\n                    maxDist=max(dist1[i],dist2[i]);\n                }\n            }\n        }\n\n        return (res==INT_MAX)?-1:res;\n    }\n};\n\n`\n[15118,54473,25936,30867,68507,51205,50784,37400,13723,63400,42866,53345,15120,-1,11919,-1,2853,12724,52691,-1,71082,-1,58500,-1,24235,24844,40043,-1,48239,25453,31433,48294,14438,31630,29513,17673,13013,53082,42775,1997,17203,-1,45187,51897,28542,-1,21782,30642,63329,33225,51054,55716,9832,...]\nNode 1: 358\nNode 2: 5598\n`\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "Can someone explain why the answer for this input is 1 and not 4?\n\nInput: \n[4,4,8,-1,9,8,4,4,1,1]\n5\n6\n\nWouldn't it be 4 since it takes node1 a distance of 3 and node2 a distance of 1\nWhile to get to 1 it takes node1 a distance of 2 and node2 a distance of 3\n\nand 3 + 1 < 3 + 2 hence it would 4 and not 1"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "[@polyp](/polyp) oh ok. So since they both have a max of 3, we must pick 1, since it\\'s the lower of the indexes"
                    },
                    {
                        "username": "polyp",
                        "content": "It\\'s only the node with the longest distance that counts (minimize the maximum thing). So both nodes are solutions and then we should choose the one with the lowest index according to the description."
                    },
                    {
                        "username": "paliya64",
                        "content": "[leetcode](https://leetcode.com) https://leetcode.com/problems/find-closest-node-to-given-two-nodes/submissions/885265264/ umm.. if anyone can help me out why does this solution lead to TLE and how to possibly optimize it."
                    }
                ]
            },
            {
                "id": 1774961,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774939,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774934,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774723,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774628,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774602,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774511,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774473,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774415,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774382,
                "content": [
                    {
                        "username": "RASWQQW",
                        "content": "[5,-1,3,4,5,6,-1,-1,4,3] \\nnode1 = 0\\nnode2 = 0\\n\\nwhy result is 0?\\n\\nand [2,2,3,-1]\\n\\nnode1 = 0\\nnode2 = 1\\n\\nand expected answer 2\\nwhy not 0?\\n\\nis there some explanation?\\n"
                    },
                    {
                        "username": "pains_baka_san",
                        "content": "For the first one, it is 0 because they are both already at zero, hence there is no need for them to find another node\\nFor the second one,  it is not 0 because node2 can never get to 0, however they both can get to 2 and both of them need a distance of 1 to get there, hence 2 is the answer"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "piyushagrawal886",
                        "content": "the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\n\\ncan anyone plz explain the above statement in simplest form \\n"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "for all i, find the min(max(dist_1[i], dist_2[i]))"
                    },
                    {
                        "username": "BrandoZ",
                        "content": "My reading skills prevent me from acing this problem  \\uD83D\\uDE43"
                    },
                    {
                        "username": "mg8228004",
                        "content": "I don\\'t understand Please anyone explain me \\nmy code not a work, give a error"
                    },
                    {
                        "username": "SirKris",
                        "content": "Ok I seriously don\\'t understand what the hell this question even wants.\\n\\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\"\\n\\nWTF is that even supposed to mean?!  The maximum between node1 to some node and node2 to some node must be minimized?  This is even more confusing than the old \"Count & Say\" description.  I really wish somebody would proofread these...."
                    },
                    {
                        "username": "polyp",
                        "content": "Maybe this is more clear: If person1 is at node1 and person2 is at node2 then we should find some node where the two persons can meet. And the node should be chosen so that the walking distance for the person who has to walk the longest is minimized."
                    },
                    {
                        "username": "abhijeetkumar2001heroacademy",
                        "content": "Easy C++ code with video explanation and line by line BFS and DFS code, O(N) complexity https://youtu.be/PJFH252PyqE"
                    },
                    {
                        "username": "summer_23",
                        "content": "why [4,4,8,-1,9,8,4,4,1,1], node1 = 5, node2=6, should return 1 but not 4? "
                    },
                    {
                        "username": "jagnathreddy",
                        "content": "because they give same distance ,in such cases we are supposed to return lowest index"
                    },
                    {
                        "username": "Yatin30",
                        "content": "Ahh... description of the question is hard to grasp in one reading\n"
                    },
                    {
                        "username": "zaureqs",
                        "content": "##### 1.  Find distance of all node from node1 and store in a vector\\n##### 2.  Find distance of all node from node2 and store in a vector\\n##### 3.  Find the minimum max distance from both nodes by traversing both vectors simultaneously.\\n\\n                remember to store -1 initially while defining the distance vector"
                    },
                    {
                        "username": "polyp",
                        "content": "You can actually do both searches in the same loop, and when one search finds a node already visited by the other search, then you have a solution."
                    }
                ]
            },
            {
                "id": 1774355,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774310,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774290,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774287,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774283,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774265,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774249,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774248,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774244,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774224,
                "content": [
                    {
                        "username": "prachiti1998",
                        "content": "Can someone explain why doesnt this work but it does when I use the same queue q for the second BFS?\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\\n        int n = edges.size();\\n        \\n\\n        queue<int> q;\\n        q.push(node1);\\n        \\n        vector<int> distance1(n,-1);\\n        distance1[node1] = 0;\\n        \\n        while(!q.empty()){\\n            int curr = q.front();\\n            q.pop();\\n            int neighbor = edges[curr];\\n            if(neighbor != -1 && distance1[neighbor]==-1){\\n                q.push(neighbor);\\n                distance1[neighbor] = distance1[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        \\n        \\n        queue<int> q2; //reusing above queue here makes it work\\n        q2.push(node2);\\n        vector<int> distance2(n,-1);\\n        distance2[node2] = 0;\\n        \\n        while(!q2.empty()){\\n            int curr = q2.front();\\n            \\n            q2.pop();\\n            int neighbor = edges[curr];\\n            \\n            if(neighbor != -1 && distance2[neighbor] == -1){\\n                q.push(neighbor);\\n                distance2[neighbor] = distance2[curr]+1;\\n                \\n            }\\n            \\n        }\\n\\n        int smallestIndex = INT_MAX;\\n        int node = -1;\\n        for(int i=0; i<n;i++){\\n            if(distance1[i] != -1 && distance2[i] != -1){\\n                int currMax = max(distance1[i],distance2[i]);\\n                if(smallestIndex >currMax){\\n                    smallestIndex=currMax;\\n                    node = i;\\n                }\\n                cout<<distance1[i]<<\" \"<<distance2[i]<<endl;\\n                \\n            }\\n            \\n        }\\n\\n        return node;\\n\\n    }\\n};\\n\\'\\'\\'"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) Oh shoot!! Thanks a lot"
                    },
                    {
                        "username": "polyp",
                        "content": "[@prachiti1998](/prachiti1998) You have q.push call in second bfs instead of q2.push"
                    },
                    {
                        "username": "prachiti1998",
                        "content": "[@polyp](/polyp) yeah you are right, could have used a variable but I followed BFS hence. either way this shouldnt be wrong"
                    },
                    {
                        "username": "polyp",
                        "content": "There is no need for any queues at all. Every node can have at most one outgoing edge, so why use a queue?"
                    },
                    {
                        "username": "officialvikasmaurya",
                        "content": "facing issue please help??\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        queue1 = [node1]\\n        queue2 = [node2]\\n        visited1 = set()\\n        visited2 = set()\\n        distance1 = {node1: 0}\\n        distance2 = {node2: 0}\\n    \\n        while queue1 or queue2:\\n            if queue1:\\n                current1 = queue1.pop(0)\\n                visited1.add(current1)\\n                if current1 in visited2:\\n                    return current1\\n                next_node1 = edges[current1]\\n                if next_node1 != -1 and next_node1 not in visited1:\\n                    queue1.append(next_node1)\\n                    visited1.add(next_node1)\\n                    distance1[next_node1] = distance1[current1] + 1\\n            if queue2:\\n                current2 = queue2.pop(0)\\n                visited2.add(current2)\\n                if current2 in visited1:\\n                    return current2\\n                next_node2 = edges[current2]\\n                if next_node2 != -1 and next_node2 not in visited2:\\n                    queue2.append(next_node2)\\n                    visited2.add(next_node2)\\n                    distance2[next_node2] = distance2[current2] + 1\\n        return -1"
                    },
                    {
                        "username": "Ingodavila",
                        "content": "After 30 minutes trying to solve this I accomplished nothing but depression "
                    },
                    {
                        "username": "himanshurajput",
                        "content": "Initialize variables n to the size of the edges array, ans to -1, and minDist to the maximum value of an int.\\nCreate two arrays dist1 and dist2 of size n and initialize all elements to 0. Also, create two arrays visited1 and visited2 of size n and initialize all elements to false.\\nRun the depth-first search (DFS) algorithm from node1 and update the dist1 and visited1 arrays accordingly.\\nRun the DFS algorithm from node2 and update the dist2 and visited2 arrays accordingly.\\nIterate through all nodes currNode in the graph.\\nFor each node, check if it has been visited by both DFS calls, and if its maximum distance from node1 and node2 (i.e. max(dist1[currNode], dist2[currNode])) is less than the current value of minDist.\\nIf the above conditions are met, update the value of minDist and ans to the current node\\'s distance and index, respectively.\\nReturn ans as the result.\\nThis algorithm finds the closest meeting point between two given nodes in a graph by using DFS to calculate the distance from each node to all other nodes in the graph. It only considers nodes that are reachable from both given nodes, and chooses the one that has the smallest maximum distance from the two given nodes."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "couldn\\'t solve daily challenge for last 2 days :|"
                    },
                    {
                        "username": "osamatamer390",
                        "content": "Easiest way to get headache  "
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "The solution to the problem is quiet easy though, we have to clearly understand the wording of the description."
                    },
                    {
                        "username": "nitinyadav231",
                        "content": "Can someone give me an example where there are multiple answers and we have to return the minimum index."
                    },
                    {
                        "username": "Arnius",
                        "content": "I\\'m DONE trying -_-"
                    },
                    {
                        "username": "andrew99154",
                        "content": "Worst problem description ever"
                    }
                ]
            },
            {
                "id": 1774193,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1774190,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1774169,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1774124,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1774063,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1774049,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1774040,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1773976,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1773971,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1773966,
                "content": [
                    {
                        "username": "JakhongirMurodov",
                        "content": "\\u26A0\\uFE0F.   TRY THESE TEST CASES:\\n\\'\\'\\'     [4,4,8,-1,9,8,4,4,1,1] 5 6\\n        [5,3,1,0,2,4,5] 1 6\\n        [4,3,0,5,3,-1] 4 0\\n        [2,0,0] 2 0\\n        [1,2,0,2] 0, 3\\n        [1,2,0,2,3,4,5] 0, 6\\n\\'\\'\\'"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "[@ohYouCan](/ohYouCan) mine too"
                    },
                    {
                        "username": "ohYouCan",
                        "content": "how did you generated these testcases ??\\nBTW My solution passed all of them."
                    },
                    {
                        "username": "Shelcy_Shaji_Thekkedathu",
                        "content": "Brainteaser"
                    },
                    {
                        "username": "saumyasuhagiya",
                        "content": "One of the confusing description ever."
                    },
                    {
                        "username": "parasgarg31",
                        "content": "Good problem of graph. It would be better if the problem description is also good and easily understandable...."
                    },
                    {
                        "username": "Pravartya",
                        "content": "Can we solve this problem with the concept of LCA ?\\nDoes the concept of LCA makes sense for graphs?\\n"
                    },
                    {
                        "username": "polyp",
                        "content": "Seems my solution is faster than 100%. I do two parallel BFS searches in the same loop and as soon as one BFS finds a node that has already been visited by the other BFS I can return the result. If two solutions are found in the same iteration then we return the node with the lowest index."
                    },
                    {
                        "username": "fabiecatinella",
                        "content": "Ayo, read the specification on the min of two max distances again - will be `min(prevMin, Max(dist1, dist2))`\\nAnd remember - there is only ONE outgoing edge at each node e.g If we visit a node we have already seen, we cannot explore any new nodes. "
                    },
                    {
                        "username": "Amasterworld",
                        "content": "Anyone like me when read it two or three times: \"Return the index of the node that can be reached from both node1 and node2, such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized. \"\\n\\nFrom above sentence: I think that I MUST find the maximum distance from node 1 to that node, for example, from node1 to node x, we have many paths with different distance such as: 5 , 6, 7.  So we should get 7 because it is maximum distance. Similarly,  the distances from node2 to node x are : 4, 5, 6, then we should get 4. because it is minimum. Am I understanding the problem right? My E is problem or theirs?  "
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Do a DFS/BFS traversal to store distance to all the nodes from node1 and node2.\\nFind node where the maximum distance from node1 and node is minimum."
                    },
                    {
                        "username": "xeniawann",
                        "content": "It\\u2019s actually more related to BFS rather than DFS."
                    }
                ]
            },
            {
                "id": 1773936,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773915,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773870,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773847,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773846,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773842,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773825,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773810,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773799,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773761,
                "content": [
                    {
                        "username": "Real-Supreme",
                        "content": "such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized.\\nWhat node is that node????"
                    },
                    {
                        "username": "zhaonzh",
                        "content": "Weird question with unnecessarily strange optimization goal."
                    },
                    {
                        "username": "jga111",
                        "content": "\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nIsn\\'t this essentially asking for just the minimum distance? Why does the problem statement here have to be over-convoluted? Terrible"
                    },
                    {
                        "username": "polyp",
                        "content": "Why do people find this so hard to understand. Let's say Alice is at node1 and Bob is at node2. They want to choose a node to meet at. The node should be chosen so that the walking distance for the person who has to walk the longest is minimized. Is that easier to understand?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "what is the definition for the distance from a to b?\\nFor example, if there are two different paths from a to b, which path is satisfied??"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "[@jobless_lm10](/jobless_lm10) thanks a lot, get it!"
                    },
                    {
                        "username": "jobless_lm10",
                        "content": "There can never be two paths between a and b as problem states clearly \"where each node has at most one outgoing edge\""
                    },
                    {
                        "username": "AhmadSaleh2001",
                        "content": "This Is Maybe Week Of <b>BFS</b> :)"
                    },
                    {
                        "username": "durjoyovi76",
                        "content": "It took couple of hours to solve this problem.\\nI think this problem deserve this.\\nSuch an interesting problem.\\nLearned something."
                    },
                    {
                        "username": "user7386M",
                        "content": "It\\'s not a typical map problem"
                    },
                    {
                        "username": "niththish21",
                        "content": "The hints made the question very simple and easy :)"
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Thank you for such an interesting problem! Can be solved in different ways, more or less efficient.\\n\\nJust a small note. It looks like there is a bug in the official implementaion. It gives two different answers to the following inputs:\\n```\\n([1,2,0,2], 0, 3) -> 0\\n([1,2,0,2,3,4,5], 0, 6) -> 2\\n```\\n\\nBut the correct answer must be the same for both inputs, and the answer is `0`:\\n* In both cases the following nodes are reachable: `0`, `1` and `2`\\n* But the distances to nodes `1` and `2` are greater than the distance to node `0` for both `node1` and `node2."
                    },
                    {
                        "username": "dmkurilov",
                        "content": "Now i\\'v got why both answers are correct.\\n\\nThe right answer is `min(max(dist1, dist2))`, where `dist1 = distance(node1, answer)` and `dist2 = distance(node2, answer)`.\\n\\nSo, if we replace distance with time, we can ask to find a node where a couple of friends will meet each other as soon as possible if they start from node1 and node2."
                    },
                    {
                        "username": "shriyansnaik",
                        "content": "`[5,3,1,0,2,4,5]`\\n`1`\\n`6`\\n\\nCan someone tell why the answer is **5** and not **1**. Both are at a distance of 4 but 1 has a lower index so it should be our answer right? Tell me if I am missing something!!"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\nIn that cases distances are:\n```\nd1: [2, 0, 5, 1, 4, 3, 9223372036854775807]\nd2: [6, 4, 3, 5, 2, 1, 0]\n```\nSo `min(max(d1[i], d2[i])) = 1`, it's the 5th node. `9223372036854775807` is a value to show there is no path from node1 or node2 to ith node."
                    }
                ]
            },
            {
                "id": 1773732,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773731,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773703,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773683,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773679,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773675,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773645,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773643,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773635,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773632,
                "content": [
                    {
                        "username": "ROHIT25082000",
                        "content": "For the folks who are thinking why some people are using DFS instead of BFS.\n\nIdeally only BFS should be used to solve this problem as we want shortest distance from a source node \nbut the solutions where folks are using DFS to solve is \ngiving correct answer only because the is only one outgoing edge from a Node. \n\nDFS would fail if \n                        1\n                        / \\ \n                      /    3\n                    2- / \nfor distance of Node \"2\" will be 1 but DFS will say 2 (1->3- > 2) \n\nBFS would still work in this case."
                    },
                    {
                        "username": "indrazit",
                        "content": "We can make this problem more challenging, by requiring a solution of O(n) time and O(1) additional space, without changing the values of the input edges.  I wonder why it is not mentioned in the problem description or in the solution."
                    },
                    {
                        "username": "indrazit",
                        "content": "[@kbbhatt61](/kbbhatt61) Definitely possible to use only O(1) space.  Suppose there is no cycle in the graph, then we can find the distance from each of the two nodes to its dead-end, so we know which nodes to compare.  For example, the distance from node1 to the dead-end of its path is 3 and that distance of node 2 is 5, we need to compare (node1 and 2nd in node2-path), (1st in node1-path and 3rd in node2-path), (2nd in node1 and 4th in node2-path).  We have only to extend this algorithm to the cases when there are cycles in the graph."
                    },
                    {
                        "username": "kbbhatt61",
                        "content": "Is it possible to use O(1) space only? "
                    },
                    {
                        "username": "jayantkhd",
                        "content": "wrong in testcase\\n[4,3,0,5,3,-1]\\n4\\n0"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, -1, -1, 1, 0, 2]\\nd2: [0, -1, -1, 2, 1, 3]\\n```\\nSo `min(max(d1[i], d2[i])) = 1`, it\\'s the 4th node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/2359_Find_Closest_Node_to_Given_Two_Nodes.cpp"
                    },
                    {
                        "username": "shu8hamRajput",
                        "content": "When I use python list it works fine and passes all tests. But when i use queue.Queue, It gives TLE error?\\n```\\n# using python list as queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = []\\n            q.append(s)\\n            d[s] = 0\\n            while q:\\n                elem = q[0]\\n                del q[0]\\n                if vis[elem]:\\n                    continue\\n                vis[elem] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.append(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d\\n                \\n```\\n\\n```\\n# using queue. Queue\\nfrom queue import Queue\\n\\nclass Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        n = len(edges)\\n        d1 = [float(\\'inf\\')]*n\\n        d2 = d1[:]\\n\\n        def bfs(s, edges, d):\\n            vis = [False] * n\\n            q = Queue(n)\\n            q.put_nowait(s)\\n            d[s] = 0\\n            while not q.empty():\\n                elem = q.get_nowait()\\n                if vis[elem]:\\n                    continue\\n                vis[s] = True\\n                nei = edges[elem]\\n                if nei != -1 and not vis[nei]:\\n                    d[nei] = 1+ d[elem]\\n                    q.put_nowait(nei)\\n            return d\\n        \\n        bfs(node1, edges, d1)\\n        bfs(node2, edges, d2)\\n\\n        min_d = -1\\n        min_t_now = float(\\'inf\\')\\n        for i in range(n):\\n            if min_t_now > max(d1[i], d2[i]):\\n                min_d = i\\n                min_t_now = max(d1[i], d2[i])\\n        return min_d                \\n```"
                    },
                    {
                        "username": "santanusen",
                        "content": "DFS from node1/node2 till you reach -1 or an already visited node."
                    },
                    {
                        "username": "Panda_2397",
                        "content": "You need to find the minimum distance of the node from node1 and node2, but the minimum value is max(distance from node1, distance from node2)  "
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "For the test case \\n[4,4,8,-1,9,8,4,4,1,1]\\n5\\n6\\nThe expected answer is 1 instead of 4 because the question states that we have to minimize the maximum among the distance of a particular node from node 1 and node 2 i.e we have to minimize `max(d(node1, node), d(node2, node))`. Here when we consider node 4, the maximum is 3 which is the same for 1 . So we choose the node with lower value, hence 1."
                    },
                    {
                        "username": "dmitryartux",
                        "content": "You need to find a `min` of `max(d1[i], d2[i])` where d1 and d2 are the distances to ith node from node1 and node2.\\nIn that cases distances are:\\n```\\nd1: [-1, 2, -1, -1, 0, -1, -1, -1, -1, 1]\\nd2: [-1, 2, -1, -1, 3, 0, -1, -1, 1, 4]\\n```\\nSo `min(max(d1[i], d2[i])) = 2`, it\\'s the 1st node. `-1` is a value to show there is no path from node1 or node2 to ith node."
                    },
                    {
                        "username": "darasingh12998",
                        "content": "     \\n      class Solution:\\n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\\n        def solution_dict(node):\\n            res = {}\\n            flag = 0\\n            while node!=-1:\\n                if node in res:\\n                    break\\n                res[node]=flag\\n                node = edges[node]\\n                flag +=1\\n            return res\\n            \\n        if node1==node2:\\n            return node1\\n        dict1, dict2 = solution_dict(node1), solution_dict(node2)\\n        cands = set(dict1) & set(dict2)\\n        return min(cands, key=lambda c:(max(dict1[c], dict2[c]), c), default =-1)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "The wording \"minimum of maximum\" is confusing, They could have at least given better examples, not lazy examples containing just 3 nodes \\uD83D\\uDE12\\uD83D\\uDE12"
                    }
                ]
            },
            {
                "id": 1773624,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773583,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773565,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773560,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773505,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773446,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773413,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773398,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773384,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            },
            {
                "id": 1773363,
                "content": [
                    {
                        "username": "vinaygottipamula",
                        "content": "Brooo unable to solve these graph problems :-(, someone help me with the playlist. \n\nThanks in advance"
                    },
                    {
                        "username": "Leetcoder_R",
                        "content": "Bro go for the strivers sheet... that is epic and is from scratch.\\n"
                    },
                    {
                        "username": "mar123kr",
                        "content": "Test case \nedges = [4,4,8,-1,9,8,4,4,1,1]\nnode1 = 5, node2 = 6\n\nExplanation\nnode1's dfs = [5,8,1,4,9]\nnode2's dfs = [6,4,9,1]  \n\ncommonNode = [1,4,9]        \nIndex.....Distance from node1.....Distance from node2.....maxDistance    \n....1.............................2...........................................3........................................3       \n....4.............................3...........................................2........................................3\n....9.............................4...........................................2........................................4\n\nAccording to the table\nmin of maxDistance is 3 of Index1 and Index4\nif there are multiple answers, the smallest Index is the answer. ==> Index 1 \n"
                    },
                    {
                        "username": "VikasSoni10",
                        "content": "The relationship between Tree and Leetcode is pure hearted . Love It \\uD83D\\uDE0D "
                    },
                    {
                        "username": "halfengineer",
                        "content": "[5,3,1,0,2,4,5]\\n3\\n2\\nthis test case got me "
                    },
                    {
                        "username": "arghyadas",
                        "content": "Graph. Here we go again."
                    },
                    {
                        "username": "jahid_shakil",
                        "content": "The last line should be rephrased -\\n\\nReturn the `index` of the `node` that can be reached from both `node1` and `node2`, such that the maximum of distances, from `node1` to that `node` and from `node2` to that `node`, is minimized. "
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "can anyone give a case when there are multiple answer possible ?\\namong which we have to choose smallest index\\n\\nCase1 :as per my understanding edges=[3,3,-1,2]  node1=0, node2=1 then its distance from 3 is 1 for  both node and for 2 it is 2 from both node then we should print  answer as 2 because 2 is lower in index but it shows 3 as ans\\n\\nCase2: as per 2nd for edges=[2,-1,1], node1=0 , node2=2 it can see both node can go to node value 1 but they stop at 2 and return it as ans"
                    },
                    {
                        "username": "Pulkitgoy",
                        "content": "[@KhacLong](/KhacLong) but how can we have multiple path when any node can have only 1 outer edge?\\n"
                    },
                    {
                        "username": "KhacLong",
                        "content": "case1: multiple ans when u have some nodes which have the same dist, but in this case, dist from 2 is 2 and dist from 3 is 1 then 3 is ans\\ncase2: dist from 2 is max( 1(0 -> 2), 0(2 -> 2) ), and dist from 1 is max( 2(0 -> 1), 1(2 -> 1)) then dist from 2 is lower and the ans is 2"
                    },
                    {
                        "username": "lchelloroad",
                        "content": "The description is really confusing me a lot until I read some comments about \\n\"such that the maximum between the distance from node1 to that node, and from node2 to that node is minimized\"\\n\\nThanks for all the explanations for the above sentences .\\n\\nMy understanding is that for any reachable node by n1 and n2, assuming the distance is d1 and d2,\\nget the larger one from d1 and d2, we want to compare all the larger ones from every reachable node and pick the minimal one (if there are nodes with the same minimal larger dist, choose the smallest idx)\\n\\nOnce you understand the question, it is very straight forward BFS"
                    },
                    {
                        "username": "fymmmmm",
                        "content": "????????"
                    },
                    {
                        "username": "adityasinghz",
                        "content": "Hello Graph!"
                    }
                ]
            }
        ]
    }
]