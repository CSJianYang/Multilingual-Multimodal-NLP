[
    {
        "title": "Root Equals Sum of Children",
        "question_content": "You are given the root of a binary tree that consists of exactly 3 nodes: the root, its left child, and its right child.\nReturn true if the value of the root is equal to the sum of the values of its two children, or false otherwise.\n&nbsp;\nExample 1:\n\nInput: root = [10,4,6]\nOutput: true\nExplanation: The values of the root, its left child, and its right child are 10, 4, and 6, respectively.\n10 is equal to 4 + 6, so we return true.\n\nExample 2:\n\nInput: root = [5,3,1]\nOutput: false\nExplanation: The values of the root, its left child, and its right child are 5, 3, and 1, respectively.\n5 is not equal to 3 + 1, so we return false.\n\n&nbsp;\nConstraints:\n\n\tThe tree consists only of the root, its left child, and its right child.\n\t-100 <= Node.val <= 100",
        "solutions": [
            {
                "id": 2775146,
                "title": "java-easy-1-liner-o-1-solution",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n       return root.val == root.right.val + root.left.val; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1977620,
                "title": "java-c-python-1line-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "**As a professional with a passion for problem-solving and collaboration, I am always looking to expand my network of like-minded individuals on LinkedIn. By connecting with me, we can work together to tackle complex challenges, share ideas, and grow both professionally and personally.**\\n\\n**Whether you\\'re an expert in your field or just starting out, I welcome connections from all backgrounds and experiences. By building a diverse and collaborative network, we can leverage our unique perspectives and skill sets to push the boundaries of what\\'s possible.**\\n\\n**So, if you\\'re interested in connecting and exploring the potential for future collaborations, please don\\'t hesitate to reach out. Let\\'s start a conversation and see where it takes us!**\\n\\n---\\n\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\nhttps://www.linkedin.com/in/cucerdariancatalin/\\n\\n---\\n***Java***\\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\\n\\n***C++***\\n```\\nclass Solution\\n{\\npublic:\\n    bool checkTree(TreeNode* root)\\n\\t{\\n       if((root->left->val)+(root->right->val)==root->val) return true;\\n        return false;\\n    }\\n};\\n```\\n\\n***Python***\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n***Consider upvote if useful!***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\n```\\nclass Solution\\n{\\npublic:\\n    bool checkTree(TreeNode* root)\\n\\t{\\n       if((root->left->val)+(root->right->val)==root->val) return true;\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934995,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)",
                "codeTag": "Java"
            },
            {
                "id": 2180137,
                "title": "python-easy-solution-with-explanation",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        # As per the def of binary tree node, we can compare the root value \\\\\\n        # with the TreeNode function, the root.left.val retrieves value of left node \\\\\\n        # the root.right.val retrieves value of right node. \\'==\\' compares two values\\n        if root.val == root.left.val + root.right.val:  \\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        # As per the def of binary tree node, we can compare the root value \\\\\\n        # with the TreeNode function, the root.left.val retrieves value of left node \\\\\\n        # the root.right.val retrieves value of right node. \\'==\\' compares two values\\n        if root.val == root.left.val + root.right.val:  \\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053858,
                "title": "javascript-solution-o-1-one-liner-81ms-basic-comparison-maths-examples",
                "content": "***Happy Coding..!* Feel free to ask Q\\'s...**\\n\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\n\\nconst checkTree = root => root.val === (root.left.val + root.right.val);\\n\\n```\\n\\n// Tree Node\\nfunction TreeNode(val, left, right) {\\n    this.val = (val === undefined ? 0 : val)\\n    this.left = (left === undefined ? null : left)\\n    this.right = (right === undefined ? null : right)\\n}\\n\\n// Test Case 1\\n// root = [10, 4, 6]\\nlet tNode1 = new TreeNode(10);\\nlet tNode2 = new TreeNode(4);\\nlet tNode3 = new TreeNode(6);\\n\\ntNode1.left = tNode2;\\ntNode1.right = tNode3;\\n\\nlet root = tNode1;\\nconsole.log(checkTree(root)); // true\\n\\n\\n***#happytohelpu***\\n\\n# ***Do upvote if you find this solution useful..***\\n",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\n\\nconst checkTree = root => root.val === (root.left.val + root.right.val);\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3130162,
                "title": "easy-to-understand-for-beginners-python-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nDirect Tree approach ATTACKKKKKKKKK\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2058305,
                "title": "c-easy-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961431,
                "title": "hardest-binary-tree-problem-hard",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val+root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val+root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937186,
                "title": "javascript-one-liner",
                "content": "Let me know if you have any doubts. I try to answer/help.\\n\\nPlease upvote if you liked the solution.\\n\\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1939586,
                "title": "cpp-one-liner-beats-100",
                "content": "Since we are guaranteed by the contstraints that ```root``` has a right and a left child all that we need to do is just check if the sum of the children values is equal to the value of the root.\\n```cpp\\nbool checkTree(TreeNode* root) {\\n   return root->val == root->left->val + root->right->val;    \\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```root```\n```cpp\\nbool checkTree(TreeNode* root) {\\n   return root->val == root->left->val + root->right->val;    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3519510,
                "title": "my-checktree",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3524372,
                "title": "python-one-line-solution-easy",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```\\n**An upvote will be encouraging**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795902,
                "title": "python-one-liner-easy-to-understand",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546066,
                "title": "javascript-easy-to-understand-one-line-solution",
                "content": "```/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3731720,
                "title": "i-ask-why-u-are-seeing-this",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nLOL U Still opened this ......\\n# Code\\n```\\nNOTHING HERE BRO - SORRY !\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Tree"
                ],
                "code": "```\\nNOTHING HERE BRO - SORRY !\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3011338,
                "title": "using-single-line-expression-body",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val + root.right.val;\\n    \\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val + root.right.val;\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695970,
                "title": "python-simple-solution-in-4-lines",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2602756,
                "title": "c-generic-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n      queue<TreeNode*>q;\\n      q.push(root);\\n      while(!q.empty()){\\n          int size = q.size();\\n          for(int i=0;i<size;i++){\\n          TreeNode* curr = q.front();\\n          q.pop();\\n          int parentValue = curr->val;\\n          int childValue = 0;\\n          int child = 0;\\n          if(curr->left){\\n              q.push(curr->left);\\n              childValue+=curr->left->val;\\n          }else{\\n              child++;\\n          }\\n          if(curr->right){\\n          q.push(curr->right);\\n          childValue+=curr->right->val;\\n          }else{\\n              child++;\\n          }\\n          if(child==2) continue;\\n          if(parentValue != childValue) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n      queue<TreeNode*>q;\\n      q.push(root);\\n      while(!q.empty()){\\n          int size = q.size();\\n          for(int i=0;i<size;i++){\\n          TreeNode* curr = q.front();\\n          q.pop();\\n          int parentValue = curr->val;\\n          int childValue = 0;\\n          int child = 0;\\n          if(curr->left){\\n              q.push(curr->left);\\n              childValue+=curr->left->val;\\n          }else{\\n              child++;\\n          }\\n          if(curr->right){\\n          q.push(curr->right);\\n          childValue+=curr->right->val;\\n          }else{\\n              child++;\\n          }\\n          if(child==2) continue;\\n          if(parentValue != childValue) return false;\\n          }\\n      }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178260,
                "title": "python-oneliner",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.left.val+root.right.val == root.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.left.val+root.right.val == root.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935634,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root_node = root.as_ref().unwrap().borrow();\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root_node = root.as_ref().unwrap().borrow();\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2973035,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    if(root->val == ((root->left->val) + (root->right->val))){\\n        return true;\\n    }else {\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    if(root->val == ((root->left->val) + (root->right->val))){\\n        return true;\\n    }else {\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2945899,
                "title": "c-one-line-code-super-easy",
                "content": "![image](https://assets.leetcode.com/users/images/be24e3a1-f1ff-4926-b2f1-9e892f9e7992_1671888672.6683366.png)\\n\\n**TC->O(1) && SC->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tbool checkTree(TreeNode* root) {\\n\\t\\t\\treturn root->val==root->left->val+root->right->val;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tbool checkTree(TreeNode* root) {\\n\\t\\t\\treturn root->val==root->left->val+root->right->val;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2683146,
                "title": "python-one-liner-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\t\\treturn root.val == (root.left.val + root.right.val)",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\t\\t\\treturn root.val == (root.left.val + root.right.val)",
                "codeTag": "Java"
            },
            {
                "id": 2603021,
                "title": "rust-0-ms-simple-solution-with-detailed-comments",
                "content": "This [**solution**](https://leetcode.com/submissions/detail/804824674/) employs simple operations with smart pointers. It demonstrated **0 ms runtime (100.00%)** and used **2.1 MB memory (67.14%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution \\n{\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool \\n    {\\n        // unfortunately, in Rust the use of smart pointers\\n        // is challenging due to security issues;\\n        // also, an Option requires unwrapping...\\n        \\n        // [1] unpack smart pointer and borrow TreeNode\\n        let root_node = root.as_ref().unwrap().borrow();\\n\\n        // [2] unpack left & right smart pointers and borrow their TreeNodes\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution \\n{\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool \\n    {\\n        // unfortunately, in Rust the use of smart pointers\\n        // is challenging due to security issues;\\n        // also, an Option requires unwrapping...\\n        \\n        // [1] unpack smart pointer and borrow TreeNode\\n        let root_node = root.as_ref().unwrap().borrow();\\n\\n        // [2] unpack left & right smart pointers and borrow their TreeNodes\\n        let left_node = root_node.left.as_ref().unwrap().borrow();\\n        let right_node = root_node.right.as_ref().unwrap().borrow();\\n\\n        root_node.val == left_node.val + right_node.val\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2581688,
                "title": "rust-solution-with-pattern-matching",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        // type(root): Option<...>, use pattern matching to handle this\\n        match root {\\n            Some(root) =>  {\\n                // what happend when we use root.borrow() ?\\n                //    1. In rust, all smart pointers(like Rc<T> here) implement Deref trait.\\n                //    2. Deref coersion, a feature provided by rust. It will convert automatically\\n                //       for us:\\n                //           a reference to a type that implements Deref \\n                //       ->  a reference to a type that Deref can convert the original type into. \\n                //    3. The borrow() method accepts a &self paramater. However, the type of root is Rc<RefCell<TreeNode>>>.\\n                //    4. We can imagine the conversion here:\\n                //           Rc<RefCell<TreeNode>> -> &RefCell<TreeNode> -> &TreeNode\\n                //                               get reference         borrows the wrapped value.\\n                let root_node = root.borrow();\\n                // type(root_node.left/right) = Option<Rc<RefCell<TreeNode>>>\\n                // , which means we need to call .unwrap() method\\n                // why use .as_ref() here ?\\n                //     because we need to take care of the ownship\\'s problem :)\\n                let left_child = root_node.left.as_ref().unwrap().borrow();\\n                let right_child = root_node.right.as_ref().unwrap().borrow();\\n                root_node.val == left_child.val + right_child.val\\n            }\\n            // a empty root is ok\\n            None => true,\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        // type(root): Option<...>, use pattern matching to handle this\\n        match root {\\n            Some(root) =>  {\\n                // what happend when we use root.borrow() ?\\n                //    1. In rust, all smart pointers(like Rc<T> here) implement Deref trait.\\n                //    2. Deref coersion, a feature provided by rust. It will convert automatically\\n                //       for us:\\n                //           a reference to a type that implements Deref \\n                //       ->  a reference to a type that Deref can convert the original type into. \\n                //    3. The borrow() method accepts a &self paramater. However, the type of root is Rc<RefCell<TreeNode>>>.\\n                //    4. We can imagine the conversion here:\\n                //           Rc<RefCell<TreeNode>> -> &RefCell<TreeNode> -> &TreeNode\\n                //                               get reference         borrows the wrapped value.\\n                let root_node = root.borrow();\\n                // type(root_node.left/right) = Option<Rc<RefCell<TreeNode>>>\\n                // , which means we need to call .unwrap() method\\n                // why use .as_ref() here ?\\n                //     because we need to take care of the ownship\\'s problem :)\\n                let left_child = root_node.left.as_ref().unwrap().borrow();\\n                let right_child = root_node.right.as_ref().unwrap().borrow();\\n                root_node.val == left_child.val + right_child.val\\n            }\\n            // a empty root is ok\\n            None => true,\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2426866,
                "title": "with-explanation-comments-time-0-ms-100-space-12-6-mb-66-2",
                "content": "**Like it? ->Upvote please!**\\n\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        //check if the left & the right values equals the main root value\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\'\\'\\'\\n\\n**Like it? ->Upvote please!**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        //check if the left & the right values equals the main root value\\n        return root->val == root->left->val + root->right->val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2239768,
                "title": "swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n                guard let root = root, let leftVal = root.left?.val, let rightVal = root.right?.val else { return false }\\n        return root.val == leftVal + rightVal\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n                guard let root = root, let leftVal = root.left?.val, let rightVal = root.right?.val else { return false }\\n        return root.val == leftVal + rightVal\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096471,
                "title": "beginner-friendly-solutoin-one-line-solution",
                "content": "**Time Complexity : O(1)**\\njava\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\njavascript\\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val\\n};\\n```\\npython\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val\\n};\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054085,
                "title": "c-one-liner",
                "content": "```\\npublic class Solution \\n{\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val+root.right.val;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool CheckTree(TreeNode root) => root.val == root.left.val+root.right.val;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1953001,
                "title": "java-o-1-one-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1937707,
                "title": "one-liner-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst checkTree = root => {\\n    return root.val === root.left.val + root.right.val \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree = root => {\\n    return root.val === root.left.val + root.right.val \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3448027,
                "title": "easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if(root.val==root.right.val+root.left.val):\\n            return(True)\\n        return(False)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if(root.val==root.right.val+root.left.val):\\n            return(True)\\n        return(False)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3360082,
                "title": "easy-to-understand-c-solution-beats-100-of-other-solutions",
                "content": "Please upvote if you like it.\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if (root -> val == (root -> left -> val + root -> right -> val)){\\n            return true;\\n        }\\n        else{\\n            return false;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if (root -> val == (root -> left -> val + root -> right -> val)){\\n            return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3215805,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return false;\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return false;\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        else\\n        return false;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\n```Java []\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2761196,
                "title": "python-easy-solution",
                "content": "**Please upvote if you like my solution. Let me know in the comments if you have any suggestions to increase performance or readability.**\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```\\n\\n**Happy coding!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2671683,
                "title": "c-java-python-one-line-code-faster-than-100",
                "content": "C++ : \\n-------------------------------------------------------------------\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\n\\nJAVA : \\n--------------------------------------------------------------------\\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\\n\\n\\nPYTHON :\\n--------------------------------------------------------------------\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```\\n\\n\\nplz upvote; happy coding :)",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\n    public boolean checkTree(TreeNode root)\\n\\t{\\n        return root.val == root.left.val + root.right.val;  // O(1)\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663173,
                "title": "java-solution-one-line-code",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) { \\n        return (root.val == root.left.val + root.right.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) { \\n        return (root.val == root.left.val + root.right.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2254854,
                "title": "one-line-js",
                "content": "```\\nconst checkTree =  (root) => root.val === root.right.val + root.left.val\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree =  (root) => root.val === root.right.val + root.left.val\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2246142,
                "title": "python-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val ==(root.left.val +root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val ==(root.left.val +root.right.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2219867,
                "title": "kotlin-resolve-o-1-space",
                "content": "It is known from the condition that the binary tree consists of exactly 3 nodes. Therefore, there is no need to specify Nullable in the root: TreeNode argument. The final solution without using secure calls will take the following form:\\n```\\nclass Solution {\\n        fun checkTree(root: TreeNode) = root.`val` == root.left.`val` + root.right.`val`\\n    }\\n\\t",
                "solutionTags": [],
                "code": "class Solution {\\n        fun checkTree(root: TreeNode) = root.`val` == root.left.`val` + root.right.`val`\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3196201,
                "title": "java-easy-sol-0ms-beats-100-one-liner",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196200,
                "title": "beats-100-easy",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3074170,
                "title": "java-applicable-to-all-trees-for-beginners-o-1",
                "content": "Can be used for all Trees\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Applicable to all Trees\\nclass Solution \\n{\\n    int num = 0;\\n\\n    public boolean checkTree(TreeNode root) \\n    {\\n        inorder(root);\\n\\n        //subtract the root val and cmp them\\n        if((num - root.val) == root.val)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    //recursive function\\n    public void inorder(TreeNode node)\\n    {\\n        //if reach the end\\n        if (node == null)\\n            return;\\n \\n        //recuring on the left child\\n        inorder(node.left);\\n \\n        //add all the values\\n        num += node.val;\\n \\n        //then recuring on the right child\\n        inorder(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\n// Applicable to all Trees\\nclass Solution \\n{\\n    int num = 0;\\n\\n    public boolean checkTree(TreeNode root) \\n    {\\n        inorder(root);\\n\\n        //subtract the root val and cmp them\\n        if((num - root.val) == root.val)\\n            return true;\\n\\n        return false;\\n    }\\n\\n    //recursive function\\n    public void inorder(TreeNode node)\\n    {\\n        //if reach the end\\n        if (node == null)\\n            return;\\n \\n        //recuring on the left child\\n        inorder(node.left);\\n \\n        //add all the values\\n        num += node.val;\\n \\n        //then recuring on the right child\\n        inorder(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925093,
                "title": "98-faster-solution-easy-to-understand",
                "content": "![Screenshot 2022-12-18 at 16.02.43.png](https://assets.leetcode.com/users/images/f4d30438-82c5-495e-9d39-e54807f78a6b_1671361444.7605064.png)\\n\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==root.left.val+root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895960,
                "title": "c-easiest-way-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        TreeNode* l = root->left;\\n        TreeNode* r = root->right;\\n\\n        return root->val == l->val + r->val;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        TreeNode* l = root->left;\\n        TreeNode* r = root->right;\\n\\n        return root->val == l->val + r->val;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2827085,
                "title": "java-one-line-code",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==root.left.val+root.right.val;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==root.left.val+root.right.val;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792297,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n     return (root->val==(root->left->val + root->right->val));  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n     return (root->val==(root->left->val + root->right->val));  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2766329,
                "title": "one-line-solution",
                "content": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==(root.left.val+root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val==(root.left.val+root.right.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2761009,
                "title": "c-1-line-approach-o-1-time-complexity",
                "content": "bool checkTree(TreeNode* root) {\\n       \\n        if(root->val == (root->left->val + root->right->val))return true;\\n        else return false;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "bool checkTree(TreeNode* root) {\\n       \\n        if(root->val == (root->left->val + root->right->val))return true;\\n        else return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2755142,
                "title": "python-simple-python-solution",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 58 ms, faster than 50.14% of Python3 online submissions for Root Equals Sum of Children.\\n# Memory Usage: 13.8 MB, less than 94.99% of Python3 online submissions for Root Equals Sum of Children.\\n\\n\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tif root != None:\\n\\n\\t\\t\\t\\tif root.val == root.left.val + root.right.val:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 58 ms, faster than 50.14% of Python3 online submissions for Root Equals Sum of Children.\\n# Memory Usage: 13.8 MB, less than 94.99% of Python3 online submissions for Root Equals Sum of Children.\\n\\n\\tclass Solution:\\n\\t\\tdef checkTree(self, root: Optional[TreeNode]) -> bool:\\n\\n\\t\\t\\tif root != None:\\n\\n\\t\\t\\t\\tif root.val == root.left.val + root.right.val:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn False\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn False\\n\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 2744279,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val){\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2509473,
                "title": "three-different-solutions-for-beginner-s",
                "content": "##### **Solution : 1**\\n```\\n    def checkTree(self, root):\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        return False\\n```\\n\\n##### **Solution : 2**\\n```\\n    def checkTree(self, root):\\n        return (root.val == root.left.val + root.right.val)\\n```\\n\\n##### **Solution : 3**\\n```\\n    def checkTree(self, root):\\n        total = root.left.val + root.right.val\\n        return total == root.val\\n```\\n\\nLiked it? Please **UpVote**",
                "solutionTags": [],
                "code": "```\\n    def checkTree(self, root):\\n        if root.val == root.left.val + root.right.val:\\n            return True\\n        return False\\n```\n```\\n    def checkTree(self, root):\\n        return (root.val == root.left.val + root.right.val)\\n```\n```\\n    def checkTree(self, root):\\n        total = root.left.val + root.right.val\\n        return total == root.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2506582,
                "title": "python-one-line-code-tree",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499960,
                "title": "java-solution-one-line-of-code-1ms-runtime-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return (root.left.val + root.right.val) == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return (root.left.val + root.right.val) == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2403440,
                "title": "java-one-liner",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2393335,
                "title": "safest-1-line-kotlin-solution-all-edge-cases-covered",
                "content": "```class Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return if((root?.`val` ?: 0) == (root?.right?.`val` ?: 0) + (root?.left?.`val` ?: 0)) true else false\\n    }\\n}",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "class Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return if((root?.`val` ?: 0) == (root?.right?.`val` ?: 0) + (root?.left?.`val` ?: 0)) true else false\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2262869,
                "title": "c-simple-oneline-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == root->left->val + root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == root->left->val + root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2098710,
                "title": "c-one-line-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val==root->right->val+root->left->val?1:0;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val==root->right->val+root->left->val?1:0;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2005563,
                "title": "python-solution",
                "content": "**Upvote** if you like solution and feel **free to ask** If you have any question.\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val == (root.left.val + root.right.val):\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1978941,
                "title": "haven-t-seen-this-much-simple-question",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val) \\n            return true; \\n        return false;\\n    }\\n}; // please upvote if it helps you!\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val) \\n            return true; \\n        return false;\\n    }\\n}; // please upvote if it helps you!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4004701,
                "title": "0ms-beats-100-00-of-users-with-c-1-line-code",
                "content": "# Complexity\\n- Time complexity:\\nO(1)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->left->val+root->right->val==root->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985693,
                "title": "c-1-line-code-tc-o-n",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs they have informed tree has only 3 nodes , so its easy to access them . left + right == root ?\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val + root->right->val == root->val) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984030,
                "title": "easy-one-liner-solution-in-c",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val + root->right->val == root->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val + root->right->val == root->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3783934,
                "title": "fix-documentation-before",
                "content": "# Fix documentation\\nProperties of TreeNode were not type hinted, after fixing this, solution is easy!\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public TreeNode $left = null;\\n *     public TreeNode $right = null;\\n *     function __construct($val = 0, TreeNode $left = null, TreeNode $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree(TreeNode $root) {\\n        return $root->val === ($root->left->val + $root->right->val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public TreeNode $left = null;\\n *     public TreeNode $right = null;\\n *     function __construct($val = 0, TreeNode $left = null, TreeNode $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree(TreeNode $root) {\\n        return $root->val === ($root->left->val + $root->right->val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735396,
                "title": "easy-3-line-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->left->val+root->right->val==root->val)\\n        return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665571,
                "title": "check-this-out",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        bool checkRootValue = root.val == (root.left.val + root.right.val) ? true : false;\\n        return checkRootValue;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        bool checkRootValue = root.val == (root.left.val + root.right.val) ? true : false;\\n        return checkRootValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410421,
                "title": "what-if-the-height-of-the-tree-was-more-than-two",
                "content": "\\n\\n**This code will work for the tree with  any number of height.**\\n# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null&&root.right==null)\\n        return true;\\n        int sum=0;\\n        if(root.left!=null)\\n         sum+=root.left.val;\\n        \\n        if(root.right!=null) \\n        sum+=root.right.val;\\n       \\n        return (sum==root.val&&checkTree(root.left)&&checkTree(root.right));\\n    }\\n}\\n```\\nplease upvote if you find it helpful.\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null&&root.right==null)\\n        return true;\\n        int sum=0;\\n        if(root.left!=null)\\n         sum+=root.left.val;\\n        \\n        if(root.right!=null) \\n        sum+=root.right.val;\\n       \\n        return (sum==root.val&&checkTree(root.left)&&checkTree(root.right));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364957,
                "title": "c-1-liner",
                "content": "# Complexity\\n- Time complexity: $$O(1)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val +root->right->val));\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val +root->right->val));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253905,
                "title": "c-super-ez-tree-prob",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        if(root == null)\\n            return true;\\n        if(root.left == null && root.right != null)\\n            return (root.val == root.right.val);\\n        else if(root.right == null && root.left != null)\\n            return (root.val == root.left.val);\\n        else\\n            return (root.val == (root.right.val + root.left.val));\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        if(root == null)\\n            return true;\\n        if(root.left == null && root.right != null)\\n            return (root.val == root.right.val);\\n        else if(root.right == null && root.left != null)\\n            return (root.val == root.left.val);\\n        else\\n            return (root.val == (root.right.val + root.left.val));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206666,
                "title": "java-100-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.right.val + root.left.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.right.val + root.left.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3200221,
                "title": "java-1-liner-approach-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false;   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val ? true : false;   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169261,
                "title": "js",
                "content": "# Intuition\\nCheck if the sume of the left and right children is equal to the value of the node.\\n\\n# Complexity\\n- Time complexity: O(1): performs a constant amount of work\\n\\n- Space complexity: O(1): does not use any additional variables / data structures\\n\\n# Code\\n```\\nconst checkTree = (root) => {\\n    return root.val === (root.left.val) + (root.right.val)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst checkTree = (root) => {\\n    return root.val === (root.left.val) + (root.right.val)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2939455,
                "title": "c-2-liner-easy-solution-beat-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->val==(root->right->val + root->left->val))\\n        return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        return 0;\\n        if(root->val==(root->right->val + root->left->val))\\n        return true;\\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854093,
                "title": "pattern-matching",
                "content": "# Intuition\\nBeing passed in a struct was a little weird compared to the example passing in a list. \\n\\n# Approach\\nPattern match the different inputs to return false with the last pattern doing the summation. Might not be the most efficient but it does work.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n#\\n# defmodule TreeNode do\\n#   @type t :: %__MODULE__{\\n#           val: integer,\\n#           left: TreeNode.t() | nil,\\n#           right: TreeNode.t() | nil\\n#         }\\n#   defstruct val: 0, left: nil, right: nil\\n# end\\n\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(nil), do: false\\n  def check_tree(%TreeNode{left: nil}), do: false\\n  def check_tree(%TreeNode{right: nil}), do: false\\n  def check_tree(%TreeNode{val: total, left: left, right: right}) do\\n    left.val + right.val == total\\n  end\\nend\\n```",
                "solutionTags": [
                    "Elixir"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n#\\n# defmodule TreeNode do\\n#   @type t :: %__MODULE__{\\n#           val: integer,\\n#           left: TreeNode.t() | nil,\\n#           right: TreeNode.t() | nil\\n#         }\\n#   defstruct val: 0, left: nil, right: nil\\n# end\\n\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(nil), do: false\\n  def check_tree(%TreeNode{left: nil}), do: false\\n  def check_tree(%TreeNode{right: nil}), do: false\\n  def check_tree(%TreeNode{val: total, left: left, right: right}) do\\n    left.val + right.val == total\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2821687,
                "title": "java-detailed-explanation-o-1-time-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nJava Solution to Root Equals Sum Of Children.\\n\\nDetailed explanation included in code comments.\\n\\n# Complexity\\n- Time complexity: $$O(1)$$ constant time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ no additional space is used, only constant needed for the boolean returned by the function.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * Checks A Binary Tree Root Node Consisting Of 3 Nodes (Root, Left Child, Right Child)\\n     * To See If Sum Of Children Node Values Equals Root Node Value.\\n     * @param TreeNode - Root node of a binary tree consisting of 3 nodes: root, left, and right children nodes.\\n     * @return boolean - True if sum of children node values equals root node value, false otherwise.\\n     */\\n    public boolean checkTree(TreeNode root) {\\n        // Sum of left and right children nodes of the root node equal root value\\n        if (root.left.val + root.right.val == root.val)\\n        {\\n            return true;\\n        }\\n\\n        // Return false when sum of right and left children nodes values not equal root node value\\n        return false;\\n\\n        // NOTE: Could also solve using one line shown below\\n        // return root.val == root.right.val + root.left.val; \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    /**\\n     * Checks A Binary Tree Root Node Consisting Of 3 Nodes (Root, Left Child, Right Child)\\n     * To See If Sum Of Children Node Values Equals Root Node Value.\\n     * @param TreeNode - Root node of a binary tree consisting of 3 nodes: root, left, and right children nodes.\\n     * @return boolean - True if sum of children node values equals root node value, false otherwise.\\n     */\\n    public boolean checkTree(TreeNode root) {\\n        // Sum of left and right children nodes of the root node equal root value\\n        if (root.left.val + root.right.val == root.val)\\n        {\\n            return true;\\n        }\\n\\n        // Return false when sum of right and left children nodes values not equal root node value\\n        return false;\\n\\n        // NOTE: Could also solve using one line shown below\\n        // return root.val == root.right.val + root.left.val; \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744869,
                "title": "c-recursive-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n \\nclass Solution {\\npublic:\\n\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)){return true;}\\n        int l, r;\\n        if(root->left!=NULL){l=root->left->val;}else{l=0;}\\n        if(root->right!=NULL){r=root->right->val;}else{r=0;}\\n        if(root->val!=(l+r)){return false;}\\n        return checkTree(root->left) && checkTree(root->right);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL || (root->left==NULL && root->right==NULL)){return true;}",
                "codeTag": "Java"
            },
            {
                "id": 2661568,
                "title": "java-solution-recursive-0ms",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->Auxillary stack space.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left!=null && root.right!=null)\\n        {\\n        if(root.val==root.left.val+root.right.val)return true;}\\n        checkTree(root.left);\\n        checkTree(root.right);\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left!=null && root.right!=null)\\n        {\\n        if(root.val==root.left.val+root.right.val)return true;}\\n        checkTree(root.left);\\n        checkTree(root.right);\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641237,
                "title": "c-one-liner",
                "content": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2637705,
                "title": "java-easy-to-understand-not-one-liner",
                "content": "Runtime - 1ms\\nUsing a \\'temp\\' TreeNode to store \\'root\\'.\\n\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        TreeNode temp = root; //Creating temp TreeNode\\n        int sum=0;\\n        root = root.left; //Traversing to left node\\n        sum = sum + root.val; //Adding left node value\\n        root = temp; //Returning to Root Node\\n        root = root.right;  //Traversing to right node\\n        sum = sum + root.val; //Adding right node value\\n        if(sum == temp.val) return true; //Final condition\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        TreeNode temp = root; //Creating temp TreeNode\\n        int sum=0;\\n        root = root.left; //Traversing to left node\\n        sum = sum + root.val; //Adding left node value\\n        root = temp; //Returning to Root Node\\n        root = root.right;  //Traversing to right node\\n        sum = sum + root.val; //Adding right node value\\n        if(sum == temp.val) return true; //Final condition\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2589206,
                "title": "single-line-code-javascript",
                "content": "```\\nvar checkTree = function(root) {    \\n    return root.val === root.left.val + root.right.val ? true : false;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar checkTree = function(root) {    \\n    return root.val === root.left.val + root.right.val ? true : false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2579229,
                "title": "easy-one-liner-c",
                "content": "# One Line\\n\\n```\\nbool checkTree(TreeNode* root) {\\n        return (root->val) == (root->left)->val + (root->right)->val ? true : false;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        return (root->val) == (root->left)->val + (root->right)->val ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2552128,
                "title": "1-liner-java-c-very-easy",
                "content": "```\\n// Java Solution\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Java Solution\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n\\n\\n\\n// C++ Solution\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n\\n\\n\\n/*\\n\\tif(you like)\\n\\t\\tplease upvote;\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506775,
                "title": "simplest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->val == (root->left->val + root->right->val));    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492642,
                "title": "java-5-lines-code-100-faster-easy-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        int sum = 0;\\n        sum = root.left.val + root.right.val;\\n        if(root.val == sum){\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```\\n**Thanks for visiting :)**",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        int sum = 0;\\n        sum = root.left.val + root.right.val;\\n        if(root.val == sum){\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462159,
                "title": "python-simple-and-faster-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        d=root.val\\n        self.res=0\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left==None and root.right==None):\\n                self.res+=root.val\\n            else:\\n                dsf(root.left)\\n                dsf(root.right)\\n        dsf(root)\\n        return self.res==d\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        d=root.val\\n        self.res=0\\n        def dsf(root):\\n            if(root==None):\\n                return \\n            if(root.left==None and root.right==None):\\n                self.res+=root.val\\n            else:\\n                dsf(root.left)\\n                dsf(root.right)\\n        dsf(root)\\n        return self.res==d\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433136,
                "title": "root-equals-sum-of-children-solution-java",
                "content": "class Solution {\\n  public boolean checkTree(TreeNode root) {\\n    return root.val == root.left.val + root.right.val;\\n  }\\n}\\n",
                "solutionTags": [
                    "Tree",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n  public boolean checkTree(TreeNode root) {\\n    return root.val == root.left.val + root.right.val;\\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2342925,
                "title": "root-equals-sum-of-children",
                "content": "```\\nvar checkTree = function(root) {\\n    // let binary = (root[0] === root[1]+root[2])? true: false\\n    return root.val === root.left.val+root.right.val\\n    //return binary;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    // let binary = (root[0] === root[1]+root[2])? true: false\\n    return root.val === root.left.val+root.right.val\\n    //return binary;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2329524,
                "title": "python-100-faster-one-line",
                "content": "return (root.left.val + root.right.val) == root.val",
                "solutionTags": [
                    "Python"
                ],
                "code": "return (root.left.val + root.right.val) == root.val",
                "codeTag": "Unknown"
            },
            {
                "id": 2312637,
                "title": "why-why-why-why-why-why",
                "content": "return (root->val == root->left->val + root->right->val);",
                "solutionTags": [],
                "code": "return (root->val == root->left->val + root->right->val);",
                "codeTag": "Unknown"
            },
            {
                "id": 2276459,
                "title": "c-easiest-solution-10-ms-runtime-very-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        if(root->left->val + root->right->val==root->val) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        \\n        if(root->left->val + root->right->val==root->val) return true ;\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2256250,
                "title": "java",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val+root.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val+root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227427,
                "title": "simple-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2196708,
                "title": "easy-one-liner-python-solution",
                "content": "Code: \\n```return root.val == (root.left.val + root.right.val)```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```return root.val == (root.left.val + root.right.val)```",
                "codeTag": "Unknown"
            },
            {
                "id": 2178290,
                "title": "one-line-killer-typescript-javascript",
                "content": "```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val === root.left.val + root.right.val\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val === root.left.val + root.right.val\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2156990,
                "title": "javascript-easy-solution",
                "content": "```\\nvar checkTree = function(root) {\\n    let value = root.left.val + root.right.val;\\n    value = value === root.val ? true : false;\\n    return value;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function(root) {\\n    let value = root.left.val + root.right.val;\\n    value = value === root.val ? true : false;\\n    return value;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2109950,
                "title": "easy-python-1-liner",
                "content": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == (root.left.val + root.right.val)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2076045,
                "title": "php",
                "content": "```\\nfunction checkTree($root) {\\n        return $root->val === $root->left->val+$root->right->val;\\n        \\n    }\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nfunction checkTree($root) {\\n        return $root->val === $root->left->val+$root->right->val;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2028580,
                "title": "java-1-liner-short-simple-and-easy-using-shorthand-if-notation",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return ((root.left.val)+(root.right.val)==root.val)?true:false; // just used shorthand if notation in java - google it !\\n\\t\\t//root.right - > will get the right node & .val will get its value, similarly for others !\\n    }\\n}\\n```\\n\\n**Perform a dry run for better understanding !\\nHappy Coding !\\nDo upvote if it helped !**",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return ((root.left.val)+(root.right.val)==root.val)?true:false; // just used shorthand if notation in java - google it !\\n\\t\\t//root.right - > will get the right node & .val will get its value, similarly for others !\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2010130,
                "title": "sharing-my-solution-in-11-languages",
                "content": "I cannot comprehend which company would ask this question and for which role ?\\nMaybe as an interviewer myself, if I ask a tree based question to a candidate, and the candidate is completely clueless - I would usually level-down the problem, but never ever to this type of level.\\n\\n@Leetcode please do not post such trivial problems on a site which is supposedly used by people preparing for coding contests/interviews.\\n\\nThis problem is good for Exercise in a textbook which has introductory chapter on Trees.\\n\\nEnough of ranting, let us discuss the solutions .....\\n\\n**C**\\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\\n\\n\\n**C#**\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**Go**\\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\\n\\n\\n**Java**\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**Javascript**\\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```\\n\\n**PHP**\\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\\n\\n**Python**\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \"\"\"\\n        return root.val == root.left.val + root.right.val\\n```\\n\\n**Python3**\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n \\n```\\n\\n**Ruby**\\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\\n\\n**TypeScript**\\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val === root.left.val + root.right.val;\\n};\\n```\n```\\nclass Solution {\\n\\n    /**\\n     * @param TreeNode $root\\n     * @return Boolean\\n     */\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :rtype: bool\\n        \"\"\"\\n        return root.val == root.left.val + root.right.val\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n \\n```\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1952848,
                "title": "hardest-question-needs-sophisticated-solution",
                "content": "```java\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n```\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1947025,
                "title": "every-programming-language-c-java-python-c-c-javascript-ruby-swift-go-scala-and-more",
                "content": "If you think this question is too easy, complete it in every programming language offered by LeetCode.\\n\\n**C++**:\\n```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\\n\\n**Java**:\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.right.val + root.left.val;\\n    }\\n}\\n```\\n\\n**Python**:\\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.right.val + root.left.val\\n```\\n\\n**Python 3**:\\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.right.val + root.left.val\\n```\\n\\n**C**:\\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\\n\\n**C#**:\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n**JavaScript**:\\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\\n\\n**Ruby**:\\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\\n\\n**Swift**:\\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return root!.val == root!.left!.val + root!.right!.val\\n    }\\n}\\n```\\n\\n**Go**:\\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\\n\\n**Scala**:\\n```\\nobject Solution {\\n    def checkTree(root: TreeNode): Boolean = {\\n        return root.value == root.left.value + root.right.value\\n    }\\n}\\n```\\n\\n**Kotlin**:\\n```\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == root!!.left!!.`val` + root!!.right!!.`val`\\n    }\\n}\\n```\\n\\n**Rust**:\\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root = root.as_ref().unwrap().borrow();    \\n        return root.val == root.left.as_ref().unwrap().borrow().val + root.right.as_ref().unwrap().borrow().val;\\n    }\\n}\\n```\\n\\n**PHP**:\\n```\\nclass Solution {\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\\n\\n**TypeScript**:\\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\\n\\n**Racket**:\\n```\\n(define/contract (check-tree root)\\n  (-> (or/c tree-node? #f) boolean?)\\n    (eq? (tree-node-val root) (+ (tree-node-val (tree-node-left root)) (tree-node-val (tree-node-right root))))\\n  )\\n```\\n\\n**Erlang**:\\n```\\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\\ncheck_tree(Root) ->\\n  Root#tree_node.val == Root#tree_node.left#tree_node.val + Root#tree_node.right#tree_node.val.\\n```\\n\\n**Elixir**:\\n```\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(root) do\\n    root.val == root.left.val + root.right.val\\n  end\\nend\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Ruby",
                    "Swift",
                    "Scala",
                    "Rust"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.right.val + root.left.val;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def checkTree(self, root):\\n        return root.val == root.right.val + root.left.val\\n```\n```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.right.val + root.left.val\\n```\n```\\nbool checkTree(struct TreeNode* root){\\n    return root->val == root->left->val + root->right->val;\\n}\\n```\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\n```\\nvar checkTree = function(root) {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\n```\\ndef check_tree(root)\\n    return root.val == root.left.val + root.right.val\\nend\\n```\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return root!.val == root!.left!.val + root!.right!.val\\n    }\\n}\\n```\n```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val;\\n}\\n```\n```\\nobject Solution {\\n    def checkTree(root: TreeNode): Boolean = {\\n        return root.value == root.left.value + root.right.value\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == root!!.left!!.`val` + root!!.right!!.`val`\\n    }\\n}\\n```\n```\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        let root = root.as_ref().unwrap().borrow();    \\n        return root.val == root.left.as_ref().unwrap().borrow().val + root.right.as_ref().unwrap().borrow().val;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    function checkTree($root) {\\n        return $root->val == $root->left->val + $root->right->val;\\n    }\\n}\\n```\n```\\nfunction checkTree(root: TreeNode | null): boolean {\\n    return root.val == root.left.val + root.right.val;\\n};\\n```\n```\\n(define/contract (check-tree root)\\n  (-> (or/c tree-node? #f) boolean?)\\n    (eq? (tree-node-val root) (+ (tree-node-val (tree-node-left root)) (tree-node-val (tree-node-right root))))\\n  )\\n```\n```\\n-spec check_tree(Root :: #tree_node{} | null) -> boolean().\\ncheck_tree(Root) ->\\n  Root#tree_node.val == Root#tree_node.left#tree_node.val + Root#tree_node.right#tree_node.val.\\n```\n```\\ndefmodule Solution do\\n  @spec check_tree(root :: TreeNode.t | nil) :: boolean\\n  def check_tree(root) do\\n    root.val == root.left.val + root.right.val\\n  end\\nend\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945881,
                "title": "c-solution",
                "content": "My little solution in C#\\n\\n\\n```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        \\n        int left = root.left.val;\\n        int right= root.right.val;\\n        \\n        return(left+right==root.val);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool CheckTree(TreeNode root) {\\n        \\n        int left = root.left.val;\\n        int right= root.right.val;\\n        \\n        return(left+right==root.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1944211,
                "title": "javascript-js",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function (root) {\\n  return root.val === root.left.val + root.right.val;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {boolean}\\n */\\nvar checkTree = function (root) {\\n  return root.val === root.left.val + root.right.val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1940061,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val)\\n            return true; \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val)\\n            return true; \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1938760,
                "title": "rust-0ms-pattern-matching",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match root {\\n            Some(node) => match (node.borrow().left.as_ref(), node.borrow().right.as_ref()) {\\n                (Some(left), Some(right)) => {\\n                    left.borrow().val + right.borrow().val == node.borrow().val\\n                }\\n                _ => true,\\n            },\\n            None => true,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn check_tree(root: Option<Rc<RefCell<TreeNode>>>) -> bool {\\n        match root {\\n            Some(node) => match (node.borrow().left.as_ref(), node.borrow().right.as_ref()) {\\n                (Some(left), Some(right)) => {\\n                    left.borrow().val + right.borrow().val == node.borrow().val\\n                }\\n                _ => true,\\n            },\\n            None => true,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1938094,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935170,
                "title": "java-recursive-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode node) {\\n        if(node.left == null){\\n            return true;\\n        }\\n        if(node.right==null){\\n            return true;\\n        }\\n        checkTree(node.left);\\n        checkTree(node.right);\\n        if(node.val == node.left.val + node.right.val){\\n            return true;\\n            \\n        }\\n        else{\\n            return false;\\n        }\\n        \\n      \\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode node) {\\n        if(node.left == null){\\n            return true;\\n        }\\n        if(node.right==null){\\n            return true;\\n        }\\n        checkTree(node.left);\\n        checkTree(node.right);\\n        if(node.val == node.left.val + node.right.val){\\n            return true;\\n            \\n        }\\n        else{\\n            return false;\\n        }\\n        \\n      \\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1934711,
                "title": "don-t-see-the-point-of-this-problem",
                "content": "```\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val+root.right.val\\n```",
                "solutionTags": [],
                "code": "```\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val+root.right.val\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4063581,
                "title": "best-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3964841,
                "title": "100-faster-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        int sum = root->left->val + root->right->val;\\n\\n        return root->val == sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        int sum = root->left->val + root->right->val;\\n\\n        return root->val == sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877448,
                "title": "2-lines-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n       if(root.val==root.left.val+root.right.val)return true;\\n       return false;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n       if(root.val==root.left.val+root.right.val)return true;\\n       return false;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793957,
                "title": "root-equals-sum-of-children",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/d16f0b89-7c41-4ab2-8a87-436262395422_1689877762.281462.png)\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        if root.val==root.left.val+root.right.val:\\n            return True\\n        else:\\n            return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3757098,
                "title": "clean-and-easy-with-type-hinting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public $left = null;\\n *     public $right = null;\\n *     function __construct($val = 0, $left = null, $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution\\n{\\n    function checkTree(TreeNode $root): bool\\n    {\\n        return $root->left->val + $root->right->val === $root->val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * class TreeNode {\\n *     public $val = null;\\n *     public $left = null;\\n *     public $right = null;\\n *     function __construct($val = 0, $left = null, $right = null) {\\n *         $this->val = $val;\\n *         $this->left = $left;\\n *         $this->right = $right;\\n *     }\\n * }\\n */\\nclass Solution\\n{\\n    function checkTree(TreeNode $root): bool\\n    {\\n        return $root->left->val + $root->right->val === $root->val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3698924,
                "title": "2-line-sol-beats-100-c",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==(root->left->val+root->right->val)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==(root->left->val+root->right->val)) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3555807,
                "title": "easy-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        int s=0;\\n        if(root.left!=null) s+=root.left.val;\\n        if(root.right!=null) s+=root.right.val;\\n        \\n        return (root.val==s && checkTree(root.left) && checkTree(root.right)) ;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root==null) return true;\\n        if(root.left==null && root.right==null) return true;\\n        int s=0;\\n        if(root.left!=null) s+=root.left.val;\\n        if(root.right!=null) s+=root.right.val;\\n        \\n        return (root.val==s && checkTree(root.left) && checkTree(root.right)) ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532202,
                "title": "swift-recursive-solution",
                "content": "Recursive solution:\\n```\\nclass Solution {\\n\\n    func sum(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n\\n        return root.val + sum(root.left) + sum(root.right)\\n    }\\n\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n\\n        return root.val == sum(root.left) + sum(root.right)\\n    }\\n}\\n```\\n\\nOne liner:\\n\\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return (root?.val ?? -1) - (root?.left?.val ?? 0) - (root?.right?.val ?? 0) == 0\\n    }\\n}\\n\\n```\\n\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n\\n    func sum(_ root: TreeNode?) -> Int {\\n        guard let root = root else {\\n            return 0\\n        }\\n\\n        return root.val + sum(root.left) + sum(root.right)\\n    }\\n\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        guard let root = root else {\\n            return false\\n        }\\n\\n        return root.val == sum(root.left) + sum(root.right)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func checkTree(_ root: TreeNode?) -> Bool {\\n        return (root?.val ?? -1) - (root?.left?.val ?? 0) - (root?.right?.val ?? 0) == 0\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3505689,
                "title": "easiest-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n        TreeNode node1 =root.left;\\n        TreeNode node2 = root.right;\\n        if(root.val == (node1.val+node2.val)) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\n        TreeNode node1 =root.left;\\n        TreeNode node2 = root.right;\\n        if(root.val == (node1.val+node2.val)) return true;\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3456779,
                "title": "0-ms-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if(root.val==root.left.val+root.right.val)\\n        {\\n            return true;\\n        }\\n        return false;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355187,
                "title": "java-sol-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if((root.left.val+root.right.val) == root.val){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if((root.left.val+root.right.val) == root.val){\\n            return true;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160860,
                "title": "c-and-c-one-line-solution",
                "content": "\\n# C++\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->right->val + root->left->val == root->val;\\n        \\n    }\\n    \\n};\\n```\\n\\n# C Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->right->val + root->left->val == root->val;\\n        \\n    }\\n    \\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     struct TreeNode *left;\\n *     struct TreeNode *right;\\n * };\\n */\\nbool checkTree(struct TreeNode* root){\\n    return root->right->val + root->left->val == root->val;\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103175,
                "title": "root-equals-sum-of-children-using-kotlin-best-complexity-o-1",
                "content": "# Complexity\\n- Time complexity: O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Author: Mohamed Shaban Ahmed\\n\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == (root!!.left!!.`val` + root!!.right!!.`val`)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Tree"
                ],
                "code": "```\\n//Author: Mohamed Shaban Ahmed\\n\\n/**\\n * Example:\\n * var ti = TreeNode(5)\\n * var v = ti.`val`\\n * Definition for a binary tree node.\\n * class TreeNode(var `val`: Int) {\\n *     var left: TreeNode? = null\\n *     var right: TreeNode? = null\\n * }\\n */\\nclass Solution {\\n    fun checkTree(root: TreeNode?): Boolean {\\n        return root!!.`val` == (root!!.left!!.`val` + root!!.right!!.`val`)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3101716,
                "title": "2236-java",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Runtime : 0 ms\\n- Beats : 100%\\n- Memory : 39.6 MB\\n- Beats : 97.64%\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode r) {\\n        return r.val == r.left.val + r.right.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode r) {\\n        return r.val == r.left.val + r.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075269,
                "title": "dart-null-safety-solution",
                "content": "# Code\\n```\\nclass Solution {\\n  bool checkTree(TreeNode? root) {\\n      if (root == null) return false;\\n\\n      final leftValue = root.left?.val ?? 0;\\n      final rightValue = root.right?.val ?? 0;\\n\\n      return root.val == leftValue + rightValue;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  bool checkTree(TreeNode? root) {\\n      if (root == null) return false;\\n\\n      final leftValue = root.left?.val ?? 0;\\n      final rightValue = root.right?.val ?? 0;\\n\\n      return root.val == leftValue + rightValue;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3063740,
                "title": "recursive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc checkTree(root *TreeNode) bool {\\n\\n     if root==nil {\\n         return true\\n     }\\n     sum:=0\\n     if root.Left!= nil {\\n         sum+=root.Left.Val\\n     }\\n      if root.Right!=nil {\\n          sum+=root.Right.Val\\n      }\\n      if sum==root.Val {\\n          return true\\n      } else {\\n          return false\\n      }\\n      sum=0\\n    return checkTree(root.Left) && checkTree(root.Right)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * type TreeNode struct {\\n *     Val int\\n *     Left *TreeNode\\n *     Right *TreeNode\\n * }\\n */\\nfunc checkTree(root *TreeNode) bool {\\n\\n     if root==nil {\\n         return true\\n     }\\n     sum:=0\\n     if root.Left!= nil {\\n         sum+=root.Left.Val\\n     }\\n      if root.Right!=nil {\\n          sum+=root.Right.Val\\n      }\\n      if sum==root.Val {\\n          return true\\n      } else {\\n          return false\\n      }\\n      sum=0\\n    return checkTree(root.Left) && checkTree(root.Right)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3031466,
                "title": "c-easy-2-lines-code-beats-100",
                "content": "# C++ Easy solution\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val) return true;\\n        else return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val == root->left->val + root->right->val) return true;\\n        else return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2853865,
                "title": "go-one-line-solution",
                "content": "```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2839553,
                "title": "c-one-liner-beats-100-submissions",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val+ root->right->val== root->val) ? true : false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return (root->left->val+ root->right->val== root->val) ? true : false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2784979,
                "title": "for-all-depths",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void help(TreeNode* r, int &sum)\\n    {\\n        if(!r)\\n            return ;\\n        if(!r->left && !r->right)\\n            sum+=r->val;\\n        help(r->left,sum);\\n        help(r->right,sum);\\n        \\n        \\n    }\\n    bool checkTree(TreeNode* r) {\\n        \\n        if(!r)\\n            return true;\\n        \\n        int sum = 0;\\n        help(r,sum);\\n        return r->val == sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    void help(TreeNode* r, int &sum)\\n    {\\n        if(!r)\\n            return ;\\n        if(!r->left && !r->right)\\n            sum+=r->val;\\n        help(r->left,sum);\\n        help(r->right,sum);\\n        \\n        \\n    }\\n    bool checkTree(TreeNode* r) {\\n        \\n        if(!r)\\n            return true;\\n        \\n        int sum = 0;\\n        help(r,sum);\\n        return r->val == sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751619,
                "title": "one-line-solution-c",
                "content": "Assuming that in the constraints of the problem it is specified that each input has only 3 nodes including the root, and its two right and left nodes. We can simply return an equality check between the sum of the two nodes and the root.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n        bool checkTree(TreeNode* root) {\\n            return (root->val == (root->left->val + root->right->val));\\n        }\\n};\\n```\\n\\n**If that helped, an upvote would be welcome.**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n        bool checkTree(TreeNode* root) {\\n            return (root->val == (root->left->val + root->right->val));\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744252,
                "title": "ruby-five-different-ways",
                "content": "# Intuition\\nWe are given the root node that has access its left and right children. Simply call its left and right right children values and see if the add up to the root\\'s value. Keep in mind that each node in the tree has a val, left, and right attribute. \\n\\n##### Root:\\nroot => root\\n\\nroot value => root.val\\n\\n##### Root\\'s Left:\\nleft child => root.left\\n\\nleft child value => root.left.val\\n\\n\\n##### Root\\'s Right:\\nright child => root.right\\n\\nright child value => root.right.val\\n\\n# Complexity\\n- Time complexity: O(1)\\nGenerally speaking operations take O(1) time and accessing the immediate children of the root node is constant as well.   \\n\\n- Space complexity: O(1)\\nSince no additional data structures are created to perform the calculations. \\n\\n# Code\\n\\n### ternary operator\\n```\\n# ternary operator\\n# time: O(1) \\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val + root.right.val == root.val ? true : false\\nend\\n```\\n\\n### implicit boolean return \\n```\\n# implicit boolean return \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.val == root.left.val + root.right.val\\nend\\n```\\n\\n### complement\\n```\\n# complement\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val == root.val - root.right.val \\nend\\n```\\n\\n### conditional part 1\\n```\\n# conditional part 1\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    if root.val == root.left.val + root.right.val\\n        return true\\n    else\\n        return false\\n    end\\nend\\n```\\nOne can omit the return statement\\n\\n### conditional part 2  \\n```\\n# conditional part 2 \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    return true if root.val == root.left.val + root.right.val\\n    return false\\nend\\n```\\n\\n",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\n# ternary operator\\n# time: O(1) \\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val + root.right.val == root.val ? true : false\\nend\\n```\n```\\n# implicit boolean return \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.val == root.left.val + root.right.val\\nend\\n```\n```\\n# complement\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    root.left.val == root.val - root.right.val \\nend\\n```\n```\\n# conditional part 1\\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    if root.val == root.left.val + root.right.val\\n        return true\\n    else\\n        return false\\n    end\\nend\\n```\n```\\n# conditional part 2 \\n# time: O(1)\\n# space: O(1)\\ndef check_tree(root)\\n    return true if root.val == root.left.val + root.right.val\\n    return false\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2739176,
                "title": "python3-single-liner-code",
                "content": "python3 solution in just one line\\n\\n```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "solutionTags": [],
                "code": "```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2693206,
                "title": "cpp-easy-to-understand",
                "content": "```\\nbool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n            return false;\\n        else if(root->val==(root->left->val+root->right->val))\\n            return true;\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "```\\nbool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n            return false;\\n        else if(root->val==(root->left->val+root->right->val))\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2655474,
                "title": "c-simple-recursive-solution",
                "content": "```\\n// Please, UpVote if you like it :)\\n// Runtime: 8 ms, faster than 25.96% of C++ online submissions for Root Equals Sum of Children.\\n// Memory Usage: 12.6 MB, less than 14.35% of C++ online submissions for Root Equals Sum of Children.\\nbool checkTree(TreeNode* root) {\\n\\tif (!root || !root->left && !root->right)\\n\\t\\treturn true;\\n\\treturn (root->val == ((root->left) ? root->left->val : 0) + ((root->right) ? root->right->val : 0)) &&\\n\\t\\tcheckTree(root->left) &&\\n\\t\\tcheckTree(root->right);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\n// Please, UpVote if you like it :)\\n// Runtime: 8 ms, faster than 25.96% of C++ online submissions for Root Equals Sum of Children.\\n// Memory Usage: 12.6 MB, less than 14.35% of C++ online submissions for Root Equals Sum of Children.\\nbool checkTree(TreeNode* root) {\\n\\tif (!root || !root->left && !root->right)\\n\\t\\treturn true;\\n\\treturn (root->val == ((root->left) ? root->left->val : 0) + ((root->right) ? root->right->val : 0)) &&\\n\\t\\tcheckTree(root->left) &&\\n\\t\\tcheckTree(root->right);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639773,
                "title": "go-simple-solution-in-go-golang",
                "content": "Hello Gophers!\\n\\n# Problem: Root Equals Sum of Children (Easy)\\n\\n## Solution 1: One Line Solution\\n\\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```\\n\\n## Solution 2: Best Practice\\n\\nLet\\'s say we are not sure if `root` is not nil or if it has children:\\n\\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    if root == nil {\\n        return false\\n    }\\n    var sum int = 0\\n    if root.Left != nil {\\n        sum += root.Left.Val\\n    }\\n    if root.Right != nil {\\n        sum += root.Right.Val\\n    }\\n    return root.Val == sum\\n}\\n```\\n\\nI hope it helped! =)",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc checkTree(root *TreeNode) bool {\\n    return root.Val == root.Left.Val + root.Right.Val\\n}\\n```\n```go\\nfunc checkTree(root *TreeNode) bool {\\n    if root == nil {\\n        return false\\n    }\\n    var sum int = 0\\n    if root.Left != nil {\\n        sum += root.Left.Val\\n    }\\n    if root.Right != nil {\\n        sum += root.Right.Val\\n    }\\n    return root.Val == sum\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602398,
                "title": "c-starightforward",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593043,
                "title": "one-liner-pythonic-way",
                "content": "\\'\\'\\'\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        return root.val == root.left.val + root.right.val\\n\\'\\'\\'",
                "codeTag": "Java"
            },
            {
                "id": 2569744,
                "title": "java-one-liner",
                "content": "Please Upvote if Helpful\\n\\n***\\n\\n```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```\\n\\n***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val == root.left.val + root.right.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567885,
                "title": "python3-one-line-solution",
                "content": "```\\nreturn root.val == root.left.val + root.right.val\\n```",
                "solutionTags": [],
                "code": "```\\nreturn root.val == root.left.val + root.right.val\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2530043,
                "title": "c-solution-one-line-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val + root->right->val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == (root->left->val + root->right->val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2529742,
                "title": "python-easy-solution",
                "content": "```python\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        def subtreeSum(node: Optional[TreeNode], value) -> int:\\n            if not node:\\n                return 0\\n\\n            return value + subtreeSum(node.left, node.val) + subtreeSum(node.right, node.val)\\n\\n        return root.val == (subtreeSum(root.left, root.left.val) + subtreeSum(root.right, root.right.val))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```python\\nclass Solution:\\n    def checkTree(self, root: Optional[TreeNode]) -> bool:\\n        def subtreeSum(node: Optional[TreeNode], value) -> int:\\n            if not node:\\n                return 0\\n\\n            return value + subtreeSum(node.left, node.val) + subtreeSum(node.right, node.val)\\n\\n        return root.val == (subtreeSum(root.left, root.left.val) + subtreeSum(root.right, root.right.val))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526561,
                "title": "java-simple-one-line-solution-the-most-minimalistic-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\t\\treturn root.val == root.left.val + root.right.val;\\n\\t}\\n}\\n```\\nIf you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n\\t\\treturn root.val == root.left.val + root.right.val;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507139,
                "title": "java-solution-faster-than-100-00-of-submissions",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if (root == null) \\n            return false;\\n        else \\n            return (root.val == root.left.val + root.right.val); \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        if (root == null) \\n            return false;\\n        else \\n            return (root.val == root.left.val + root.right.val); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2503005,
                "title": "javascript-sol",
                "content": "```\\nvar checkTree = function (root) {\\n    let node = root.val;\\n    let left = root.left.val;\\n    let right = root.right.val;\\n\\n    if (node == (left + right)) { return true }\\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar checkTree = function (root) {\\n    let node = root.val;\\n    let left = root.left.val;\\n    let right = root.right.val;\\n\\n    if (node == (left + right)) { return true }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2495069,
                "title": "javascript",
                "content": "```\\nconst checkTree = (root) => root.val === (root.right.val + root.left.val)\\n```\\n\\nRuntime: 62 ms, faster than 96.61% of JavaScript online submissions for Root Equals Sum of Children.\\nMemory Usage: 42.2 MB, less than 98.62% of JavaScript online submissions for Root Equals Sum of Children.",
                "solutionTags": [],
                "code": "```\\nconst checkTree = (root) => root.val === (root.right.val + root.left.val)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2480656,
                "title": "c-solution-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==root->left->val+root->right->val)\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root->val==root->left->val+root->right->val)\\n            return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2475103,
                "title": "2236-root-equals-sum-of-children",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->left->val + root->right->val == root->val)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        if(root==NULL)\\n        {\\n            return true;\\n        }\\n        if(root->left->val + root->right->val == root->val)\\n        {\\n            return true;\\n        }\\n        else\\n        {\\n            return false;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465225,
                "title": "java-1-line-easy",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.left.val + root.right.val == root.val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2448051,
                "title": "single-line-solution-clean-c-code",
                "content": "# If you liked this solution then do upvote.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    bool checkTree(TreeNode* root) {\\n        return root->val == root->left->val + root->right->val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440740,
                "title": "java-1-liner-1ms",
                "content": "# Please Upvote\\n\\n```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nreturn root.val == (root.right.val + root.left.val);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420305,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==(root.left).val+(root.right).val;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean checkTree(TreeNode root) {\\n        return root.val==(root.left).val+(root.right).val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1693829,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1564888,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1565649,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1735919,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1925445,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1570895,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1861691,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1726629,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1698119,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1576632,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1693829,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1564888,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1565649,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1735919,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1925445,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1570895,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1861691,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1726629,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1698119,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 1576632,
                "content": [
                    {
                        "username": "charlessrze",
                        "content": " Why its not working...\\n`if(root[1] + root[2] == root[0]) return true;\\n    else return false;`"
                    },
                    {
                        "username": "At-sushi",
                        "content": "I think it is because the code lacks \".val\" after object statements. Reading them as an array is actually work for the result of C pointer trick (though I recommend to avoid this because the result is undefined)."
                    },
                    {
                        "username": "willima09",
                        "content": "[@jerryy147](/jerryy147) are you sure\\njs is declarative\\n"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "[@jerryy147](/jerryy147)  are you suggesting this solution for JS?"
                    },
                    {
                        "username": "mujeeb1441",
                        "content": "Because it\\'s not an array, root is a pointer"
                    },
                    {
                        "username": "jerryy147",
                        "content": "try root.val, root.left, and root.right"
                    },
                    {
                        "username": "rymoon",
                        "content": "It is not a list. Access properties via pointer."
                    },
                    {
                        "username": "voyager1winterberry",
                        "content": "Your code is meant to access the values of a list, but when I used console.log(typeof root), I saw that it is an object. Think of how you access the properties and values of an object."
                    },
                    {
                        "username": "EivindDelFierro",
                        "content": "On java script, when i console.log\\'d the input of function, it appeared like an array, but when i tried to convert it to string, it had an interesting output: the data structure that I was working with. From that output I was able to figure out the problem.."
                    },
                    {
                        "username": "Vladomira",
                        "content": "because it's not an array. In my case (TypeScript) every left side and every right side has own data: left side has own [value]- (its like independent node ) and also it has [left side] and [right side]. the same for right side. Every side can has own children.\nTry to console every element and type of it  and you will see"
                    },
                    {
                        "username": "niloufer_anjum",
                        "content": "It\\'s a TreeNode not a list. Try print(root) and solve from there."
                    },
                    {
                        "username": "rowe1227",
                        "content": "This question is much simpler than what one would expect to see in any interview setting.  \\n\\nThis is by design.  This problem and its [counterpart](https://leetcode.com/problems/add-two-integers/) will be used to help new LeetCode users become familiar with the platform and learn how to submit solutions.  \\n\\nAs many new LeetCode users will start at this problem, please feel free to share any advice you have for them below!"
                    },
                    {
                        "username": "deleted_user",
                        "content": "I feel as if this shouldn\\'t be an official problem; and if it is, that it be more findable to a new user. Just a suggestion. :) "
                    },
                    {
                        "username": "Universe_ldy",
                        "content": "Seriously? This is a real interview question?"
                    },
                    {
                        "username": "rparks52",
                        "content": "No, it\\'s not. It\\'s for learning how to use LeetCode for users that are not familiar with coding."
                    },
                    {
                        "username": "venka_",
                        "content": "For other noobs like me: pay attention to how to access structures using pointers, note that there are multiple pointers"
                    },
                    {
                        "username": "CoffeeCode247",
                        "content": "Why so many dislikes?? We all start from somewhere. Don\\'t forget that some of us WERE beginners at one point."
                    },
                    {
                        "username": "boo-m",
                        "content": "I do not understand the purpose of few of these problems\\n\\n[2235. Add Two Integers](https://leetcode.com/problems/add-two-integers/)\\n[2236. Root Equals Sum of Children](https://leetcode.com/problems/root-equals-sum-of-children/)\\n[1480. Running Sum of 1d Array](https://leetcode.com/problems/running-sum-of-1d-array/)\\n[1920. Build Array from Permutation](https://leetcode.com/problems/build-array-from-permutation/)\\n[1929. Concatenation of Array](https://leetcode.com/problems/concatenation-of-array/)\\n\\nPlease add to the list if you find any more easy problems.\\n"
                    },
                    {
                        "username": "hectorstestlab",
                        "content": "Its good for catching up on the programming logic again. I have been a Software QA Lead for almost 4 years now and I lost that, this is helping me."
                    },
                    {
                        "username": "mqberry",
                        "content": "It lowers the coding barrier to entry for new coders who may be coming to LC as a primary source of learning.  It is also hard to see what can be learned from simple problems like these when your experience and understanding far surpasses what these problems are testing you for.  :)"
                    },
                    {
                        "username": "denz1994",
                        "content": "It is good if you are teaching someone how to use the LC platform. Not really for interviews."
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of tree is more than two ?\nThen this will become a medium level problem;\n\nHere is the code for this question if height of tree was more than two!!\n\n```\nclass Solution {\npublic boolean checkTree(TreeNode root) {\nif(root==null) return true;\nif(root.left==null&&root.right==null)\n     return true;\n    int sum=0;\n     if(root.left!=null)\n      sum+=root.left.val;\n        \n      if(root.right!=null) \n      sum+=root.right.val;\n       \n        return\n(sum==root.val&&checkTree(root.left)&&checkTree(root.right));\n    }\n}\n```\n\nplease upvote if you like this ![leetcode] "
                    },
                    {
                        "username": "deredskoy",
                        "content": "Everyone is wondering why there is this question at all, but for one year of dev I never even encountered a problem with nodes. Usually it's baskets or smiley faces, this one is a bit more mature. I guess it's what is educated in the uni "
                    },
                    {
                        "username": "yeedaKing",
                        "content": "True, I am a computer science major, and I have not been taught nodes/trees/graphs during my first year of college, Leetcode helped me learn what nodes and such are beforehand."
                    },
                    {
                        "username": "dilanekamga777",
                        "content": "The easiest problem on Tree"
                    },
                    {
                        "username": "Finesse",
                        "content": "Is there an easier problem on the whole LeetCode?\n\nUpdate: yes, it's «2235. Add Two Integers»"
                    },
                    {
                        "username": "tomereli",
                        "content": "But no tree knowledge required to solve it.."
                    },
                    {
                        "username": "nadabao",
                        "content": "\\u7B80\\u5355\\u5230\\u8BA9\\u4EBA\\u6D41\\u6CEA\\uFF0C\\u597D\\u611F\\u4EBA\\u3002\\u3002\\u3002"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "\\u592A\\u96E3\\u4E86\\uFF0C\\u6211\\u4E0D\\u6703 : ("
                    }
                ]
            },
            {
                "id": 2047005,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1945995,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1737102,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2047791,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2001533,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1998810,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2058053,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2051470,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2046940,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 2046108,
                "content": [
                    {
                        "username": "load-a",
                        "content": "Important Information:\\nI\\'m using Ruby but hopefully this helps others too.\\n- The `root` input is not an array, it is an instance of the `TreeNode` class. Likewise, the other values in the array are also nodes. It should actually look something like this, in my opinion:\\n`TreeNode.new(X, TreeNode.new(Y, nil, nil), TreeNode.new(Z, nil, nil))`\\n- Because of the above hint, `val` can (and must) be called on the root node\\'s `left` and `right` values.\\n\\nThis feels like a pretty mean trick for a beginner question."
                    },
                    {
                        "username": "Mudi26",
                        "content": "Wow thanks, i just added .val to the right and left as you said, and then it worked lol"
                    },
                    {
                        "username": "cheuyin",
                        "content": "This question is too hard."
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "exactly"
                    },
                    {
                        "username": "HelloWorldfromMine",
                        "content": "what I told myself : \\n-the struc has2 pointers for children\\n-root points to struc TreeNode which starts at the beg of the 3 numbers given. [root, left child, right child]\\n\\nas a total beg, it helped me connect the dots so I hope it helps someone looking for help."
                    },
                    {
                        "username": "EzequielGil",
                        "content": "\"the struc has2 pointers for children\", this totally helped me to understand how to refer to the values of the childs. Thank you so much for sharing! :)"
                    },
                    {
                        "username": "cs_can",
                        "content": "idk if it is just me? \\nit should be tagged hard.. spent 2 days solving it after looking so many solutions still didnt get it completely"
                    },
                    {
                        "username": "rebirthfox333",
                        "content": "2 days ? I spent 200 light years finally I passed."
                    },
                    {
                        "username": "mazharkafi",
                        "content": "If you are scared of solving  `Tree` problems, you should start with this."
                    },
                    {
                        "username": "khemendra123b",
                        "content": "Too easy to get disliked"
                    },
                    {
                        "username": "heriwahyudianto",
                        "content": "how to console.log?"
                    },
                    {
                        "username": "eagerLearner21",
                        "content": "I think the definition for binary tree is incorrect which may cause a confusion I tried accessing value at left and right node by using root.left and root.right but I was unaware that those are of type TreeNode in python they should have explicitly told about this ( I think so I\\'m a noob if there is some naive mistake please explain me of my mistake instead of replying by harsh comments)\\n"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "This is the easiest tree problem on this website."
                    },
                    {
                        "username": "smamir",
                        "content": "Can someone please explain the struct TreeNode part that is commented out?   "
                    },
                    {
                        "username": "load-a",
                        "content": "don\\'t know what language you\\'re using but I just posted a tip that might help"
                    }
                ]
            },
            {
                "id": 1997803,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1991957,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1990410,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1936881,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1926382,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1922463,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1903034,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1878259,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1853444,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            },
            {
                "id": 1842313,
                "content": [
                    {
                        "username": "lazlo2024",
                        "content": "I got a long way to go, this was rocket science to me."
                    },
                    {
                        "username": "MJ12_Believer",
                        "content": "IMO this is a really good intro binary trees. In my data structures class we focused a lot on theory and barely on implementation so this was a really good jumping off point for me."
                    },
                    {
                        "username": "JohnGiorgi",
                        "content": "Is there a reason the `root` argument to `checkTree` is type hinted as `Optional` in `Python3`?"
                    },
                    {
                        "username": "daddyunluck",
                        "content": "bro i searched children sum property leetcode and i got this, i\\'m not complaining tho."
                    },
                    {
                        "username": "kleinodergross",
                        "content": "Hello! Why this solution doesn't work?\n\n`bool checkTree(struct TreeNode* root){\n    if ((root->left + root->right) == root->val)}\n        return true;\n    } else {\n        return false;\n    }\n}` "
                    },
                    {
                        "username": "anonode",
                        "content": "Here is the corrected version of your code:\n```clang\nbool checkTree(struct TreeNode* root){ \n    if((root->left->val + root->right->val) == root->val){ return true;}\n     else { return false; } \n    }\n```\n\nThe reason why your solution doesn't work is because you are not accessing the values associated with root's child nodes. You were close by attempting to access with `root->left` and `root->right`. However, in order to access the *val* attribute of, for instance, root's left child, you must use `root->left->val`. \n\nThere was also a curly brace facing the wrong direction at the end of your if-statement. This generated one of the errors.\n\nAdditionally, the necessary code could have been condensed to one line without the use of an if-else statement:\n```c\nbool checkTree(struct TreeNode* root){\n    return root->val == (root->left->val + root->right->val);\n}\n```\n\nHere is a link to a markdown guide for leetcode that made the formatting of this comment possible: https://leetcode.com/discuss/general-discussion/1560831/markdown-reference-for-leetcode-formatting-cheatsheet\n\nBest of luck to you on your coding journey, [@Alfiya](/kleinodergross)!\n\n"
                    },
                    {
                        "username": "jerryy147",
                        "content": "despite the fact that this is the easiest question ever, this is also my first time using binary trees, so i got the question wrong once. That means it is officially harder than some other medium questions that i get first try"
                    },
                    {
                        "username": "aftab0711",
                        "content": "What if the height of Binary tree was more than two?\\n\\nhere the code for height more than two: https://leetcode.com/problems/root-equals-sum-of-children/solutions/3410421/what-if-the-height-of-the-tree-was-more-than-two/"
                    },
                    {
                        "username": "dhruvil2511",
                        "content": "wtf is this"
                    },
                    {
                        "username": "itzRAYY",
                        "content": " public boolean checkTree(TreeNode root) {\\n        return root.val == sumNodes(root,true);\\n    }\\n    public int sumNodes(TreeNode node,boolean root){\\n        if(node==null){\\n            return 0;\\n        }\\n        return root==false?node.val+sumNodes(node.left,false)+sumNodes(node.right,false):sumNodes(node.left,false)+sumNodes(node.right,false);\\n    }"
                    },
                    {
                        "username": "rahulsah6003",
                        "content": "Can someone tell me what happens if there is more then n nodes and we have to check for all of them ?"
                    },
                    {
                        "username": "Jeyko28",
                        "content": "I suppose that as in the first part made"
                    }
                ]
            }
        ]
    },
    {
        "title": "Find Resultant Array After Removing Anagrams",
        "question_content": "<p>You are given a <strong>0-indexed</strong> string array <code>words</code>, where <code>words[i]</code> consists of lowercase English letters.</p>\n\n<p>In one operation, select any index <code>i</code> such that <code>0 &lt; i &lt; words.length</code> and <code>words[i - 1]</code> and <code>words[i]</code> are <strong>anagrams</strong>, and <strong>delete</strong> <code>words[i]</code> from <code>words</code>. Keep performing this operation as long as you can select an index that satisfies the conditions.</p>\n\n<p>Return <code>words</code> <em>after performing all operations</em>. It can be shown that selecting the indices for each operation in <strong>any</strong> arbitrary order will lead to the same result.</p>\n\n<p>An <strong>Anagram</strong> is a word or phrase formed by rearranging the letters of a different word or phrase using all the original letters exactly once. For example, <code>&quot;dacb&quot;</code> is an anagram of <code>&quot;abdc&quot;</code>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;abba&quot;,&quot;baba&quot;,&quot;bbaa&quot;,&quot;cd&quot;,&quot;cd&quot;]\n<strong>Output:</strong> [&quot;abba&quot;,&quot;cd&quot;]\n<strong>Explanation:</strong>\nOne of the ways we can obtain the resultant array is by using the following operations:\n- Since words[2] = &quot;bbaa&quot; and words[1] = &quot;baba&quot; are anagrams, we choose index 2 and delete words[2].\n  Now words = [&quot;abba&quot;,&quot;baba&quot;,&quot;cd&quot;,&quot;cd&quot;].\n- Since words[1] = &quot;baba&quot; and words[0] = &quot;abba&quot; are anagrams, we choose index 1 and delete words[1].\n  Now words = [&quot;abba&quot;,&quot;cd&quot;,&quot;cd&quot;].\n- Since words[2] = &quot;cd&quot; and words[1] = &quot;cd&quot; are anagrams, we choose index 2 and delete words[2].\n  Now words = [&quot;abba&quot;,&quot;cd&quot;].\nWe can no longer perform any operations, so [&quot;abba&quot;,&quot;cd&quot;] is the final answer.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> words = [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]\n<strong>Output:</strong> [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]\n<strong>Explanation:</strong>\nNo two adjacent strings in words are anagrams of each other, so no operations are performed.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= words.length &lt;= 100</code></li>\n\t<li><code>1 &lt;= words[i].length &lt;= 10</code></li>\n\t<li><code>words[i]</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2040664,
                "title": "java-easy-two-methods-clean-simple",
                "content": "**Method 1**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\\n\\n**Method 2**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = words.length-1;i>= 0;i--){\\n            String s = words[i];\\n            while(!stack.isEmpty() && anagram(stack.peek(),s) == true)stack.pop();\\n            stack.push(s);\\n        }\\n        List<String> res = new ArrayList<>();\\n        while(!stack.isEmpty())res.add(stack.pop());\\n        return res;\\n    }\\n    \\n    public boolean anagram(String p,String q){\\n        int arr[] = new int[26];\\n        for(char i : p.toCharArray())arr[i-\\'a\\']+=1;\\n        for(char i : q.toCharArray())arr[i-\\'a\\']-=1;\\n        for(int i : arr)if(i != 0)return false;\\n        return true;\\n    }\\n}\\n```\\n**IF YOU LIKED THE APPROACH PLEASE UPVOTE \\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        Stack<String> stack = new Stack<>();\\n        for(int i = words.length-1;i>= 0;i--){\\n            String s = words[i];\\n            while(!stack.isEmpty() && anagram(stack.peek(),s) == true)stack.pop();\\n            stack.push(s);\\n        }\\n        List<String> res = new ArrayList<>();\\n        while(!stack.isEmpty())res.add(stack.pop());\\n        return res;\\n    }\\n    \\n    public boolean anagram(String p,String q){\\n        int arr[] = new int[26];\\n        for(char i : p.toCharArray())arr[i-\\'a\\']+=1;\\n        for(char i : q.toCharArray())arr[i-\\'a\\']-=1;\\n        for(int i : arr)if(i != 0)return false;\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039752,
                "title": "weird-description",
                "content": "Misread this question 2 times and wasted like 20 minutes. \\n\\n**Python 3**\\nWanted to bubble-up this solution by one of our humble commenters below (whose name rhymes with batman). \\n\\nApparently, `itertools.groupby` groups *consecutive* elements by a key (which is `sorted` here). And `next` takes the first element from that group.\\n\\nIt pays to learn vast and powerful Python libraries.\\n\\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [next(g) for _, g in groupby(w, sorted)]\\n```\\n\\nOriginal Solution\\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [w[i] for i in range(0, len(w)) if i == 0 or sorted(w[i]) != sorted(w[i - 1])]\\n```\\n#### Silly Hash\\nThis solution won\\'t work if there are hash collisions (unless we add a check). The idea is to compute a hash using characters value but not position. \\n\\nIf the size of words is limited to 10, computing a hash would be faster than comparing counter for 26 characters.\\n\\n**C++**\\n```cpp\\nvector<string> removeAnagrams(vector<string>& words) {\\n    long long hash = -1;\\n    vector<string> res;\\n    for (auto &w : words)\\n        if (auto new_hash = accumulate(begin(w), end(w), 0LL, [](long long s, char ch){ return s + (1 << (ch - \\'a\\')); });\\n            hash != new_hash) {\\n            res.push_back(w);\\n            hash = new_hash;\\n        }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [next(g) for _, g in groupby(w, sorted)]\\n```\n```python\\nclass Solution:\\n    def removeAnagrams(self, w: List[str]) -> List[str]:\\n        return [w[i] for i in range(0, len(w)) if i == 0 or sorted(w[i]) != sorted(w[i - 1])]\\n```\n```cpp\\nvector<string> removeAnagrams(vector<string>& words) {\\n    long long hash = -1;\\n    vector<string> res;\\n    for (auto &w : words)\\n        if (auto new_hash = accumulate(begin(w), end(w), 0LL, [](long long s, char ch){ return s + (1 << (ch - \\'a\\')); });\\n            hash != new_hash) {\\n            res.push_back(w);\\n            hash = new_hash;\\n        }\\n    return res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039931,
                "title": "2-pointers-without-sorting",
                "content": "**Description**:\\n+ For every we will put our **first pointer** at a string and **second pointer** at the next position of first pointer.\\n+ Keep on moving the **second pointer** by one step ahead if the string it is pointing is a anagram of string at **first pointer**.\\n+  If we found a string pointed by **second pointer** is not an anagram of string at first pointer then put string at **first pointer** in the answer array.\\n\\n> Instead of deleting words, we will skip it, this will save our time.\\n\\n# C++\\n\\n    vector<string> removeAnagrams(vector<string>& A) {\\n        vector<string> ans;\\n        int n= size(A);\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n and isang(A[i],A[j]) ) j++;\\n            ans.push_back(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    bool isang(string p,string q){\\n        vector<int> cnt(26);\\n        int res=0;\\n        for(auto i:p) cnt[i-\\'a\\']++;\\n        for(auto i:q) cnt[i-\\'a\\']--;         \\n        for(auto i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\n# Java\\n    public List<String> removeAnagrams(String[] A) {\\n        List<String> ans= new ArrayList<>();\\n        int n= A.length;\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n && isang(A[i],A[j]) ) j++;\\n            ans.add(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    boolean isang(String p,String q){\\n        int[] cnt= new int[26];\\n        int res=0;\\n        for(int i=0;i<p.length();i++) cnt[p.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<q.length();i++) cnt[q.charAt(i)-\\'a\\']--;\\n        for(int i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\t\\nTime - O(N * M)\\nSpace - O(1)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "**Description**:\\n+ For every we will put our **first pointer** at a string and **second pointer** at the next position of first pointer.\\n+ Keep on moving the **second pointer** by one step ahead if the string it is pointing is a anagram of string at **first pointer**.\\n+  If we found a string pointed by **second pointer** is not an anagram of string at first pointer then put string at **first pointer** in the answer array.\\n\\n> Instead of deleting words, we will skip it, this will save our time.\\n\\n# C++\\n\\n    vector<string> removeAnagrams(vector<string>& A) {\\n        vector<string> ans;\\n        int n= size(A);\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n and isang(A[i],A[j]) ) j++;\\n            ans.push_back(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    bool isang(string p,string q){\\n        vector<int> cnt(26);\\n        int res=0;\\n        for(auto i:p) cnt[i-\\'a\\']++;\\n        for(auto i:q) cnt[i-\\'a\\']--;         \\n        for(auto i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\n# Java\\n    public List<String> removeAnagrams(String[] A) {\\n        List<String> ans= new ArrayList<>();\\n        int n= A.length;\\n        for(int i=0;i<n;){\\n            int j=i+1;\\n            while( j<n && isang(A[i],A[j]) ) j++;\\n            ans.add(A[i]);\\n            i=j;\\n        }\\n        return ans;\\n    }\\n    //function for checking if two string are anagrams or not\\n    boolean isang(String p,String q){\\n        int[] cnt= new int[26];\\n        int res=0;\\n        for(int i=0;i<p.length();i++) cnt[p.charAt(i)-\\'a\\']++;\\n        for(int i=0;i<q.length();i++) cnt[q.charAt(i)-\\'a\\']--;\\n        for(int i:cnt) if(i!=0) return false;\\n        return true;\\n    }\\n\\t\\nTime - O(N * M)\\nSpace - O(1)",
                "codeTag": "Unknown"
            },
            {
                "id": 2039775,
                "title": "easy-c-solution-using-sorting",
                "content": "We take the first element and sort it to compare it with the second element.\\nIf both elements or strings are equal, we then delete ith element, else we go to next element.\\n\\n**Why are we doing i--? :**\\n```\\nOkay, lets take an array a= [\"abb\", \"bax\", \"xab\", \"axb\"]\\nsuppose we start loop, following are the iterations:\\nloop 1: compare \"bax\" with \"abb\", not anagram\\nloop 2: compare \"xab\" with \"bax\", it is anagram and we delete i th(2th) element, i.e, \"xab\", now array is = [\"abb\", \"bax\", \"axb\"];\\n            now i is still 2, we increment it by 3. Since 3>sizeof(arr) we get out of the loop.\\n            See, \"bax\" and \"axb\" are still anagram and we are not checking them.\\n            So while deleting element we decrease size of i, so that we make sure to compare the left elements.\\n```\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```\\n\\n\\n\\nHope you get it now :)",
                "solutionTags": [],
                "code": "```\\nOkay, lets take an array a= [\"abb\", \"bax\", \"xab\", \"axb\"]\\nsuppose we start loop, following are the iterations:\\nloop 1: compare \"bax\" with \"abb\", not anagram\\nloop 2: compare \"xab\" with \"bax\", it is anagram and we delete i th(2th) element, i.e, \"xab\", now array is = [\"abb\", \"bax\", \"axb\"];\\n            now i is still 2, we increment it by 3. Since 3>sizeof(arr) we get out of the loop.\\n            See, \"bax\" and \"axb\" are still anagram and we are not checking them.\\n            So while deleting element we decrease size of i, so that we make sure to compare the left elements.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039991,
                "title": "python-beginner-friendly-explanation-with-time-and-space-complexity-analysis",
                "content": "Two words are condidered as **anagram** if they have the same letters with exactly same letter counts. The order of the letters in the words does not matter.\\n\\n`E.g.: abbaa, aabab, aabbb, bbaaa, etc.. are all anagrams of each other as both have 2 letters \\'a\\' and \\'b\\' and both the letters in all the words have the same count, i.e., |a| = 3 and |b| = 2`.\\n\\nNow Since, the order doesn\\'t matter, **sorting them all will make them equal**. \\nE.g.: In the above example, if we sort all the words we get \\'aaabb\\'. Which means all of them are anagrams of each other.\\n\\nI hope finding anagrams is clear.\\n\\nNow, if word[i] and word[i+1] are anagrams, then remove word[i + 1] from the list, do not increment the index and compare again, else ignore and increment the index.\\n\\nThe full code (***written during contest***) is given below:\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\\n\\n**Time and Space complexity Analysis:**\\n* Let n = size of words array, and m = max length of a word.\\n\\nThe loop runs for \\'n\\' times and sorting takes \\'mlogm\\' time, and both are nested (done simultaneously).  Hence, **time complexity = O(n * mlogm)**.\\nNote that the time complexity can be easily reduced to ***O(n *  m)*** as finding anagrams can be done efficiently in O(m) time.\\nWe do not use any extra space, so space complexity = O(1) but sorting takes some internal space O(m). Thus, **space complexity = O(m)**.\\n\\nDo Upvote, if helpful.\\n\\n**EDIT:** The corresponding one liner for the above code (inspired from votrubac):\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[i] for i in range(0, len(words)) if i == 0 or sorted(words[i]) != sorted(words[i - 1])]\\n```\\n\\n***But wait can\\'t we do better?***\\n\\nYes actually, we can still reduce the time complexity. \\n\\n**Idea:** As anagrams must have same letters with same letter counts. We can count each letter in both the strings in O(n) time and match their counts in O(n) time sequentially (not simultaneously). Hence, **optimized time complexity** = O(n + n)  **= O(n)**.\\n\\nCan we reduce the sapce complexity?? => We will see after this code.\\n\\nThe **optimized solution** is given below:\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        def get_counts(x):\\n            \"\"\"\\n            As there are only 26 alphabets, make an array of constant size = 26 \\n            such that its index 0 maps to letter \\'a\\', 1 maps to \\'b\\' and so on...\\n            upto index 25 that maps to letter \\'z\\'\\n            \\n            E.g.: If we want count of letter \\'c\\', we will get it from count[2], \\n                  as index 2 maps to letter \\'c\\'.\\n                  \\n            But how will we do the mapping?\\n            \\n            There is a function in Python that returns a corresponding integer value for a character.\\n            \\n            ord(c) => return ordinal value of character \\'c\\'.\\n            \\n            index of a = 0 right? => ord(\\'a\\') - ord(\\'a\\')\\n            index of b = 1        => ord(\\'b\\') - ord(\\'a\\')\\n            .\\n            .\\n            .\\n            index of z = 25       => ord(\\'z\\') - ord(\\'a\\')\\n            \\n            \"\"\"\\n            count = [0] * 26 \\n            for c in x:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            return count\\n        \\n        \\n        if not words:\\n            return []\\n        \\n        \\n        i = 0\\n        while i < len(words) - 1:\\n            # just replace sort function by get_count functions\\n            if get_counts(words[i]) == get_counts(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\\n\\nIn the above code we have used a list, but it is always fixed in size (= 26 integers). Also apart from the list, we have used only fixed sized variables.\\n\\nSo **optimized space complexity = O(1)** = constant.\\n\\n`Hope it helps.` ***UPVOTE***.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if sorted(words[i]) == sorted(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[i] for i in range(0, len(words)) if i == 0 or sorted(words[i]) != sorted(words[i - 1])]\\n```\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        def get_counts(x):\\n            \"\"\"\\n            As there are only 26 alphabets, make an array of constant size = 26 \\n            such that its index 0 maps to letter \\'a\\', 1 maps to \\'b\\' and so on...\\n            upto index 25 that maps to letter \\'z\\'\\n            \\n            E.g.: If we want count of letter \\'c\\', we will get it from count[2], \\n                  as index 2 maps to letter \\'c\\'.\\n                  \\n            But how will we do the mapping?\\n            \\n            There is a function in Python that returns a corresponding integer value for a character.\\n            \\n            ord(c) => return ordinal value of character \\'c\\'.\\n            \\n            index of a = 0 right? => ord(\\'a\\') - ord(\\'a\\')\\n            index of b = 1        => ord(\\'b\\') - ord(\\'a\\')\\n            .\\n            .\\n            .\\n            index of z = 25       => ord(\\'z\\') - ord(\\'a\\')\\n            \\n            \"\"\"\\n            count = [0] * 26 \\n            for c in x:\\n                count[ord(c) - ord(\\'a\\')] += 1\\n            return count\\n        \\n        \\n        if not words:\\n            return []\\n        \\n        \\n        i = 0\\n        while i < len(words) - 1:\\n            # just replace sort function by get_count functions\\n            if get_counts(words[i]) == get_counts(words[i + 1]):\\n                words.remove(words[i + 1])\\n                continue\\n            i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039961,
                "title": "easy-cpp-solution-for-beginners-simple",
                "content": "```\\n\\nclass Solution {\\npublic:\\n\\nvector<string> removeAnagrams(vector<string>& w) {\\n   vector<string>ans;\\n\\n\\tstring x=w[0];\\n\\tans.push_back(x);\\n\\tsort(x.begin(), x.end());\\n\\n\\n\\tfor(int i=1;i<w.size();i++){\\n\\t\\tstring z=w[i];\\n\\t\\tsort(z.begin(), z.end());\\n\\t\\tif(x==z)\\n\\t\\t\\tcontinue;\\n\\t\\telse{\\n\\t\\t\\tans.push_back(w[i]);\\n\\t\\t\\tx=z;\\n\\t\\t}\\n\\n        }\\n      \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\nvector<string> removeAnagrams(vector<string>& w) {\\n   vector<string>ans;\\n\\n\\tstring x=w[0];\\n\\tans.push_back(x);\\n\\tsort(x.begin(), x.end());\\n\\n\\n\\tfor(int i=1;i<w.size();i++){\\n\\t\\tstring z=w[i];\\n\\t\\tsort(z.begin(), z.end());\\n\\t\\tif(x==z)\\n\\t\\t\\tcontinue;\\n\\t\\telse{\\n\\t\\t\\tans.push_back(w[i]);\\n\\t\\t\\tx=z;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2039900,
                "title": "python-3-intuitive-how-to-approach-o-n-without-sorting",
                "content": "# Goal\\nReturn the list of words after removing anagrams\\n\\n\\n# Approach\\n## 1. How do we know if those words have the same anagram? \\n\\nThose words have the same anagram if the words have the same letters even though they have different orders of letters.\\n\\n\"baby\" and \"ybba\" are anagrams because they have 2b, 1a, and 1y. It means we count the letters in the word. So, to solve this problem, we need to store the counter of the letter of the word as a key tuple in the dictionary (hashmap) and the value will be the word itself. To make it easier, the counter of the letter will be the list of 26 integers with 0 as the initialized number.\\n\\ne.g \\n- \"ab\" will be [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n- \"bapak\" will be [2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\\n\\n## 2. What if the counter of letters as key tuple exists in anagram? \\n\\nCheck if the previous word doesn\\'t have the same anagram, we can put the current word into result\\n\\nE.g words = [\"ab\", \"c\", \"ba\"]\\n1. \"ab\", we will have dictionary:\\n{(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'ab\\'}\\n2. \"c\" we will have dictionary: {(1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'ab\\', (0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0): \\'c\\'}\\n3. We know that the counter of phrase \"ba\" will be (1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) which is already exist in the dictionary. \\n\\nSo, does it mean we exclude phrase \"ba\"? The answer is NO because we should check the previous word == the word already stored in the same tuple counter or not. You could take a look the rule in the problem description that `select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words`. Therefore, if it\\'s not the same, we should include the word.\\n\\nCode:\\n\\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    anagrams = {}\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if tuple(counter) not in anagrams:\\n        res.append(word)\\n      else:\\n        if anagrams[tuple(counter)] != words[i-1]:\\n          res.append(word)\\n      anagrams[tuple(counter)] = word\\n    return res\\n```\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n# Can we do better?\\nYes, we can improve the space complexity slightly better by getting rid of the dictionary (hashmap). We just need to store the previous into the previous list. Thanks @codebreaker176 for the better code.\\n\\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    prev = []\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if counter != prev:\\n        res.append(word)\\n        prev = counter\\n    return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    anagrams = {}\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if tuple(counter) not in anagrams:\\n        res.append(word)\\n      else:\\n        if anagrams[tuple(counter)] != words[i-1]:\\n          res.append(word)\\n      anagrams[tuple(counter)] = word\\n    return res\\n```\n```python\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    res = []\\n    prev = []\\n\\n    for i in range(len(words)):\\n      word = words[i]\\n      counter = [0]*26\\n      for c in word:\\n        counter[ord(c)-ord(\\'a\\')] += 1\\n\\n      if counter != prev:\\n        res.append(word)\\n        prev = counter\\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2832345,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string x = words[i];\\n            sort(x.begin(),x.end());\\n            string y = words[i-1];\\n            sort(y.begin(),y.end());\\n            if(x == y){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2044880,
                "title": "python-counter-clean-code",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(1,len(words)):\\n            if Counter(res[-1]) != Counter(words[i]):\\n                res.append(words[i])\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(1,len(words)):\\n            if Counter(res[-1]) != Counter(words[i]):\\n                res.append(words[i])\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2045774,
                "title": "c-solution-with-picture-explanation-two-pointer-easy-solution",
                "content": "This is two-pointer approach. Keep the first pointer at the start of the array and keep moving the second pointer until you find a string which is not the anagram of the first pointer. Just when you find the desired string, move the first pointer to this position and start moving the second pointer ahead again.\\n\\n\\n![image](https://assets.leetcode.com/users/images/e705fbef-1f81-4183-a1d7-a18480ad6fa6_1652728455.4177735.jpeg)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {        \\n        vector<string> resultant_array;\\n        \\n\\t\\t// Keeping the first pointer at index 0 and the second pointer at index 1\\n        int ptr1 = 0;\\n        int ptr2 = 1;\\n        \\n        while(ptr2<=words.size()){\\n            string s1 = words[ptr1];\\n            sort(s1.begin(),s1.end());\\n            \\n            resultant_array.push_back(words[ptr1]);\\n            \\n            while(ptr2<words.size()){\\n                string s2 = words[ptr2];\\n                sort(s2.begin(), s2.end());\\n                \\n\\t\\t\\t\\t// Remember to compare the sorted arrays to check for anagrams\\n                if(s1!=s2){\\n                    break;\\n                }\\n                else{\\n                    ptr2++;\\n                }\\n            }\\n            \\n            ptr1 = ptr2;\\n            ptr2++;\\n        }\\n        \\n        return resultant_array;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {        \\n        vector<string> resultant_array;\\n        \\n\\t\\t// Keeping the first pointer at index 0 and the second pointer at index 1\\n        int ptr1 = 0;\\n        int ptr2 = 1;\\n        \\n        while(ptr2<=words.size()){\\n            string s1 = words[ptr1];\\n            sort(s1.begin(),s1.end());\\n            \\n            resultant_array.push_back(words[ptr1]);\\n            \\n            while(ptr2<words.size()){\\n                string s2 = words[ptr2];\\n                sort(s2.begin(), s2.end());\\n                \\n\\t\\t\\t\\t// Remember to compare the sorted arrays to check for anagrams\\n                if(s1!=s2){\\n                    break;\\n                }\\n                else{\\n                    ptr2++;\\n                }\\n            }\\n            \\n            ptr1 = ptr2;\\n            ptr2++;\\n        }\\n        \\n        return resultant_array;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162725,
                "title": "c-easiest-beginner-friendly-sol-o-n-m-26-time-and-o-n-m-space",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Create a vector called \"count\" with 26 elements, all initialized to 0.\\n2. Compare the length of two strings, if they are not equal, return false.\\n3. Increment the count of elements in \"count\" corresponding to the characters in string s and decrement the count of elements corresponding to the characters in string t.\\n4. Call the function \"countAllZeroes\" to check if all elements in \"count\" are 0, if yes return true, otherwise return false.\\n5. Create a vector called \"uniqueWords\" and insert the first element of the \"words\" vector into it.\\n6. Loop through the rest of the \"words\" vector and compare the current word with the previous word in \"uniqueWords\". If they are anagrams, skip this word and continue with the next word. If they are not anagrams, insert this word into \"uniqueWords\".\\n7. Return \"uniqueWords\".\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    bool countAllZeroes(vector<int>& count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isAnagram(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s[i] - \\'a\\']++;\\n            count[t[i] - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> uniqueWords;\\n        uniqueWords.push_back(words[0]);\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.push_back(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public boolean countAllZeroes(int[] count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean isAnagram(String s, String t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n            count[t.charAt(i) - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> uniqueWords = new ArrayList<>();\\n        uniqueWords.add(words[0]);\\n        for (int i = 1; i < words.length; i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.add(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def countAllZeroes(self, count):\\n        for i in range(26):\\n            if count[i] != 0:\\n                return False\\n        return True\\n    \\n    def isAnagram(self, s, t):\\n        n = len(s)\\n        m = len(t)\\n        if n != m:\\n            return False\\n        count = [0] * 26\\n        for i in range(n):\\n            count[ord(s[i]) - ord(\\'a\\')] += 1\\n            count[ord(t[i]) - ord(\\'a\\')] -= 1\\n        if self.countAllZeroes(count) == True:\\n            return True\\n        return False\\n    \\n    def removeAnagrams(self, words):\\n        uniqueWords = []\\n        uniqueWords.append(words[0])\\n        for i in range(1, len(words)):\\n            if self.isAnagram(words[i-1], words[i]):\\n                continue\\n            else:\\n                uniqueWords.append(words[i])\\n        return uniqueWords\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n * m * 26)**, where n is the number of words in the given list and m is the maximum length of a word. This is because for each pair of words, the time taken to check if they are anagrams of each other is O(m * 26), and this operation is repeated for n-1 pairs, giving us a time complexity of O(n * m * 26).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(n * m)**, where n is the number of words in the given list and m is the maximum length of a word. This is because we are using a list uniqueWords to store the unique words, and its length can be at most n.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool countAllZeroes(vector<int>& count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    bool isAnagram(string s, string t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        vector<int> count(26, 0);\\n        for (int i = 0; i < n; i++) {\\n            count[s[i] - \\'a\\']++;\\n            count[t[i] - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> uniqueWords;\\n        uniqueWords.push_back(words[0]);\\n        for (int i = 1; i < words.size(); i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.push_back(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public boolean countAllZeroes(int[] count) {\\n        for (int i = 0; i < 26; i++) {\\n            if (count[i] != 0)\\n                return false;\\n        }\\n        return true;\\n    }\\n    public boolean isAnagram(String s, String t) {\\n        int n = s.length();\\n        int m = t.length();\\n        if (n != m)\\n            return false;\\n        int[] count = new int[26];\\n        for (int i = 0; i < n; i++) {\\n            count[s.charAt(i) - \\'a\\']++;\\n            count[t.charAt(i) - \\'a\\']--;\\n        }\\n        if (countAllZeroes(count) == true)\\n            return true;\\n        return false;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> uniqueWords = new ArrayList<>();\\n        uniqueWords.add(words[0]);\\n        for (int i = 1; i < words.length; i++) {\\n            if (isAnagram(words[i-1], words[i]))\\n                continue;\\n            else\\n                uniqueWords.add(words[i]);\\n        }\\n        return uniqueWords;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def countAllZeroes(self, count):\\n        for i in range(26):\\n            if count[i] != 0:\\n                return False\\n        return True\\n    \\n    def isAnagram(self, s, t):\\n        n = len(s)\\n        m = len(t)\\n        if n != m:\\n            return False\\n        count = [0] * 26\\n        for i in range(n):\\n            count[ord(s[i]) - ord(\\'a\\')] += 1\\n            count[ord(t[i]) - ord(\\'a\\')] -= 1\\n        if self.countAllZeroes(count) == True:\\n            return True\\n        return False\\n    \\n    def removeAnagrams(self, words):\\n        uniqueWords = []\\n        uniqueWords.append(words[0])\\n        for i in range(1, len(words)):\\n            if self.isAnagram(words[i-1], words[i]):\\n                continue\\n            else:\\n                uniqueWords.append(words[i])\\n        return uniqueWords\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2753693,
                "title": "java-easy-solution",
                "content": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i-1],words[i])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    \\n     public boolean isAnagram(String s, String t) {\\n        char[] ss = s.toCharArray();\\n        Arrays.sort(ss);\\n         String s1 = new String(ss);\\n        \\n        char[] tt = t.toCharArray();\\n       Arrays.sort(tt);\\n         String s2 = new String(tt);\\n       \\n        \\n        return s1.equals(s2);\\n    }\\n}\\n// please upvote if it helps :)",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i-1],words[i])){\\n                list.add(words[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3154408,
                "title": "python-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while True:\\n            if i == len(words)-1:\\n                break\\n            if \\'\\'.join(sorted(words[i])) == \\'\\'.join(sorted(words[i+1])):\\n                words.pop(i+1)\\n                i-=1\\n            i+=1\\n        return words\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while True:\\n            if i == len(words)-1:\\n                break\\n            if \\'\\'.join(sorted(words[i])) == \\'\\'.join(sorted(words[i+1])):\\n                words.pop(i+1)\\n                i-=1\\n            i+=1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140655,
                "title": "fast-c-using-map-count-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimply sort each string and check adjacent if equal they are anagrams and if not then push them in answer .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting and Hash map\\n**Note**: Instead of normal sort I have used count sort which can be done when we have limited number of characters since string has only 26 charcaters so we can use it . And its time complexity is only $$O(n)$$ so very fast than  normal sort that takes $$O(nlogn)$$\\n# Complexity\\n- Time complexity:O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(26) not taking answer as space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  string count_sort(string s) {\\n        int mp[26] = {0};\\n        for (char c : s) {\\n            mp[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(mp[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       vector<string>ans;\\n       int n=words.size();\\n       ans.push_back(words[0]);\\n       for(int i=1;i<n;i++)\\n       // insted of count_sort u can stl sort but takes nlogn\\n           if(count_sort(words[i])==count_sort(words[i-1]));\\n           else ans.push_back(words[i]);\\n       \\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  string count_sort(string s) {\\n        int mp[26] = {0};\\n        for (char c : s) {\\n            mp[c - \\'a\\']++;\\n        }\\n        string t;\\n        for (int c = 0; c < 26; c++) {\\n            t += string(mp[c], c + \\'a\\');\\n        }\\n        return t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       vector<string>ans;\\n       int n=words.size();\\n       ans.push_back(words[0]);\\n       for(int i=1;i<n;i++)\\n       // insted of count_sort u can stl sort but takes nlogn\\n           if(count_sort(words[i])==count_sort(words[i-1]));\\n           else ans.push_back(words[i]);\\n       \\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351539,
                "title": "java-fast-solution",
                "content": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\n```\\n\\t\\tList<String> ans = new ArrayList<>();\\n        String temp = \"\";\\n        for (String s: words){\\n            char[] carr = s.toCharArray();\\n            Arrays.sort(carr);\\n            String curr = new String(carr);\\n            if (!curr.equals(temp))\\n                ans.add(s);\\n            temp = curr;\\n        }\\n        return ans;",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nPLEASE UPVOTE IF YOU LIKE.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2040051,
                "title": "python-easy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        \\n        i = 1\\n        while i < len(words):\\n            anagram = \"\".join(sorted(words[i]))\\n\\t\\t\\t# check if words[i-1] and words[i] are anagrams\\n            if anagram == \"\".join(sorted(words[i - 1])):\\n\\t\\t\\t\\t# if anagrams then remove second instance from the list of words\\n                words.pop(i)\\n            else:\\n                i += 1\\n                \\n        return words\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        \\n        i = 1\\n        while i < len(words):\\n            anagram = \"\".join(sorted(words[i]))\\n\\t\\t\\t# check if words[i-1] and words[i] are anagrams\\n            if anagram == \"\".join(sorted(words[i - 1])):\\n\\t\\t\\t\\t# if anagrams then remove second instance from the list of words\\n                words.pop(i)\\n            else:\\n                i += 1\\n                \\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3632776,
                "title": "remove-anagrams-4-liner-code-least-complexity",
                "content": "# KARRAR\\n>Anagrams...\\n>>Removing anagrams...\\n>>>Low time complexity...\\n>>>>Optimized and generalized solution...\\n>>>>>   Easy to understand...\\n-     PLEASE \\uD83D\\uDC4D\\uD83C\\uDFFB UPVOTE...\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach:\\n            Simplest approach...\\n            Sort the arrays and compare there indeces...\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: Beats 88% (57 ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: Beats 15% (16 MB)\\n\\n![image.png](https://assets.leetcode.com/users/images/939680b3-2168-420f-ba83-7b9ea6a45a55_1686651121.8875034.png)\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        ans=[words[0]]\\n        for i in range(1,len(words)):\\n            if(sorted(words[i-1])!=sorted(words[i])):\\n                ans.append(words[i])\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        ans=[words[0]]\\n        for i in range(1,len(words)):\\n            if(sorted(words[i-1])!=sorted(words[i])):\\n                ans.append(words[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466371,
                "title": "simple-approach-c",
                "content": "# Approach\\nThe Approach to this problem is to keep the point in mind that, \"if two strings are anagrams, and we sort them, both of them would be equal\"\\nfor example, \\n\"abba\" and \"bbaa\" are anagrams, and when we sort them, both of them would be \"aabb\" and \"aabb\".\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string s1 = words[i];\\n            string s2 = words[i-1];\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            if(s1 == s2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string s1 = words[i];\\n            string s2 = words[i-1];\\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            if(s1 == s2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141419,
                "title": "c-cpp",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i = words.size()-1;i>0;i--){\\n            string c1 = words[i];\\n            string c2 = words[i-1];\\n            sort(c1.begin() ,c1.end());\\n            sort(c2.begin() , c2.end());\\n            if(c1 == c2){\\n                words[i] = \"#\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]!= \"#\"){\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i = words.size()-1;i>0;i--){\\n            string c1 = words[i];\\n            string c2 = words[i-1];\\n            sort(c1.begin() ,c1.end());\\n            sort(c2.begin() , c2.end());\\n            if(c1 == c2){\\n                words[i] = \"#\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i=0;i<words.size();i++){\\n            if(words[i]!= \"#\"){\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040091,
                "title": "c-map-easy-stl",
                "content": "We will be maintaining a map for storing frequency of every word. If consecutive words have same frequency then word will become \"\".\\n```\\nclass Solution {\\npublic:\\n    bool map_compare (map<char,int>&lhs, map<char,int>&rhs) \\n    {\\n    // No predicate needed because there is operator== for pairs already.\\n    return lhs.size() == rhs.size()&& std::equal(lhs.begin(), lhs.end(),rhs.begin());\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            if(words[i]==\"\")continue;\\n            map<char,int>m1;\\n            for(char c:words[i])\\n            {\\n                m1[c]++;\\n            }\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                map<char,int>m2;\\n                for(char c:words[j])\\n                {\\n                    m2[c]++;\\n                }    \\n                if(map_compare(m1,m2)){\\n                    words[j]=\"\";                    \\n                } \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        for(string word:words)\\n        {\\n            if(word!=\"\")ans.push_back(word);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool map_compare (map<char,int>&lhs, map<char,int>&rhs) \\n    {\\n    // No predicate needed because there is operator== for pairs already.\\n    return lhs.size() == rhs.size()&& std::equal(lhs.begin(), lhs.end(),rhs.begin());\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        for(int i=0;i<words.size()-1;i++)\\n        {\\n            if(words[i]==\"\")continue;\\n            map<char,int>m1;\\n            for(char c:words[i])\\n            {\\n                m1[c]++;\\n            }\\n            for(int j=i+1;j<words.size();j++)\\n            {\\n                map<char,int>m2;\\n                for(char c:words[j])\\n                {\\n                    m2[c]++;\\n                }    \\n                if(map_compare(m1,m2)){\\n                    words[j]=\"\";                    \\n                } \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        for(string word:words)\\n        {\\n            if(word!=\"\")ans.push_back(word);\\n        }\\n\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2942687,
                "title": "c-solution-using-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1; i < words.size(); i++){ //start the loop from first index\\n            string a = words[i-1]; \\n            map <char, int> mp; //stores the details of the (i-1)st word\\n            for(int j = 0; j < a.length(); j++){\\n                mp[words[i-1][j]]++;\\n            }\\n            map <char, int> m; //stores the details of the i th word\\n            for(int h = 0; h < words[i].length(); h++){\\n                m[words[i][h]]++;\\n            }\\n            if(mp == m){ //if maps are equal then the words are anagrams\\n                words.erase(words.begin() + i);\\n                i--; //as we delete from the vector, we need to reset i to i-1\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1; i < words.size(); i++){ //start the loop from first index\\n            string a = words[i-1]; \\n            map <char, int> mp; //stores the details of the (i-1)st word\\n            for(int j = 0; j < a.length(); j++){\\n                mp[words[i-1][j]]++;\\n            }\\n            map <char, int> m; //stores the details of the i th word\\n            for(int h = 0; h < words[i].length(); h++){\\n                m[words[i][h]]++;\\n            }\\n            if(mp == m){ //if maps are equal then the words are anagrams\\n                words.erase(words.begin() + i);\\n                i--; //as we delete from the vector, we need to reset i to i-1\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2056341,
                "title": "python-small-easy-to-understand-solution",
                "content": "Runtime: 52 ms, faster than 96.66% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\nMemory Usage: 13.8 MB, less than 75.32% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    key = \"\"\\n    result = []\\n    \\n    for word in words:\\n      letters = list(word)\\n      letters.sort()\\n      new_key = \"\".join(letters)\\n      \\n      if new_key != key :\\n        key = new_key\\n        result.append(word)\\n        \\n    return result\\n```\\n\\n**More understanding variant :**\\n\\n**idea of solution :**\\n1. get first word from array and sorting it and retain as **key** and put first word in answer(**result**) \\n2. in loop will give all words from array starting with index 1\\n3. for each word will check : is the sorting rearranging of this word equal **key** or not ?\\n a. is eqaul : ignore this word\\n b. isn\\'t equal : put this word in answer and update **key**\\nRuntime: 56 ms, faster than 93.03% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\nMemory Usage: 13.8 MB, less than 75.32% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    def sort_construct(word):\\n      letters = list(word)\\n      letters.sort()\\n      return \"\".join(letters)\\n    \\n    key = sort_construct(words[0])\\n    result = [words[0]]\\n    \\n    for i in range(1, len(words)):\\n      new_key = sort_construct(words[i])\\n      if new_key != key :\\n        key = new_key\\n        result.append(words[i])\\n        \\n    return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    key = \"\"\\n    result = []\\n    \\n    for word in words:\\n      letters = list(word)\\n      letters.sort()\\n      new_key = \"\".join(letters)\\n      \\n      if new_key != key :\\n        key = new_key\\n        result.append(word)\\n        \\n    return result\\n```\n```\\nclass Solution:\\n  def removeAnagrams(self, words: List[str]) -> List[str]:\\n    def sort_construct(word):\\n      letters = list(word)\\n      letters.sort()\\n      return \"\".join(letters)\\n    \\n    key = sort_construct(words[0])\\n    result = [words[0]]\\n    \\n    for i in range(1, len(words)):\\n      new_key = sort_construct(words[i])\\n      if new_key != key :\\n        key = new_key\\n        result.append(words[i])\\n        \\n    return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043991,
                "title": "clear-and-easily-understandable",
                "content": "```\\nclass Solution {\\n\\tpublic static List<String> removeAnagrams(String[] words) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tString next = \"\";\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tchar tempArray[] = words[i].toCharArray();\\n\\t\\t\\tArrays.sort(tempArray);\\n\\t\\t\\tString temp = new String(tempArray);\\n\\t\\t\\tif ((!temp.equals(next))) {\\n\\t\\t\\t\\tans.add(words[i]);\\n\\t\\t\\t}\\n\\t\\t\\tnext = temp;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static List<String> removeAnagrams(String[] words) {\\n\\t\\tList<String> ans = new ArrayList<>();\\n\\t\\tString next = \"\";\\n\\t\\tfor (int i = 0; i < words.length; i++) {\\n\\t\\t\\tchar tempArray[] = words[i].toCharArray();\\n\\t\\t\\tArrays.sort(tempArray);\\n\\t\\t\\tString temp = new String(tempArray);\\n\\t\\t\\tif ((!temp.equals(next))) {\\n\\t\\t\\t\\tans.add(words[i]);\\n\\t\\t\\t}\\n\\t\\t\\tnext = temp;\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040665,
                "title": "c-one-pass-o-1-space",
                "content": "```\\n   int n=words.size();\\n        vector<string> ans;\\n        ans.emplace_back(words[0]);\\n        vector<int> f1(26,0);\\n        for(auto it : words[0]) f1[it-\\'a\\']++;\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> f2(26,0);\\n            for(auto it : words[i])\\n            {\\n                f2[it-\\'a\\']++;\\n            }\\n            if(f1==f2) continue;\\n            else \\n            {\\n                ans.emplace_back(words[i]);\\n                f1=f2;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int n=words.size();\\n        vector<string> ans;\\n        ans.emplace_back(words[0]);\\n        vector<int> f1(26,0);\\n        for(auto it : words[0]) f1[it-\\'a\\']++;\\n        for(int i=1;i<n;i++)\\n        {\\n            vector<int> f2(26,0);\\n            for(auto it : words[i])\\n            {\\n                f2[it-\\'a\\']++;\\n            }\\n            if(f1==f2) continue;\\n            else \\n            {\\n                ans.emplace_back(words[i]);\\n                f1=f2;\\n            }\\n        }\\n        return ans;   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3409786,
                "title": "find-resultant-array-after-removing-anagrams-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0;\\n        while(i<words.size()-1)\\n        {\\n            string s1 = words[i];\\n            sort(s1.begin(), s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(), s2.end());\\n\\n            if(s1==s2)\\n            {\\n                words.erase(words.begin()+i+1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0;\\n        while(i<words.size()-1)\\n        {\\n            string s1 = words[i];\\n            sort(s1.begin(), s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(), s2.end());\\n\\n            if(s1==s2)\\n            {\\n                words.erase(words.begin()+i+1);\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2762311,
                "title": "java-88-faster-not-using-maps",
                "content": "# Code\\n```\\nclass Solution {\\n\\n    static short[] alph;\\n\\n    public List<String> removeAnagrams(String[] words) {\\n        alph = new short[26];\\n        if (words.length == 1) {\\n            List<String> list = new ArrayList<>();\\n            list.add(words[0]);\\n            return list;\\n        }\\n\\n        List<String> list = new ArrayList<>(words.length);\\n\\n        for (String word : words) {\\n            list.add(word);\\n        }\\n        int idx = 1;\\n        while (idx < list.size()) {\\n            if (hasNextAnagram(list, idx)) {\\n                list.remove(idx);\\n                continue;\\n            }\\n            idx++;\\n        }\\n        return list;\\n    }\\n\\n    private static boolean hasNextAnagram(List<String> list, int idx) {\\n        return isAnagram(list.get(idx), list.get(idx - 1));\\n    }\\n\\n    private static boolean isAnagram(String one, String two) {\\n        for (int i = 0; i < one.length(); i++) {\\n            char c = one.charAt(i);\\n            alph[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < two.length(); i++) {\\n            char c = two.charAt(i);\\n            alph[c - \\'a\\']--;\\n        }\\n        boolean isAnagram = true;\\n        for (int i = 0; i < alph.length; i++) {\\n            if (alph[i] != 0) {\\n                isAnagram = false;\\n            }\\n            alph[i] = 0;\\n        }\\n        return isAnagram;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    static short[] alph;\\n\\n    public List<String> removeAnagrams(String[] words) {\\n        alph = new short[26];\\n        if (words.length == 1) {\\n            List<String> list = new ArrayList<>();\\n            list.add(words[0]);\\n            return list;\\n        }\\n\\n        List<String> list = new ArrayList<>(words.length);\\n\\n        for (String word : words) {\\n            list.add(word);\\n        }\\n        int idx = 1;\\n        while (idx < list.size()) {\\n            if (hasNextAnagram(list, idx)) {\\n                list.remove(idx);\\n                continue;\\n            }\\n            idx++;\\n        }\\n        return list;\\n    }\\n\\n    private static boolean hasNextAnagram(List<String> list, int idx) {\\n        return isAnagram(list.get(idx), list.get(idx - 1));\\n    }\\n\\n    private static boolean isAnagram(String one, String two) {\\n        for (int i = 0; i < one.length(); i++) {\\n            char c = one.charAt(i);\\n            alph[c - \\'a\\']++;\\n        }\\n        for (int i = 0; i < two.length(); i++) {\\n            char c = two.charAt(i);\\n            alph[c - \\'a\\']--;\\n        }\\n        boolean isAnagram = true;\\n        for (int i = 0; i < alph.length; i++) {\\n            if (alph[i] != 0) {\\n                isAnagram = false;\\n            }\\n            alph[i] = 0;\\n        }\\n        return isAnagram;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2754510,
                "title": "c-solution",
                "content": "```\\n#define MAX_LENGTH      (100+4)\\n\\nint compareChar(const void* c1, const void* c2)\\n{\\n    // ascending order\\n    return (*(char*)c1 - *(char*)c2);\\n}\\n\\nbool isAnagrams(char* pSrc, char* pDst)\\n{\\n    int retVal = false;\\n\\n    char sortSrc[MAX_LENGTH];\\n    memset(sortSrc, 0, sizeof(sortSrc));\\n    snprintf(sortSrc, sizeof(sortSrc), \"%s\", pSrc);\\n    qsort(sortSrc, strlen(sortSrc), sizeof(char), compareChar);\\n\\n    char sortDst[MAX_LENGTH];\\n    memset(sortDst, 0, sizeof(sortDst));\\n    snprintf(sortDst, sizeof(sortDst), \"%s\", pDst);\\n    qsort(sortDst, strlen(sortDst), sizeof(char), compareChar);\\n\\n    if (strcmp(sortSrc, sortDst) == 0)\\n    {\\n        retVal = true;\\n    }\\n\\n    return retVal;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }\\n\\n        if ((*returnSize) != i)\\n        {\\n            free(words[(*returnSize)]);\\n            words[(*returnSize)] = NULL;\\n\\n            len = strlen(words[i]) + 1;\\n            words[(*returnSize)] = (char*)malloc(len*sizeof(char));\\n            if (words[(*returnSize)] == NULL)\\n            {\\n                perror(\"malloc\");\\n                return words;\\n            }\\n            memset(words[(*returnSize)], 0, len*sizeof(char));\\n            snprintf(words[(*returnSize)], len*sizeof(char), \"%s\", words[i]);\\n        }\\n\\n        (*returnSize)++;\\n    }\\n\\n    return words;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define MAX_LENGTH      (100+4)\\n\\nint compareChar(const void* c1, const void* c2)\\n{\\n    // ascending order\\n    return (*(char*)c1 - *(char*)c2);\\n}\\n\\nbool isAnagrams(char* pSrc, char* pDst)\\n{\\n    int retVal = false;\\n\\n    char sortSrc[MAX_LENGTH];\\n    memset(sortSrc, 0, sizeof(sortSrc));\\n    snprintf(sortSrc, sizeof(sortSrc), \"%s\", pSrc);\\n    qsort(sortSrc, strlen(sortSrc), sizeof(char), compareChar);\\n\\n    char sortDst[MAX_LENGTH];\\n    memset(sortDst, 0, sizeof(sortDst));\\n    snprintf(sortDst, sizeof(sortDst), \"%s\", pDst);\\n    qsort(sortDst, strlen(sortDst), sizeof(char), compareChar);\\n\\n    if (strcmp(sortSrc, sortDst) == 0)\\n    {\\n        retVal = true;\\n    }\\n\\n    return retVal;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nchar ** removeAnagrams(char ** words, int wordsSize, int* returnSize){\\n    (*returnSize) = 1;\\n\\n    int len;\\n    int i;\\n    for (i=1; i<wordsSize; ++i)\\n    {\\n        if (isAnagrams(words[(*returnSize)-1], words[i]) == true)\\n        {\\n            continue;\\n        }\\n\\n        if ((*returnSize) != i)\\n        {\\n            free(words[(*returnSize)]);\\n            words[(*returnSize)] = NULL;\\n\\n            len = strlen(words[i]) + 1;\\n            words[(*returnSize)] = (char*)malloc(len*sizeof(char));\\n            if (words[(*returnSize)] == NULL)\\n            {\\n                perror(\"malloc\");\\n                return words;\\n            }\\n            memset(words[(*returnSize)], 0, len*sizeof(char));\\n            snprintf(words[(*returnSize)], len*sizeof(char), \"%s\", words[i]);\\n        }\\n\\n        (*returnSize)++;\\n    }\\n\\n    return words;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517232,
                "title": "vector-manipulation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& ans) {\\n     \\n        vector<string> words = ans;\\n        int i=0;\\n        while(i<words.size()-1){\\n            string s1 = words[i];\\n            string s2 = words[i+1];\\n            \\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            \\n            if(s1.compare(s2)==0){\\n                words.erase(words.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& ans) {\\n     \\n        vector<string> words = ans;\\n        int i=0;\\n        while(i<words.size()-1){\\n            string s1 = words[i];\\n            string s2 = words[i+1];\\n            \\n            sort(s1.begin(), s1.end());\\n            sort(s2.begin(), s2.end());\\n            \\n            if(s1.compare(s2)==0){\\n                words.erase(words.begin()+i+1);\\n            }\\n            else i++;\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474416,
                "title": "easy-c-solution-o-n",
                "content": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        vector<string> temp;\\n        for(auto s:words)\\n        {\\n            sort(s.begin(),s.end());\\n            temp.push_back(s);\\n        }\\n        for(int i = 0;i<temp.size();i++)\\n        {\\n            if((i==0) || temp[i] != temp[i-1])\\n            {\\n                ans.push_back(words[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        vector<string> temp;\\n        for(auto s:words)\\n        {\\n            sort(s.begin(),s.end());\\n            temp.push_back(s);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2391910,
                "title": "python-one-liner-95-speed",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[0]]+[words[i] for i in range(1,len(words)) if sorted(words[i])!=sorted(words[i-1])]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return [words[0]]+[words[i] for i in range(1,len(words)) if sorted(words[i])!=sorted(words[i-1])]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345429,
                "title": "python-5-lines",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(len(words)):\\n            #check anagram\\n            if sorted(words[i-1])!=sorted(words[i]):\\n                res.append(words[i])\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for i in range(len(words)):\\n            #check anagram\\n            if sorted(words[i-1])!=sorted(words[i]):\\n                res.append(words[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2208901,
                "title": "time-0-n-and-space-0-1",
                "content": "````\\nvar removeAnagrams = function(words) {\\n    let n = words.length;\\n    \\n    for(let i=0; i<n-1; i++){\\n        if(isAnagram(words[i], words[i+1])){\\n            words.splice(i+1, 1);\\n            i--\\n            n--\\n        }\\n    }\\n    return words\\n};\\n\\nfunction isAnagram(a, b){\\n    \\n    let freqArr = new Array(26).fill(0);\\n    if(a.length != b.length) return false\\n    \\n    for(let i=0; i<a.length; i++){\\n        let idx1 = a[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx1]++;\\n        let idx2 = b[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx2]--\\n    }\\n\\n    \\n    for(let i=0; i<26; i++){\\n        if(freqArr[i] > 0){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n````",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "````\\nvar removeAnagrams = function(words) {\\n    let n = words.length;\\n    \\n    for(let i=0; i<n-1; i++){\\n        if(isAnagram(words[i], words[i+1])){\\n            words.splice(i+1, 1);\\n            i--\\n            n--\\n        }\\n    }\\n    return words\\n};\\n\\nfunction isAnagram(a, b){\\n    \\n    let freqArr = new Array(26).fill(0);\\n    if(a.length != b.length) return false\\n    \\n    for(let i=0; i<a.length; i++){\\n        let idx1 = a[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx1]++;\\n        let idx2 = b[i].charCodeAt(0) - \"a\".charCodeAt(0);\\n        freqArr[idx2]--\\n    }\\n\\n    \\n    for(let i=0; i<26; i++){\\n        if(freqArr[i] > 0){\\n            return false\\n        }\\n    }\\n    return true\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2192113,
                "title": "c-basic-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>v1;\\n        v1.push_back(words[0]);\\n        string prev=words[0];\\n        sort(prev.begin(),prev.end());\\n        \\n        for(int i=1;i<words.size();i++)\\n        {\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            \\n            if(s!=prev)\\n            {\\n                v1.push_back(words[i]);\\n                prev = s;\\n            }\\n            \\n        }\\n        return v1;  \\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>v1;\\n        v1.push_back(words[0]);\\n        string prev=words[0];\\n        sort(prev.begin(),prev.end());\\n        \\n        for(int i=1;i<words.size();i++)\\n        {\\n            string s = words[i];\\n            sort(s.begin(),s.end());\\n            \\n            if(s!=prev)\\n            {\\n                v1.push_back(words[i]);\\n                prev = s;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2127195,
                "title": "simple-and-easy-javascript-typescript-solution",
                "content": "My simple and easy JavaScript/TypeScript solution:\\n```\\nfunction removeAnagrams(words: string[]): string[] {\\n    const newWords = [];\\n    let prevSortedWord = \\'\\';\\n    for (const word of words) {\\n        const sortedWord = word.split(\\'\\').sort().join(\\'\\');\\n        if (sortedWord === prevSortedWord) continue;\\n        \\n        prevSortedWord = sortedWord;\\n        newWords.push(word);\\n    }\\n    return newWords;\\n};\\n```\\nRuntime:\\xA081 ms, faster than\\xA097.92%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Find Resultant Array After Removing Anagrams.\\nMemory Usage:\\xA048.7 MB, less than\\xA089.58%\\xA0of\\xA0TypeScript\\xA0online submissions for\\xA0Find Resultant Array After Removing Anagrams.\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sorting"
                ],
                "code": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    const newWords = [];\\n    let prevSortedWord = \\'\\';\\n    for (const word of words) {\\n        const sortedWord = word.split(\\'\\').sort().join(\\'\\');\\n        if (sortedWord === prevSortedWord) continue;\\n        \\n        prevSortedWord = sortedWord;\\n        newWords.push(word);\\n    }\\n    return newWords;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2042605,
                "title": "c",
                "content": "```\\n    public IList<string> RemoveAnagrams(string[] words)\\n    {\\n        IList<string> result = new List<string>();\\n        result.Add(words[0]);\\n        for (int i = 1; i < words.Length; i++)\\n        {\\n            if (String.Concat(words[i].OrderBy(a => a)) != String.Concat(words[i - 1].OrderBy(a => a)))\\n                result.Add(words[i]);\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public IList<string> RemoveAnagrams(string[] words)\\n    {\\n        IList<string> result = new List<string>();\\n        result.Add(words[0]);\\n        for (int i = 1; i < words.Length; i++)\\n        {\\n            if (String.Concat(words[i].OrderBy(a => a)) != String.Concat(words[i - 1].OrderBy(a => a)))\\n                result.Add(words[i]);\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2039880,
                "title": "c-implementation-clean-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    bool anagram(string str1, string str2)\\n{\\n    // Get lengths of both strings\\n    int n1 = str1.length();\\n    int n2 = str2.length();\\n \\n    // If length of both strings is not same, then they\\n    // cannot be anagram\\n    if (n1 != n2)\\n        return false;\\n \\n    // Sort both the strings\\n    sort(str1.begin(), str1.end());\\n    sort(str2.begin(), str2.end());\\n \\n    // Compare sorted strings\\n    for (int i = 0; i < n1; i++)\\n        if (str1[i] != str2[i])\\n            return false;\\n \\n    return true;\\n}\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        vector<string>ans;\\n        int n=words.size();\\n        int i,j;\\n        map<int,int>ma;\\n        while(1)\\n        {\\n            bool be=false;\\n            \\n            for(i=1;i<n;i++)\\n            {\\n                if(ma[i]!=1 and anagram(words[i],words[i-1]))\\n                {\\n                    ma[i]=1;\\n                    be=true;\\n                    break;\\n                }\\n            }\\n            if(be==false)\\n                break;\\n            \\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(ma[i]!=1)\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n**Pls upvote the post if you found helpful.\\nDo comment down your doubts if any.\\nTill then, happy coding : )**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool anagram(string str1, string str2)\\n{\\n    // Get lengths of both strings\\n    int n1 = str1.length();\\n    int n2 = str2.length();\\n \\n    // If length of both strings is not same, then they\\n    // cannot be anagram\\n    if (n1 != n2)\\n        return false;\\n \\n    // Sort both the strings\\n    sort(str1.begin(), str1.end());\\n    sort(str2.begin(), str2.end());\\n \\n    // Compare sorted strings\\n    for (int i = 0; i < n1; i++)\\n        if (str1[i] != str2[i])\\n            return false;\\n \\n    return true;\\n}\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        vector<string>ans;\\n        int n=words.size();\\n        int i,j;\\n        map<int,int>ma;\\n        while(1)\\n        {\\n            bool be=false;\\n            \\n            for(i=1;i<n;i++)\\n            {\\n                if(ma[i]!=1 and anagram(words[i],words[i-1]))\\n                {\\n                    ma[i]=1;\\n                    be=true;\\n                    break;\\n                }\\n            }\\n            if(be==false)\\n                break;\\n            \\n        }\\n        for(i=0;i<n;i++)\\n        {\\n            if(ma[i]!=1)\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039835,
                "title": "c-beginner-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>res;\\n        set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            sort(temp.begin(),temp.end());\\n            if(st.count(temp)){\\n                continue;\\n            }\\n            else{\\n                res.push_back(words[i]);\\n                st.erase(st.begin(),st.end());\\n                st.insert(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>res;\\n        set<string>st;\\n        for(int i=0;i<words.size();i++){\\n            string temp=words[i];\\n            sort(temp.begin(),temp.end());\\n            if(st.count(temp)){\\n                continue;\\n            }\\n            else{\\n                res.push_back(words[i]);\\n                st.erase(st.begin(),st.end());\\n                st.insert(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039786,
                "title": "c-solution-easy-understanding-sorting",
                "content": "```\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>ans;\\n     ans.push_back(words[0]);\\n    for (int i = 1; i<words.size(); i++) \\n    { \\n        string a=words[i];\\n        string b=ans[ans.size()-1];\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n    }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\n    vector<string> removeAnagrams(vector<string>& words) {\\n     vector<string>ans;\\n     ans.push_back(words[0]);\\n    for (int i = 1; i<words.size(); i++) \\n    { \\n        string a=words[i];\\n        string b=ans[ans.size()-1];\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a!=b)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n    }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2039762,
                "title": "java-store-previous-anagrams-string",
                "content": "Store the previous anagram string with characters sorted. Iterate over the words, if the anagramStr is newly seen, add the current to the result and update the lastAnagramStr; if the anagramStr is the same as lastAnagramStr, skip.\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new LinkedList<>();\\n        String lastAnagramStr = null;\\n        for (String s : words) {\\n            char[] charArr = s.toCharArray();\\n            Arrays.sort(charArr);\\n            String curAnagramStr = new String(charArr);\\n            \\n            if (curAnagramStr.equals(lastAnagramStr)) {\\n                continue;\\n            }\\n            else {\\n                lastAnagramStr = curAnagramStr;\\n                result.add(s);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new LinkedList<>();\\n        String lastAnagramStr = null;\\n        for (String s : words) {\\n            char[] charArr = s.toCharArray();\\n            Arrays.sort(charArr);\\n            String curAnagramStr = new String(charArr);\\n            \\n            if (curAnagramStr.equals(lastAnagramStr)) {\\n                continue;\\n            }\\n            else {\\n                lastAnagramStr = curAnagramStr;\\n                result.add(s);\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039732,
                "title": "python-simple-solution-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return words\\n        i = 1 \\n        while i<len(words):\\n            if sorted(list(words[i]))==sorted(list(words[i-1])):\\n                words.pop(i)\\n            else:\\n                i+=1 \\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words)==1:\\n            return words\\n        i = 1 \\n        while i<len(words):\\n            if sorted(list(words[i]))==sorted(list(words[i-1])):\\n                words.pop(i)\\n            else:\\n                i+=1 \\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039720,
                "title": "create-stack-and-compare-with-top-of-stack",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack = []\\n        for w in words:\\n            if len(stack) == 0 or sorted(w) != sorted(stack[-1]):\\n                stack.append(w)\\n        return stack\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack = []\\n        for w in words:\\n            if len(stack) == 0 or sorted(w) != sorted(stack[-1]):\\n                stack.append(w)\\n        return stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3924820,
                "title": "java-solution-easy-to-understand",
                "content": "\\n\\n## Intuition\\nThe problem is about removing anagrams from an array of strings and returning a list of strings where each string is not an anagram of any other string in the list.\\n\\n## Approach\\n1. **isAnagram Method**: The `isAnagram` method checks whether two input strings are anagrams of each other or not. It sorts the characters of both strings and compares them. If the sorted arrays of characters are equal, then the strings are anagrams.\\n\\n2. **removeAnagrams Method**: The `removeAnagrams` method iterates through the array of strings and uses the `isAnagram` method to identify and mark anagrams.\\n   - It maintains a boolean array `vis` to track visited words (anagrams are marked as visited).\\n   - For each word at index `i`, it searches for the next non-visited word (starting from `i + 1`) and marks it as visited if it\\'s an anagram.\\n   - After marking all anagrams, the method adds the non-visited words to the result list.\\n\\n## Complexity\\n- **Time complexity**:\\n   - The `isAnagram` method sorts two char arrays, which takes O(k * log(k)) time complexity, where k is the length of the longest string in the array.\\n   - The main part of the time complexity comes from the nested loops in the `removeAnagrams` method. The outer loop runs in O(n) time, and for each word, the inner loop can run up to n - 1 times (when all words are anagrams of each other). The `isAnagram` method itself takes O(k * log(k)) time in the worst case. So, the overall time complexity is O(n^2 * k * log(k)).\\n\\n- **Space complexity**:\\n   - The space complexity of the `isAnagram` method is O(k), where k is the length of the longest string.\\n   - The `removeAnagrams` method uses a boolean array `vis` of size n to mark visited words, so the space complexity is O(n).\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())return false;\\n        char a[]=s1.toCharArray();\\n        char b[]=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<a.length;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list=new ArrayList<>();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            while(vis[j]==true){\\n                j++;\\n            }\\n            if(isAnagram(words[i],words[j])){\\n                vis[j]=true;\\n            }\\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```\\n# Give me ThumsUp if it helps for you \\uD83D\\uDC4D\\uD83D\\uDC4D\\uD83D\\uDE09\\uD83D\\uDE09",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())return false;\\n        char a[]=s1.toCharArray();\\n        char b[]=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        for(int i=0;i<a.length;i++){\\n            if(a[i]!=b[i])return false;\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list=new ArrayList<>();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            while(vis[j]==true){\\n                j++;\\n            }\\n            if(isAnagram(words[i],words[j])){\\n                vis[j]=true;\\n            }\\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752922,
                "title": "python-easy-solution-stack",
                "content": "# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def check(self,word1: str,word2: str)->bool:\\n        word1=list(word1)\\n        word1.sort()\\n        word2=list(word2)\\n        word2.sort()\\n        if word1==word2:\\n            return 1\\n        return 0\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        lis=[]\\n        for i in range(len(words)):\\n            if len(lis)==0 or Solution.check(self,lis[len(lis)-1],words[i])==0:\\n                lis.append(words[i])\\n        return lis            \\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def check(self,word1: str,word2: str)->bool:\\n        word1=list(word1)\\n        word1.sort()\\n        word2=list(word2)\\n        word2.sort()\\n        if word1==word2:\\n            return 1\\n        return 0\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        lis=[]\\n        for i in range(len(words)):\\n            if len(lis)==0 or Solution.check(self,lis[len(lis)-1],words[i])==0:\\n                lis.append(words[i])\\n        return lis            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490966,
                "title": "pattern-c",
                "content": "# Intuition\\nBasic two pointer pattern.\\n\\nA lot of similar questions can be solved with this like \\nhttps://leetcode.com/problems/sort-array-by-parity-ii\\nremove element \\nRemove Duplicates from Sorted Array - LeetCode\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe can have two pointers as i=0,j=0 and k=0 as counter to replace the words vector according to question.\\nIncrease j till words[i] and words[j] aree not anagrams anymore\\n\\n         - - - - - -\\n         i     j\\n\\nso we got one element words[i] do the same for all the elements \\none corner case has to be taken into account\\n# Complexity\\n- Time complexity:\\nO(n*m)\\n\\n- Space complexity:\\nO(1);\\n\\n# Code\\nclass Solution {\\npublic:\\n\\n    bool anagram(string &str1,string &str2){\\n        int cnt[256]={0};\\n        int n=str1.length();\\n        int m=str2.length();\\n        if(n != m){\\n            return false;\\n        }\\n        for(int i=0;i<n;i++){\\n            cnt[str1[i]-\\'a\\']++;\\n            cnt[str2[i]-\\'a\\']--;\\n        }\\n        for(int i=0;i<256;i++){\\n            if(cnt[i] !=0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int r= words.size();\\n        int i=0,j=0,k=0;\\n        while(j<r){\\n            \\n            while(j<r && anagram(words[j],words[i]) == true){\\n                j++;\\n            }\\n            \\n            if(j<r && !anagram(words[j],words[i])){\\n                words[k]=words[i];\\n                cout<<k;\\n                k++;\\n                i=j;\\n            }\\n        }\\n        // if(k==0){\\n        //     words.resize(1);\\n        // }\\n        // else{\\n        //     words.resize(k);\\n        // }\\n\\n        if(j==r){\\n            words[k]=words[i];\\n        }\\n        k++;\\n        words.resize(k);\\n        return  words;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool anagram(string &str1,string &str2){\\n        int cnt[256]={0}",
                "codeTag": "Java"
            },
            {
                "id": 3280257,
                "title": "easy-solution",
                "content": "# Code\\n```\\nfunc removeAnagrams(words []string) []string {\\n    \\n    j := 0\\n\\n    for i, v := range words {\\n        if v != \"\" {\\n             for j := i+1; j < len(words); j++ {\\n                if sort(v) == sort(words[j]) {\\n                    words[j] = \"\"\\n                }else{\\n                    break\\n                }\\n            }\\n            words[j] = v\\n            j++\\n        }\\n    }\\n    \\n\\n    return words[:j]\\n}\\n\\nfunc sort(str string) string {\\n  runes := []rune(str)\\n\\n    // Bubble sort the slice of runes\\n    for i := 0; i < len(runes); i++ {\\n        for j := i + 1; j < len(runes); j++ {\\n            if runes[i] > runes[j] {\\n                temp := runes[i]\\n                runes[i] = runes[j]\\n                runes[j] = temp\\n            }\\n        }\\n    }\\n\\n    // Convert the slice of runes back to a string\\n    sortedStr := string(runes)\\n\\n    return sortedStr\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc removeAnagrams(words []string) []string {\\n    \\n    j := 0\\n\\n    for i, v := range words {\\n        if v != \"\" {\\n             for j := i+1; j < len(words); j++ {\\n                if sort(v) == sort(words[j]) {\\n                    words[j] = \"\"\\n                }else{\\n                    break\\n                }\\n            }\\n            words[j] = v\\n            j++\\n        }\\n    }\\n    \\n\\n    return words[:j]\\n}\\n\\nfunc sort(str string) string {\\n  runes := []rune(str)\\n\\n    // Bubble sort the slice of runes\\n    for i := 0; i < len(runes); i++ {\\n        for j := i + 1; j < len(runes); j++ {\\n            if runes[i] > runes[j] {\\n                temp := runes[i]\\n                runes[i] = runes[j]\\n                runes[j] = temp\\n            }\\n        }\\n    }\\n\\n    // Convert the slice of runes back to a string\\n    sortedStr := string(runes)\\n\\n    return sortedStr\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3202524,
                "title": "5-lines-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        x=[words[0]]\\n        for i in range(1,len(words)):\\n            if sorted(x[-1])!=sorted(words[i]):\\n                x.append(words[i])\\n        return x\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        x=[words[0]]\\n        for i in range(1,len(words)):\\n            if sorted(x[-1])!=sorted(words[i]):\\n                x.append(words[i])\\n        return x\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3031282,
                "title": "itertools-is-awesome",
                "content": "Here\\'s a one-liner\\n\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return (next(val) for _, val in groupby(words, key=sorted))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        return (next(val) for _, val in groupby(words, key=sorted))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902430,
                "title": "easy-js-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n   for(let i =1;i<words.length; i++){\\n       if(isAnagram(words[i], words[i-1])){\\n           words.splice(i,1);\\n           i--;\\n       }\\n   } \\n    return words;\\n   function isAnagram(s1, s2){\\n       let arr1 = s1.split(\"\");\\n       let arr2 = s2.split(\"\");\\n       if(arr1.length != arr2.length) return false;\\n       for(let i =0; i<arr1.length; i++){\\n           if(arr2.includes(arr1[i])){\\n               arr2.splice(arr2.indexOf(arr1[i]),1);\\n           }\\n       }\\n       return arr2.length ===0;\\n   }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n   for(let i =1;i<words.length; i++){\\n       if(isAnagram(words[i], words[i-1])){\\n           words.splice(i,1);\\n           i--;\\n       }\\n   } \\n    return words;\\n   function isAnagram(s1, s2){\\n       let arr1 = s1.split(\"\");\\n       let arr2 = s2.split(\"\");\\n       if(arr1.length != arr2.length) return false;\\n       for(let i =0; i<arr1.length; i++){\\n           if(arr2.includes(arr1[i])){\\n               arr2.splice(arr2.indexOf(arr1[i]),1);\\n           }\\n       }\\n       return arr2.length ===0;\\n   }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2849481,
                "title": "simple-c-solution-for-beginners-c-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCompare the two adjacent elemets and if not equal push into result array\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the two strings for comparision\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n  O(nlogn)\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\\\\\n        vector<string> ans;\\n        ans.push_back(words[0]);\\n        for(int i=1;i<words.size();i++) {\\n            string a = words[i] , b = words[i-1];\\n            sort(a.begin() , a.end());\\n            sort(b.begin() , b.end());\\n            if(a != b) ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\\\\\n        vector<string> ans;\\n        ans.push_back(words[0]);\\n        for(int i=1;i<words.size();i++) {\\n            string a = words[i] , b = words[i-1];\\n            sort(a.begin() , a.end());\\n            sort(b.begin() , b.end());\\n            if(a != b) ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2751510,
                "title": "python-counter-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res=[words[0]] \\n        for i in range(1,len(words)):\\n            mp1,mp2=Counter(words[i-1]),Counter(words[i]) \\n            if mp1!=mp2:\\n                res.append(words[i]) \\n        return res\\n\\t\\t#misread easy to medium\\n        # s=[]\\n        # ans=[]\\n        # for i in words:\\n        #     mp=[0]*26 \\n        #     for j in i:\\n        #         mp[ord(j)-ord(\"a\")]+=1\\n        #     if str(mp) in s:\\n        #         continue\\n        #     else:\\n        #         ans.append(i)\\n        #         s.append(str(mp))\\n        # return ans\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res=[words[0]] \\n        for i in range(1,len(words)):\\n            mp1,mp2=Counter(words[i-1]),Counter(words[i]) \\n            if mp1!=mp2:\\n                res.append(words[i]) \\n        return res\\n\\t\\t#misread easy to medium\\n        # s=[]\\n        # ans=[]\\n        # for i in words:\\n        #     mp=[0]*26 \\n        #     for j in i:\\n        #         mp[ord(j)-ord(\"a\")]+=1\\n        #     if str(mp) in s:\\n        #         continue\\n        #     else:\\n        #         ans.append(i)\\n        #         s.append(str(mp))\\n        # return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2599969,
                "title": "java-string-sorting-simple-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev = \"\";\\n        ArrayList<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev = \"\";\\n        ArrayList<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597106,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()==1)\\n        {\\n            return {words[0]};\\n        }\\n        vector<string>ans;\\n        string temp1=\"\";\\n        string temp2=\"\";\\n        int i=0;\\n        int j=1;\\n        temp1=words[i];\\n        sort(temp1.begin(),temp1.end());\\n        temp2=words[j];\\n        sort(temp2.begin(),temp2.end());\\n        while(j<words.size())\\n        {\\n            temp2=words[j];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1==temp2)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                ans.push_back(words[i]);\\n                i=j;\\n                temp1=words[i];\\n                sort(temp1.begin(),temp1.end());\\n                j++;\\n            }\\n        }\\n        if(temp1==temp2)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n        else\\n        {\\n             ans.push_back(words[i]);\\n              ans.push_back(words[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()==1)\\n        {\\n            return {words[0]};\\n        }\\n        vector<string>ans;\\n        string temp1=\"\";\\n        string temp2=\"\";\\n        int i=0;\\n        int j=1;\\n        temp1=words[i];\\n        sort(temp1.begin(),temp1.end());\\n        temp2=words[j];\\n        sort(temp2.begin(),temp2.end());\\n        while(j<words.size())\\n        {\\n            temp2=words[j];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1==temp2)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                ans.push_back(words[i]);\\n                i=j;\\n                temp1=words[i];\\n                sort(temp1.begin(),temp1.end());\\n                j++;\\n            }\\n        }\\n        if(temp1==temp2)\\n        {\\n            ans.push_back(words[i]);\\n        }\\n        else\\n        {\\n             ans.push_back(words[i]);\\n              ans.push_back(words[j]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549497,
                "title": "my-js-solution-easy-and-simple-to-understand",
                "content": "```javascript\\nconst removeAnagrams = function(words) {  \\n  if (words.length === 0) return [];\\n  \\n const result = [words[0]];\\n  for (let i = 1, j = 0; i < words.length; i++) {\\n    const isAnagramTrue = isAnagram(result[j], words[i]);\\n    \\n    if (!isAnagramTrue) {\\n      result.push(words[i]);\\n      j++;\\n    }\\n  }\\n\\n  return result;\\n};\\n\\nconst isAnagram = function (str1, str2) {\\n  const firstStr = str1;\\n  const secondStr = str2;\\n  \\n  if (firstStr === secondStr) return true;\\n  if (firstStr.length !== secondStr.length) return false;\\n  \\n  const firstHashMap = {};\\n  const secondHashMap = {};\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]])\\n      firstHashMap[firstStr[i]]++;\\n    else\\n      firstHashMap[firstStr[i]] = 1;\\n    \\n    if (secondHashMap[secondStr[i]])\\n      secondHashMap[secondStr[i]]++;\\n    else \\n      secondHashMap[secondStr[i]] = 1;\\n  }\\n\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]] !== secondHashMap[firstStr[i]]) return false;\\n  }\\n  \\n  return true;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst removeAnagrams = function(words) {  \\n  if (words.length === 0) return [];\\n  \\n const result = [words[0]];\\n  for (let i = 1, j = 0; i < words.length; i++) {\\n    const isAnagramTrue = isAnagram(result[j], words[i]);\\n    \\n    if (!isAnagramTrue) {\\n      result.push(words[i]);\\n      j++;\\n    }\\n  }\\n\\n  return result;\\n};\\n\\nconst isAnagram = function (str1, str2) {\\n  const firstStr = str1;\\n  const secondStr = str2;\\n  \\n  if (firstStr === secondStr) return true;\\n  if (firstStr.length !== secondStr.length) return false;\\n  \\n  const firstHashMap = {};\\n  const secondHashMap = {};\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]])\\n      firstHashMap[firstStr[i]]++;\\n    else\\n      firstHashMap[firstStr[i]] = 1;\\n    \\n    if (secondHashMap[secondStr[i]])\\n      secondHashMap[secondStr[i]]++;\\n    else \\n      secondHashMap[secondStr[i]] = 1;\\n  }\\n\\n  \\n  for (let i = 0; i < firstStr.length; i++) {\\n    if (firstHashMap[firstStr[i]] !== secondHashMap[firstStr[i]]) return false;\\n  }\\n  \\n  return true;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2531100,
                "title": "find-resultant-array-after-removing-anagrams-solution",
                "content": "C++ Simple Solution\\n\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        for(int i=0;i<words.size();i++){\\n            string str = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            if( i > 0 && words[i]==words[i-1]) continue;\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        for(int i=0;i<words.size();i++){\\n            string str = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            if( i > 0 && words[i]==words[i-1]) continue;\\n            res.push_back(str);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530295,
                "title": "c-solution-faster-than-100",
                "content": "```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n            IList<string> list = new List<string>();\\n            Stack<string> stack = new Stack<string>();\\n            int n = words.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                char[] str = words[i].ToCharArray();\\n                Array.Sort(str);\\n                if (stack.Count == 0)\\n                {\\n                    stack.Push(new string(str));\\n                    list.Add(words[i]);\\n                }\\n                else\\n                {\\n                    if(!stack.Peek().Equals(new string(str)))\\n                    {\\n                        list.Add(words[i]);\\n                        stack.Push(new string(str));\\n                    }\\n                }\\n            }\\n            return list;\\n    }\\n}",
                "solutionTags": [
                    "C#",
                    "String",
                    "Stack"
                ],
                "code": "class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n            IList<string> list = new List<string>();\\n            Stack<string> stack = new Stack<string>();\\n            int n = words.Length;\\n            for (int i = 0; i < n; i++)\\n            {\\n                char[] str = words[i].ToCharArray();\\n                Array.Sort(str);\\n                if (stack.Count == 0)\\n                {\\n                    stack.Push(new string(str));\\n                    list.Add(words[i]);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2372879,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        print(res)\\n        for i in range(1,len(words)):\\n            if sorted(words[i])!=sorted(words[i-1]):\\n                res.append(words[i])\\n        return res\\n```\\n***if useful then vote up***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        print(res)\\n        for i in range(1,len(words)):\\n            if sorted(words[i])!=sorted(words[i-1]):\\n                res.append(words[i])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345096,
                "title": "java-o-n-2-solution-with-comments-to-understand-2-pointer-method",
                "content": "**Please Upvote if  you liked and simply understand the solution it means world to me!!**\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < words.length;) {\\n\\t\\t// we will run loop from 0 to words.length for i.\\n            int j;\\n            for (j = i + 1; j < words.length; j++) {\\n\\t\\t\\t// we will check if anagram strings or not\\n\\t\\t\\t// if not then we will break the looop\\n                if (!isAnagram(words[i], words[j])) {\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// after breaking the loop we will add our first anagram number ar ith index \\n\\t\\t\\t//after that we will set i to j\\n            ans.add(words[i]);\\n            i = j;\\n        }\\n\\n        return ans;\\n    }\\n\\t\\n\\t// function to know wheather two strings are anagram or not\\n    boolean isAnagram(String s, String t) {\\n\\t\\n\\t//if lengths of both strings is not equal they cannot be anagram\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//conver the both strings into the character arrays\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\t\\t\\n\\t\\t//sort the respectively both arrays\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n\\t\\t// check if elements of both sorted arrays are equal or not\\n        for (int i = 0; i < c2.length; i++) {\\n            if (c1[i] != c2[i]) {\\n\\t\\t\\t// if elements are not equal then return false.\\n                return false;\\n            }\\n        }\\n\\t\\t// loop over means all the elements are equal so it is anagram reutrning true\\n        return true;\\n}\\n}\\n```\\n**Thank You!!**\\n**if you liked solution please upvote!!**",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = 0; i < words.length;) {\\n\\t\\t// we will run loop from 0 to words.length for i.\\n            int j;\\n            for (j = i + 1; j < words.length; j++) {\\n\\t\\t\\t// we will check if anagram strings or not\\n\\t\\t\\t// if not then we will break the looop\\n                if (!isAnagram(words[i], words[j])) {\\n                    break;\\n                }\\n            }\\n\\t\\t\\t// after breaking the loop we will add our first anagram number ar ith index \\n\\t\\t\\t//after that we will set i to j\\n            ans.add(words[i]);\\n            i = j;\\n        }\\n\\n        return ans;\\n    }\\n\\t\\n\\t// function to know wheather two strings are anagram or not\\n    boolean isAnagram(String s, String t) {\\n\\t\\n\\t//if lengths of both strings is not equal they cannot be anagram\\n        if (s.length() != t.length()) {\\n            return false;\\n        }\\n\\t\\t\\n\\t\\t//conver the both strings into the character arrays\\n        char[] c1 = s.toCharArray();\\n        char[] c2 = t.toCharArray();\\n\\t\\t\\n\\t\\t//sort the respectively both arrays\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n\\n\\t\\t// check if elements of both sorted arrays are equal or not\\n        for (int i = 0; i < c2.length; i++) {\\n            if (c1[i] != c2[i]) {\\n\\t\\t\\t// if elements are not equal then return false.\\n                return false;\\n            }\\n        }\\n\\t\\t// loop over means all the elements are equal so it is anagram reutrning true\\n        return true;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338945,
                "title": "py-nerd-counter-frequency-list-no-sorting",
                "content": "### The main idea:\\n1. use Counter or Frequency list to identify anagrams\\n2. use `prev` (the most recent Counter) to remove adjcent anagrams\\n\\nComment below for any questions / corrections\\n\\n\\n### how to implement Freq. list\\n```\\nlst = [0] * 26\\noffset = ord(\\'a\\')\\nfor c in s:\\n\\tlst[ord(c) - offset] +=1\\n```\\n\\n### Main algo\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        prev = None\\n        for w in words:\\n            count = Counter(w)\\n            if count != prev:\\n                res.append(w)\\n                prev = count\\n        return res\\n    # time O(n * k) visit each word, and Counter takes k = longest word len\\n    # space O(n) at most save n words\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nlst = [0] * 26\\noffset = ord(\\'a\\')\\nfor c in s:\\n\\tlst[ord(c) - offset] +=1\\n```\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        prev = None\\n        for w in words:\\n            count = Counter(w)\\n            if count != prev:\\n                res.append(w)\\n                prev = count\\n        return res\\n    # time O(n * k) visit each word, and Counter takes k = longest word len\\n    # space O(n) at most save n words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2227786,
                "title": "simple-and-easy-c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        res.push_back(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string temp1 = words[i];\\n            string temp2 = words[i-1];\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            if(temp1!= temp2)\\n                res.push_back(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> res;\\n        res.push_back(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string temp1 = words[i];\\n            string temp2 = words[i-1];\\n            sort(temp1.begin(), temp1.end());\\n            sort(temp2.begin(), temp2.end());\\n            if(temp1!= temp2)\\n                res.push_back(words[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2110139,
                "title": "stack-based-solution-c",
                "content": "```\\n\\n```class Solution {\\npublic:\\n    bool isanagram(string x,string y)\\n    {\\n        sort(x.begin(),x.end());\\n        sort(y.begin(),y.end());\\n        if(x==y)\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++)\\n        {\\n            if(isanagram(s.top(),words[i]))\\n            {\\n                continue;\\n            }\\n            s.push(words[i]);\\n        }\\n        while(!s.empty())\\n        {\\n            ans.push_back(s.top());\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2104358,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        tmp = words[0] \\n        words = words[1:]\\n        ans = [tmp] \\n        while words: \\n            if sorted(words[0]) != sorted(tmp): \\n                tmp = words[0]\\n                ans.append(tmp)\\n            words.pop(0)\\n                \\n        return ans",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        tmp = words[0] \\n        words = words[1:]\\n        ans = [tmp] \\n        while words: \\n            if sorted(words[0]) != sorted(tmp): \\n                tmp = words[0]\\n                ans.append(tmp)\\n            words.pop(0)\\n                \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2104211,
                "title": "simple-python-solution-easy-to-understand",
                "content": "```\\n\\n```def removeAnagrams(self, words: List[str]) -> List[str]:\\n        \\n        save = []\\n        save.append(words[0])\\n        \\n        for i in range(1, len(words)):\\n            save.append(words[i])\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                save.pop()\\n        \\n        return save",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2085199,
                "title": "swift-simple-and-easy-to-understand-solution",
                "content": "```\\nlass Solution {\\n    func removeAnagrams(_ words: [String]) -> [String] {\\n\\n        var answer = words\\n        var i = 0\\n\\n        while i < answer.count - 1 {\\n\\n            if answer[i].sorted() == answer[i+1].sorted() {\\n                answer.remove(at: i+1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\t\\t\\n        return answer\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nlass Solution {\\n    func removeAnagrams(_ words: [String]) -> [String] {\\n\\n        var answer = words\\n        var i = 0\\n\\n        while i < answer.count - 1 {\\n\\n            if answer[i].sorted() == answer[i+1].sorted() {\\n                answer.remove(at: i+1)\\n            } else {\\n                i += 1\\n            }\\n        }\\n\\t\\t\\n        return answer\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2081579,
                "title": "easy-cpp-maps",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        vector<string>temp=words;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n        unordered_map<string,int>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            auto it=s.find(temp[i]);\\n            \\n            if(it==s.end()||i-it->second>1)\\n            {\\n               ans.push_back(words[i]);\\n            }\\n            else if(it!=s.end())\\n            {\\n                s.erase(temp[i]);\\n            }\\n            s[temp[i]]=i;\\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        vector<string>temp=words;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n        unordered_map<string,int>s;\\n        for(int i=0;i<words.size();i++)\\n        {\\n            auto it=s.find(temp[i]);\\n            \\n            if(it==s.end()||i-it->second>1)\\n            {\\n               ans.push_back(words[i]);\\n            }\\n            else if(it!=s.end())\\n            {\\n                s.erase(temp[i]);\\n            }\\n            s[temp[i]]=i;\\n            \\n        }\\n       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077569,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        res.add(words[0]);\\n        for(int i=1; i<words.length; i++){\\n            String left = toSorted(words[i-1]);\\n            String right = toSorted(words[i]);\\n            if(!left.equals(right)){\\n                res.add(words[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public String toSorted(String strs){\\n        char[] ch = strs.toCharArray();\\n        Arrays.sort(ch);\\n        String key = String.valueOf(ch);\\n       \\n        return key;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        res.add(words[0]);\\n        for(int i=1; i<words.length; i++){\\n            String left = toSorted(words[i-1]);\\n            String right = toSorted(words[i]);\\n            if(!left.equals(right)){\\n                res.add(words[i]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    public String toSorted(String strs){\\n        char[] ch = strs.toCharArray();\\n        Arrays.sort(ch);\\n        String key = String.valueOf(ch);\\n       \\n        return key;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2067894,
                "title": "easy-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isequal(string x, string y) {\\n        vector<int> ans(26, 0);\\n        for (int j = 0; j < x.size(); j++) {\\n            ans[x[j] - \\'a\\']++;\\n        }\\n        for (int k = 0; k < y.size(); k++) {\\n            ans[y[k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < ans.size(); k++) {\\n            if (ans[k] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> harsh;\\n        for (int i = 0; i < words.size();) {\\n            int j = i + 1;\\n            for (; j < words.size() and isequal(words[i], words[j]);) {\\n                j++;\\n            }\\n            harsh.push_back(words[i]);\\n            i = j;\\n        }\\n        return harsh;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isequal(string x, string y) {\\n        vector<int> ans(26, 0);\\n        for (int j = 0; j < x.size(); j++) {\\n            ans[x[j] - \\'a\\']++;\\n        }\\n        for (int k = 0; k < y.size(); k++) {\\n            ans[y[k] - \\'a\\']--;\\n        }\\n        for (int k = 0; k < ans.size(); k++) {\\n            if (ans[k] != 0) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> harsh;\\n        for (int i = 0; i < words.size();) {\\n            int j = i + 1;\\n            for (; j < words.size() and isequal(words[i], words[j]);) {\\n                j++;\\n            }\\n            harsh.push_back(words[i]);\\n            i = j;\\n        }\\n        return harsh;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2066230,
                "title": "python3-solution-readable",
                "content": "```\\nclass Solution:\\n    \\n    def anagram_detector(self, a: str, b: str) -> bool:\\n        a =sorted(list(a))\\n        b = sorted(list(b))\\n        if a == b:\\n            return True\\n        else:\\n            return False\\n        \\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        while len(words) > 2:\\n            detected = False\\n            for i in range(1,len(words)):\\n                if self.anagram_detector(words[i],words[i-1]):\\n                    del words[i]\\n                    detected = True\\n                    break\\n            if not detected:\\n                return words\\n        if self.anagram_detector(words[0],words[1]):\\n            del words[1]\\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def anagram_detector(self, a: str, b: str) -> bool:\\n        a =sorted(list(a))\\n        b = sorted(list(b))\\n        if a == b:\\n            return True\\n        else:\\n            return False\\n        \\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        if len(words) == 1:\\n            return words\\n        while len(words) > 2:\\n            detected = False\\n            for i in range(1,len(words)):\\n                if self.anagram_detector(words[i],words[i-1]):\\n                    del words[i]\\n                    detected = True\\n                    break\\n            if not detected:\\n                return words\\n        if self.anagram_detector(words[0],words[1]):\\n            del words[1]\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2064281,
                "title": "java-simple-fast-low-memory",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> ans = new ArrayList<>(words.length);\\n        byte[] sign = new byte[26], tmp, buf = new byte[26];\\n        for (String s : words) {\\n            Arrays.fill(buf, (byte) 0);\\n            for (int i=0, slen=s.length(); i < slen; i++) {\\n                buf[s.charAt(i) - \\'a\\']++;\\n            }\\n            if (Arrays.equals(sign, buf)) continue;\\n            tmp = sign; sign = buf; buf = tmp; // swap\\n            ans.add(s);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> ans = new ArrayList<>(words.length);\\n        byte[] sign = new byte[26], tmp, buf = new byte[26];\\n        for (String s : words) {\\n            Arrays.fill(buf, (byte) 0);\\n            for (int i=0, slen=s.length(); i < slen; i++) {\\n                buf[s.charAt(i) - \\'a\\']++;\\n            }\\n            if (Arrays.equals(sign, buf)) continue;\\n            tmp = sign; sign = buf; buf = tmp; // swap\\n            ans.add(s);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054934,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String>res = new LinkedList<>();\\n        for (String word:words){\\n            if (res.isEmpty() || !isAnagram(word, res.get(res.size()-1)))res.add(word);\\n        }\\n        return res;\\n    }\\n    \\n    public Boolean isAnagram(String w1, String w2){\\n        if (w1.length()!=w2.length())return false;\\n        else {\\n            char[] word1 = w1.toCharArray();\\n            Arrays.sort(word1);\\n            char[] word2 = w2.toCharArray();\\n            Arrays.sort(word2);\\n            return Arrays.equals(word1, word2);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String>res = new LinkedList<>();\\n        for (String word:words){\\n            if (res.isEmpty() || !isAnagram(word, res.get(res.size()-1)))res.add(word);\\n        }\\n        return res;\\n    }\\n    \\n    public Boolean isAnagram(String w1, String w2){\\n        if (w1.length()!=w2.length())return false;\\n        else {\\n            char[] word1 = w1.toCharArray();\\n            Arrays.sort(word1);\\n            char[] word2 = w2.toCharArray();\\n            Arrays.sort(word2);\\n            return Arrays.equals(word1, word2);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2054810,
                "title": "4-lines-solution-with-counter",
                "content": "What do you think about this solution?\\n\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\t# `Counter` makes a letter frequency dictionary\\n\\t\\t\\t#  the == operator compares the two dictionaries\\n\\t\\t\\t#  if anagrams then delete the next word\\n\\t\\t\\t#  otherwise, we increment the pointer\\n        \\n        pointer = 0\\n        while pointer < len(words)-1:\\n            if ( Counter(words[pointer]) == Counter(words[pointer+1])  ):\\n                words.pop(pointer+1)\\n            else:\\n                pointer+=1\\n        return words\\n\\t```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\t# `Counter` makes a letter frequency dictionary\\n\\t\\t\\t#  the == operator compares the two dictionaries\\n\\t\\t\\t#  if anagrams then delete the next word\\n\\t\\t\\t#  otherwise, we increment the pointer\\n        \\n        pointer = 0\\n        while pointer < len(words)-1:\\n            if ( Counter(words[pointer]) == Counter(words[pointer+1])  ):\\n                words.pop(pointer+1)\\n            else:\\n                pointer+=1\\n        return words\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2053561,
                "title": "c-easy-understanding-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n    /* \\n      words[i-1] and words[i] are anagrams when:\\n        +) words[i-1].size() == words[i].size();\\n        +) occurrence of each letter in words[i] equals to that in words[i-1]\\n    */\\n    for (int i = 1; i < words.size();){\\n        // We iterate from 1 to the end of list\\n        map<char, int> mp1, mp2;\\n        // We use map to store the occurrence of each letter in words[i] and words[i-1]\\n        for(char &x : words[i-1]) mp1[x]++;\\n        for(char &x : words[i]) mp2[x]++;\\n        if(mp1 == mp2){\\n            // If words[i] and words[i-1] are anagrams, we delete words[i] from the list\\n            words.erase(words.begin()+i);\\n        }else i++;\\n    }\\n    return words;        \\n}\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n    /* \\n      words[i-1] and words[i] are anagrams when:\\n        +) words[i-1].size() == words[i].size();\\n        +) occurrence of each letter in words[i] equals to that in words[i-1]\\n    */\\n    for (int i = 1; i < words.size();){\\n        // We iterate from 1 to the end of list\\n        map<char, int> mp1, mp2;\\n        // We use map to store the occurrence of each letter in words[i] and words[i-1]\\n        for(char &x : words[i-1]) mp1[x]++;\\n        for(char &x : words[i]) mp2[x]++;\\n        if(mp1 == mp2){\\n            // If words[i] and words[i-1] are anagrams, we delete words[i] from the list\\n            words.erase(words.begin()+i);\\n        }else i++;\\n    }\\n    return words;        \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2050674,
                "title": "java-solution",
                "content": "```java \\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> a = new ArrayList<String>();\\n        a.add(words[0]);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            if(check(words[i],words[i-1])==false)\\n                a.add(words[i]);\\n        }\\n        return a;\\n    }\\n    \\n    private boolean check(String s, String t)\\n    {\\n        int[] a = new int[26];\\n        int[] b = new int[26];\\n        \\n        for(int i=0;i<Math.max(s.length(),t.length());i++)\\n        {\\n            if(i<s.length())\\n            a[s.charAt(i)-\\'a\\']++;\\n            if(i<t.length())\\n            b[t.charAt(i)-\\'a\\']++;\\n        }\\n        \\n        for(int i=0;i<26;i++)\\n        {\\n            if(a[i]!=b[i])\\n                return false;\\n        }\\n        return true;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> a = new ArrayList<String>();\\n        a.add(words[0]);\\n        for(int i=1;i<words.length;i++)\\n        {\\n            if(check(words[i],words[i-1])==false)\\n                a.add(words[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2046324,
                "title": "python3-simple",
                "content": "itertools.groupby is very cool but this is more beginner friendly\\n\\n```python\\ndef removeAnagrams(self, words: List[str]) -> List[str]:\\n        last_sorted_word = \\'\\'\\n        res = []\\n        for w in words:\\n            cur_sorted_word = \\'\\'.join(sorted(w))\\n            if cur_sorted_word != last_sorted_word:\\n                res.append(w)\\n            last_sorted_word = cur_sorted_word\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef removeAnagrams(self, words: List[str]) -> List[str]:\\n        last_sorted_word = \\'\\'\\n        res = []\\n        for w in words:\\n            cur_sorted_word = \\'\\'.join(sorted(w))\\n            if cur_sorted_word != last_sorted_word:\\n                res.append(w)\\n            last_sorted_word = cur_sorted_word\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2042701,
                "title": "python-beat-both-100-no-sort-but-dictionary",
                "content": "sort will cause log(l) factor. \\nTo match, we have two approches. One is to make them ordered, so that we can compare one by one, at cost of O(logL) (L is length)\\nBut we want to know if exist or not. So why don\\'t we use dictionary(counter) instead?  Same length, and for each char, the count is same. Then the COUNT of each char is matched. and it saves a logL.\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        D = Counter(words[0])\\n        res = [words[0]]\\n        for word in words[1:]:\\n            temp = Counter(word)\\n            \\n            found = True\\n            if len(temp) != len(D):\\n                found = False\\n            for key in temp:\\n                if temp[key]!= D[key]:\\n                    found = False\\n                    break\\n            if not found:\\n                res.append(word)\\n            D = temp\\n        return res\\n\\t\\t``",
                "solutionTags": [
                    "Python"
                ],
                "code": "sort will cause log(l) factor. \\nTo match, we have two approches. One is to make them ordered, so that we can compare one by one, at cost of O(logL) (L is length)\\nBut we want to know if exist or not. So why don\\'t we use dictionary(counter) instead?  Same length, and for each char, the count is same. Then the COUNT of each char is matched. and it saves a logL.\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        D = Counter(words[0])\\n        res = [words[0]]\\n        for word in words[1:]:\\n            temp = Counter(word)\\n            \\n            found = True\\n            if len(temp) != len(D):\\n                found = False\\n            for key in temp:\\n                if temp[key]!= D[key]:\\n                    found = False\\n                    break\\n            if not found:\\n                res.append(word)\\n            D = temp\\n        return res\\n\\t\\t``",
                "codeTag": "Java"
            },
            {
                "id": 2041969,
                "title": "without-sorting-c-o-n-using-set",
                "content": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n        unordered_set<int> set;\\n        for(int i = 0; i < words.size() - 1; i++) {\\n            string s = words[i];\\n            string t = words[i + 1];\\n\\n            if(s.size() == t.size()) {\\n                vector<int> v(26, 0);\\n                int sChars = s.size();\\n\\n                for(int j = 0; j < s.length(); j++) v[s[j] - \\'a\\']++;\\n\\n                vector<int> h = v;\\n                int tChars = sChars;\\n\\n                for(int k = 0; k < t.size(); k++)\\n                    if(h[t[k] - \\'a\\']-- >= 1)\\n                        tChars--;\\n\\n                if(tChars == 0) set.insert(i + 1);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i < words.size(); i++) {\\n            if(set.find(i) == set.end())\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n        unordered_set<int> set;\\n        for(int i = 0; i < words.size() - 1; i++) {\\n            string s = words[i];\\n            string t = words[i + 1];\\n\\n            if(s.size() == t.size()) {\\n                vector<int> v(26, 0);\\n                int sChars = s.size();\\n\\n                for(int j = 0; j < s.length(); j++) v[s[j] - \\'a\\']++;\\n\\n                vector<int> h = v;\\n                int tChars = sChars;\\n\\n                for(int k = 0; k < t.size(); k++)\\n                    if(h[t[k] - \\'a\\']-- >= 1)\\n                        tChars--;\\n\\n                if(tChars == 0) set.insert(i + 1);\\n            }\\n        }\\n        vector<string> ans;\\n        for(int i = 0; i < words.size(); i++) {\\n            if(set.find(i) == set.end())\\n                ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041397,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let mut res = vec![];\\n        let mut prev_count = [0; 26];\\n        for word in words {\\n            let mut count = [0; 26];\\n            word.bytes().for_each(|b| count[(b - b\\'a\\') as usize] += 1);\\n            \\n            if prev_count != count {\\n                res.push(word);\\n            }\\n            prev_count = count;\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let mut res = vec![];\\n        let mut prev_count = [0; 26];\\n        for word in words {\\n            let mut count = [0; 26];\\n            word.bytes().for_each(|b| count[(b - b\\'a\\') as usize] += 1);\\n            \\n            if prev_count != count {\\n                res.push(word);\\n            }\\n            prev_count = count;\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2041302,
                "title": "c-map-vector-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& s) {\\n         unordered_map<string,int> mp;\\n        vector<string> ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string t=s[i];\\n            sort(t.begin(),t.end());\\n            if(!mp.count(t) or i-mp[t]>1)\\n                ans.push_back(s[i]); \\n            mp[t]=i;\\n        }\\n      \\n    return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& s) {\\n         unordered_map<string,int> mp;\\n        vector<string> ans;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            string t=s[i];\\n            sort(t.begin(),t.end());\\n            if(!mp.count(t) or i-mp[t]>1)\\n                ans.push_back(s[i]); \\n            mp[t]=i;\\n        }\\n      \\n    return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040180,
                "title": "100-faster-and-easy-solution-explained-5-liner",
                "content": "```\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack=[words[0]]      #We need a stack for this beacuse we have to delete those who are same as first one \\n        for i in range(len(words)):\\n            if stack:\\n                pr=sorted(stack[-1])       #We have to sort last element of stack and our current element\\n                cur=sorted(words[i])\\n                if pr!=cur :     #If they are equal we don\\'t add it to stack else we append it to stack\\n                    stack.append(words[i])            \\n        return stack\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        stack=[words[0]]      #We need a stack for this beacuse we have to delete those who are same as first one \\n        for i in range(len(words)):\\n            if stack:\\n                pr=sorted(stack[-1])       #We have to sort last element of stack and our current element\\n                cur=sorted(words[i])\\n                if pr!=cur :     #If they are equal we don\\'t add it to stack else we append it to stack\\n                    stack.append(words[i])            \\n        return stack\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2040106,
                "title": "c-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    string sortStr(string s){\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<words.size() || j<words.size()){\\n            string temp = sortStr(words[j]);\\n            \\n            ans.push_back(words[j]);\\n            while(i<words.size() and temp==sortStr(words[i]))\\n                i++;\\n        j = i;\\n        i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string sortStr(string s){\\n        sort(s.begin(),s.end());\\n        return s;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>ans;\\n        int i=0;\\n        int j=0;\\n        while(i<words.size() || j<words.size()){\\n            string temp = sortStr(words[j]);\\n            \\n            ans.push_back(words[j]);\\n            while(i<words.size() and temp==sortStr(words[i]))\\n                i++;\\n        j = i;\\n        i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2040097,
                "title": "unnecessarily-complicated-the-description-c-solution",
                "content": "If the anagram of current word is present in the map and the index of that anagram is current index - 1, we get the required word.\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        unordered_map<string, int> found;\\n \\n        for (int i = 0; i < words.size(); i++) {\\n              string word = words[i];\\n              sort(begin(word), end(word));\\n\\n        if (found.find(word) == found.end() || found[word] != i - 1) {\\n            ans.push_back(words[i]);\\n        }\\n        found[word] = i;\\n    }\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        unordered_map<string, int> found;\\n \\n        for (int i = 0; i < words.size(); i++) {\\n              string word = words[i];\\n              sort(begin(word), end(word));\\n\\n        if (found.find(word) == found.end() || found[word] != i - 1) {\\n            ans.push_back(words[i]);\\n        }\\n        found[word] = i;\\n    }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039952,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=1;\\n        while(i<words.size()){\\n            string a = words[i];\\n            string b = words[i-1];\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            if(a == b){\\n                words.erase (words.begin()+i);\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=1;\\n        while(i<words.size()){\\n            string a = words[i];\\n            string b = words[i-1];\\n            sort(a.begin(),a.end());\\n            sort(b.begin(),b.end());\\n            if(a == b){\\n                words.erase (words.begin()+i);\\n            }else{\\n                i++;\\n            }\\n        }\\n        \\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039935,
                "title": "easy-c",
                "content": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       for(int i = 1;i<words.size();i++){\\n            string str1 = words[i];\\n            sort(str1.begin(),str1.end());\\n            string str2 = words[i-1];\\n            sort(str2.begin(),str2.end());\\n            if(str1 == str1){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n       for(int i = 1;i<words.size();i++){\\n            string str1 = words[i];\\n            sort(str1.begin(),str1.end());\\n            string str2 = words[i-1];\\n            sort(str2.begin(),str2.end());\\n            if(str1 == str1){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2039928,
                "title": "easy-n-k-log-k-solution-k-is-average-size-of-string",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) \\n    {\\n        int n=words.size();\\n        vector<pair<int,string>>g;\\n        for(int i=0;i<n;i++)\\n        {\\n            //temporary vectory storing original strings with index\\n            g.push_back({i,words[i]});\\n        }\\n        for(int i=0;i<n;i++)\\n          {  \\n            //sorting string for comparison\\n            sort(words[i].begin(),words[i].end());\\n          }\\n        vector<pair<string,int>>v;\\n        v.push_back({words[0],0});\\n        for(int i=1;i<n;i++)\\n        {\\n            if(words[i]==(v[(v.size()-1)].first))\\n            {\\n                //dont put into vector if same string\\n            }\\n            else\\n            {\\n                v.push_back({words[i],i});\\n            }\\n        }\\n        vector<string>ans;\\n        int len=v.size();\\n        for(int i=0;i<len;i++)\\n        {\\n            int t=v[i].second;\\n            for(int j=0;j<n;j++)\\n            {\\n                int t1=g[j].first;\\n                //retrieving original string\\n                if(t==t1)\\n                {\\n                    ans.push_back(g[j].second);\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) \\n    {\\n        int n=words.size();\\n        vector<pair<int,string>>g;\\n        for(int i=0;i<n;i++)\\n        {\\n            //temporary vectory storing original strings with index\\n            g.push_back({i,words[i]}",
                "codeTag": "Java"
            },
            {
                "id": 2039920,
                "title": "cpp-2-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0,j=1;\\n        int n = words.size();\\n        vector<string> res;\\n        while(j<n){\\n            string str1 = words[j], str2= words[i];\\n            sort(str1.begin(),str1.end());\\n            sort(str2.begin(),str2.end());\\n            if(str1==str2){\\n                words[j] = \"-1\";\\n                j++;\\n            }\\n            else{\\n                i=j;\\n                j++;\\n            }\\n        }\\n        for(auto str:words){\\n            if(str!=\"-1\"){\\n                res.push_back(str);\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int i=0,j=1;\\n        int n = words.size();\\n        vector<string> res;\\n        while(j<n){\\n            string str1 = words[j], str2= words[i];\\n            sort(str1.begin(),str1.end());\\n            sort(str2.begin(),str2.end());\\n            if(str1==str2){\\n                words[j] = \"-1\";\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2039901,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = words.length - 1; i > 0; i--){\\n            if(helper(words[i], words[i-1]) == false){\\n                ans.add(words[i]);\\n            }\\n        }\\n        ans.add(words[0]);\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n    \\n    public boolean helper(String s1, String s2){\\n        if(s1.length() != s2.length()) return false;\\n        char[] c1 = s1.toCharArray();\\n        char[] c2 = s2.toCharArray();\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        for(int i = 0; i < c1.length; i++){\\n            if(c1[i] != c2[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> ans = new ArrayList<>();\\n        for (int i = words.length - 1; i > 0; i--){\\n            if(helper(words[i], words[i-1]) == false){\\n                ans.add(words[i]);\\n            }\\n        }\\n        ans.add(words[0]);\\n        Collections.reverse(ans);\\n        return ans;\\n    }\\n    \\n    public boolean helper(String s1, String s2){\\n        if(s1.length() != s2.length()) return false;\\n        char[] c1 = s1.toCharArray();\\n        char[] c2 = s2.toCharArray();\\n        Arrays.sort(c1);\\n        Arrays.sort(c2);\\n        for(int i = 0; i < c1.length; i++){\\n            if(c1[i] != c2[i]) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039864,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        unordered_map<char,int> mp;\\n        for(char c:s1) mp[c]++;\\n        for(char c:s2) mp[c]--;\\n        \\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second != 0) return false;\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        for(string word:words)\\n        {\\n            if(ans.empty()) ans.push_back(word);\\n            else\\n            {\\n                if(isAnagram(word,ans[ans.size()-1]))\\n                    continue;\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s1,string s2)\\n    {\\n        unordered_map<char,int> mp;\\n        for(char c:s1) mp[c]++;\\n        for(char c:s2) mp[c]--;\\n        \\n        for(auto itr=mp.begin();itr!=mp.end();itr++)\\n        {\\n            if(itr->second != 0) return false;\\n        }\\n        return true;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        for(string word:words)\\n        {\\n            if(ans.empty()) ans.push_back(word);\\n            else\\n            {\\n                if(isAnagram(word,ans[ans.size()-1]))\\n                    continue;\\n                ans.push_back(word);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039828,
                "title": "c-easy-to-understand-hashing",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            string s=words[i];\\n            int cnt[26]={0};\\n            for(auto k:s) cnt[k-\\'a\\']++;\\n            int j=i+1;\\n            while(j<n){\\n                string s2=words[j];\\n                int cnt2[26]={0};\\n                for(auto k:s2) cnt2[k-\\'a\\']++;\\n                bool f=0;\\n                for(int k=0;k<26;k++){\\n                    if(cnt[k]!=cnt2[k]){ f=1; break;}\\n                }\\n                if(f) break; \\n                j++;\\n            }\\n            i=j;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int n=words.size();\\n        int i=0;\\n        while(i<n){\\n            string s=words[i];\\n            int cnt[26]={0};\\n            for(auto k:s) cnt[k-\\'a\\']++;\\n            int j=i+1;\\n            while(j<n){\\n                string s2=words[j];\\n                int cnt2[26]={0};\\n                for(auto k:s2) cnt2[k-\\'a\\']++;\\n                bool f=0;\\n                for(int k=0;k<26;k++){\\n                    if(cnt[k]!=cnt2[k]){ f=1; break;}\\n                }\\n                if(f) break; \\n                j++;\\n            }\\n            i=j;\\n            ans.push_back(s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039804,
                "title": "c-simple-and-straight-forward-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()<=1){\\n            return words;\\n        }\\n        vector<string> temp = words;\\n        for(int i=0;i<words.size();i++){\\n            sort(temp[i].begin(),temp[i].end()); // sorting to make work easier in temporary array\\n        }\\n        vector<string> ans;\\n        // for(int i=0;i<words.size();i++){\\n        //     cout<<temp[i]<<endl;\\n        // }\\n        int i=0,j=1;\\n        // we will add the first words[i] which comes in array with anagrams\\n        while( (i < words.size()) && (j < words.size())){\\n            if(temp[i]!=temp[j]){ // we push first anagram , when next is not equal to previous as it means the word has changed and we update to new word anagram\\n                ans.push_back(words[i]);\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n            \\n            \\n            // cout<<ans[i]<<endl;\\n        }\\n        j = words.size()-1;\\n        if(  (temp[j-1] != temp[j])){\\n                ans.push_back(words[j]);\\n                // break;\\n                \\n        }\\n        if((j==words.size()-1) && (temp[j-1] == temp[j])){\\n            ans.push_back(words[i]);\\n                // break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        if(words.size()<=1){\\n            return words;\\n        }\\n        vector<string> temp = words;\\n        for(int i=0;i<words.size();i++){\\n            sort(temp[i].begin(),temp[i].end()); // sorting to make work easier in temporary array\\n        }\\n        vector<string> ans;\\n        // for(int i=0;i<words.size();i++){\\n        //     cout<<temp[i]<<endl;\\n        // }\\n        int i=0,j=1;\\n        // we will add the first words[i] which comes in array with anagrams\\n        while( (i < words.size()) && (j < words.size())){\\n            if(temp[i]!=temp[j]){ // we push first anagram , when next is not equal to previous as it means the word has changed and we update to new word anagram\\n                ans.push_back(words[i]);\\n                i=j;\\n                j++;\\n            }\\n            else{\\n                j++;\\n            }\\n            \\n            \\n            // cout<<ans[i]<<endl;\\n        }\\n        j = words.size()-1;\\n        if(  (temp[j-1] != temp[j])){\\n                ans.push_back(words[j]);\\n                // break;\\n                \\n        }\\n        if((j==words.size()-1) && (temp[j-1] == temp[j])){\\n            ans.push_back(words[i]);\\n                // break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2039790,
                "title": "c-short-solutions-with-explanation-2-approaches-for-comparing-words",
                "content": "**Approach 1:** Using Multiset\\n\\nMultisets are a type of associative containers similar to the set, with the exception that multiple elements can have the same values.\\n* Compare multisets of adjacent words\\n* If multisets are equal, erase next word and decrease the index\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(multiset<char>(words[i].begin(), words[i].end()) == multiset<char>(words[i+1].begin(), words[i+1].end()))\\n                words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```\\n**Approach 2:** Using Map\\n* Make maps for adjacent words to count frequency for all letters\\n* If maps are equal, erase next word and decrease the index\\n```\\nclass Solution {\\npublic:\\n    bool isagm(string s1,string s2){\\n        map<char,int>m1,m2;\\n        for(auto i:s1)  m1[i]++;\\n        for(auto i:s2)  m2[i]++;\\n        return m1==m2;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(isagm(words[i], words[i+1]))     words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(multiset<char>(words[i].begin(), words[i].end()) == multiset<char>(words[i+1].begin(), words[i+1].end()))\\n                words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isagm(string s1,string s2){\\n        map<char,int>m1,m2;\\n        for(auto i:s1)  m1[i]++;\\n        for(auto i:s2)  m2[i]++;\\n        return m1==m2;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=0; i < words.size()-1; i++)\\n            if(isagm(words[i], words[i+1]))     words.erase(words.begin() + 1 + i--);\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039788,
                "title": "easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n          int index  = 1 ;\\n          vector<string> ans, word_cp ; \\n          word_cp = words ; \\n          int j =0 ; \\n          for(int i = 0 ; i < words.size(); i ++) {\\n              sort(words[i].begin(), words[i].end()); \\n               if(ans.size() == 0 ) {\\n                    ans.push_back(word_cp[i]); \\n               }else {\\n                   if(ans.size() > 0  and words[j] != words[i]) {\\n                        j = i ; \\n                        ans.push_back(word_cp[i]); \\n                   } \\n               }\\n          }\\n        return ans ; \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n          int index  = 1 ;\\n          vector<string> ans, word_cp ; \\n          word_cp = words ; \\n          int j =0 ; \\n          for(int i = 0 ; i < words.size(); i ++) {\\n              sort(words[i].begin(), words[i].end()); \\n               if(ans.size() == 0 ) {\\n                    ans.push_back(word_cp[i]); \\n               }else {\\n                   if(ans.size() > 0  and words[j] != words[i]) {\\n                        j = i ; \\n                        ans.push_back(word_cp[i]); \\n                   } \\n               }\\n          }\\n        return ans ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039787,
                "title": "iterative-solution-o-n-loop",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i =0 \\n        while i < len(words)-1:\\n            if Counter(words[i]) == Counter(words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i += 1\\n        return words\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i =0 \\n        while i < len(words)-1:\\n            if Counter(words[i]) == Counter(words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039781,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\n    bool areAnagram(string str1, string str2){\\n        int n1 = str1.length();\\n        int n2 = str2.length();\\n        if (n1 != n2)\\n            return false;\\n\\n        sort(str1.begin(), str1.end());\\n        sort(str2.begin(), str2.end());\\n\\n        for (int i = 0; i < n1; i++)\\n            if (str1[i] != str2[i])\\n                return false;\\n\\n        return true;\\n    }\\npublic:\\n    vector<string> removeAnagrams(vector<string>& w) {\\n        for(int i=1; i<w.size(); i++){\\n            if(areAnagram(w[i-1], w[i])){\\n                w.erase(w.begin() + i);\\n                i--;\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool areAnagram(string str1, string str2){\\n        int n1 = str1.length();\\n        int n2 = str2.length();\\n        if (n1 != n2)\\n            return false;\\n\\n        sort(str1.begin(), str1.end());\\n        sort(str2.begin(), str2.end());\\n\\n        for (int i = 0; i < n1; i++)\\n            if (str1[i] != str2[i])\\n                return false;\\n\\n        return true;\\n    }\\npublic:\\n    vector<string> removeAnagrams(vector<string>& w) {\\n        for(int i=1; i<w.size(); i++){\\n            if(areAnagram(w[i-1], w[i])){\\n                w.erase(w.begin() + i);\\n                i--;\\n            }\\n        }\\n        return w;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2039709,
                "title": "easy-solution-with-sort-how-i-wasted-first-30-minutes-in-contest",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 0 ; i < words.size() -1; i++){\\n            int idx = i;\\n            string s1 = words[i];\\n            sort(s1.begin(),s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(),s2.end());\\n            if(s1 == s2){\\n                words.erase(words.begin() + i+1);\\n                i = idx - 1;\\n            }\\n         }\\n        return words;\\n        \\n    }\\n};\\n```\\n\\n**2 days ago i have solved question no 49. Group Anagrams  problem and today in contest when i saw the test cases of this problem i think it\\'s almost same . . and i have started solving with my previous approach . and wasted 30 minutes . \\nand then read the question carefully .**\\n\\n***So specially beginners please always read the question carefully . don\\'t be overconfident*** \\n",
                "solutionTags": [
                    "C",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 0 ; i < words.size() -1; i++){\\n            int idx = i;\\n            string s1 = words[i];\\n            sort(s1.begin(),s1.end());\\n            string s2 = words[i+1];\\n            sort(s2.begin(),s2.end());\\n            if(s1 == s2){\\n                words.erase(words.begin() + i+1);\\n                i = idx - 1;\\n            }\\n         }\\n        return words;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081776,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nCreate a function to check anagaram between two words, if true remove them and repeat the process\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n const removeAnagrams =   function(words) {\\n    if(words.length === 0) { return false}\\n    let i = 0;\\n     while (i < words.length - 1) {\\n        if(!words[i+1]){ return;}\\n\\n        const ifAnagram =  validAnagram(words[i], words[i+1])\\n   if (ifAnagram){\\n       words.splice(i+1,1)\\n  \\n   }else{\\n   i+=1}\\n    }\\n    return words\\n};\\n\\n function validAnagram(str1, str2) {\\n  if (str1.length !== str2.length) {\\n    return false;\\n  }\\n\\n  let first = {};\\n  let second = {};\\n\\n  for (let i = 0; i < str1.length; i++) {\\n    first[str1[i]] = (first[str1[i]] || 0) + 1;\\n    second[str2[i]] = (second[str2[i]] || 0) + 1;\\n  }\\n\\n  console.log(first, second);\\n\\n  for (let key in first) {\\n    if (!(key in second)) {\\n      return false;\\n    }\\n    if (second[key] !== first[key]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\n const removeAnagrams =   function(words) {\\n    if(words.length === 0) { return false}\\n    let i = 0;\\n     while (i < words.length - 1) {\\n        if(!words[i+1]){ return;}\\n\\n        const ifAnagram =  validAnagram(words[i], words[i+1])\\n   if (ifAnagram){\\n       words.splice(i+1,1)\\n  \\n   }else{\\n   i+=1}\\n    }\\n    return words\\n};\\n\\n function validAnagram(str1, str2) {\\n  if (str1.length !== str2.length) {\\n    return false;\\n  }\\n\\n  let first = {};\\n  let second = {};\\n\\n  for (let i = 0; i < str1.length; i++) {\\n    first[str1[i]] = (first[str1[i]] || 0) + 1;\\n    second[str2[i]] = (second[str2[i]] || 0) + 1;\\n  }\\n\\n  console.log(first, second);\\n\\n  for (let key in first) {\\n    if (!(key in second)) {\\n      return false;\\n    }\\n    if (second[key] !== first[key]) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4079550,
                "title": "easy-cpp-solution-beats-93-3-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/7f806d18-d0f6-4b9e-b408-0189ba787cdf_1695453036.5051134.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int sz=words.size();\\n        vector<bool> vis(sz, false);\\n        for(int i=0; i<sz; i++){\\n            if(vis[i]) continue;\\n            int t = 0;\\n            string tmp = words[i];\\n            sort(tmp.begin(), tmp.end());\\n            for(int j=i+1; j<sz; j++){\\n                if(t != j-i-1) break;\\n                if(words[i].length() == words[j].length() && vis[j] == false){\\n                    string tmp2 = words[j];\\n                    sort(tmp2.begin(), tmp2.end());\\n                    if(tmp == tmp2){\\n                        vis[j] = true;\\n                        t++;\\n                    }\\n                }\\n            }\\n            ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string> ans;\\n        int sz=words.size();\\n        vector<bool> vis(sz, false);\\n        for(int i=0; i<sz; i++){\\n            if(vis[i]) continue;\\n            int t = 0;\\n            string tmp = words[i];\\n            sort(tmp.begin(), tmp.end());\\n            for(int j=i+1; j<sz; j++){\\n                if(t != j-i-1) break;\\n                if(words[i].length() == words[j].length() && vis[j] == false){\\n                    string tmp2 = words[j];\\n                    sort(tmp2.begin(), tmp2.end());\\n                    if(tmp == tmp2){\\n                        vis[j] = true;\\n                        t++;\\n                    }\\n                }\\n            }\\n            ans.push_back(words[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072676,
                "title": "70-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    if(words.length <= 0){\\n        return []\\n    }\\n    for(let i = 0; i < words.length-1;i++){\\n        let x = words[i].split(\"\").sort().join(\"\")\\n        let y = words[i+1].split(\"\").sort().join(\"\")\\n\\n        if(x == y){\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words\\n\\n  \\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    if(words.length <= 0){\\n        return []\\n    }\\n    for(let i = 0; i < words.length-1;i++){\\n        let x = words[i].split(\"\").sort().join(\"\")\\n        let y = words[i+1].split(\"\").sort().join(\"\")\\n\\n        if(x == y){\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words\\n\\n  \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4061949,
                "title": "easy-simple-c-solution",
                "content": "\\n# Approach\\nSort the words and compare. Always add accept the first array element.\\n\\n# Complexity\\n- Time complexity:\\nO(m * n log n)\\n\\n- Space complexity:\\nO(m + n)\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> wordList = new();\\n        for(int i = 0; i<words.Length; i++)\\n        {   \\n            if(i==0)\\n            {\\n                wordList.Add(words[i]);\\n                continue;\\n            }\\n            //char and sort words i, i-1 and i+1\\n            char[] less = words[i-1].ToCharArray();\\n            char[] same = words[i].ToCharArray();\\n            Array.Sort(less);\\n            Array.Sort(same);\\n            string str = new string(same);\\n            string strLess = new string(less);\\n            if(str != strLess)\\n                wordList.Add(words[i]);\\n            \\n        }\\n        return wordList;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> wordList = new();\\n        for(int i = 0; i<words.Length; i++)\\n        {   \\n            if(i==0)\\n            {\\n                wordList.Add(words[i]);\\n                continue;\\n            }\\n            //char and sort words i, i-1 and i+1\\n            char[] less = words[i-1].ToCharArray();\\n            char[] same = words[i].ToCharArray();\\n            Array.Sort(less);\\n            Array.Sort(same);\\n            string str = new string(same);\\n            string strLess = new string(less);\\n            if(str != strLess)\\n                wordList.Add(words[i]);\\n            \\n        }\\n        return wordList;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4059240,
                "title": "find-resultant-array-after-removing-anagrams-using-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string> s1;\\n        for(int i=0;i<words.size();i++){\\n            if(s1.empty()){\\n                s1.push(words[i]);\\n            }\\n            else{\\n                string s=s1.top(),s2=words[i];\\n                sort(s.begin(),s.end());\\n                sort(s2.begin(),s2.end());\\n                if(s==s2){\\n                    continue;\\n                }\\n                else{\\n                    s1.push(words[i]);\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        while(!s1.empty()){\\n            ans.push_back(s1.top());\\n            s1.pop();\\n        } \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string> s1;\\n        for(int i=0;i<words.size();i++){\\n            if(s1.empty()){\\n                s1.push(words[i]);\\n            }\\n            else{\\n                string s=s1.top(),s2=words[i];\\n                sort(s.begin(),s.end());\\n                sort(s2.begin(),s2.end());\\n                if(s==s2){\\n                    continue;\\n                }\\n                else{\\n                    s1.push(words[i]);\\n                }\\n            }\\n        }\\n        vector<string> ans;\\n        while(!s1.empty()){\\n            ans.push_back(s1.top());\\n            s1.pop();\\n        } \\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4052298,
                "title": "java-best-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i],words[i-1])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())\\n            return false;\\n        if(s1==s2)\\n            return true;\\n        int[] arr = new int[26];    \\n        for(int i=0;i<s1.length();i++){\\n            arr[s1.charAt(i)-\\'a\\']++;\\n            arr[s2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        list.add(words[0]);\\n        for(int i=1;i<words.length;i++){\\n            if(!isAnagram(words[i],words[i-1])){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n    public boolean isAnagram(String s1,String s2){\\n        if(s1.length()!=s2.length())\\n            return false;\\n        if(s1==s2)\\n            return true;\\n        int[] arr = new int[26];    \\n        for(int i=0;i<s1.length();i++){\\n            arr[s1.charAt(i)-\\'a\\']++;\\n            arr[s2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0;i<26;i++){\\n            if(arr[i]!=0)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024985,
                "title": "easy-c-sorting-and-unordered-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterating through the string vector\\nsorting the each string element\\nChecking if it is already present in hashmap\\nIf not present pushing it into the result vector\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will push the very first element in the result vector.\\nThen we will sort the string a put that string in map \\nwhen frequency is 1 we will push the string in the result vector.\\nif frequecy is greater than 1 we will not push that string in the result.\\nreturn the result vector\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nmlogn)\\nn - number of strings\\nm -  avg length of a string\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(nm)\\nn - given string vector\\nm -  size of result string vector\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<string,int>mp;\\n        res.push_back(words[0]);\\n        sort(words[0].begin(),words[0].end());\\n        mp[words[0]]++;\\n        for(int i=1;i<words.size();i++){\\n            string temp = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            mp[words[i]]++;\\n            if(mp[words[i]] == 1 || (words[i-1] != words[i])){\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        vector<string>res;\\n        unordered_map<string,int>mp;\\n        res.push_back(words[0]);\\n        sort(words[0].begin(),words[0].end());\\n        mp[words[0]]++;\\n        for(int i=1;i<words.size();i++){\\n            string temp = words[i];\\n            sort(words[i].begin(),words[i].end());\\n            mp[words[i]]++;\\n            if(mp[words[i]] == 1 || (words[i-1] != words[i])){\\n                res.push_back(temp);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4016784,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        \\n        if (words.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(words[0]);\\n\\n        for (int i = 1; i < words.length; i++) {\\n            if (!areAnagrams(words[i], words[i - 1])) {\\n                result.add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private boolean areAnagrams(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n\\n        int[] charCount = new int[26];\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            charCount[s1.charAt(i) - \\'a\\']++;\\n            charCount[s2.charAt(i) - \\'a\\']--;\\n        }\\n\\n        for (int count : charCount) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> result = new ArrayList<>();\\n        \\n        if (words.length == 0) {\\n            return result;\\n        }\\n\\n        result.add(words[0]);\\n\\n        for (int i = 1; i < words.length; i++) {\\n            if (!areAnagrams(words[i], words[i - 1])) {\\n                result.add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    private boolean areAnagrams(String s1, String s2) {\\n        if (s1.length() != s2.length()) {\\n            return false;\\n        }\\n\\n        int[] charCount = new int[26];\\n        \\n        for (int i = 0; i < s1.length(); i++) {\\n            charCount[s1.charAt(i) - \\'a\\']++;\\n            charCount[s2.charAt(i) - \\'a\\']--;\\n        }\\n\\n        for (int count : charCount) {\\n            if (count != 0) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4013537,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n         List<String> ans = new ArrayList<>();\\n         if(words.length == 1)\\n         return Arrays.asList(words[0]);\\n         \\n         for(int i = words.length-1 ; i> 0 ;i--){\\n             char[] ch1 = words[i].toCharArray();\\n             char[] ch2 = words[i-1].toCharArray();\\n             Arrays.sort(ch1);\\n             Arrays.sort(ch2);\\n             if(!Arrays.equals(ch1,ch2)){\\n                 ans.add(words[i]);\\n             }\\n             if(i == 1)\\n             ans.add(words[i-1]);\\n         }\\n         Collections.reverse(ans);\\n         return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n         List<String> ans = new ArrayList<>();\\n         if(words.length == 1)\\n         return Arrays.asList(words[0]);\\n         \\n         for(int i = words.length-1 ; i> 0 ;i--){\\n             char[] ch1 = words[i].toCharArray();\\n             char[] ch2 = words[i-1].toCharArray();\\n             Arrays.sort(ch1);\\n             Arrays.sort(ch2);\\n             if(!Arrays.equals(ch1,ch2)){\\n                 ans.add(words[i]);\\n             }\\n             if(i == 1)\\n             ans.add(words[i-1]);\\n         }\\n         Collections.reverse(ans);\\n         return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006864,
                "title": "c-simple-just-do-what-ask-simple-sorting-apporach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int sz=words.size();\\n         vector<string> res;\\n          for(int i=0;i<sz;i++)\\n            {\\n              \\n              string curr=words[i];\\n              //just sort the curr string so that we can check anagaram of that string\\n               sort(curr.begin(),curr.end());\\n                int j=i+1;\\n                for(;j<sz;j++)\\n                  {\\n                    string s=words[j];\\n                    //sort adjacnet string also that we can compare 2 string\\n                      sort(begin(s),end(s));\\n                      //if both are equal then just continue\\n                      if(s==curr)\\n                           continue;\\n                      else\\n                      break;\\n                  }\\n            \\n                  res.push_back(words[i]);\\n                \\n                        i=j-1;\\n            }\\n            return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int sz=words.size();\\n         vector<string> res;\\n          for(int i=0;i<sz;i++)\\n            {\\n              \\n              string curr=words[i];\\n              //just sort the curr string so that we can check anagaram of that string\\n               sort(curr.begin(),curr.end());\\n                int j=i+1;\\n                for(;j<sz;j++)\\n                  {\\n                    string s=words[j];\\n                    //sort adjacnet string also that we can compare 2 string\\n                      sort(begin(s),end(s));\\n                      //if both are equal then just continue\\n                      if(s==curr)\\n                           continue;\\n                      else\\n                      break;\\n                  }\\n            \\n                  res.push_back(words[i]);\\n                \\n                        i=j-1;\\n            }\\n            return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985510,
                "title": "easy-solution-beats-95-time",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        w = []\\n        w.append(words[0])\\n\\n        for i in range(1,len(words)):\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                continue\\n            else:\\n                w.append(words[i])\\n        return w\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        w = []\\n        w.append(words[0])\\n\\n        for i in range(1,len(words)):\\n            if sorted(words[i]) == sorted(words[i-1]):\\n                continue\\n            else:\\n                w.append(words[i])\\n        return w\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3985262,
                "title": "simple-java-solution-without-sort",
                "content": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        char[][] table = new char[words.length][26];\\n        for(int i = 0; i < words.length; i++){\\n            String word = words[i];\\n            for(char c : word.toCharArray()){\\n                table[i][c - \\'a\\']++;\\n            }\\n        }\\n        int i = 0;\\n        while(i < words.length){\\n            res.add(words[i]);\\n            int j = i + 1;\\n            while(j < words.length && words[i].length() == words[j].length() && Arrays.equals(table[i], table[j])){\\n                j++;\\n            }\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> res = new ArrayList<>();\\n        char[][] table = new char[words.length][26];\\n        for(int i = 0; i < words.length; i++){\\n            String word = words[i];\\n            for(char c : word.toCharArray()){\\n                table[i][c - \\'a\\']++;\\n            }\\n        }\\n        int i = 0;\\n        while(i < words.length){\\n            res.add(words[i]);\\n            int j = i + 1;\\n            while(j < words.length && words[i].length() == words[j].length() && Arrays.equals(table[i], table[j])){\\n                j++;\\n            }\\n            i = j;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980926,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list= new  ArrayList();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            if(isAnagram(words[i] , words[j] )){\\n                vis[j]=true;\\n            }\\n            \\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n\\n        \\n        \\n        \\n    }\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())return false;\\n        char[]c0=s.toCharArray();\\n        char[]c1=t.toCharArray();\\n        Arrays.sort(c0);\\n        Arrays.sort(c1);\\n        return Arrays.equals(c0,c1);\\n\\n\\n\\n        }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list= new  ArrayList();\\n        boolean vis[]=new boolean[words.length];\\n        for(int i=0;i<words.length-1;i++){\\n            int j=i+1;\\n            if(isAnagram(words[i] , words[j] )){\\n                vis[j]=true;\\n            }\\n            \\n        }\\n        for(int i=0;i<words.length;i++){\\n            // System.out.print(i+\"--\"+vis[i]);\\n            if(vis[i]==false)\\n            {\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n\\n        \\n        \\n        \\n    }\\n    public boolean isAnagram(String s, String t) {\\n        if(s.length()!=t.length())return false;\\n        char[]c0=s.toCharArray();\\n        char[]c1=t.toCharArray();\\n        Arrays.sort(c0);\\n        Arrays.sort(c1);\\n        return Arrays.equals(c0,c1);\\n\\n\\n\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3979398,
                "title": "simple-c-only-sorting-techniq",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string str1 = words[i];\\n            string str2 = words[i-1];\\n\\n            sort(str1.begin(), str1.end());\\n            sort(str2.begin(), str2.end());\\n\\n            if(str1==str2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        \\n        for(int i=1; i<words.size(); i++)\\n        {\\n            string str1 = words[i];\\n            string str2 = words[i-1];\\n\\n            sort(str1.begin(), str1.end());\\n            sort(str2.begin(), str2.end());\\n\\n            if(str1==str2)\\n            {\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n            \\n        }\\n        return words;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977773,
                "title": "python-one-liner-beats-98-98-with-comments",
                "content": "# Intuition\\nIf two sorted words are the same they are anagrams.\\n\\n# Approach\\nLoop through the list and check if $$adjacent$$ words are anagrams. The first word will always meet the requirement, so we can add that to the final list.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return [words[0]] + [words[i] for i in range(1, len(words)) if sorted(words[i]) != sorted(words[i-1])]\\n        # Check if the previous word is an anagram of the current word. Add the first word in words as well.\\n        \\n```\\n\\n**Please upvote if this helped!!!**",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        \"\"\"\\n        :type words: List[str]\\n        :rtype: List[str]\\n        \"\"\"\\n        return [words[0]] + [words[i] for i in range(1, len(words)) if sorted(words[i]) != sorted(words[i-1])]\\n        # Check if the previous word is an anagram of the current word. Add the first word in words as well.\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976691,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    private boolean isAnagram(String str1, String str2){\\n        if(str1.length() != str2.length())return false;\\n        int[] ans =  new int[26];\\n        for(int i=0; i<str1.length(); i++){\\n            ans[str1.charAt(i)-\\'a\\']++;\\n            ans[str2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ans[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list =  new ArrayList<>();\\n        boolean ans[]=new boolean[words.length];\\n        for(int i=0; i<words.length-1; i++){\\n            int j = i+1;\\n            while(ans[j]){\\n                j++;\\n            }\\n            if(isAnagram(words[i], words[j])){\\n                ans[j] =  true;\\n            }\\n        }\\n\\n        for(int i=0; i<words.length; i++){\\n            if(ans[i] == false){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private boolean isAnagram(String str1, String str2){\\n        if(str1.length() != str2.length())return false;\\n        int[] ans =  new int[26];\\n        for(int i=0; i<str1.length(); i++){\\n            ans[str1.charAt(i)-\\'a\\']++;\\n            ans[str2.charAt(i)-\\'a\\']--;\\n        }\\n        for(int i=0; i<26; i++){\\n            if(ans[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list =  new ArrayList<>();\\n        boolean ans[]=new boolean[words.length];\\n        for(int i=0; i<words.length-1; i++){\\n            int j = i+1;\\n            while(ans[j]){\\n                j++;\\n            }\\n            if(isAnagram(words[i], words[j])){\\n                ans[j] =  true;\\n            }\\n        }\\n\\n        for(int i=0; i<words.length; i++){\\n            if(ans[i] == false){\\n                list.add(words[i]);\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976357,
                "title": "easy-logic-java-using-2-functions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String convertString(String[] words, int i){\\n        String str = words[i];\\n            char arr[] = str.toCharArray();\\n            Arrays.sort(arr);\\n\\n            str = new String(arr); \\n            return str;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        //go from n to 0\\n        //check i and i-1\\n        List<String> res = new ArrayList<>();\\n        int i = words.length-1;\\n            //string in sorted manner\\n            //now compare i with i-1\\n            while(i>0){\\n                String str1 = convertString(words, i);\\n                String str2 = convertString(words, i-1);\\n                \\n                if(!str1.equals(str2)){\\n                    res.add(words[i]);\\n                }\\n                i--;\\n            }\\n            res.add(words[0]); \\n\\n            Collections.reverse(res);\\n            return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String convertString(String[] words, int i){\\n        String str = words[i];\\n            char arr[] = str.toCharArray();\\n            Arrays.sort(arr);\\n\\n            str = new String(arr); \\n            return str;\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n        //go from n to 0\\n        //check i and i-1\\n        List<String> res = new ArrayList<>();\\n        int i = words.length-1;\\n            //string in sorted manner\\n            //now compare i with i-1\\n            while(i>0){\\n                String str1 = convertString(words, i);\\n                String str2 = convertString(words, i-1);\\n                \\n                if(!str1.equals(str2)){\\n                    res.add(words[i]);\\n                }\\n                i--;\\n            }\\n            res.add(words[0]); \\n\\n            Collections.reverse(res);\\n            return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3973732,
                "title": "easy-to-understand-python3-solution-tc-o-n-sc-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for word in words[1:]:\\n            curr = \"\".join(sorted(word))\\n            if curr != \"\".join(sorted(res[-1])):\\n                res.append(word)\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = [words[0]]\\n        for word in words[1:]:\\n            curr = \"\".join(sorted(word))\\n            if curr != \"\".join(sorted(res[-1])):\\n                res.append(word)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3970787,
                "title": "runtime-59ms-beats-95-24-memory-45-39-mb-beats-100",
                "content": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    let i = 1\\n\\n    while (i < words.length) {\\n        if (isAnagram(words[i - 1], words[i])) {\\n            words.splice(i,1)\\n            i = 1\\n            continue\\n        }\\n\\n        i++\\n    }\\n\\n    return words\\n};\\n\\n\\nconst isAnagram = (word1: string, word2: string): boolean => {\\n    if (word1.length !== word2.length) return false\\n    if (word1 === word2) return true\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        const letter = word1[i]\\n        word2 = word2.replace(letter, \\'\\')\\n    }\\n\\n    return !word2\\n}\\n```\\n\\n",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction removeAnagrams(words: string[]): string[] {\\n    let i = 1\\n\\n    while (i < words.length) {\\n        if (isAnagram(words[i - 1], words[i])) {\\n            words.splice(i,1)\\n            i = 1\\n            continue\\n        }\\n\\n        i++\\n    }\\n\\n    return words\\n};\\n\\n\\nconst isAnagram = (word1: string, word2: string): boolean => {\\n    if (word1.length !== word2.length) return false\\n    if (word1 === word2) return true\\n\\n    for (let i = 0; i < word1.length; i++) {\\n        const letter = word1[i]\\n        word2 = word2.replace(letter, \\'\\')\\n    }\\n\\n    return !word2\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932999,
                "title": "rust-0ms-linear-solution",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let maps = words\\n            .iter()\\n            .map(|w| {\\n                let mut lut = [0; 26];\\n                for c in w.chars() {\\n                    lut[c as usize - \\'a\\' as usize] += 1;\\n                }\\n                lut\\n            })\\n            .collect::<Vec<[i32; 26]>>();\\n\\n        let mut res = vec![];\\n\\n        res.push(words[0].clone());\\n        for i in 1..words.len() {\\n            if maps[i] != maps[i - 1] {\\n                res.push(words[i].clone());\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn remove_anagrams(words: Vec<String>) -> Vec<String> {\\n        let maps = words\\n            .iter()\\n            .map(|w| {\\n                let mut lut = [0; 26];\\n                for c in w.chars() {\\n                    lut[c as usize - \\'a\\' as usize] += 1;\\n                }\\n                lut\\n            })\\n            .collect::<Vec<[i32; 26]>>();\\n\\n        let mut res = vec![];\\n\\n        res.push(words[0].clone());\\n        for i in 1..words.len() {\\n            if maps[i] != maps[i - 1] {\\n                res.push(words[i].clone());\\n            }\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3924581,
                "title": "clean-easy-to-understand-solution-beats-100-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n     boolean isAnagram(String word1, String word2){\\n        if(word1 == null || word2 == null)return false;\\n\\n        int[] freq=new int[26];\\n\\n        for(int i=0;i<word1.length();i++){\\n            int ascii = word1.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] + 1;\\n        }\\n\\n        for(int i=0;i<word2.length();i++){\\n            int ascii = word2.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] - 1;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(freq[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<String> removeAnagrams(String[] words){\\n        List<String> ans = new ArrayList<>();\\n        while(true){\\n            boolean changed = false;\\n            for(int i=words.length-1;i>=1;i--){\\n                if(words[i] == null)\\n                    continue;\\n                if(isAnagram(words[i],words[i-1])){\\n                    words[i] = null;\\n                    changed = true;\\n                }\\n            }\\n            if(changed == false){\\n                for(int i= 0; i< words.length; i++){\\n                    if(words[i] != null){\\n                        ans.add(words[i]);\\n                    }\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n     boolean isAnagram(String word1, String word2){\\n        if(word1 == null || word2 == null)return false;\\n\\n        int[] freq=new int[26];\\n\\n        for(int i=0;i<word1.length();i++){\\n            int ascii = word1.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] + 1;\\n        }\\n\\n        for(int i=0;i<word2.length();i++){\\n            int ascii = word2.charAt(i) - \\'a\\';\\n            freq[ascii] = freq[ascii] - 1;\\n        }\\n\\n        for(int i=0; i<26; i++){\\n            if(freq[i] != 0){\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    public List<String> removeAnagrams(String[] words){\\n        List<String> ans = new ArrayList<>();\\n        while(true){\\n            boolean changed = false;\\n            for(int i=words.length-1;i>=1;i--){\\n                if(words[i] == null)\\n                    continue;\\n                if(isAnagram(words[i],words[i-1])){\\n                    words[i] = null;\\n                    changed = true;\\n                }\\n            }\\n            if(changed == false){\\n                for(int i= 0; i< words.length; i++){\\n                    if(words[i] != null){\\n                        ans.add(words[i]);\\n                    }\\n                }\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923974,
                "title": "c-easy-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string temp1 = words[i];\\n            sort(temp1.begin(),temp1.end());\\n            string temp2 = words[i-1];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1 == temp2){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i = 1;i<words.size();i++){\\n            string temp1 = words[i];\\n            sort(temp1.begin(),temp1.end());\\n            string temp2 = words[i-1];\\n            sort(temp2.begin(),temp2.end());\\n            if(temp1 == temp2){\\n                words.erase(words.begin() + i);\\n                i--;\\n            }\\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915665,
                "title": "simple-c-one-traversal-no-map-used",
                "content": "# Complexity\\n- Time complexity: O(n * (wordLen log(wordLen)))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) Not considering returing vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> res;\\n\\n        res.push_back(words[0]);\\n        for(int i=1; i<n; i++){\\n            string prevStr = words[i-1];\\n            string currStr = words[i];\\n\\n            sort(prevStr.begin(), prevStr.end());\\n            sort(currStr.begin(), currStr.end());\\n\\n            if(prevStr != currStr)\\n                res.push_back(words[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string> res;\\n\\n        res.push_back(words[0]);\\n        for(int i=1; i<n; i++){\\n            string prevStr = words[i-1];\\n            string currStr = words[i];\\n\\n            sort(prevStr.begin(), prevStr.end());\\n            sort(currStr.begin(), currStr.end());\\n\\n            if(prevStr != currStr)\\n                res.push_back(words[i]);\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3915357,
                "title": "python3-list-of-sorted-words-beats-99-26",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        srt = [sorted(words[0])]\\n        res = [words[0]]\\n        for word in words[1:]:\\n            sorted_word = sorted(word)\\n            if sorted_word != srt[-1]:\\n                srt.append(sorted_word)\\n                res.append(word)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        srt = [sorted(words[0])]\\n        res = [words[0]]\\n        for word in words[1:]:\\n            sorted_word = sorted(word)\\n            if sorted_word != srt[-1]:\\n                srt.append(sorted_word)\\n                res.append(word)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3911604,
                "title": "python-2-pointers-while",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        j = i+1\\n        n = len(words)\\n        res = []\\n        while j < n:\\n            if sorted(words[i]) == sorted(words[j]): \\n                if j == i+1:\\n                    res.append(words[i])\\n            else: \\n                if j == i+1:\\n                    res.append(words[i])\\n                i = j\\n            j += 1\\n\\n        if j == i+1:\\n            res.append(words[i])  \\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        j = i+1\\n        n = len(words)\\n        res = []\\n        while j < n:\\n            if sorted(words[i]) == sorted(words[j]): \\n                if j == i+1:\\n                    res.append(words[i])\\n            else: \\n                if j == i+1:\\n                    res.append(words[i])\\n                i = j\\n            j += 1\\n\\n        if j == i+1:\\n            res.append(words[i])  \\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906583,
                "title": "easiest-c-code",
                "content": "# Code\\n```\\npublic class Solution {\\n    private int[] GetCharMap(string s) {\\n        int[] map = new int[26];\\n\\n        foreach (char c in s) {\\n            map[c - \\'a\\']++;\\n        }\\n\\n        return map;\\n    }\\n\\n    private bool IsSameCharMap(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.Length; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> result = new List<string> { words[0] };\\n        int[] charMap = GetCharMap(words[0]);\\n\\n        for (int i = 1; i < words.Length; i++) {\\n            int[] nextCharMap = GetCharMap(words[i]);\\n\\n            if (!IsSameCharMap(charMap, nextCharMap)) {\\n                charMap = nextCharMap;\\n                result.Add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    private int[] GetCharMap(string s) {\\n        int[] map = new int[26];\\n\\n        foreach (char c in s) {\\n            map[c - \\'a\\']++;\\n        }\\n\\n        return map;\\n    }\\n\\n    private bool IsSameCharMap(int[] arr1, int[] arr2) {\\n        for (int i = 0; i < arr1.Length; i++) {\\n            if (arr1[i] != arr2[i]) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n\\n    public IList<string> RemoveAnagrams(string[] words) {\\n        List<string> result = new List<string> { words[0] };\\n        int[] charMap = GetCharMap(words[0]);\\n\\n        for (int i = 1; i < words.Length; i++) {\\n            int[] nextCharMap = GetCharMap(words[i]);\\n\\n            if (!IsSameCharMap(charMap, nextCharMap)) {\\n                charMap = nextCharMap;\\n                result.Add(words[i]);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3899171,
                "title": "by-using-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for(var i=0;i<words.length-1;i++)\\n    {\\n        var x=words[i].split(\"\").sort().join(\"\");\\n        var y=words[i+1].split(\"\").sort().join(\"\");\\n        if(x==y)\\n        {\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for(var i=0;i<words.length-1;i++)\\n    {\\n        var x=words[i].split(\"\").sort().join(\"\");\\n        var y=words[i+1].split(\"\").sort().join(\"\");\\n        if(x==y)\\n        {\\n            words.splice(i+1,1)\\n            i--;\\n        }\\n    }\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892186,
                "title": "java-best-solution-4-ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n     Brute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(nklogk)\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> list=new ArrayList<>();\\n        String temp=\"\";\\n        for(String s:words){\\n            char[] c=s.toCharArray();\\n            Arrays.sort(c);\\n            String current=new String(c);\\n            if(!current.equals(temp))\\n                list.add(s);\\n            temp=current;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        ArrayList<String> list=new ArrayList<>();\\n        String temp=\"\";\\n        for(String s:words){\\n            char[] c=s.toCharArray();\\n            Arrays.sort(c);\\n            String current=new String(c);\\n            if(!current.equals(temp))\\n                list.add(s);\\n            temp=current;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879943,
                "title": "simplest-python-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        left = [0] * 26\\n        for w in words:\\n            right = [0] * 26\\n            for c in w:\\n                right[ord(c)-ord(\\'a\\')] +=1\\n\\n            if left != right:\\n                res.append(w)\\n            left, right = right, left \\n        \\n        return res\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        left = [0] * 26\\n        for w in words:\\n            right = [0] * 26\\n            for c in w:\\n                right[ord(c)-ord(\\'a\\')] +=1\\n\\n            if left != right:\\n                res.append(w)\\n            left, right = right, left \\n        \\n        return res\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879899,
                "title": "easy-to-understand-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought is to use what I learned from validAnagrams. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI used a while loop to loop through the words list. If words[i] and words[i+1] are anagrams, I will pop words[i+1] from the list. And then, in the next loop, the words[i+1] becomes the next element of the poped element from last cycle.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nI am not sure about the time complexity, I guess it\\'s O(n2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nI am guessing O(n) for space complexity\\n# Code\\n```\\n\\nclass Solution:\\n\\n    def checkAnagrams(self, string1, string2):\\n        dict1 = {}\\n        dict2 = {}\\n        for char in string1:\\n            dict1[char] = 1 + dict1.get(char, 0)\\n        for char in string2:\\n            dict2[char] = 1 + dict2.get(char, 0)\\n        return dict1 == dict2\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if self.checkAnagrams(words[i], words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i+=1\\n\\n        return words\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n\\n    def checkAnagrams(self, string1, string2):\\n        dict1 = {}\\n        dict2 = {}\\n        for char in string1:\\n            dict1[char] = 1 + dict1.get(char, 0)\\n        for char in string2:\\n            dict2[char] = 1 + dict2.get(char, 0)\\n        return dict1 == dict2\\n\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        i = 0\\n        while i < len(words) - 1:\\n            if self.checkAnagrams(words[i], words[i+1]):\\n                words.pop(i+1)\\n            else:\\n                i+=1\\n\\n        return words\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3877970,
                "title": "very-simple-and-easy-cpp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return (s == t) ? true : false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& v) {\\n        int n = v.size();\\n        vector<string> ans = {v[0]}; \\n        \\n        for(int i = 0; i<n ;i++){\\n            if( isAnagram(v[i] , ans[ans.size()-1]) ){\\n                // do nothing\\n            }\\n            else{\\n                ans.push_back(v[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isAnagram(string s, string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return (s == t) ? true : false;\\n    }\\n    vector<string> removeAnagrams(vector<string>& v) {\\n        int n = v.size();\\n        vector<string> ans = {v[0]}; \\n        \\n        for(int i = 0; i<n ;i++){\\n            if( isAnagram(v[i] , ans[ans.size()-1]) ){\\n                // do nothing\\n            }\\n            else{\\n                ans.push_back(v[i]);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3868647,
                "title": "js-short-60-90",
                "content": "# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst sortWord = (word) => word.split(\\'\\').sort().join(\\'\\');\\n\\nconst removeAnagrams = (words) => {\\n    for (let i = 1; i < words.length;) {\\n        if (sortWord(words[i - 1]) === sortWord(words[i])) words.splice(i, 1);\\n        else i++;\\n    }\\n\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nconst sortWord = (word) => word.split(\\'\\').sort().join(\\'\\');\\n\\nconst removeAnagrams = (words) => {\\n    for (let i = 1; i < words.length;) {\\n        if (sortWord(words[i - 1]) === sortWord(words[i])) words.splice(i, 1);\\n        else i++;\\n    }\\n\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861202,
                "title": "find-resultant-array-after-removing-anagrams",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String  s = \"\";\\n        List<String> li = new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] arr =words[i].toCharArray();\\n            Arrays.sort(arr);\\n            String cur = String.valueOf(arr);\\n            if(!cur.equals(s)){\\n                li.add(words[i]);\\n                s = cur;\\n            }\\n        }\\n        return li;\\n        \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String  s = \"\";\\n        List<String> li = new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] arr =words[i].toCharArray();\\n            Arrays.sort(arr);\\n            String cur = String.valueOf(arr);\\n            if(!cur.equals(s)){\\n                li.add(words[i]);\\n                s = cur;\\n            }\\n        }\\n        return li;\\n        \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3842125,
                "title": "one-line-solution-runtime-40ms-100-00",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        return list(map(lambda word: next(word[1]), groupby(words, key= sorted)))\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n        return list(map(lambda word: next(word[1]), groupby(words, key= sorted)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833155,
                "title": "cpp-easy-code-clean-code",
                "content": "\\n# Complexity\\n- Time complexity:O(n*log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isanagram(string s,string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        for(int i=n-1;i>0;i--){\\n            if(isanagram(words[i],words[i-1])){\\n                words[i]=\"AMAN\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(auto e: words){\\n            if(e==\"AMAN\")continue;\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isanagram(string s,string t){\\n        sort(s.begin(),s.end());\\n        sort(t.begin(),t.end());\\n        return s==t;\\n    }\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        for(int i=n-1;i>0;i--){\\n            if(isanagram(words[i],words[i-1])){\\n                words[i]=\"AMAN\";\\n            }\\n        }\\n        vector<string> ans;\\n        for(auto e: words){\\n            if(e==\"AMAN\")continue;\\n            ans.push_back(e);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3826214,
                "title": "js-ez",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for (let i = words.length - 1; i > 0; i--) {\\n        if (isAnagram(words[i], words[i - 1])) {\\n            words.splice(i, 1);\\n        }\\n    }\\n\\n    return words;\\n};\\n\\nconst isAnagram = (wordOne, wordTwo) => {\\n    return wordOne.split(\"\").sort().join(\"\") === wordTwo.split(\"\").sort().join(\"\")\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    for (let i = words.length - 1; i > 0; i--) {\\n        if (isAnagram(words[i], words[i - 1])) {\\n            words.splice(i, 1);\\n        }\\n    }\\n\\n    return words;\\n};\\n\\nconst isAnagram = (wordOne, wordTwo) => {\\n    return wordOne.split(\"\").sort().join(\"\") === wordTwo.split(\"\").sort().join(\"\")\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3822486,
                "title": "java-very-easy-0sec",
                "content": "# Intuition\\n![upvote.png](https://assets.leetcode.com/users/images/2fa81ae1-1e2a-48d1-9974-f32a110a86f3_1690442496.7153208.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        String prev =\"\";\\n        List<String> li=new ArrayList<>();\\n        for(int i=0;i<words.length;i++){\\n            char[] ch=words[i].toCharArray();\\n            Arrays.sort(ch);\\n            String curr=String.valueOf(ch);\\n            if(!curr.equals(prev)){\\n                li.add(words[i]);\\n                prev=curr;\\n            }\\n        }\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820055,
                "title": "java-solution-using-string-comparison",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isanagram(String s1,String s2){\\n        char[] a=s1.toCharArray();\\n        char[] b=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String s11=String.valueOf(a);\\n        String s22=String.valueOf(b);\\n        return s11.equals(s22);\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n       List<String> list=new ArrayList<>();\\n       list.add(words[0]);\\n       for(int i=1;i<words.length;i++){\\n           if(!isanagram(words[i-1],words[i])){\\n               list.add(words[i]);\\n           }\\n       } \\n       return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isanagram(String s1,String s2){\\n        char[] a=s1.toCharArray();\\n        char[] b=s2.toCharArray();\\n        Arrays.sort(a);\\n        Arrays.sort(b);\\n        String s11=String.valueOf(a);\\n        String s22=String.valueOf(b);\\n        return s11.equals(s22);\\n    }\\n    public List<String> removeAnagrams(String[] words) {\\n       List<String> list=new ArrayList<>();\\n       list.add(words[0]);\\n       for(int i=1;i<words.length;i++){\\n           if(!isanagram(words[i-1],words[i])){\\n               list.add(words[i]);\\n           }\\n       } \\n       return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3813406,
                "title": "php-two-pointers-solution",
                "content": "# Complexity\\n- Time complexity: O(n)\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\n\\n    /**\\n     * @param String[] $words\\n     * @return String[]\\n     */\\n    function removeAnagrams($words) {     \\n        $left = 0;\\n        $right = 1;\\n        while (isset($words[$right])) {\\n            // Check if the current word is an anagram of the next word\\n            if ($this->isAnagram($words[$left], $words[$right]) === true) {\\n                unset($words[$right]); // Remove the anagram from the array\\n            } else {\\n                $left = $right; // Move the left pointer to the next non-anagram word\\n            }\\n            $right++; // Move the right pointer to the next word to be compared\\n        }\\n\\n        return $words;\\n    }\\n\\n    /**\\n     * Check if two words are anagrams.\\n     * Anagrams are words that have the same characters but in a different order.\\n     * @param string $current The first word\\n     * @param string $next The second word\\n     * @return bool True if the words are anagrams, False otherwise\\n     */\\n    function isAnagram(string $current, string $next) {\\n        $a = str_split($current);\\n        $b = str_split($next);\\n        sort($a);                 // Sort the characters of the first word in alphabetical order\\n        sort($b);                 // Sort the characters of the second word in alphabetical order\\n        return implode($a) == implode($b); // Check if the sorted words are equal, i.e., they are anagrams\\n    }\\n \\n}\\n```",
                "solutionTags": [
                    "PHP",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n\\n\\n    /**\\n     * @param String[] $words\\n     * @return String[]\\n     */\\n    function removeAnagrams($words) {     \\n        $left = 0;\\n        $right = 1;\\n        while (isset($words[$right])) {\\n            // Check if the current word is an anagram of the next word\\n            if ($this->isAnagram($words[$left], $words[$right]) === true) {\\n                unset($words[$right]); // Remove the anagram from the array\\n            } else {\\n                $left = $right; // Move the left pointer to the next non-anagram word\\n            }\\n            $right++; // Move the right pointer to the next word to be compared\\n        }\\n\\n        return $words;\\n    }\\n\\n    /**\\n     * Check if two words are anagrams.\\n     * Anagrams are words that have the same characters but in a different order.\\n     * @param string $current The first word\\n     * @param string $next The second word\\n     * @return bool True if the words are anagrams, False otherwise\\n     */\\n    function isAnagram(string $current, string $next) {\\n        $a = str_split($current);\\n        $b = str_split($next);\\n        sort($a);                 // Sort the characters of the first word in alphabetical order\\n        sort($b);                 // Sort the characters of the second word in alphabetical order\\n        return implode($a) == implode($b); // Check if the sorted words are equal, i.e., they are anagrams\\n    }\\n \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3804154,
                "title": "remove-anagrams-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        def anagrams(str1,str2):\\n            str1,str2 = str1.lower(), str2.lower()\\n            if sorted(str1) == sorted(str2):\\n                return True\\n            else:\\n                return False\\n\\n        i = 0\\n        length = len(words)\\n        while(i<length-1):\\n            if anagrams(words[i],words[i+1]):\\n                words.pop(i+1)\\n                i -= 1\\n                length -= 1\\n            i += 1\\n        return words\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeAnagrams(self, words):\\n        def anagrams(str1,str2):\\n            str1,str2 = str1.lower(), str2.lower()\\n            if sorted(str1) == sorted(str2):\\n                return True\\n            else:\\n                return False\\n\\n        i = 0\\n        length = len(words)\\n        while(i<length-1):\\n            if anagrams(words[i],words[i+1]):\\n                words.pop(i+1)\\n                i -= 1\\n                length -= 1\\n            i += 1\\n        return words\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3795474,
                "title": "stack-based-solution",
                "content": "# Intuition : \\nusing merging interval intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach : \\nusing stack instead of map\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++){\\n            string a = words[i];\\n            string b = s.top();\\n            sort(b.begin(),b.end());\\n            sort(a.begin(),a.end());\\n            if(a==b){\\n                continue;\\n            }\\n            else{\\n                s.push(words[i]);\\n            }\\n        }\\n        vector<string>ans;\\n        while(!s.empty()){\\n            string a = s.top();\\n            ans.push_back(a);\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        stack<string>s;\\n        s.push(words[0]);\\n        for(int i=1;i<words.size();i++){\\n            string a = words[i];\\n            string b = s.top();\\n            sort(b.begin(),b.end());\\n            sort(a.begin(),a.end());\\n            if(a==b){\\n                continue;\\n            }\\n            else{\\n                s.push(words[i]);\\n            }\\n        }\\n        vector<string>ans;\\n        while(!s.empty()){\\n            string a = s.top();\\n            ans.push_back(a);\\n            s.pop();\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3793306,
                "title": "easy-java-solution-two-pointer",
                "content": "# Complexity\\n- Time complexity:  O(n*log(n)) \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(n + m) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] strs) {\\n        List<Integer> toBeRemoved = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        int prev = 0;\\n        int current = 1;\\n        while (current < strs.length) {\\n            if (isAnagram(strs[current], strs[prev]))\\n                toBeRemoved.add(current);\\n            else\\n                prev = current;\\n\\n            current++;\\n        }\\n        for (int str = 0; str < strs.length; str++) {\\n            if (!toBeRemoved.contains(str)) {\\n                res.add(strs[str]);\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isAnagram(String str1, String str2) {\\n        char[] chars = str1.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr1 = new String(chars);\\n        chars = str2.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr2 = new String(chars);\\n        return sortedStr1.equals(sortedStr2);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] strs) {\\n        List<Integer> toBeRemoved = new ArrayList<>();\\n        List<String> res = new ArrayList<>();\\n        int prev = 0;\\n        int current = 1;\\n        while (current < strs.length) {\\n            if (isAnagram(strs[current], strs[prev]))\\n                toBeRemoved.add(current);\\n            else\\n                prev = current;\\n\\n            current++;\\n        }\\n        for (int str = 0; str < strs.length; str++) {\\n            if (!toBeRemoved.contains(str)) {\\n                res.add(strs[str]);\\n            }\\n        }\\n        return res;\\n    }\\n    public boolean isAnagram(String str1, String str2) {\\n        char[] chars = str1.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr1 = new String(chars);\\n        chars = str2.toCharArray();\\n        Arrays.sort(chars);\\n        String sortedStr2 = new String(chars);\\n        return sortedStr1.equals(sortedStr2);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3791459,
                "title": "python-simple-python-solution-sorting",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 69 ms, faster than 71.36% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n# Memory Usage: 16.4 MB, less than 25.48% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n\\n\\tclass Solution:\\n\\t\\tdef removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\tresult = [words[0]]\\n\\n\\t\\t\\tfor word in words[1:]:\\n\\n\\t\\t\\t\\tif sorted(result[-1]) != sorted(word):\\n\\t\\t\\t\\t\\tresult.append(word)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Time complexity: O(N)\\n# Space complexity: O(N)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack",
                    "Sorting"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 69 ms, faster than 71.36% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n# Memory Usage: 16.4 MB, less than 25.48% of Python3 online submissions for Find Resultant Array After Removing Anagrams.\\n\\n\\tclass Solution:\\n\\t\\tdef removeAnagrams(self, words: List[str]) -> List[str]:\\n\\n\\t\\t\\tresult = [words[0]]\\n\\n\\t\\t\\tfor word in words[1:]:\\n\\n\\t\\t\\t\\tif sorted(result[-1]) != sorted(word):\\n\\t\\t\\t\\t\\tresult.append(word)\\n\\n\\t\\t\\treturn result\\n\\t\\t\\t\\n# Time complexity: O(N)\\n# Space complexity: O(N)\\n# Thank You \\uD83E\\uDD73\\u270C\\uD83D\\uDC4D",
                "codeTag": "Java"
            },
            {
                "id": 3790903,
                "title": "for-loop-and-counter",
                "content": "# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        check = Counter(words[0])\\n        result = [0]\\n        for i in range(1, len(words)):\\n            word = Counter(words[i])\\n            if check != word:\\n                result.append(i)\\n                check = word\\n        return [words[i] for i in result]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        check = Counter(words[0])\\n        result = [0]\\n        for i in range(1, len(words)):\\n            word = Counter(words[i])\\n            if check != word:\\n                result.append(i)\\n                check = word\\n        return [words[i] for i in result]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787106,
                "title": "easy-javascript-solution-satisfying-all-test-cases",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    let sortedWords = words.map((word) => {\\n        return word.split(\"\").sort().join(\"\");\\n    });\\n\\n     for(let i=0; i< sortedWords.length;i++) {\\n         if(sortedWords[i+1] === sortedWords[i]) {\\n             sortedWords.splice(i+1,1);\\n             words.splice(i+1,1);\\n             i--;\\n         }\\n     }\\n\\n    return words;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    let sortedWords = words.map((word) => {\\n        return word.split(\"\").sort().join(\"\");\\n    });\\n\\n     for(let i=0; i< sortedWords.length;i++) {\\n         if(sortedWords[i+1] === sortedWords[i]) {\\n             sortedWords.splice(i+1,1);\\n             words.splice(i+1,1);\\n             i--;\\n         }\\n     }\\n\\n    return words;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3785264,
                "title": "c-solution",
                "content": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n\\tvector<string> res;\\n\\tfor (int i = 0; i < words.size(); i++) {\\n\\t\\tres.push_back(words[i]);\\n\\t\\tstring sorted = words[i];\\n\\t\\tsort(begin(sorted), end(sorted));\\n\\t\\tint j = i + 1;\\n\\t\\twhile (j < words.size()) {\\n\\t\\t\\tstring sortedj = words[j++];\\n\\t\\t\\tsort(begin(sortedj), end(sortedj));\\n\\t\\t\\tif (sorted == sortedj)\\n\\t\\t\\t\\ti++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<string> removeAnagrams(vector<string>& words) {\\n\\tvector<string> res;\\n\\tfor (int i = 0; i < words.size(); i++) {\\n\\t\\tres.push_back(words[i]);\\n\\t\\tstring sorted = words[i];\\n\\t\\tsort(begin(sorted), end(sorted));\\n\\t\\tint j = i + 1;\\n\\t\\twhile (j < words.size()) {\\n\\t\\t\\tstring sortedj = words[j++];\\n\\t\\t\\tsort(begin(sortedj), end(sortedj));\\n\\t\\t\\tif (sorted == sortedj)\\n\\t\\t\\t\\ti++;\\n\\t\\t\\telse\\n\\t\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3776388,
                "title": "easy-to-understand-python-3",
                "content": "## **Runtime**\\n- 65ms\\nBeats 85.32% of users with Python3\\n\\n## **Memory**\\n- 16.34mb\\nBeats 62.96%of users with Python3\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        p = words[0]\\n        for i in words:\\n            if sorted(i) != sorted(p):\\n                res.append(p)\\n                p = i\\n        res.append(p)\\n        return res\\n                \\n\\n                \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n        res = []\\n        p = words[0]\\n        for i in words:\\n            if sorted(i) != sorted(p):\\n                res.append(p)\\n                p = i\\n        res.append(p)\\n        return res\\n                \\n\\n                \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772853,
                "title": "find-resultant-array-after-removing-anagrams-c-9ms-solution-easy-approch-o-n-2logn",
                "content": "# Intuition :-\\n<ul><li>The one basic intution about \"Anagrams\" is that an \"Anagram\" is a string which has the same frequency of character with another string. (or) ,</li>\\n<br/>\\n<li>An \"anagram\" of a string is another string that contains the same characters, only the order of characters can be different eg:- \"abba\" is an anagram of \"abab\" and vice-verse as freq of a=2 and b=2 here.</li>\\n<br/>\\n<li>Now coming to idea the basic approch to this is sorting the string and checking.</li>\\n</ul>\\n\\n# Approach :-\\n<ul><li>At first we store the words vector into a temporary vector for our processing and maintaining the string we want.</li>  \\n    <br/>\\n    <li>Now for anagram we sort the words as after sorting we check weather the loop have any one equal word or not if not we return n-1 as all the words in words vector are anagrams.</li>\\n    <br/>\\n<li>If not then in the below for loop we check weather the two adjacent words that is words[i]==words[i+1] if they are we also have to check if this word already present in our ans if it is we can\\'t insert more of this as we want all the words(elements) of res to be anagram same if they are not equal also.</li>\\n    <br/>\\n<li>Fianlly we check if the beginning word is equal to adjacent or not as we were not able to insert if it was into res.</li>\\n<br/>\\n<li>Finally returning res as answer.</li>\\n</ul>\\n\\n# Complexity :-\\n- Time complexity:\\nO((n^2)logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string>temp;\\n        vector<string>res;\\n        unordered_map<string,bool>m;\\n\\n        temp = words;\\n\\n        for(int i=0;i<n;i++) {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n\\n        int c=0;\\n        for(int i=0;i<n-1;i++) {\\n            if(temp[i]!=temp[i+1]) c++;\\n        }\\n        \\n        // If all the words are anagrams.\\n        if(c==n-1) res = words;\\n\\n        // If not then we process and find the only anagrams.\\n        else {\\n            for(int i=0;i<n-1;i++) {\\n                if(m[temp[i]]!=true && temp[i]==temp[i+1]) {\\n                    res.push_back(words[i]);\\n                    m[temp[i]] = true;\\n                }\\n                else {\\n                    if(temp[i]!=temp[i+1]) {\\n                        res.push_back(words[i+1]);\\n                        m[temp[i+1]] = true;\\n                    }\\n                }\\n            }\\n\\n            if(temp.size()>1 && temp[0]!=temp[1]) {\\n                res.insert(res.begin(),words[0]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```\\n<img src=\"https://i.imgflip.com/7abc56.jpg\" alt=\"Please Upvote\">",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n = words.size();\\n        vector<string>temp;\\n        vector<string>res;\\n        unordered_map<string,bool>m;\\n\\n        temp = words;\\n\\n        for(int i=0;i<n;i++) {\\n            sort(temp[i].begin(),temp[i].end());\\n        }\\n\\n        int c=0;\\n        for(int i=0;i<n-1;i++) {\\n            if(temp[i]!=temp[i+1]) c++;\\n        }\\n        \\n        // If all the words are anagrams.\\n        if(c==n-1) res = words;\\n\\n        // If not then we process and find the only anagrams.\\n        else {\\n            for(int i=0;i<n-1;i++) {\\n                if(m[temp[i]]!=true && temp[i]==temp[i+1]) {\\n                    res.push_back(words[i]);\\n                    m[temp[i]] = true;\\n                }\\n                else {\\n                    if(temp[i]!=temp[i+1]) {\\n                        res.push_back(words[i+1]);\\n                        m[temp[i+1]] = true;\\n                    }\\n                }\\n            }\\n\\n            if(temp.size()>1 && temp[0]!=temp[1]) {\\n                res.insert(res.begin(),words[0]);\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770019,
                "title": "o-1-sc-and-o-n-log-n-tc-simple-approach",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\nO(n * log(n))\\n\\n- Space complexity:\\nO(1)\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        int n = words.length;\\n        \\n        List<String> li = new ArrayList<>();\\n        int i = 0;\\n        while(i<n){\\n            li.add(words[i]);\\n            char curr[] = words[i].toCharArray();\\n            Arrays.sort(curr);\\n            String current = new String(curr);\\n            String prev = current;\\n            while(current.equals(prev)){\\n                i++;\\n                if(i<n){\\n                    curr = words[i].toCharArray();\\n                    Arrays.sort(curr);\\n                    prev = new String(curr);\\n                }else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n        return li;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        int n = words.length;\\n        \\n        List<String> li = new ArrayList<>();\\n        int i = 0;\\n        while(i<n){\\n            li.add(words[i]);\\n            char curr[] = words[i].toCharArray();\\n            Arrays.sort(curr);\\n            String current = new String(curr);\\n            String prev = current;\\n            while(current.equals(prev)){\\n                i++;\\n                if(i<n){\\n                    curr = words[i].toCharArray();\\n                    Arrays.sort(curr);\\n                    prev = new String(curr);\\n                }else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n\\n        return li;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766658,
                "title": "java-comparing-alphabet-arrays-beats-99",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        int[] prev = new int[26];\\n        for(String word: words) {\\n            int[] curr = new int[26];\\n            for(char ch: word.toCharArray()) curr[ch - \\'a\\']++;\\n            if(list.isEmpty()|| !Arrays.equals(curr, prev)) {\\n                list.add(word);\\n                prev = curr;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<String> removeAnagrams(String[] words) {\\n        List<String> list = new ArrayList<>();\\n        int[] prev = new int[26];\\n        for(String word: words) {\\n            int[] curr = new int[26];\\n            for(char ch: word.toCharArray()) curr[ch - \\'a\\']++;\\n            if(list.isEmpty()|| !Arrays.equals(curr, prev)) {\\n                list.add(word);\\n                prev = curr;\\n            }\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3758014,
                "title": "c-easy-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nexplained line by line in below code see\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string frst=words[i];\\n            sort(frst.begin(),frst.end());\\n            string scnd=words[i-1];\\n            sort(scnd.begin(),scnd.end());\\n            if(frst==scnd)\\n            {\\n                words.erase(words.begin()+i);\\n                i--;\\n            }\\n           \\n        }\\n        return words;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        for(int i=1;i<words.size();i++)\\n        {\\n            string frst=words[i];\\n            sort(frst.begin(),frst.end());\\n            string scnd=words[i-1];\\n            sort(scnd.begin(),scnd.end());\\n            if(frst==scnd)\\n            {\\n                words.erase(words.begin()+i);\\n                i--;\\n            }\\n           \\n        }\\n        return words;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754616,
                "title": "brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBrute Force\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force, use for loops\\n\\n# Complexity\\n- Time complexity: O(len(words) * len(words[i]))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n**        #mark elements to be removed**\\n        mark_idx = [0] * len(words)\\n\\n**        #itr through the list, mark**\\n        for i in range(len(words) - 1):\\n            my_array = [0] * 26\\n            for j in range(len(words[i])):\\n                my_array[ord(words[i][j]) - 97] += 1\\n            comp_array = [0] * 26\\n            for l in range(len(words[i+1])):\\n                comp_array[ord(words[i+1][l]) - 97] += 1\\n            if all(elt1 == elt2 for elt1, elt2 in zip(my_array, comp_array)):\\n                mark_idx[i+1] = 1\\n\\n**        #list to return**\\n        return_array = []\\n        for i in range(len(words)):\\n            if (mark_idx[i] == 0):\\n                return_array.append(words[i])\\n        return return_array\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeAnagrams(self, words: List[str]) -> List[str]:\\n**        #mark elements to be removed**\\n        mark_idx = [0] * len(words)\\n\\n**        #itr through the list, mark**\\n        for i in range(len(words) - 1):\\n            my_array = [0] * 26\\n            for j in range(len(words[i])):\\n                my_array[ord(words[i][j]) - 97] += 1\\n            comp_array = [0] * 26\\n            for l in range(len(words[i+1])):\\n                comp_array[ord(words[i+1][l]) - 97] += 1\\n            if all(elt1 == elt2 for elt1, elt2 in zip(my_array, comp_array)):\\n                mark_idx[i+1] = 1\\n\\n**        #list to return**\\n        return_array = []\\n        for i in range(len(words)):\\n            if (mark_idx[i] == 0):\\n                return_array.append(words[i])\\n        return return_array\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3741761,
                "title": "two-pointers-erase-not-reqd-c-easy",
                "content": "# Intuition\\nTwo Pointers without using erase function\\n\\n# Complexity\\n- Time complexity:\\nO(nklogk)  (k is the max length of string)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> ans;\\n        // ans.push_back(words[0]);\\n        int prev=0,i=1;\\n        if(n==1)\\n            return words;\\n        while(i<n)\\n        {\\n            while(i<n && isanagram(words[i],words[prev]))\\n            {\\n                i++;\\n            }\\n            ans.push_back(words[prev]);\\n            if(i==n-1)\\n                ans.push_back(words[i]);\\n            prev=i;\\n            i++;\\n        }\\n        return ans;\\n    }\\n   bool isanagram(string a,string b)\\n   {\\n       if(a.length()!=b.length())\\n        return false;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a==b)\\n            return true;\\n        return false;\\n   }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<string> removeAnagrams(vector<string>& words) {\\n        int n=words.size();\\n        vector<string> ans;\\n        // ans.push_back(words[0]);\\n        int prev=0,i=1;\\n        if(n==1)\\n            return words;\\n        while(i<n)\\n        {\\n            while(i<n && isanagram(words[i],words[prev]))\\n            {\\n                i++;\\n            }\\n            ans.push_back(words[prev]);\\n            if(i==n-1)\\n                ans.push_back(words[i]);\\n            prev=i;\\n            i++;\\n        }\\n        return ans;\\n    }\\n   bool isanagram(string a,string b)\\n   {\\n       if(a.length()!=b.length())\\n        return false;\\n        sort(a.begin(),a.end());\\n        sort(b.begin(),b.end());\\n        if(a==b)\\n            return true;\\n        return false;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740806,
                "title": "remove-anagrams-js-intuitive-92",
                "content": "1. Solution simple but slow ( double sorting ) - Beats 26.5 %\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        if (anagram(words[i-1], words[i])) {\\n            words.splice(i, 1), i--\\n        }\\n    }\\n\\n    function anagram(str1, str2) {\\n        if (str1.length != str2.length) return false\\n        return str1.split(\\'\\').sort().join() == str2.split(\\'\\').sort().join()\\n    }\\n\\n    return words\\n};\\n```\\n2. Solution 2x times faster ( once sort every words[i] ) - Beats 92.37 %\\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    prev = \\'\\'\\n\\n    for (let i = 0; i < words.length; i++) {\\n        str = words[i].split(\\'\\').sort().join(\\'\\')\\n        str == prev && words.splice(i, 1) && i--\\n        prev = str\\n    }\\n\\n    return words\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    \\n    for (let i = 1; i < words.length; i++) {\\n        if (anagram(words[i-1], words[i])) {\\n            words.splice(i, 1), i--\\n        }\\n    }\\n\\n    function anagram(str1, str2) {\\n        if (str1.length != str2.length) return false\\n        return str1.split(\\'\\').sort().join() == str2.split(\\'\\').sort().join()\\n    }\\n\\n    return words\\n};\\n```\n```\\n/**\\n * @param {string[]} words\\n * @return {string[]}\\n */\\nvar removeAnagrams = function(words) {\\n    prev = \\'\\'\\n\\n    for (let i = 0; i < words.length; i++) {\\n        str = words[i].split(\\'\\').sort().join(\\'\\')\\n        str == prev && words.splice(i, 1) && i--\\n        prev = str\\n    }\\n\\n    return words\\n};\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1683714,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1786585,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1714798,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2036581,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2016048,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 2005525,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1828179,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            },
            {
                "id": 1721292,
                "content": [
                    {
                        "username": "Sudha_S",
                        "content": "words = [\"a\", \"b\", \"a\"]\\nOutput  = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\n\\nTestcase 167 is wrong. Please look into it. "
                    },
                    {
                        "username": "wyldbill",
                        "content": "Actually, I\\'m going to revise my statement. The problem statement says:\\n\"In one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words\"\\n\\nEssentially we are supposed to remove _consecutive_ anagrams, not all anagrams present. It\\'d be nice if the problem was stated and/or named that way. If that is correct, then this test case is correct."
                    },
                    {
                        "username": "wyldbill",
                        "content": "Yup. \\nActually got a passing submission until I read this comment, then re-implemented exactly as specified in the problem statement....."
                    },
                    {
                        "username": "speeep",
                        "content": "So true"
                    },
                    {
                        "username": "heg816",
                        "content": "Please change title to \"Find Resultant Array After Removing Consecutive Anagrams\" or include example testcase that demonstates this-- it seems easy to miss this detail."
                    },
                    {
                        "username": "Ber40",
                        "content": "words =[\"ab\",\"bc\",\"cb\",\"ab\",\"bc\"]\\nOutput = [\"ab\",\"bc\"]\\nExpected = [\"ab\",\"bc\",\"ab\",\"bc\"]\\n\\nTestcase 195 is wrong. "
                    },
                    {
                        "username": "user2285TI",
                        "content": "Problem statement specifies that when two adjacent words are anagrams, the later one in the list should be deleted. What you are doing here is deleting all later cases of anagrams and not just from adjacent pairs.  "
                    },
                    {
                        "username": "Noobcoooooder",
                        "content": "Tip :\\nFor every index i, find the largest index j < i such that words[j] will be present in the final answer.\\nCheck if words[i] and words[j] are anagrams. If they are, then it can be confirmed that words[i] will not be present in the final answer.\\n"
                    },
                    {
                        "username": "SinghManraj",
                        "content": "For those whose test case fails at : \\nwords = [\"a\", \"b\", \"a\"]\\nOutput = [\"a\", \"b\"]\\nExpected = [\"a\", \"b\", \"a\"]\\nRead question statement carefully, we have to delete adjacent anagrams, not all possible anagrams from vector.\\n\\nIn one operation, select any index i such that 0 < i < words.length and words[i - 1] and words[i] are anagrams, and delete words[i] from words."
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "````\\n[\"z\",\"z\",\"z\",\"gsw\",\"wsg\",\"gsw\",\"krptu\"]\\noutput - [\"gsw\",\"krptu\",\"z\"]\\nexpected - [\"z\",\"gsw\",\"krptu\"]\\n````\\nWhy my ans is wrong?"
                    },
                    {
                        "username": "sarthak6596",
                        "content": "what should be the ouput for this one:\\ninput:\\n[\"az\",\"azz\"]\\noutput:\\n[\"az\"]\\nexpected:\\n[\"az\",\"azz\"]"
                    },
                    {
                        "username": "debdeepsanyal",
                        "content": "\"azz\" and \"az\" are not anagrams since they dont have the same number of alphabets in the first place. \"za\" is an anagram for \"az\" or \"zaz\" is an anagram for \"azz\" but the two arent anagrams to each other "
                    },
                    {
                        "username": "topswe",
                        "content": "You want the first unique anagrams in some consecutive sequence of anagrams."
                    }
                ]
            }
        ]
    },
    {
        "title": "Partition Array Such That Maximum Difference Is K",
        "question_content": "<p>You are given an integer array <code>nums</code> and an integer <code>k</code>. You may partition <code>nums</code> into one or more <strong>subsequences</strong> such that each element in <code>nums</code> appears in <strong>exactly</strong> one of the subsequences.</p>\n\n<p>Return <em>the <strong>minimum </strong>number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is <strong>at most</strong> </em><code>k</code><em>.</em></p>\n\n<p>A <strong>subsequence</strong> is a sequence that can be derived from another sequence by deleting some or no elements without changing the order of the remaining elements.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,6,1,2,5], k = 2\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nWe can partition nums into the two subsequences [3,1,2] and [6,5].\nThe difference between the maximum and minimum value in the first subsequence is 3 - 1 = 2.\nThe difference between the maximum and minimum value in the second subsequence is 6 - 5 = 1.\nSince two subsequences were created, we return 2. It can be shown that 2 is the minimum number of subsequences needed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,3], k = 1\n<strong>Output:</strong> 2\n<strong>Explanation:</strong>\nWe can partition nums into the two subsequences [1,2] and [3].\nThe difference between the maximum and minimum value in the first subsequence is 2 - 1 = 1.\nThe difference between the maximum and minimum value in the second subsequence is 3 - 3 = 0.\nSince two subsequences were created, we return 2. Note that another optimal solution is to partition nums into the two subsequences [1] and [2,3].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [2,2,4,5], k = 0\n<strong>Output:</strong> 3\n<strong>Explanation:</strong>\nWe can partition nums into the three subsequences [2,2], [4], and [5].\nThe difference between the maximum and minimum value in the first subsequences is 2 - 2 = 0.\nThe difference between the maximum and minimum value in the second subsequences is 4 - 4 = 0.\nThe difference between the maximum and minimum value in the third subsequences is 5 - 5 = 0.\nSince three subsequences were created, we return 3. It can be shown that 3 is the minimum number of subsequences needed.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>0 &lt;= k &lt;= 10<sup>5</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2112243,
                "title": "java-c-python-sort-greedy",
                "content": "# **Explanation**\\n`mn` means the minimum number in the current sequence.\\n`mx` means the maximum number in the current sequence.\\n\\nIterate each element `A[i]` in the input array,\\nand we try to add it into the current subsequence.\\n\\nWe need to check if the differnce is still good.\\nSo we firstly update the value of  `mn` and `mx`\\n`mn = min(mn, a)`\\n`mx = max(mx, a)`.\\n\\n\\nIf `mx - mn > k`,\\nthis means the difference between the maximum and minimum values,\\nis bigger than `k`  in current subsequence,\\n\\n`A[i]` cannot be added to the subsequence,\\nso we start a new subsequence with `A[i]` as the first element,\\nthus increment `res` and update `mn = mx = a`.\\n\\nWe continue doing this process and finally return result `res`.\\n\\nThen I notice it\\'s subsequences instead of subarray,\\nI added a sort at the beginning.....\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int partitionArray(int[] A, int k) {\\n        Arrays.sort(A);\\n        int res = 1, mn = A[0], mx = A[0];\\n        for (int a: A) {\\n            mn = Math.min(mn, a);\\n            mx = Math.max(mx, a);\\n            if (mx - mn > k) {\\n                res++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int partitionArray(vector<int>& A, int k) {\\n        sort(A.begin(), A.end());\\n        int res = 1, mn = A[0], mx = A[0];\\n        for (int& a: A) {\\n            mn = min(mn, a);\\n            mx = max(mx, a);\\n            if (mx - mn > k) {\\n                res++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def partitionArray(self, A, k):\\n        A.sort()\\n        res = 1\\n        mn = mx = A[0]\\n        for a in A:\\n            mn = min(mn, a)\\n            mx = max(mx, a)\\n            if mx - mn > k:\\n                res += 1\\n                mn = mx = a\\n        return res\\n```\\n\\n# Solution II\\n**Java**\\n```java\\n    public int partitionArray(int[] A, int k) {\\n        Arrays.sort(A);\\n        int res = 1, n = A.length, j = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] - A[j] > k) {\\n                res++;\\n                j = i;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int partitionArray(vector<int>& A, int k) {\\n        sort(A.begin(), A.end());\\n        int res = 1, n = A.size(), j = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] - A[j] > k) {\\n                res++;\\n                j = i;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n**Python**\\n```py\\n    def partitionArray(self, A, k):\\n        A.sort()\\n        res, j = 1, 0\\n        for i in range(len(A)):\\n             if A[i] - A[j] > k:\\n                res += 1\\n                j = i\\n        return res\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```java\\n    public int partitionArray(int[] A, int k) {\\n        Arrays.sort(A);\\n        int res = 1, mn = A[0], mx = A[0];\\n        for (int a: A) {\\n            mn = Math.min(mn, a);\\n            mx = Math.max(mx, a);\\n            if (mx - mn > k) {\\n                res++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int partitionArray(vector<int>& A, int k) {\\n        sort(A.begin(), A.end());\\n        int res = 1, mn = A[0], mx = A[0];\\n        for (int& a: A) {\\n            mn = min(mn, a);\\n            mx = max(mx, a);\\n            if (mx - mn > k) {\\n                res++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def partitionArray(self, A, k):\\n        A.sort()\\n        res = 1\\n        mn = mx = A[0]\\n        for a in A:\\n            mn = min(mn, a)\\n            mx = max(mx, a)\\n            if mx - mn > k:\\n                res += 1\\n                mn = mx = a\\n        return res\\n```\n```java\\n    public int partitionArray(int[] A, int k) {\\n        Arrays.sort(A);\\n        int res = 1, n = A.length, j = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] - A[j] > k) {\\n                res++;\\n                j = i;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```cpp\\n    int partitionArray(vector<int>& A, int k) {\\n        sort(A.begin(), A.end());\\n        int res = 1, n = A.size(), j = 0;\\n        for (int i = 1; i < n; ++i) {\\n            if (A[i] - A[j] > k) {\\n                res++;\\n                j = i;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```py\\n    def partitionArray(self, A, k):\\n        A.sort()\\n        res, j = 1, 0\\n        for i in range(len(A)):\\n             if A[i] - A[j] > k:\\n                res += 1\\n                j = i\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2111862,
                "title": "sort-and-select",
                "content": "* Sort the array \\n* And select maximum gap of max element - min element\\n* If difference >= k then only increase answer and make start of another subsequence as ith element.\\n\\nTime - O(sort)\\n```\\nclass Solution {\\n\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int c = 1, prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - nums[prev] <= k) continue;\\n            c++; prev = i;\\n        }\\n        return c;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int c = 1, prev = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] - nums[prev] <= k) continue;\\n            c++; prev = i;\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111923,
                "title": "python-easy-solution-using-sorting",
                "content": "### Explanation:\\n\\nInitially I did think it as a DP problem because of the word \"**subsequence**\" and \"**minimum**\". But after analysing the array and output I realized we are more concerned about \"**at most difference should be K**\", and the at most difference is of min element and max element of subsequence, so what\\'s better than sorting? Sorting gives min and max element.\\n\\nYes, we are changing the order of elements but it wouldnt matter because we dont need to return the exact subsequences, we need to return the count of subsequences.\\n\\n**Example:**\\n\\n*before sort:*\\nnums -> [3, 6, 1, 2, 5]\\nsubsequences -> [3, 1, 2], [6, 5]\\noutput -> 2\\n\\n*after sort:*\\nnums -> [1, 2, 3, 5, 6]\\nsubsequences -> [1, 2, 3], [5, 6]\\noutput -> 2\\n\\nSo the order of elements would change but the elements inside each subsequence would remain same.\\n\\n\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 1\\n\\t\\t# To keep track of starting element of each subsequence\\n        start = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            diff = nums[i] - start\\n            if diff > k:\\n\\t\\t\\t\\t# If difference of starting and current element of subsequence is greater\\n\\t\\t\\t\\t# than K, then only start new subsequence\\n                ans += 1\\n                start = nums[i]\\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "### Explanation:\\n\\nInitially I did think it as a DP problem because of the word \"**subsequence**\" and \"**minimum**\". But after analysing the array and output I realized we are more concerned about \"**at most difference should be K**\", and the at most difference is of min element and max element of subsequence, so what\\'s better than sorting? Sorting gives min and max element.\\n\\nYes, we are changing the order of elements but it wouldnt matter because we dont need to return the exact subsequences, we need to return the count of subsequences.\\n\\n**Example:**\\n\\n*before sort:*\\nnums -> [3, 6, 1, 2, 5]\\nsubsequences -> [3, 1, 2], [6, 5]\\noutput -> 2\\n\\n*after sort:*\\nnums -> [1, 2, 3, 5, 6]\\nsubsequences -> [1, 2, 3], [5, 6]\\noutput -> 2\\n\\nSo the order of elements would change but the elements inside each subsequence would remain same.\\n\\n\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 1\\n\\t\\t# To keep track of starting element of each subsequence\\n        start = nums[0]\\n        \\n        for i in range(1, len(nums)):\\n            diff = nums[i] - start\\n            if diff > k:\\n\\t\\t\\t\\t# If difference of starting and current element of subsequence is greater\\n\\t\\t\\t\\t# than K, then only start new subsequence\\n                ans += 1\\n                start = nums[i]\\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2112127,
                "title": "easy",
                "content": "**Here we only have to tell the number of subsequences and we can use an element only once that\\'s why we can sort the array.**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int n(size(nums)), res(0);\\n        sort(begin(nums), end(nums));\\n    \\n        for (int start=0, next=0; start<n;) {\\n            while (next<n and nums[next]-nums[start] <= k) next++;            \\n            start = next;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int n(size(nums)), res(0);\\n        sort(begin(nums), end(nums));\\n    \\n        for (int start=0, next=0; start<n;) {\\n            while (next<n and nums[next]-nums[start] <= k) next++;            \\n            start = next;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112706,
                "title": "two-pointers",
                "content": "Sort, then use two pointers to track the current valid subsequence. Start a new subsequence if `nums[i]` cannot be added to the current one.\\n\\nAs the second pointer, we use the last element of the `subs` array. This could be handy if we need to identify subarrays in the end, for some reason.\\n\\n**C++**\\n```cpp\\nint partitionArray(vector<int>& nums, int k) {\\n    sort(begin(nums), end(nums));\\n    vector<int> subs{nums[0]};\\n    for (int i = 1; i < nums.size(); ++i)\\n        if (nums[i] - subs.back() > k)\\n            subs.push_back(nums[i]);\\n    return subs.size();\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint partitionArray(vector<int>& nums, int k) {\\n    sort(begin(nums), end(nums));\\n    vector<int> subs{nums[0]};\\n    for (int i = 1; i < nums.size(); ++i)\\n        if (nums[i] - subs.back() > k)\\n            subs.push_back(nums[i]);\\n    return subs.size();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112218,
                "title": "java-python-3-sort-and-count-w-brief-explanation-and-analysis",
                "content": "Greedy algorithm.\\n\\n----\\n\\n**method 1: two pointers**\\n1. Sort `nums`, starting from 1st two elements, `nums[0]` and `nums[1]`, as the values that two pointers `prev` and `cur` initially point to; Initialize a counter `partitions` as `1` since we at lease have `1` partition;\\n2. if `nums[cur] - nums[prev] > k`, increase the counter by `1` and update `prev` and `cur` accordingly;\\n3. Repeat 2 till the end of `nums`.\\n```java\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int partitions = 1;\\n        for (int cur = 1, prev = 0; cur < nums.length; ++cur) {\\n            if (nums[cur] - nums[prev] > k) {\\n                ++partitions; \\n                prev = cur;\\n            }\\n        }\\n        return partitions;\\n    }\\n```\\n```python\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        prev, partitions, n = 0, 1, len(nums)\\n        for cur in range(1, n):\\n            if nums[cur] - nums[prev] > k:\\n                partitions += 1\\n                prev = cur\\n        return partitions\\n```\\n\\n----\\n\\nWe can use binary search after sorting, which is of course only a minor optimiztaton.\\n\\n**Method 2: binary search**\\n\\n1. Sort `nums`, starting from 1st element, `nums[0]`, binary search the index of the ceil of `nums[0] + k`, `nums[0] + 2 * k`, ...`nums[0] + i * k`,.., respectively, till reach the last element of `nums`;\\n2. Increase the partitions by `1` whenever find each during the binary search in 1.\\n```java\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int key = nums[0] + k, partitions = 1;\\n        while (binarySearch(nums, key) < nums.length) {\\n            ++partitions;\\n            key = nums[binarySearch(nums, key)] + k;\\n        }\\n        return partitions;\\n    }\\n    private int binarySearch(int[] nums, int key) {\\n        int lo = 0, hi = nums.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] <= key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n```\\n```python\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        partitions = 1\\n        cur = nums[0]\\n        while (idx := bisect.bisect(nums, cur + k)) < len(nums):\\n            partitions += 1\\n            cur = nums[idx]\\n        return partitions    \\n```\\n\\n**Analysis:**\\n\\nTime: `O(nlogn)`, space: `O(n)` - including sorting space, where `n = nums.length`.",
                "solutionTags": [],
                "code": "```java\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int partitions = 1;\\n        for (int cur = 1, prev = 0; cur < nums.length; ++cur) {\\n            if (nums[cur] - nums[prev] > k) {\\n                ++partitions; \\n                prev = cur;\\n            }\\n        }\\n        return partitions;\\n    }\\n```\n```python\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        prev, partitions, n = 0, 1, len(nums)\\n        for cur in range(1, n):\\n            if nums[cur] - nums[prev] > k:\\n                partitions += 1\\n                prev = cur\\n        return partitions\\n```\n```java\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int key = nums[0] + k, partitions = 1;\\n        while (binarySearch(nums, key) < nums.length) {\\n            ++partitions;\\n            key = nums[binarySearch(nums, key)] + k;\\n        }\\n        return partitions;\\n    }\\n    private int binarySearch(int[] nums, int key) {\\n        int lo = 0, hi = nums.length;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (nums[mid] <= key) {\\n                lo = mid + 1;\\n            }else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n```\n```python\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        partitions = 1\\n        cur = nums[0]\\n        while (idx := bisect.bisect(nums, cur + k)) < len(nums):\\n            partitions += 1\\n            cur = nums[idx]\\n        return partitions    \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2111948,
                "title": "c-python-java-sort-short-and-clean",
                "content": "**CPP**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& v, int k,int ans=0,int idx=0) {\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]-v[idx]>k)ans++,idx=i;\\n        }\\n        return ans+1;\\n    }\\n};\\n```\\n\\n**PYTHON**\\n\\n```\\nclass Solution:\\n    def partitionArray(self, v: List[int], k: int,idx=0 ,ans=0) -> int:\\n        v.sort()\\n        for i in range(len(v)):\\n            if v[i] - v[idx]>k:\\n                ans+=1\\n                idx=i\\n        return ans+1\\n        \\n```\\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public int partitionArray(int[] v, int k) {\\n        Arrays.sort(v);\\n        int ans=0,idx=0;\\n        for(int i=0;i<v.length;i++){\\n            if(v[i]-v[idx]>k){\\n                ans++;idx=i;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& v, int k,int ans=0,int idx=0) {\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]-v[idx]>k)ans++,idx=i;\\n        }\\n        return ans+1;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def partitionArray(self, v: List[int], k: int,idx=0 ,ans=0) -> int:\\n        v.sort()\\n        for i in range(len(v)):\\n            if v[i] - v[idx]>k:\\n                ans+=1\\n                idx=i\\n        return ans+1\\n        \\n```\n```\\nclass Solution {\\n    public int partitionArray(int[] v, int k) {\\n        Arrays.sort(v);\\n        int ans=0,idx=0;\\n        for(int i=0;i<v.length;i++){\\n            if(v[i]-v[idx]>k){\\n                ans++;idx=i;\\n            }\\n        }\\n        return ans+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112342,
                "title": "java-o-n-turns-out-bucket-is-faster-in-this-solution-7ms-beats-100",
                "content": "After you put nums into buckets, scan it, if it appeared, then jump k steps.\\nTo shorten time, it could check only from smallest to biggest in buckets.\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        int[] buckets=new int[(int)(Math.pow(10,5)+1)];\\n        int max=0;\\n        for(int num:nums){\\n            buckets[num]++;\\n            max=Math.max(max,num);\\n        }\\n        int result=0;\\n        for(int i=0;i<=max;i++){\\n            if(buckets[i]>0){\\n                result++;\\n                i+=k;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        int[] buckets=new int[(int)(Math.pow(10,5)+1)];\\n        int max=0;\\n        for(int num:nums){\\n            buckets[num]++;\\n            max=Math.max(max,num);\\n        }\\n        int result=0;\\n        for(int i=0;i<=max;i++){\\n            if(buckets[i]>0){\\n                result++;\\n                i+=k;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112025,
                "title": "max-heap-priority-queue-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        int last=-1;\\n        int count=0;\\n        while(pq.size()>0)\\n        {\\n            int t=pq.top();\\n            pq.pop();\\n            if(last!=-1)\\n            {\\n                if(last-t<=k)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    last=t;\\n                    count++;\\n                }\\n            }\\n            else\\n            { count++;\\n                last=t;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Like it? Please Upvote ;-)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        priority_queue<int> pq;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            pq.push(nums[i]);\\n        }\\n        int last=-1;\\n        int count=0;\\n        while(pq.size()>0)\\n        {\\n            int t=pq.top();\\n            pq.pop();\\n            if(last!=-1)\\n            {\\n                if(last-t<=k)\\n                {\\n                    continue;\\n                }\\n                else\\n                {\\n                    last=t;\\n                    count++;\\n                }\\n            }\\n            else\\n            { count++;\\n                last=t;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851294,
                "title": "cpp-solution-better-than-100-o-nlogn-time-complexity",
                "content": "# Approach\\n-> The idea is to sort the array in decending order and then apply two pointers the first pointer will point to the first element of any partition and second pointer will traverse and find the last element of the partition \\n\\n-> The job of second pointer is find to the element whose difference with the element (first pointer is pointing) is greater than the value k, and when we find that element simply increase the value of partition variable (this variable is counting the number of partions we require) \\n\\n-> The answer of the query is value of partition variable + 1 (because we need to return number of subsequences or partition)\\n\\n```\\nGiven nums = [3,6,1,2,5], k = 2\\n             part = 0\\n->           nums = 6  5  3  2  1  // After Sorting in Descending order\\n                    |  |\\n                    i  j           // Pointers\\n    n[i]-n[j] = 1 < 2          //ignore and increment value of j\\n\\n\\n->            nums = 6  5  3  2  1\\n                     |     |\\n                     i     j\\n    n[i]-n[j] = 3 > 2   // increment partition variable\\'s value by 1 and do i=j\\n\\n\\n-> Now,        nums = 6  5 | 3  2  1\\n                             |  |\\n                             i  j\\n    n[i]-n[j] = 1 < 2  // ignore and increment value of j\\n\\n\\n           nums = 6  5 | 3  2  1\\n                         |     |\\n                         i     j  \\n    n[i]-n[j] = 2 == 2 //ignore and increment value of j\\n\\n\\n j == n.size() therefore terminate the loop \\n\\n```\\n\\n```\\nPLease Like if find the code interesting\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0A\\uD83D\\uDE0A\\n```\\n\\n# Complexity\\n- Time complexity: O(nlogn + n) ,better than 100% Cpp online Submissions\\n\\n- Space complexity: O(1), better than 52% Cpp online Submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& n, int k) {\\n        int part=0;\\n        sort(n.begin(),n.end(),greater<int>());\\n        int i=0,j=1;\\n        while(i<n.size() && j<n.size())\\n        {\\n            if(n[i]-n[j]>k)\\n            {\\n                part++;\\n                i=j;\\n            }\\n            j++;\\n        }\\n  return part+1;  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nGiven nums = [3,6,1,2,5], k = 2\\n             part = 0\\n->           nums = 6  5  3  2  1  // After Sorting in Descending order\\n                    |  |\\n                    i  j           // Pointers\\n    n[i]-n[j] = 1 < 2          //ignore and increment value of j\\n\\n\\n->            nums = 6  5  3  2  1\\n                     |     |\\n                     i     j\\n    n[i]-n[j] = 3 > 2   // increment partition variable\\'s value by 1 and do i=j\\n\\n\\n-> Now,        nums = 6  5 | 3  2  1\\n                             |  |\\n                             i  j\\n    n[i]-n[j] = 1 < 2  // ignore and increment value of j\\n\\n\\n           nums = 6  5 | 3  2  1\\n                         |     |\\n                         i     j  \\n    n[i]-n[j] = 2 == 2 //ignore and increment value of j\\n\\n\\n j == n.size() therefore terminate the loop \\n\\n```\n```\\nPLease Like if find the code interesting\\uD83D\\uDE01\\uD83D\\uDE01\\uD83D\\uDE0A\\uD83D\\uDE0A\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& n, int k) {\\n        int part=0;\\n        sort(n.begin(),n.end(),greater<int>());\\n        int i=0,j=1;\\n        while(i<n.size() && j<n.size())\\n        {\\n            if(n[i]-n[j]>k)\\n            {\\n                part++;\\n                i=j;\\n            }\\n            j++;\\n        }\\n  return part+1;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112182,
                "title": "fully-explained",
                "content": "\\'\\'\\'\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        // sorted array - so that we can simply traverse for min and max elements\\n        \\n        Arrays.sort(nums);\\n        \\n        int min = nums[0];  //obvious\\n        int max;\\n        \\n        int result = 1; //intially our whole array is a subsequence for us\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            // we have to traverse ahead till the min and the max difference is smaller than that of k\\n            // so that we can get the max of our first subsequence and thereon further subsequences\\n            \\n            max = nums[i];\\n            \\n            if((max - min) > k)     // if it exceeds - we will have to make a new subsequence\\n            {\\n                result++;\\n                \\n                // and when getting to another subsequence, we will also have to update our min value\\n                \\n               min = nums[i];\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        // sorted array - so that we can simply traverse for min and max elements\\n        \\n        Arrays.sort(nums);\\n        \\n        int min = nums[0];  //obvious\\n        int max;\\n        \\n        int result = 1; //intially our whole array is a subsequence for us\\n        \\n        for(int i=0;i<nums.length;i++)\\n        {\\n            // we have to traverse ahead till the min and the max difference is smaller than that of k\\n            // so that we can get the max of our first subsequence and thereon further subsequences\\n            \\n            max = nums[i];\\n            \\n            if((max - min) > k)     // if it exceeds - we will have to make a new subsequence\\n            {\\n                result++;\\n                \\n                // and when getting to another subsequence, we will also have to update our min value\\n                \\n               min = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3347962,
                "title": "very-easy-java-solution",
                "content": "Please **UPVOTE** if you like my solution!\\n\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        if(nums.length == 1){\\n            return 1;\\n        }\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for(int i = 1,j = 0;i<nums.length;i++){\\n            if(nums[i] - nums[j] <= k){\\n                continue;\\n            }\\n            else{\\n                count++;\\n                j = i;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        if(nums.length == 1){\\n            return 1;\\n        }\\n        Arrays.sort(nums);\\n        int count = 0;\\n        for(int i = 1,j = 0;i<nums.length;i++){\\n            if(nums[i] - nums[j] <= k){\\n                continue;\\n            }\\n            else{\\n                count++;\\n                j = i;\\n            }\\n        }\\n        return count+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2128692,
                "title": "c-108ms-o-n-83-mb-o-n-100-86-counting-sort-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int rt=0,ma=0,mi=100000;\\n        bool ct[100005]={0};\\n        for(int i=0;i<nums.size();++i){\\n            ma=max(ma,nums[i]);\\n            mi=min(mi,nums[i]);\\n            ct[nums[i]]=1;\\n        }\\n\\t\\tif(k>=ma-mi)\\n            return 1;\\n        for(int i=mi;i<=ma;++i){\\n            if(ct[i]){\\n                ++rt;\\n                i+=k;\\n            }\\n        }\\n        return rt;\\n    }\\n};\\n```\\n1.we don\\'t need to count the times of each number because it is equivalence between [2] and [2,2,2] **->** use boolean array to reduce memory use.\\n2.we don\\'t need to traverse each number after counting sort **->** when a single number x  apper in nums, x ~ x+k is the best way to partition (greedy).\\n3.we don\\'t need to traverse from 0 to 10000 for every test case **->** recording the min/max value of nums and iterating over them.\\n4.if (k >= max-min) and (the size of nums > 0) **->** the answer is 1.",
                "solutionTags": [
                    "Greedy",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int rt=0,ma=0,mi=100000;\\n        bool ct[100005]={0};\\n        for(int i=0;i<nums.size();++i){\\n            ma=max(ma,nums[i]);\\n            mi=min(mi,nums[i]);\\n            ct[nums[i]]=1;\\n        }\\n\\t\\tif(k>=ma-mi)\\n            return 1;\\n        for(int i=mi;i<=ma;++i){\\n            if(ct[i]){\\n                ++rt;\\n                i+=k;\\n            }\\n        }\\n        return rt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119674,
                "title": "c-smooth-solution-clearly-explained",
                "content": "**dry run with steps:**\\nnums = [3 6 1 2 5], k= 2\\n**step-1:** sort in decreasing order\\n6 5 3 2 1\\n**Step-2:** count sub-sequences (if the difference between elements (nums[j]- nums[i] > k) book a new subsequence).\\n6-5 = 1         |   j = 0,  ans = 1\\n6-3 = 3> k    |  j = 2,   ans = 2\\n3-2 = 1         |  j = 2,   ans = 2\\n3-1 = 2         |  j = 2,   ans = 2\\n\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int j = 0;\\n        int ans = 1;    //complete array is 1 subsequence in itself\\n        \\n        //sort in decreasing fashion\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        //if the difference between elements (nums[j]- nums[i] > k) book a new subsequence\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[j]- nums[i] > k){\\n                ans++;\\n                j = i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please do upvote if you like the solution:)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int j = 0;\\n        int ans = 1;    //complete array is 1 subsequence in itself\\n        \\n        //sort in decreasing fashion\\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n        //if the difference between elements (nums[j]- nums[i] > k) book a new subsequence\\n        for(int i=1; i<nums.size(); i++){\\n            if(nums[j]- nums[i] > k){\\n                ans++;\\n                j = i;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111994,
                "title": "c-sorting-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int s=nums[0];\\n        int cnt=0;\\n        for(int i=1;i<n;i++){\\n            if(s-nums[i]>k){\\n                s=nums[i];\\n                cnt++;\\n            }\\n        }\\n        cnt++;\\n        return cnt;\\n    }\\n};\\n```\\n**Don\\'t forget to upvote this post if it has helped you!!!**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int s=nums[0];\\n        int cnt=0;\\n        for(int i=1;i<n;i++){\\n            if(s-nums[i]>k){\\n                s=nums[i];\\n                cnt++;\\n            }\\n        }\\n        cnt++;\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111928,
                "title": "simple-cpp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1)\\n            return 1;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=i+1;\\n        int ans=0;\\n        while(j<n && i<n){\\n            if(k>=nums[j]-nums[i]){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n                j=i+1;\\n            }\\n        }\\n        ans++;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        if(n==1)\\n            return 1;\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=i+1;\\n        int ans=0;\\n        while(j<n && i<n){\\n            if(k>=nums[j]-nums[i]){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n                j=i+1;\\n            }\\n        }\\n        ans++;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112569,
                "title": "c-sort-two-pointer-most-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i,j=0, cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]-nums[j]>k){\\n                cnt++;\\n                j=i;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i,j=0, cnt=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(nums[i]-nums[j]>k){\\n                cnt++;\\n                j=i;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112393,
                "title": "c-use-sorting-and-flag-explanation-through-comments",
                "content": "**Please upvote if you find this solution helpful:)\\nTC: O(NlogN), SC: O(1)**\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        //sort nums to get all values in ascending order  \\n        sort(nums.begin(), nums.end());\\n        int n=nums.size(), count=0, flag=0, mini=INT_MAX;\\n        \\n    \\n        //iterate through the nums\\n        for(int j=0; j<n; j++)\\n        {\\n            //when flag is 0 \\n            if(!flag)\\n            {\\n                flag=1; //mark flag=1 which shows new subsequence started\\n                mini = nums[j];  //since nums is in ascending order, mini will be at first index of new subsequence\\n                count++;\\n            }\\n\\n            //when difference is greater than k we need to start new subsequence\\n            if(abs(nums[j]-mini) > k)\\n            {\\n                //re-assign flag=0, mini, and decrement j, to consider it in new subsequence\\n                flag=0; \\n                mini = INT_MAX; \\n                j--;\\n            }\\n        }\\n            \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        //sort nums to get all values in ascending order  \\n        sort(nums.begin(), nums.end());\\n        int n=nums.size(), count=0, flag=0, mini=INT_MAX;\\n        \\n    \\n        //iterate through the nums\\n        for(int j=0; j<n; j++)\\n        {\\n            //when flag is 0 \\n            if(!flag)\\n            {\\n                flag=1; //mark flag=1 which shows new subsequence started\\n                mini = nums[j];  //since nums is in ascending order, mini will be at first index of new subsequence\\n                count++;\\n            }\\n\\n            //when difference is greater than k we need to start new subsequence\\n            if(abs(nums[j]-mini) > k)\\n            {\\n                //re-assign flag=0, mini, and decrement j, to consider it in new subsequence\\n                flag=0; \\n                mini = INT_MAX; \\n                j--;\\n            }\\n        }\\n            \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112209,
                "title": "4-liner-sort-two-pointer",
                "content": "**Point to be Noted :** *There should be minimum one Partition Always.*\\n\\t\\n\\t\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\t\\tint start = 0,end = 0,ans = 1;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\twhile(end != nums.size()){\\n\\t\\t\\t\\tif(nums[end] - nums[start] <= k) end++;\\n\\t\\t\\t\\telse ans++, start = end;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\t\\n**Time Complexity :** *O(nlogn)*\\n**Space Complexity :** *O(1)*",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\t\\tint start = 0,end = 0,ans = 1;\\n\\t\\t\\tsort(nums.begin(),nums.end());\\n\\t\\t\\twhile(end != nums.size()){\\n\\t\\t\\t\\tif(nums[end] - nums[start] <= k) end++;\\n\\t\\t\\t\\telse ans++, start = end;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2112114,
                "title": "greedy-using-treeset",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for(int num: nums){\\n           ts.add(num);\\n        }\\n\\n        Integer start = ts.first();\\n        int count = 0;\\n        while(start!=null && ts.ceiling(start)!=null){\\n            int end = start+k;\\n            count++;\\n            if(ts.ceiling(end+1)==null)\\n                return count;\\n            if(ts.contains(end+1))\\n            start = end+1;\\n            else\\n            start = ts.ceiling(end+1);  \\n        }\\n        return count;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        for(int num: nums){\\n           ts.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3810227,
                "title": "python-3-sort-greedy-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(NlogN)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        j = 0\\n        res = 1\\n        for i, num in enumerate(nums):\\n            if num - nums[j] > k:\\n                res += 1\\n                j = i\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        j = 0\\n        res = 1\\n        for i, num in enumerate(nums):\\n            if num - nums[j] > k:\\n                res += 1\\n                j = i\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510637,
                "title": "3-solutions-for-partition-array-such-that-maximum-difference-is-k-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*BRUTE FORCE -> SORTING*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, j, min, count=1;\\n        sort(nums.begin(), nums.end());\\n        min = nums[0];\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]-min>k)\\n            {\\n                count++;\\n                min = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*USING HASHMAP*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, min=-1, count=1;\\n        map<int, int> mp;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(min==-1)\\n            {\\n                min = it.first;\\n            }\\n            else if(it.first-min>k)\\n            {\\n                min = it.first;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# 3. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*USING SET*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, min=-1, count=1;\\n        set<int> s(nums.begin(), nums.end());\\n        for(auto it:s)\\n        {\\n            if(min==-1)\\n            {\\n                min = it;\\n            }\\n            else if(it-min>k)\\n            {\\n                min = it;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/a8c0d5e9-c618-4854-90e8-a0d852a12a8d_1683773556.702196.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, j, min, count=1;\\n        sort(nums.begin(), nums.end());\\n        min = nums[0];\\n        for(i=1 ; i<nums.size() ; i++)\\n        {\\n            if(nums[i]-min>k)\\n            {\\n                count++;\\n                min = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, min=-1, count=1;\\n        map<int, int> mp;\\n        for(i=0 ; i<nums.size() ; i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(min==-1)\\n            {\\n                min = it.first;\\n            }\\n            else if(it.first-min>k)\\n            {\\n                min = it.first;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i, min=-1, count=1;\\n        set<int> s(nums.begin(), nums.end());\\n        for(auto it:s)\\n        {\\n            if(min==-1)\\n            {\\n                min = it;\\n            }\\n            else if(it-min>k)\\n            {\\n                min = it;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2736428,
                "title": "two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n{\\n    sort(nums.begin(),nums.end());\\n    // 3 6 1 2 5--> 1 2 3 5 6         \\n    int count=0;\\n    int start=0;\\n    int end=0;\\n    \\n    while(end<nums.size())\\n    {\\n    \\twhile(end<nums.size() and (nums[end]-nums[start])<=k)\\n    \\t{\\n    \\t\\tend++;\\n\\t\\t}\\n\\t\\tstart=end;\\n\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n{\\n    sort(nums.begin(),nums.end());\\n    // 3 6 1 2 5--> 1 2 3 5 6         \\n    int count=0;\\n    int start=0;\\n    int end=0;\\n    \\n    while(end<nums.size())\\n    {\\n    \\twhile(end<nums.size() and (nums[end]-nums[start])<=k)\\n    \\t{\\n    \\t\\tend++;\\n\\t\\t}\\n\\t\\tstart=end;\\n\\t\\tcount++;\\n\\t}\\n\\treturn count;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141430,
                "title": "sort-cpp-very-easy",
                "content": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int l=0;\\n        int ans=0;\\n        // 6 5 3 2 1 0\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[l]-nums[i]>k){\\n                ans++;\\n                l=i;\\n            }\\n        }\\n        return ans+1;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        \\n        sort(nums.begin(),nums.end(),greater<int>());\\n        int l=0;\\n        int ans=0;\\n        // 6 5 3 2 1 0\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[l]-nums[i]>k){\\n                ans++;\\n                l=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2119165,
                "title": "c-easy-code",
                "content": "**Please Upvote If It Helps**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 0;\\n        int flag = 1;\\n        int n = nums.size();\\n        int mn = INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // if our flag is 1 it means we are ready with new subsequence\\n            if(flag==1)\\n            {\\n                flag = 0;\\n                mn = nums[i];\\n                cnt++;\\n            }\\n            \\n            // if our consecutive diff is greater than k then we need to start new subsequence\\n            if(nums[i]-mn > k)\\n            {\\n                flag = 1;               // made flag 1 to start the new subsequence\\n                mn = INT_MAX;           // make again mn as max\\n                i--;                    // move curr pointer , 1 step behind\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 0;\\n        int flag = 1;\\n        int n = nums.size();\\n        int mn = INT_MAX;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            // if our flag is 1 it means we are ready with new subsequence\\n            if(flag==1)\\n            {\\n                flag = 0;\\n                mn = nums[i];\\n                cnt++;\\n            }\\n            \\n            // if our consecutive diff is greater than k then we need to start new subsequence\\n            if(nums[i]-mn > k)\\n            {\\n                flag = 1;               // made flag 1 to start the new subsequence\\n                mn = INT_MAX;           // make again mn as max\\n                i--;                    // move curr pointer , 1 step behind\\n            }\\n        }\\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114621,
                "title": "array-with-maximum-k-difference-sort-simple-boolean",
                "content": "Hi,\\n\\nInitially I went through the thought process of figuring out the solution, Since the differenece is the main factor of grouping the items its better to sort the given array in the first step itself.\\n\\nTo make sure the items are tracked and added I kept a boolean array to keep track of the elements. This will make sure the items are added to the resultant list.\\n\\nNext we can itrate through the given array, this is the crutial step which has multiple conditions to be handled.\\n\\nI maintained a current value which will store the differance at any point in time. If the value is greater than K then \\n\\t1. If the difference is greater than the given value k -> increment the result\\n\\t2. Increment the index everytime, because one element can\\'t be shared \\n\\t3. One last step is to make the flag as true once element is added and check at last if the element is not added then increment the result and add to the list.\\n\\nHere is the my code implementing the same, Kindly upvote if it helps.. Happy learning :)\\n\\n```\\n   public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res=0;\\n        int curr=0, i=0;\\n        boolean flag[] = new boolean[nums.length];\\n        while(i<nums.length-1){\\n        \\tcurr = curr+nums[i+1]-nums[i];\\n        \\tif(curr>k){\\n        \\t\\tflag[i]=true;\\n        \\t\\tcurr=0;\\n        \\t\\tres++;\\n        \\t}\\n        \\ti++;\\n        }\\n        if(!flag[nums.length-1])\\n        \\tres++;\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "Hi,\\n\\nInitially I went through the thought process of figuring out the solution, Since the differenece is the main factor of grouping the items its better to sort the given array in the first step itself.\\n\\nTo make sure the items are tracked and added I kept a boolean array to keep track of the elements. This will make sure the items are added to the resultant list.\\n\\nNext we can itrate through the given array, this is the crutial step which has multiple conditions to be handled.\\n\\nI maintained a current value which will store the differance at any point in time. If the value is greater than K then \\n\\t1. If the difference is greater than the given value k -> increment the result\\n\\t2. Increment the index everytime, because one element can\\'t be shared \\n\\t3. One last step is to make the flag as true once element is added and check at last if the element is not added then increment the result and add to the list.\\n\\nHere is the my code implementing the same, Kindly upvote if it helps.. Happy learning :)\\n\\n```\\n   public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res=0;\\n        int curr=0, i=0;\\n        boolean flag[] = new boolean[nums.length];\\n        while(i<nums.length-1){\\n        \\tcurr = curr+nums[i+1]-nums[i];\\n        \\tif(curr>k){\\n        \\t\\tflag[i]=true;\\n        \\t\\tcurr=0;\\n        \\t\\tres++;\\n        \\t}\\n        \\ti++;\\n        }\\n        if(!flag[nums.length-1])\\n        \\tres++;\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2113854,
                "title": "python3-heap",
                "content": "The idea is to iteratively build subsequences from nums using heap while maintaining the property that each element appears in exactly one subsequence.\\nWe initialize a variable **start** to store the first element of the current subsequence and **count** to store the number of subsequences required and set it to 1. While there are still elements left in the **heap**, we pop the smallest element from the heap using the heappop() and assign it to **num**. If the difference between **num** and **start** is greater than **k**, it means that the current subsequence has exceeded the allowed difference of k. Therefore, we update start to be equal to num and increment the count variable to indicate a new subsequence. After popping all elements from the heap, we return **count** variable which stores the minimum number of subsequences.\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        count = 1\\n        \\n        start = heappop(nums)\\n        \\n        while nums:\\n            num = heappop(nums)\\n            \\n            if num - start > k:\\n                start = num\\n                count += 1\\n                \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        heapify(nums)\\n        count = 1\\n        \\n        start = heappop(nums)\\n        \\n        while nums:\\n            num = heappop(nums)\\n            \\n            if num - start > k:\\n                start = num\\n                count += 1\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111894,
                "title": "c-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        if(size(nums) == 1) return 1;\\n        sort(begin(nums),end(nums));\\n        int i=1,cnt = 0;\\n        int minEle = nums[0];\\n        while(i < size(nums)){\\n            if(abs(minEle - nums[i]) > k){ // when the condition is not satisfied just update the min element and increase the count .\\n                minEle = nums[i];\\n                cnt++;\\n            }\\n            i++;\\n        }\\n        return cnt+1; // + 1 for the last subsequence .\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        if(size(nums) == 1) return 1;\\n        sort(begin(nums),end(nums));\\n        int i=1,cnt = 0;\\n        int minEle = nums[0];\\n        while(i < size(nums)){\\n            if(abs(minEle - nums[i]) > k){ // when the condition is not satisfied just update the min element and increase the count .\\n                minEle = nums[i];\\n                cnt++;\\n            }\\n            i++;\\n        }\\n        return cnt+1; // + 1 for the last subsequence .\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3386016,
                "title": "partition-array-such-that-maximum-difference-is-k-fast-super-easy",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        int i = 0;\\n        int a = 0;\\n        int b = nums[0];\\n        while(i<nums.size())\\n        {\\n            a = nums[i];\\n            if(a>(b+k))\\n            {\\n                ans++;\\n                a = nums[i];\\n                b = nums[i];\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int ans = 1;\\n        int i = 0;\\n        int a = 0;\\n        int b = nums[0];\\n        while(i<nums.size())\\n        {\\n            a = nums[i];\\n            if(a>(b+k))\\n            {\\n                ans++;\\n                a = nums[i];\\n                b = nums[i];\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255456,
                "title": "simple-python-solution",
                "content": "# Intuition\\nSort Your given array. Why? Because we need to find subsequence so order isnt define for them.\\nWe are asked to return minimum number of subsequence we need to form so our aim is to add as many number as possible in one array with limit(k).\\n`How limit is defined? largest ele - Smallest ele`\\nAs we sorted our array so for each subsequence the first element will be smallest and just check if by adding curr element if we are still in our limit. (The problem is reduced in finding subarrays within limit)\\n`If yes -> add the element\\nIf not -> add the by far collected ans in res and reset your ans as empty to start finding new subarray.`\\nRes carries all the possible subsequnces thus, return its length as the min no of subsequences required.\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        # Base Case\\n        if nums[-1] - nums[0] <= k:\\n            return 1\\n\\n        ans = []\\n        ans.append(nums[0])\\n        res = []\\n        for i in range(len(nums)-1):\\n            if nums[i + 1] - ans[0] <= k:\\n                ans.append(nums[i + 1])\\n            else:\\n                res.append(ans)\\n                ans = []\\n                ans.append(nums[i + 1])\\n        res.append(ans)\\n        # print(res)\\n        return len(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        \\n        # Base Case\\n        if nums[-1] - nums[0] <= k:\\n            return 1\\n\\n        ans = []\\n        ans.append(nums[0])\\n        res = []\\n        for i in range(len(nums)-1):\\n            if nums[i + 1] - ans[0] <= k:\\n                ans.append(nums[i + 1])\\n            else:\\n                res.append(ans)\\n                ans = []\\n                ans.append(nums[i + 1])\\n        res.append(ans)\\n        # print(res)\\n        return len(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130005,
                "title": "c-very-simple-optimized",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int c=1,mini=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mini=min(mini,nums[i]);\\n            if(nums[i]-mini>k)\\n            {\\n                c++;\\n                mini=nums[i];\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int c=1,mini=INT_MAX;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            mini=min(mini,nums[i]);\\n            if(nums[i]-mini>k)\\n            {\\n                c++;\\n                mini=nums[i];\\n            }\\n        }return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2635340,
                "title": "java-easy-to-understand-answer",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count =1;\\n        int start =0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]-nums[start]>k)\\n            {\\n                count++;\\n                start =i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count =1;\\n        int start =0;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]-nums[start]>k)\\n            {\\n                count++;\\n                start =i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2120216,
                "title": "java-javascript-simple-fast-solution-faster-than-100",
                "content": "Java code:\\n```\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        var list = new ArrayList<Integer>();\\n        list.add(nums[0]);\\n        var count = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i]-list.get(0)>k) {\\n                count++;\\n                list = new ArrayList<>();\\n            }\\n            list.add(nums[i]);\\n        }\\n        if (!list.isEmpty()) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```\\n\\nJavaScript code:\\n```\\nvar partitionArray = function(nums, k) {\\n    let sorted = nums.sort((a, b) => a-b)\\n    let list = []\\n    let count = 0\\n    list.push(sorted[0])\\n    for (i = 1; i < sorted.length; i++) {\\n        let num = sorted[i]\\n        if (num-list[0]>k) {\\n            count++\\n            list = []\\n        }\\n        list.push(num)\\n    } if (list.length) count++\\n    return count\\n\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        var list = new ArrayList<Integer>();\\n        list.add(nums[0]);\\n        var count = 0;\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i]-list.get(0)>k) {\\n                count++;\\n                list = new ArrayList<>();\\n            }\\n            list.add(nums[i]);\\n        }\\n        if (!list.isEmpty()) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```\n```\\nvar partitionArray = function(nums, k) {\\n    let sorted = nums.sort((a, b) => a-b)\\n    let list = []\\n    let count = 0\\n    list.push(sorted[0])\\n    for (i = 1; i < sorted.length; i++) {\\n        let num = sorted[i]\\n        if (num-list[0]>k) {\\n            count++\\n            list = []\\n        }\\n        list.push(num)\\n    } if (list.length) count++\\n    return count\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2115256,
                "title": "javascript-easy-understanding",
                "content": "```\\nvar partitionArray = function(nums, k) {\\n      nums.sort((a,b)=>a-b)\\n  var start = 0;\\n  var end = 0;\\n  var count = 0;\\n  \\n  while(start<nums.length){\\n    var diff = nums[end]-nums[start]\\n    if(diff<=k){\\n      end++;\\n    }\\n    else {\\n      count++;\\n      start = end;\\n    }\\n  } return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar partitionArray = function(nums, k) {\\n      nums.sort((a,b)=>a-b)\\n  var start = 0;\\n  var end = 0;\\n  var count = 0;\\n  \\n  while(start<nums.length){\\n    var diff = nums[end]-nums[start]\\n    if(diff<=k){\\n      end++;\\n    }\\n    else {\\n      count++;\\n      start = end;\\n    }\\n  } return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2113942,
                "title": "c-easy-and-simplest-solution-using-sorting",
                "content": "Step 1: We will sort the array in non-decreasing order.\\nStep 2: Mark the starting position and iterate through array and whenever the diference of starting index and cuurent index exceeds k this means we have to start a new subsequence.\\nStep 3: Returning the number of subsequences in which we have to split.\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int start=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[start]>k){\\n                start=i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int start=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[start]>k){\\n                start=i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113584,
                "title": "100-faster-solution-using-sort-and-upper-bound",
                "content": "Upper bound function return iterator of just greater element of searching element. \\nso first of all sort the given vector and using **it - nums.begin()** calculate the next element that can be part of subsequence and do untill upper bound return **nums.end()** \\nand use a counter that will count our answer and simply return it whenever its completed \\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        int ans=0;\\n        int i=0,temp=nums[0]+k;\\n        while(i<nums.size()){\\n            auto it=upper_bound(nums.begin(),nums.end(),temp);\\n            i=it-nums.begin();\\n            ans++;\\n            if(it==nums.end())return ans;\\n            temp=nums[i]+k;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};****\\n```\\n\\n**please... Upvote :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        \\n        int ans=0;\\n        int i=0,temp=nums[0]+k;\\n        while(i<nums.size()){\\n            auto it=upper_bound(nums.begin(),nums.end(),temp);\\n            i=it-nums.begin();\\n            ans++;\\n            if(it==nums.end())return ans;\\n            temp=nums[i]+k;\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};****\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113361,
                "title": "c-easy-to-understand-clean-code-with-comments",
                "content": "It has been asked that we need to partition the array such that the difference of the maximum and the minimum values of the individual partition do not exceed a certain value `k `. \\n\\nIt is clear that we need to keep track of the **minimum** and **maximum** value of the partition. But if we **sort** the array beforehand, the first value would be the minimum and last value would be maximum. \\n\\nThen we loop through the array, checking at each step that we take that if the difference of maximum and minimum exceeds k, if it does, a new partion is formed with present element as the new minimum.\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i,j,count=1; // initially the whole array is a single partition, hence count=1\\n        sort(nums.begin(), nums.end()); // sort the whole array\\n\\t\\t\\n        for(i=0; i<nums.size();){\\n            for(j=i; j<nums.size(); j++){\\n\\t\\t\\t\\t// i is the index of present minimum, j is the index of present maximum\\n                if(nums[j]-nums[i] > k){ \\n                    count++;\\n                    break;\\n                }\\n            }\\n            i=j; // present element becomes the new minimum\\n        }\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int i,j,count=1; // initially the whole array is a single partition, hence count=1\\n        sort(nums.begin(), nums.end()); // sort the whole array\\n\\t\\t\\n        for(i=0; i<nums.size();){\\n            for(j=i; j<nums.size(); j++){\\n\\t\\t\\t\\t// i is the index of present minimum, j is the index of present maximum\\n                if(nums[j]-nums[i] > k){ \\n                    count++;\\n                    break;\\n                }\\n            }\\n            i=j; // present element becomes the new minimum\\n        }\\n\\t\\t\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112756,
                "title": "go-lang-solution",
                "content": "```go\\nfunc partitionArray(nums []int, k int) int {\\n    // remember you\\'re trying to minimize difference \\n    // k is the ceiling\\n    // sort to group higher values together (to minimize difference)\\n    \\n    // then keep expanding till difference larger than k \\n    // create new sequence(increment) in that case\\n    \\n    sort.Ints(nums)\\n    \\n    ans := 1\\n    \\n    \\n    min := nums[0]\\n    max := nums[0]\\n    \\n    for i := 0; i < len(nums); i++ {\\n        max = nums[i]\\n        \\n        if (max - min) > k {\\n            ans++\\n            \\n            min = nums[i]\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc partitionArray(nums []int, k int) int {\\n    // remember you\\'re trying to minimize difference \\n    // k is the ceiling\\n    // sort to group higher values together (to minimize difference)\\n    \\n    // then keep expanding till difference larger than k \\n    // create new sequence(increment) in that case\\n    \\n    sort.Ints(nums)\\n    \\n    ans := 1\\n    \\n    \\n    min := nums[0]\\n    max := nums[0]\\n    \\n    for i := 0; i < len(nums); i++ {\\n        max = nums[i]\\n        \\n        if (max - min) > k {\\n            ans++\\n            \\n            min = nums[i]\\n        }\\n    }\\n    \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112702,
                "title": "sort-array-java-o-nlogn-time",
                "content": "- The idea is to sort the array.\\n- If the array is sorted, we know that the smallest element would be at left end and largest at the right end of the sorted array.\\n - Thus, to get the difference between minimum and maximum element, we can just find the difference between the first and last element of the sorted array.\\n   \\n The algorithm can be described as,\\n - Find the sum of first and last element of sorted array,\\n\\t   1. If the difference is less than or equal to k, we no longer need to divide the subarray further.\\n\\t   2. If the difference is greater than k, we will have to divide the current array into subarrays. \\n\\t   The trick is that, we have to divide the current array such that the difference between largest and smallest element is less than the current difference. We can do this by pickup up next smaller element.\\n\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int result = 1;\\n        int end = nums.length - 1;\\n        int lastPartition = 0;\\n        \\n        for(int left = 0;left<nums.length;left++){\\n            int difference = nums[end] - nums[left];\\n            if(difference <=  k)\\n                return result;\\n            if(nums[left] - nums[lastPartition] > k || lastPartition == left){\\n                result += 1;\\n                lastPartition = left;\\n            }    \\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int result = 1;\\n        int end = nums.length - 1;\\n        int lastPartition = 0;\\n        \\n        for(int left = 0;left<nums.length;left++){\\n            int difference = nums[end] - nums[left];\\n            if(difference <=  k)\\n                return result;\\n            if(nums[left] - nums[lastPartition] > k || lastPartition == left){\\n                result += 1;\\n                lastPartition = left;\\n            }    \\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112602,
                "title": "java-sort-sliding-window-with-explanation",
                "content": "### Steps\\n1. sort the array\\n2. for each element:\\n2.1.  update the min & max\\n2.2.  if max - min > k, counter++ and reset the min & max\\n3. counter++ for the last one sequence\\n\\n### Complexity\\ntime: `O(nlogn)`\\nspace: `O(logn or n)` depends on the sorting algorithm\\n\\n### Java\\n```java\\npublic int partitionArray(int[] A, int k) {\\n    int n = A.length, res = 0, min = A[0], max = A[0];\\n    Arrays.sort(A);\\n\\n    for (int i = 0; i < n; i++) {\\n        min = Math.min(min, A[i]);\\n        max = Math.max(max, A[i]);\\n\\n        if (max - min > k) {\\n            res++;\\n            min = max = A[i];\\n        }\\n    }\\n    return res + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic int partitionArray(int[] A, int k) {\\n    int n = A.length, res = 0, min = A[0], max = A[0];\\n    Arrays.sort(A);\\n\\n    for (int i = 0; i < n; i++) {\\n        min = Math.min(min, A[i]);\\n        max = Math.max(max, A[i]);\\n\\n        if (max - min > k) {\\n            res++;\\n            min = max = A[i];\\n        }\\n    }\\n    return res + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112514,
                "title": "python-easy-understanding",
                "content": "Here the most basic idea is to first sort the array , coz then it will become an easy ques as comapred to medium coz now u only have to traverse through the list at once which will only take O(n) time complexity coz then we just have to compare the min value of the curent list with the current value and if we get that difference greater than k , then we just create a new list and keep on working on this concept and we will always get minimum no of lists only.\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l=[[nums[0]]]\\n        for i in range(1,len(nums)):\\n            if nums[i]-l[-1][0]<=k:\\n                l[-1].append(nums[i])\\n            \\n            else:\\n                l.append([nums[i]])\\n                \\n        return len(l)\\n```\\nIf u understood the code then plz.......UPVOTE.......Thnx in adv",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        l=[[nums[0]]]\\n        for i in range(1,len(nums)):\\n            if nums[i]-l[-1][0]<=k:\\n                l[-1].append(nums[i])\\n            \\n            else:\\n                l.append([nums[i]])\\n                \\n        return len(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112460,
                "title": "javascript",
                "content": "- Sort the array\\n- Select maximum diff of max element - min element\\nIf difference > k then only increase count and make start of another subsequence as ith element.\\n```\\n\\nlet Partition_Array_Such_That_Maximum_Difference_Is_K = function (nums, k) {\\n  nums.sort((a, b) => a - b);\\n  let minV = nums[0];\\n  let count = 1;\\n  for (let i = 1; i < nums.length; i++) {\\n    let diff = nums[i] - minV;\\n    if (diff > k) {\\n      count++;\\n      minV = nums[i];\\n    }\\n  }\\n  return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nlet Partition_Array_Such_That_Maximum_Difference_Is_K = function (nums, k) {\\n  nums.sort((a, b) => a - b);\\n  let minV = nums[0];\\n  let count = 1;\\n  for (let i = 1; i < nums.length; i++) {\\n    let diff = nums[i] - minV;\\n    if (diff > k) {\\n      count++;\\n      minV = nums[i];\\n    }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111939,
                "title": "c-solution-using-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int count=1;\\n        int mn=nums[0];\\n        int mx=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            mn=min(nums[i],mn);\\n            mx=max(nums[i],mx);\\n            if(mx-mn<=k)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                mn=nums[i];\\n                mx=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int count=1;\\n        int mn=nums[0];\\n        int mx=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            mn=min(nums[i],mn);\\n            mx=max(nums[i],mx);\\n            if(mx-mn<=k)\\n            {\\n                continue;\\n            }\\n            else\\n            {\\n                count++;\\n                mn=nums[i];\\n                mx=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111899,
                "title": "sorting-java",
                "content": "```\\nclass Solution\\n{\\n    public int partitionArray(int[] nums, int k)\\n    {\\n        int count = 1;\\n        int min = 100001, max = -1;\\n        Arrays.sort(nums);\\n        for(int i = 0 ;i < nums.length; i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            min = Math.min(min,nums[i]);\\n            if(max - min > k)\\n            {\\n                count++;\\n                min = max; // The new substring has just one element which is max and min both\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int partitionArray(int[] nums, int k)\\n    {\\n        int count = 1;\\n        int min = 100001, max = -1;\\n        Arrays.sort(nums);\\n        for(int i = 0 ;i < nums.length; i++)\\n        {\\n            max = Math.max(max,nums[i]);\\n            min = Math.min(min,nums[i]);\\n            if(max - min > k)\\n            {\\n                count++;\\n                min = max; // The new substring has just one element which is max and min both\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4057560,
                "title": "c-o-1-space-complexity",
                "content": "# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int mini = nums[0], cnt = 0;\\n        for(int it: nums){\\n            if(it-mini > k){\\n                cnt++;  mini = it;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int mini = nums[0], cnt = 0;\\n        for(int it: nums){\\n            if(it-mini > k){\\n                cnt++;  mini = it;\\n            }\\n        }\\n        return cnt+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997463,
                "title": "first-binary-search-solution-on-leetcode",
                "content": "# Approach\\nJust think of minimization problem of binary search.\\n# Complexity\\n- Time complexity:\\nO(n*logn) ->n*log(n) due to sorting\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // int partitionArray(vector<int>& nums, int k) {\\n       int chck(vector<int>&v1,int k,int md)\\n    {\\n        int cnt=1,n=v1.size(),maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,v1[i]);\\n            mini=min(mini,v1[i]);\\n            if((maxi-mini)>k)\\n            {\\n                maxi=v1[i],mini=v1[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n\\n    int partitionArray(vector<int>& v1, int k) {\\n    sort(v1.begin(),v1.end());\\n    \\n    int l=1,h=1e9,ans=INT_MAX;\\n\\n    while(l<=h)\\n    {\\n        \\n        int md=(l+h)/2;\\n        if(ans>=chck(v1,k,md))\\n        {\\n            ans=chck(v1,k,md);\\n        }\\n        else\\n        break;\\n        \\n        h=md-1;\\n    }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // int partitionArray(vector<int>& nums, int k) {\\n       int chck(vector<int>&v1,int k,int md)\\n    {\\n        int cnt=1,n=v1.size(),maxi=INT_MIN,mini=INT_MAX;\\n        for(int i=0;i<n;i++)\\n        {\\n            maxi=max(maxi,v1[i]);\\n            mini=min(mini,v1[i]);\\n            if((maxi-mini)>k)\\n            {\\n                maxi=v1[i],mini=v1[i];\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n\\n    }\\n\\n    int partitionArray(vector<int>& v1, int k) {\\n    sort(v1.begin(),v1.end());\\n    \\n    int l=1,h=1e9,ans=INT_MAX;\\n\\n    while(l<=h)\\n    {\\n        \\n        int md=(l+h)/2;\\n        if(ans>=chck(v1,k,md))\\n        {\\n            ans=chck(v1,k,md);\\n        }\\n        else\\n        break;\\n        \\n        h=md-1;\\n    }\\n    \\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772968,
                "title": "greedy-approach",
                "content": "# Intuition\\nsorting and two pointer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- o(n);\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- o(1);\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i =0, j=0;\\n        int count = 1;\\n          while( j<n){\\n           int z =  nums[j]- nums[i];\\n           if(z<=k){\\n               j++;\\n           }\\n           else{\\n               i =j;\\n               count++;\\n           }\\n          }\\n          return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int n = nums.size();\\n        int i =0, j=0;\\n        int count = 1;\\n          while( j<n){\\n           int z =  nums[j]- nums[i];\\n           if(z<=k){\\n               j++;\\n           }\\n           else{\\n               i =j;\\n               count++;\\n           }\\n          }\\n          return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3645038,
                "title": "c-easy-to-understand-with-comments",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int ans = 1; //There will be atleast one such partition\\n        //start denotes the starting point of the partition\\n        //end denotes the ending point\\n        int start = 0, end = 0;\\n        \\n        //Sort and start traversing\\n        sort(nums.begin(),nums.end());\\n        while(end < nums.size()){\\n            if(nums[end]-nums[start] <= k){\\n                //If valid check for the next index\\n                end++;\\n            }\\n            else{\\n                //If invalid then move start to this index\\n                start = end;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int ans = 1; //There will be atleast one such partition\\n        //start denotes the starting point of the partition\\n        //end denotes the ending point\\n        int start = 0, end = 0;\\n        \\n        //Sort and start traversing\\n        sort(nums.begin(),nums.end());\\n        while(end < nums.size()){\\n            if(nums[end]-nums[start] <= k){\\n                //If valid check for the next index\\n                end++;\\n            }\\n            else{\\n                //If invalid then move start to this index\\n                start = end;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567057,
                "title": "easy-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array and apply this approach,  **how many elements can be push between minimum and maximum.**\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n\\n        int n  = arr.size();\\n\\n        int mn  = arr[0];\\n        int mx  = arr[0];\\n\\n        int ans = 1;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n          mx = arr[i];\\n          if(mx-mn>k)\\n          {\\n          mn = arr[i];\\n          ans++;\\n          }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n\\n        int n  = arr.size();\\n\\n        int mn  = arr[0];\\n        int mx  = arr[0];\\n\\n        int ans = 1;\\n\\n        for(int i = 0;i<n;i++)\\n        {\\n          mx = arr[i];\\n          if(mx-mn>k)\\n          {\\n          mn = arr[i];\\n          ans++;\\n          }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3552092,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count =0;\\n        int i=0; int j=0;\\n        while(j<nums.size()){\\n            if(abs(nums[i]-nums[j])<=k){\\n                j++;\\n            }\\n            else{\\n                count++;\\n                i=j;\\n            }\\n        }\\n\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count =0;\\n        int i=0; int j=0;\\n        while(j<nums.size()){\\n            if(abs(nums[i]-nums[j])<=k){\\n                j++;\\n            }\\n            else{\\n                count++;\\n                i=j;\\n            }\\n        }\\n\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507622,
                "title": "java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n         Arrays.sort(nums);\\n        int ans=1;\\n        int i=0, j=0;\\n        while(j<nums.length){\\n            if(i==j){\\n                j++;\\n                continue;\\n            }\\n            if(nums[j]-nums[i]<=k){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n            }\\n        }\\nreturn ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n         Arrays.sort(nums);\\n        int ans=1;\\n        int i=0, j=0;\\n        while(j<nums.length){\\n            if(i==j){\\n                j++;\\n                continue;\\n            }\\n            if(nums[j]-nums[i]<=k){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n            }\\n        }\\nreturn ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367586,
                "title": "two-pointer-solution-cpp-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int min=0;\\n        int max=0;\\n        while(max<nums.size())\\n        {\\n            if(abs(nums[max]-nums[min])<=k)\\n            {\\n                max++;\\n            }\\n            else\\n            {\\n                count++;\\n                min=max;\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=0;\\n        int min=0;\\n        int max=0;\\n        while(max<nums.size())\\n        {\\n            if(abs(nums[max]-nums[min])<=k)\\n            {\\n                max++;\\n            }\\n            else\\n            {\\n                count++;\\n                min=max;\\n            }\\n        }\\n        return count+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3355915,
                "title": "2294-simple-multiple-solutions-with-explanation-beats-96",
                "content": "\\n# Approach\\n- Two pointer + Greedy\\nSince we want the seperations to as minimum as possible we will use greedy and check with first and last and moves on to the right when a possible seperation is met the counter is updated and index of right is changed to starting index of previous seperation - 1 and left is set to 0 and approach goes on till right reaches 0.\\nBut sadly there are many worst case test cases so this doesn\\'t work properly the next code has the same time complexity irrespective of best or worst case \\n\\n# Complexity\\n- For this code the \\n Best case : O(1)\\nworst case may even go exponentially O(N^2)\\n\\n# Code - 1\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, n - 1\\n        count = 0\\n        if k == 0:\\n            new = len(set(nums))\\n            return new\\n        while right >= 0 and left <= right:\\n            first, second = nums[left], nums[right]\\n            if left == right:\\n                count += 1\\n                right -= 1\\n                left = 0\\n                continue\\n            if second - first <= k:\\n                count += 1\\n                left, right = 0, left - 1\\n            else: left += 1\\n        return count\\n```\\n# Complexity\\n- TIme Complexity : O(N + Log(N))\\n# Code - 2\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        cnt = 1\\n        nums.sort()\\n        start = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]-start <= k:\\n                continue\\n            else:\\n                start = nums[i]\\n                cnt+= 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        left, right = 0, n - 1\\n        count = 0\\n        if k == 0:\\n            new = len(set(nums))\\n            return new\\n        while right >= 0 and left <= right:\\n            first, second = nums[left], nums[right]\\n            if left == right:\\n                count += 1\\n                right -= 1\\n                left = 0\\n                continue\\n            if second - first <= k:\\n                count += 1\\n                left, right = 0, left - 1\\n            else: left += 1\\n        return count\\n```\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        cnt = 1\\n        nums.sort()\\n        start = nums[0]\\n        for i in range(1,len(nums)):\\n            if nums[i]-start <= k:\\n                continue\\n            else:\\n                start = nums[i]\\n                cnt+= 1\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324535,
                "title": "php-100-faster-in-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function partitionArray($nums, $k) {\\n        $result = 0;\\n        if ($k === 0 && count(array_count_values($nums)) === count($nums)) {\\n            return count($nums);\\n        }\\n        while (!empty($nums)) {\\n            $max = max($nums);\\n            $arr = array_filter($nums, function($val) use ($max, $k) {\\n                return $val >= $max - $k;\\n            });\\n            $nums = array_diff($nums, $arr);\\n            $result++;\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\nclass Solution {\\n\\n    /**\\n     * @param Integer[] $nums\\n     * @param Integer $k\\n     * @return Integer\\n     */\\n    function partitionArray($nums, $k) {\\n        $result = 0;\\n        if ($k === 0 && count(array_count_values($nums)) === count($nums)) {\\n            return count($nums);\\n        }\\n        while (!empty($nums)) {\\n            $max = max($nums);\\n            $arr = array_filter($nums, function($val) use ($max, $k) {\\n                return $val >= $max - $k;\\n            });\\n            $nums = array_diff($nums, $arr);\\n            $result++;\\n        }\\n        return $result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132990,
                "title": "simple-and-easy-sorting-and-greedy-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int st = 0;\\n        int count =0;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[st]<=k)\\n            {\\n                if(i == nums.size()-1)\\n                {\\n                    count++;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                    count++;\\n                    st = i;\\n                    i--;\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int st = 0;\\n        int count =0;\\n        for(int i = 0;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[st]<=k)\\n            {\\n                if(i == nums.size()-1)\\n                {\\n                    count++;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                    count++;\\n                    st = i;\\n                    i--;\\n            }\\n\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2893027,
                "title": "c-200ms-faster-than-90-easy-approach-clean-concise-code",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        int res = 1; n = nums.size(), mini = nums[0];\\n\\n        for(int i = 0; i < n; ++i)\\n        {\\n           if((nums[i] - mini) > k)\\n           {\\n               res++;\\n               mini = nums[i];\\n           }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n\\n        int res = 1; n = nums.size(), mini = nums[0];\\n\\n        for(int i = 0; i < n; ++i)\\n        {\\n           if((nums[i] - mini) > k)\\n           {\\n               res++;\\n               mini = nums[i];\\n           }\\n        }\\n\\n        return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862111,
                "title": "c-solution-using-sorting-and-map",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int x=0; x<n; x++) m[nums[x]]=x;\\n        int division=0;\\n        int i=0;\\n        while(i<n)\\n        {\\n            for(int x=nums[i]+k; x>=nums[i]; x--)\\n            {\\n                if(m.find(x)!=m.end()) \\n                {\\n                    division++;\\n                    i=m[x]+1;\\n                    break;\\n                }\\n            }\\n        }\\n        return division;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        map<int,int> m;\\n        for(int x=0; x<n; x++) m[nums[x]]=x;\\n        int division=0;\\n        int i=0;\\n        while(i<n)\\n        {\\n            for(int x=nums[i]+k; x>=nums[i]; x--)\\n            {\\n                if(m.find(x)!=m.end()) \\n                {\\n                    division++;\\n                    i=m[x]+1;\\n                    break;\\n                }\\n            }\\n        }\\n        return division;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2817978,
                "title": "c-easy-to-understand-5-6-line-code",
                "content": "class Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int j = 0;\\n        int ans = 1;    \\n        \\n       \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n       \\n        for(int i=1; i<nums.size(); i++){\\n            \\n            if(nums[j]- nums[i] > k){\\n                ans++;\\n                j = i;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int j = 0;\\n        int ans = 1;    \\n        \\n       \\n        sort(nums.begin(), nums.end(), greater<int>());\\n        \\n       \\n        for(int i=1; i<nums.size(); i++){\\n            \\n            if(nums[j]- nums[i] > k){\\n                ans++;\\n                j = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2814393,
                "title": "java-easy-solution-on-sorting",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n       Arrays.sort(nums);\\n        int res = 1, mn = nums[0], mx = nums[0];\\n        for (int a : nums) {\\n            mn = Math.min(mn, a);\\n            mx = Math.max(mx, a);\\n            if (mx - mn > k) {\\n                res ++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n       Arrays.sort(nums);\\n        int res = 1, mn = nums[0], mx = nums[0];\\n        for (int a : nums) {\\n            mn = Math.min(mn, a);\\n            mx = Math.max(mx, a);\\n            if (mx - mn > k) {\\n                res ++;\\n                mn = mx = a;\\n            }\\n        }\\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2814047,
                "title": "c-easy-solution-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[j]>k){\\n                cnt++;\\n                j=i;\\n            }\\n        }\\n        cnt++;\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int j=0;\\n        for(int i=1;i<nums.size();i++)\\n        {\\n            if(nums[i]-nums[j]>k){\\n                cnt++;\\n                j=i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2643689,
                "title": "java-brute-force-easy-solution-o-nlogn",
                "content": "# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int start=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n           if(nums[i]-start>k){\\n               start=nums[i];\\n                count++;\\n           } \\n        }return count;\\n    }\\n}   \\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int start=nums[0];\\n        for(int i=0;i<nums.length;i++){\\n           if(nums[i]-start>k){\\n               start=nums[i];\\n                count++;\\n           } \\n        }return count;\\n    }\\n}   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2612394,
                "title": "java-sort-clean-solution",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res = 0;\\n        int range = -1;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]<=range) continue;\\n            else{\\n                range = nums[i]+k;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int res = 0;\\n        int range = -1;\\n        for(int i =0;i<nums.length;i++){\\n            if(nums[i]<=range) continue;\\n            else{\\n                range = nums[i]+k;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2574773,
                "title": "c-sorting-binary-search-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n       \\n        sort(nums.begin(),nums.end());\\n       \\n        int ans=0;\\n        int j=0;\\n        while(j<nums.size())\\n        {\\n           auto i=upper_bound(nums.begin(),nums.end(),nums[j]+k);\\n           int index=int(i-nums.begin());\\n            \\n           ans++;\\n           j=index;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n       \\n        sort(nums.begin(),nums.end());\\n       \\n        int ans=0;\\n        int j=0;\\n        while(j<nums.size())\\n        {\\n           auto i=upper_bound(nums.begin(),nums.end(),nums[j]+k);\\n           int index=int(i-nums.begin());\\n            \\n           ans++;\\n           j=index;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2569752,
                "title": "java-simple-and-short-solution-88-memory-with-explanation",
                "content": "\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int start = nums[0];\\n\\t\\t//for each iteration I find difference between first element of subsequence\\n\\t\\t//and current element. If difference is > than k, then I just increment subsequence count\\n\\t\\t//and make current element as start element for the next subsequence\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] - start > k) {\\n                count++;\\n                start = nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int count = 1;\\n        int start = nums[0];\\n\\t\\t//for each iteration I find difference between first element of subsequence\\n\\t\\t//and current element. If difference is > than k, then I just increment subsequence count\\n\\t\\t//and make current element as start element for the next subsequence\\n        for (int i = 1; i < nums.length; i++) {\\n            if (nums[i] - start > k) {\\n                count++;\\n                start = nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2519425,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end()); \\n        int maxi= INT_MIN; int mini= INT_MAX; int count=0; int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mini= min(mini,nums[i]);\\n            maxi=max(maxi, nums[i]);\\n            if(maxi-mini <=k)\\n                continue;\\n            else\\n            {\\n                count++;\\n                maxi=INT_MIN;\\n                mini= INT_MAX;\\n                i--;\\n            }  \\n        }\\n        return count+1;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end()); \\n        int maxi= INT_MIN; int mini= INT_MAX; int count=0; int n=nums.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            mini= min(mini,nums[i]);\\n            maxi=max(maxi, nums[i]);\\n            if(maxi-mini <=k)\\n                continue;\\n            else\\n            {\\n                count++;\\n                maxi=INT_MIN;\\n                mini= INT_MAX;\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2399329,
                "title": "sorting-easy-2-pointer",
                "content": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=1;\\n        int i=0,j=1;\\n        while(j<nums.size())\\n        {\\n            if (nums[j]-nums[i]<=k)\\n            {\\n                j++;\\n            }\\n            else\\n            {\\n                cnt++;\\n                i=j;\\n            }\\n            \\n            \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt=1;\\n        int i=0,j=1;\\n        while(j<nums.size())\\n        {\\n            if (nums[j]-nums[i]<=k)\\n            {\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2297034,
                "title": "java-explained-two-approach-use-one-loop",
                "content": "```\\n\\n```class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums); // we sort the array so it will be easy for us to track \\n        int count=1;\\n        int start=0;//for the smallest number\\n        for(int i=0;i<nums.length;i++){\\n            \\n            //basically if the diff b/w smallest and larget number is greater \\n            //than k then we do change the minimum and  \\n            //shift the numbwe into new subsequence and +1 the count;\\n            if(nums[i]-nums[start]>k){\\n                start=i;\\n                count++;\\n            }\\n            // if(nums[i]-nums[start]<=k){\\n            // continue;\\n            // }else{\\n            //     start=i;\\n            //     count++;\\n            // }\\n        }\\n        return count;\\n    }\\n}\\n//kindly upvote if you find it helpful",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2287274,
                "title": "python3-o-n-min-max-blocks-counts",
                "content": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res=1\\n        minm=nums[0]\\n        maxm=nums[0]\\n        for x in nums:\\n            if abs(x-minm)>k or abs(x-maxm)>k:\\n                res+=1\\n                minm=x\\n                maxm=x\\n            else:\\n                minm=min(minm,x)\\n                maxm=max(maxm,x)\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        res=1\\n        minm=nums[0]\\n        maxm=nums[0]\\n        for x in nums:\\n            if abs(x-minm)>k or abs(x-maxm)>k:\\n                res+=1\\n                minm=x\\n                maxm=x\\n            else:\\n                minm=min(minm,x)\\n                maxm=max(maxm,x)\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2282069,
                "title": "60-tc-and-78-sc-easy-python-solution-using-binary-search",
                "content": "```\\ndef partitionArray(self, nums: List[int], k: int) -> int:\\n\\tans = 0\\n\\tnums.sort()\\n\\ti = 0\\n\\twhile(i < len(nums)):\\n\\t\\ti = bisect_right(nums, nums[i]+k, i)\\n\\t\\tans += 1\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Greedy",
                    "Binary Tree"
                ],
                "code": "```\\ndef partitionArray(self, nums: List[int], k: int) -> int:\\n\\tans = 0\\n\\tnums.sort()\\n\\ti = 0\\n\\twhile(i < len(nums)):\\n\\t\\ti = bisect_right(nums, nums[i]+k, i)\\n\\t\\tans += 1\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2253700,
                "title": "brute-force-to-optimized-c",
                "content": "# Brute force (TLE)\\n*Time complexity: worst case - O(n ^ 2)*\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int i = 0, j = nums.size() - 1, ans = 0;\\n        \\n        while(i < nums.size()) {\\n            if(nums[j] - nums[i] <= k) ans++, i = j + 1, j = nums.size() - 1;\\n            else j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n# Optimized\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int mn = INT_MAX, mx = INT_MIN, ans = 1;\\n        for(int i : nums) {\\n            mn = min(mn, i);\\n            mx = max(mx, i);\\n            \\n            if(mx - mn > k) ans++, mn = mx = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int i = 0, j = nums.size() - 1, ans = 0;\\n        \\n        while(i < nums.size()) {\\n            if(nums[j] - nums[i] <= k) ans++, i = j + 1, j = nums.size() - 1;\\n            else j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        \\n        int mn = INT_MAX, mx = INT_MIN, ans = 1;\\n        for(int i : nums) {\\n            mn = min(mn, i);\\n            mx = max(mx, i);\\n            \\n            if(mx - mn > k) ans++, mn = mx = i;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2201487,
                "title": "java-sort-binary-search-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        \\n        int ans=0;\\n        int i=0;\\n        \\n        while(i<nums.length)\\n        {\\n           int curr=nums[i];\\n           ans++; \\n           int pos=binarySearch(nums,i,nums[i]+k+1);\\n           i=pos;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int binarySearch(int nums[],int start,int target)\\n    {\\n        int n=nums.length;\\n        int end=n-1;int ans=n;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(nums[mid]>=target)\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            \\n            else\\n            start=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        \\n        int ans=0;\\n        int i=0;\\n        \\n        while(i<nums.length)\\n        {\\n           int curr=nums[i];\\n           ans++; \\n           int pos=binarySearch(nums,i,nums[i]+k+1);\\n           i=pos;\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    public int binarySearch(int nums[],int start,int target)\\n    {\\n        int n=nums.length;\\n        int end=n-1;int ans=n;\\n        \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(nums[mid]>=target)\\n            {\\n                ans=mid;\\n                end=mid-1;\\n            }\\n            \\n            else\\n            start=mid+1;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2173730,
                "title": "java-easy-to-understand-o-nlogn-sorting-beginner-friendly-simple-approach",
                "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int start = 0;\\n        int count=1;\\n        for(int i=1;i<nums.length;i++){\\n            if((nums[i]-nums[start])>k){\\n                start = i;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n\\n// Note :- Please upvote if you find it helpful ... Thank you ..!",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int start = 0;\\n        int count=1;\\n        for(int i=1;i<nums.length;i++){\\n            if((nums[i]-nums[start])>k){\\n                start = i;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2165764,
                "title": "java-sort-and-compare",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        \\n        int i =1;\\n        int prev_val = nums[0];\\n        int result =1;\\n        \\n        while(i < nums.length)\\n        {\\n            if(nums[i] - prev_val > k)\\n            {\\n                result++;\\n                prev_val = nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) \\n    {\\n        Arrays.sort(nums);\\n        \\n        int i =1;\\n        int prev_val = nums[0];\\n        int result =1;\\n        \\n        while(i < nums.length)\\n        {\\n            if(nums[i] - prev_val > k)\\n            {\\n                result++;\\n                prev_val = nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2161908,
                "title": "c-simple-soution-using-sorting",
                "content": "```\\nint partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int res = 0 , i = 0 , j = 0 , n = nums.size();\\n      \\n        while(j<n){\\n            if(nums[j]-nums[i] > k){                \\n                res++;\\n                i = j;  \\n            }\\n            j++;\\n        }\\n        ++res;\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nint partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        \\n        int res = 0 , i = 0 , j = 0 , n = nums.size();\\n      \\n        while(j<n){\\n            if(nums[j]-nums[i] > k){                \\n                res++;\\n                i = j;  \\n            }\\n            j++;\\n        }\\n        ++res;\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2141591,
                "title": "c-6-lines-sort-2-pointer-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 1,low = 0,i=0;\\n\\t\\t//low points to min element and i points to max \\n\\t\\t//whenever their difference exceeds k we update low index and increment counter\\n       while(i<nums.size())\\n       {\\n            if(nums[i]-nums[low] <= k) i++;\\n            else low = i,cnt++;\\n       }\\n        return cnt;             \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int cnt = 1,low = 0,i=0;\\n\\t\\t//low points to min element and i points to max \\n\\t\\t//whenever their difference exceeds k we update low index and increment counter\\n       while(i<nums.size())\\n       {\\n            if(nums[i]-nums[low] <= k) i++;\\n            else low = i,cnt++;\\n       }\\n        return cnt;             \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139697,
                "title": "o-n-solution-c-88ms-beats-100-and-java-11ms-beats-99-73",
                "content": "C++:\\n```\\nconst int ZERO = []() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    bool a[100005];\\n    \\n    int partitionArray(vector<int>& nums, int k) {\\n        int mx = -1;\\n        for(int num: nums){\\n            a[num] = 1;\\n            mx = max(num, mx);\\n        }\\n        \\n        int ans = 0;\\n        int l = 0;\\n        while(l <= mx){\\n            while(l <= mx && !a[l]) l++;\\n            l += k + 1;\\n            while(l <= mx && !a[l]) l++;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\nJava:\\n```\\nclass Solution {\\n    boolean a[] = new boolean[100004];\\n    \\n    public int partitionArray(int[] nums, int k) {\\n        int mx = -1;\\n        for(int num: nums){\\n            a[num] = true;\\n            mx = Math.max(num, mx);\\n        }\\n        \\n        int ans = 0;\\n        int l = 0;\\n        while(l <= mx){\\n            while(l <= mx && !a[l]) l++;\\n            l += k + 1;\\n            while(l <= mx && !a[l]) l++;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nconst int ZERO = []() {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    bool a[100005];\\n    \\n    int partitionArray(vector<int>& nums, int k) {\\n        int mx = -1;\\n        for(int num: nums){\\n            a[num] = 1;\\n            mx = max(num, mx);\\n        }\\n        \\n        int ans = 0;\\n        int l = 0;\\n        while(l <= mx){\\n            while(l <= mx && !a[l]) l++;\\n            l += k + 1;\\n            while(l <= mx && !a[l]) l++;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    boolean a[] = new boolean[100004];\\n    \\n    public int partitionArray(int[] nums, int k) {\\n        int mx = -1;\\n        for(int num: nums){\\n            a[num] = true;\\n            mx = Math.max(num, mx);\\n        }\\n        \\n        int ans = 0;\\n        int l = 0;\\n        while(l <= mx){\\n            while(l <= mx && !a[l]) l++;\\n            l += k + 1;\\n            while(l <= mx && !a[l]) l++;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2137517,
                "title": "scala-solution",
                "content": "```\\n\\n  def partitionArray(nums: Array[Int], k: Int): Int = {\\n    nums.sorted.foldLeft((1, nums.min))((acc, cur) =>{\\n      cur - acc._2 > k match {\\n        case true => (acc._1 + 1, cur)\\n        case _ => acc\\n      }\\n    })._1\\n  }\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n  def partitionArray(nums: Array[Int], k: Int): Int = {\\n    nums.sorted.foldLeft((1, nums.min))((acc, cur) =>{\\n      cur - acc._2 > k match {\\n        case true => (acc._1 + 1, cur)\\n        case _ => acc\\n      }\\n    })._1\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2125842,
                "title": "2-pointers-c",
                "content": "class Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0,ans=0;\\n        while(i<nums.size()&&j<nums.size()){\\n            if(nums[j]-nums[i]<=k)j++;\\n            else {\\n                i=j;\\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0,ans=0;\\n        while(i<nums.size()&&j<nums.size()){\\n            if(nums[j]-nums[i]<=k)j++;\\n            else {\\n                i=j;\\n                ans++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2123140,
                "title": "c",
                "content": "\\tPartition Array Such That Maximum Difference Is K\\nclass Solution {\\npublic:\\n         \\n        int i=0,j=i+1,count=1;\\n        int length=nums.size();\\n        sort(nums.begin(),nums.end());\\n        while(j<length)\\n        {\\n            if(nums[j]-nums[i]>k)\\n            {\\n                count++;\\n                i=j;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n         \\n        int i=0,j=i+1,count=1;\\n        int length=nums.size();\\n        sort(nums.begin(),nums.end());\\n        while(j<length)\\n        {\\n            if(nums[j]-nums[i]>k)\\n            {\\n                count++;\\n                i=j;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2116566,
                "title": "queue-sorting-approach-in-partition-array",
                "content": "Priority Queue TC:- O(n log n)\\n```\\nclass Solution {\\n     public int partitionArray(int[] nums, int k) {\\n        return usePriorityQueue(nums, k);\\n    }\\n    \\n    public int usePriorityQueue(int[] nums, int k) {\\n     PriorityQueue<Integer> p = new PriorityQueue<>();\\n     for(int num : nums){\\n         p.offer(num);\\n     }\\n        int ans = 0;\\n        while(!p.isEmpty()){\\n            ans++;\\n            int val = p.poll();\\n            while(!p.isEmpty() && p.peek() - val <= k){\\n                p.poll();\\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```\\nvia Sorting  \\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n         Arrays.sort(nums);\\n    \\n    int ans=1,j=0;\\n    for(int i=1;i<nums.length;i++)\\n    {\\n       \\n        if(nums[i]-nums[j]>k)\\n        {\\n            ans++;\\n            j=i;\\n        }\\n        else\\n        {\\n            continue;\\n        }\\n            \\n    }\\n    return ans;\\n    }\\n}\\n```\\n\\nTime complexity = O(n log n)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n     public int partitionArray(int[] nums, int k) {\\n        return usePriorityQueue(nums, k);\\n    }\\n    \\n    public int usePriorityQueue(int[] nums, int k) {\\n     PriorityQueue<Integer> p = new PriorityQueue<>();\\n     for(int num : nums){\\n         p.offer(num);\\n     }\\n        int ans = 0;\\n        while(!p.isEmpty()){\\n            ans++;\\n            int val = p.poll();\\n            while(!p.isEmpty() && p.peek() - val <= k){\\n                p.poll();\\n            }\\n        }\\n        return ans ; \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n         Arrays.sort(nums);\\n    \\n    int ans=1,j=0;\\n    for(int i=1;i<nums.length;i++)\\n    {\\n       \\n        if(nums[i]-nums[j]>k)\\n        {\\n            ans++;\\n            j=i;\\n        }\\n        else\\n        {\\n            continue;\\n        }\\n            \\n    }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2116251,
                "title": "python",
                "content": "```python\\n        nums.sort()\\n        left = res = 0\\n        for right in range(len(nums)):\\n            if nums[right] - nums[left] > k:\\n                res += 1\\n                left = right\\n        return res + 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n        nums.sort()\\n        left = res = 0\\n        for right in range(len(nums)):\\n            if nums[right] - nums[left] > k:\\n                res += 1\\n                left = right\\n        return res + 1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114688,
                "title": "java-solution-by-sorting-the-array",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int partition=0;\\n        int start=0;\\n        for(int i=0;i<nums.length;++i)\\n        {\\n            if(nums[i]-nums[start]<=k)\\n            {\\n                if(i==nums.length-1)\\n                {\\n                    ++partition;\\n                }\\n            }\\n            else\\n            {\\n                start=i;\\n                ++partition;\\n                --i;\\n            }\\n        }\\n        return partition;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int partition=0;\\n        int start=0;\\n        for(int i=0;i<nums.length;++i)\\n        {\\n            if(nums[i]-nums[start]<=k)\\n            {\\n                if(i==nums.length-1)\\n                {\\n                    ++partition;\\n                }\\n            }\\n            else\\n            {\\n                start=i;\\n                ++partition;\\n                --i;\\n            }\\n        }\\n        return partition;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114451,
                "title": "c-sorting-greedy",
                "content": "**Approach** :\\nIn problem statement, it states that min and max of every subsequence should have difference of at most k. First thing that comes to mind is to collect all elements that are in each other\\'s vicinity. Since here vicinity is matter of difference, best way to collect these elements is sorting. \\n\\nNow, for minimizing number of subsequences, we\\'ll try to make each subsequence as long as possible. Therefore, we\\'ll keep on picking up elements as long as difference is at most k. By this way, we are keeping bounds of each subsequence as tight as possible so that next subsequence to be added won\\'t get affected with this.\\n\\n**Code** :\\n```\\nint partitionArray(vector<int>& nums, int k) {\\n        int ans = 1;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int min_num = nums[0];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - min_num > k)\\n            {\\n                ans++;\\n                min_num = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nint partitionArray(vector<int>& nums, int k) {\\n        int ans = 1;\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int min_num = nums[0];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - min_num > k)\\n            {\\n                ans++;\\n                min_num = nums[i];\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114260,
                "title": "c-sorting-binary-search",
                "content": "```\\nint binarySearch(int low,int high,vector<int>&nums, int k,int left){\\n       int ans;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]-left<=k){\\n                ans = mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int partitionArray(vector<int>& nums, int k) {\\n        int left=0, right = nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        while(left<=right){\\n            if(nums[right]-nums[left]<=k){\\n                break;\\n            }\\n            else{\\n                int idx = binarySearch(left,right,nums,k,nums[left]);\\n                count++;\\n                left=idx+1;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [],
                "code": "```\\nint binarySearch(int low,int high,vector<int>&nums, int k,int left){\\n       int ans;\\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]-left<=k){\\n                ans = mid;\\n                low=mid+1;\\n            }\\n            else{\\n                high=mid-1;\\n            }\\n        }\\n        return ans;\\n    }\\n    int partitionArray(vector<int>& nums, int k) {\\n        int left=0, right = nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        while(left<=right){\\n            if(nums[right]-nums[left]<=k){\\n                break;\\n            }\\n            else{\\n                int idx = binarySearch(left,right,nums,k,nums[left]);\\n                count++;\\n                left=idx+1;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2114252,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        if(nums== null || nums.length==0) return 0;\\n        Arrays.sort(nums);\\n        int count=1;\\n        int min= Integer.MAX_VALUE;\\n        int max= Integer.MIN_VALUE;\\n        for(int val: nums){\\n            min= Math.min(val, min);\\n            max= Math.max(val, max);\\n            if(max-min> k){\\n                count++;\\n                min= max;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        if(nums== null || nums.length==0) return 0;\\n        Arrays.sort(nums);\\n        int count=1;\\n        int min= Integer.MAX_VALUE;\\n        int max= Integer.MIN_VALUE;\\n        for(int val: nums){\\n            min= Math.min(val, min);\\n            max= Math.max(val, max);\\n            if(max-min> k){\\n                count++;\\n                min= max;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113580,
                "title": "c-faster-than-100-easy-understanding",
                "content": "**As they asked for only number of subsequences, we should\\'nt worry about the order of the elements, thus we can sort the nums array.**\\n\\nnow we take 2 variables, start and next, initially both are set to 0\\nnow we loop until start < n, else it\\'ll be out of bounds\\n\\nwe keep on increasing the next pointer, if \\n1. it is less than n\\n2. nums[next] - nums[start] <= k\\n\\nonce it fails the condition, i.e the start element and the last element (next) difference crossed k, we break out and increment the count of ans.\\n\\n***we dont consider the last element (next) as it didnt meet the condition, and now we set the start to last element (next) as we start a new subsequnce.***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int start = 0;\\n        int next = 0;\\n        while(start < n){\\n            while(next < n and nums[next] - nums[start] <= k){\\n                next++;\\n            }\\n            ans++;\\n            start = next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int ans = 0;\\n        int n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        int start = 0;\\n        int next = 0;\\n        while(start < n){\\n            while(next < n and nums[next] - nums[start] <= k){\\n                next++;\\n            }\\n            ans++;\\n            start = next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113457,
                "title": "o-n-c-sort-select-easy-understanding-full-explained",
                "content": "Just sort the given array and keep track of the minimum and maximum element. When the minimum element changes, you make an extra subsequence. The minimum element is changed the moment when nums[i]-min > k\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int n = nums.size();\\n        int ans = 0;\\n        int cmin = nums[0];\\n        for(int i = 1;i<n;i++){\\n            if(nums[i]-cmin > k){\\n                cmin = nums[i];\\n                \\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(begin(nums),end(nums));\\n        int n = nums.size();\\n        int ans = 0;\\n        int cmin = nums[0];\\n        for(int i = 1;i<n;i++){\\n            if(nums[i]-cmin > k){\\n                cmin = nums[i];\\n                \\n                ans++;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113442,
                "title": "simple-5-line-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0,j=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[j]>k){\\n                ans++;\\n                j=i;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int ans=0,j=0;\\n        for(int i=1;i<nums.size();i++){\\n            if(nums[i]-nums[j]>k){\\n                ans++;\\n                j=i;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2113263,
                "title": "c-greedy",
                "content": "We need to find subsequence so we can sort the array and use sliding window to keep check for max - min, whenever it exceeds we increment cnt by 1 and change the lo pointer\\n```\\nclass Solution {\\npublic:\\n\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tint cnt = 1, n = nums.size(), lo = 0;\\n\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\tif (nums[i] - nums[lo] > k) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tlo = i;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n};",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\tsort(nums.begin(), nums.end());\\n\\t\\tint cnt = 1, n = nums.size(), lo = 0;\\n\\t\\tfor (int i = 1; i < n; ++i) {\\n\\t\\t\\tif (nums[i] - nums[lo] > k) {\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t\\tlo = i;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2113191,
                "title": "c-easy-sorting-full-explanation-intution",
                "content": "**Task:**\\n\\nReturn\\xA0the\\xA0minimum\\xA0number of subsequences needed such that the difference between the maximum and minimum values in each subsequence is\\xA0at most\\xA0k.\\n\\n**Constraints:**\\n\\nlength<=10^5\\nSo (10^5)^2 = 10^10 is not possible i.e O(n^2) fails.\\nWe need to think in O(nlogn) or O(logn) or O(n)\\ni.e sorting/logrithmic/linear\\n\\n**Approach:**\\n\\nWe only care about the count of subsequences where (max-min)<=k\\n\\nConsider,\\n\\n[3,6,1,2,5] k=2\\n\\nHere we see\\nmax-min <=k\\n\\n3-1=2<=k\\n6-5=1<=k\\n2-2=0<=k\\n\\nSo subsequences are  [3,1] [6,5] ,[2]\\nBut we need minimum no. of subsequences \\nSo we include 2 in [3,1] which doesn\\'t change diff of max and min and 3-1=2<=k still holds true\\n\\nso new subseqnces are [3,1,2] and [6,5]\\n\\nSo we observed we included 2 in the range of min and max to minimise no. of subsequences\\n\\nThus we get the idea that we should consider only max and min and any other numbers that lie in this range should lie in the same subsequence for count to be min.\\n\\nThus if we sort the array\\nleft part would be min and right part will be maximum\\n\\n[1,2,3,5,6]\\n\\nWe can check the following considering absolute difference abs(min-max)<=k\\n\\n1-2=1<=k\\n1-3=2<=k\\n1-5=4>k condition breaks means we have found one subsequence [1,2,3] here, so cnt++\\n\\nNow move to 5\\n5-6=1<=k , cnt++ \\n\\nThus cnt=2 we found 2 subsequences [1,2,3] and [5,6]\\n\\n**>>Edge case:**\\n\\nConsider\\n[1,2,3] k=1\\n\\n1-2=1<=k\\n1-3=2>k condition breaks here cnt++\\nEnd of array\\n\\ncnt =1\\n\\nBut wait we should have 2 subsequences \\n[1,2] and [3] alone\\n\\nwe only found out [1,2]\\n\\nSo whenever condition breaks we do i--\\nSo that the abs diff of element itself is checked\\nsince single element can be a subsequence\\n\\nThus\\n1-2=1<=k\\n1-3=2>k cnt++ ,  i--\\n3-3=0<=k cnt++\\nThus cnt=2\\n\\nAlso we see sorting makes us consider each element in only one subsequence as mentioned in the question as we traverse linearly only once.\\n\\nAlso if we have just one element(max==min) in array ans will be always 1 independent of k since max-min will be 0.\\n\\n**Time Complexity:**\\n\\nSorting + linear\\nO(nlogn)+O(n) = O(nlogn) \\n\\n**Code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\t\\tif(n==1) return 1;\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int idx=0;\\n        int diff;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            diff= abs(nums[idx] - nums[i]);\\n            if(diff>k){\\n                cnt++;\\n                idx = i;\\n                i--;\\n             }\\n\\n       }\\n       if(diff<=k) cnt++;\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n\\t\\tif(n==1) return 1;\\n\\t\\t\\n        sort(nums.begin(),nums.end());\\n        int cnt=0;\\n        int idx=0;\\n        int diff;\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            diff= abs(nums[idx] - nums[i]);\\n            if(diff>k){\\n                cnt++;\\n                idx = i;\\n                i--;\\n             }\\n\\n       }\\n       if(diff<=k) cnt++;\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112669,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Sorting***\\n\\n* ***Time Complexity : O(NlogN)***\\n\\n* ***Space Complexity : O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& arr, int k) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        int count = 1;\\n        \\n        while(right < arr.size())\\n        {\\n            while(right < arr.size() && (arr[right] - arr[left]) <= k)\\n            {\\n                right++; \\n            }\\n            \\n            if(right < arr.size())\\n            {\\n                count++;\\n            \\n                left = right;\\n            }  \\n        }\\n        \\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& arr, int k) {\\n        \\n        sort(arr.begin(), arr.end());\\n        \\n        int left = 0;\\n        \\n        int right = 0;\\n        \\n        int count = 1;\\n        \\n        while(right < arr.size())\\n        {\\n            while(right < arr.size() && (arr[right] - arr[left]) <= k)\\n            {\\n                right++; \\n            }\\n            \\n            if(right < arr.size())\\n            {\\n                count++;\\n            \\n                left = right;\\n            }  \\n        }\\n        \\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112642,
                "title": "javascript-simple-and-easy",
                "content": "If you like please upvote :)\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar partitionArray = function(nums, k) {\\n  \\n    nums.sort((a,b) =>{ return a-b})\\n    \\n    let n = nums.length ,ans=0\\n    \\n    for(let i=0 ; i<n; i++){\\n        let ele = nums[i]\\n        while(i<n && nums[i]-ele<=k) i++\\n        i--\\n        ans++\\n    }\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nvar partitionArray = function(nums, k) {\\n  \\n    nums.sort((a,b) =>{ return a-b})\\n    \\n    let n = nums.length ,ans=0\\n    \\n    for(let i=0 ; i<n; i++){\\n        let ele = nums[i]\\n        while(i<n && nums[i]-ele<=k) i++\\n        i--\\n        ans++\\n    }\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112567,
                "title": "c-294-ms",
                "content": "\\n```\\n    public int PartitionArray(int[] nums, int k) {\\n        \\n        Array.Sort(nums);\\n        \\n        int count = 1;\\n        int maxSubsequence = nums[0] + k;\\n        \\n        for(int i = 1; i < nums.Length; i++){\\n            if(nums[i] > maxSubsequence){\\n                count++;\\n                maxSubsequence = nums[i] + k;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int PartitionArray(int[] nums, int k) {\\n        \\n        Array.Sort(nums);\\n        \\n        int count = 1;\\n        int maxSubsequence = nums[0] + k;\\n        \\n        for(int i = 1; i < nums.Length; i++){\\n            if(nums[i] > maxSubsequence){\\n                count++;\\n                maxSubsequence = nums[i] + k;\\n            }\\n        }\\n        \\n        return count;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112414,
                "title": "python3-easy-intuitive-method-sliding-window",
                "content": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort(reverse = True)\\n        # print(nums)\\n        initial = nums[0]\\n        count = 0\\n        for i in range(1, len(nums)):\\n            if initial - nums[i] > k:\\n                initial = nums[i]\\n                count += 1\\n        count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort(reverse = True)\\n        # print(nums)\\n        initial = nums[0]\\n        count = 0\\n        for i in range(1, len(nums)):\\n            if initial - nums[i] > k:\\n                initial = nums[i]\\n                count += 1\\n        count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112348,
                "title": "sort-and-binary-search",
                "content": "Since we are asked about subsequences and required to calculate the min and max of each subsequence , the **order of the elements does not matter** and hence we can sort the array.\\n\\nOnce the array is sorted we just have to count number of blocks having *max-min element <= k*, which we can do by using binary search ( bisect_right gives the index of the rightmost occurance of the number minSeq + k )\\n\\n```\\n nums.sort()\\n        n = len(nums)\\n        count = 0\\n        i = 0\\n        while i <n:\\n            i = bisect_right(nums,nums[i] +k)\\n            count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n nums.sort()\\n        n = len(nums)\\n        count = 0\\n        i = 0\\n        while i <n:\\n            i = bisect_right(nums,nums[i] +k)\\n            count+=1\\n        return count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112276,
                "title": "javascript-greedy-sort-397ms",
                "content": "Main idea: greedily pick elements for subsequence, always increasing pick (from min -> max) to make more elements to be picked up for current collection\\n```\\nconst partitionArray = (a, k) => {\\n    a.sort((x, y) => x - y);\\n    let res = 0, pre = a[0]\\n    for (let i = 1; i < a.length; i++) {\\n        if (a[i] - pre > k) {\\n            res++;\\n            pre = a[i];\\n        }\\n    }\\n    return res + 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nconst partitionArray = (a, k) => {\\n    a.sort((x, y) => x - y);\\n    let res = 0, pre = a[0]\\n    for (let i = 1; i < a.length; i++) {\\n        if (a[i] - pre > k) {\\n            res++;\\n            pre = a[i];\\n        }\\n    }\\n    return res + 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112257,
                "title": "just-sort-and-do-the-rest",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int mnn = INT_MAX;\\n        sort(begin(nums),end(nums));\\n        int res = 0;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(abs(mnn-nums[i])<=k)\\n            {\\n                mnn = min(mnn,nums[i]);\\n            }else \\n                res++,mnn = nums[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int mnn = INT_MAX;\\n        sort(begin(nums),end(nums));\\n        int res = 0;\\n        int n = nums.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(abs(mnn-nums[i])<=k)\\n            {\\n                mnn = min(mnn,nums[i]);\\n            }else \\n                res++,mnn = nums[i];\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112237,
                "title": "python-easy-understanding-solution",
                "content": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        ans = 1\\n\\n        nums = list(set(nums))\\n        nums.sort()\\n\\n        newNums = []\\n        newNums.append(nums[0])\\n        nums.pop(0)\\n        i = 1\\n\\n        while len(nums) >= 1:\\n            if nums[0] <= newNums[ans - 1] + k:\\n                nums.pop(0)\\n            else:\\n                ans += 1\\n                newNums.append(nums[0])\\n                nums.pop(0)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        ans = 1\\n\\n        nums = list(set(nums))\\n        nums.sort()\\n\\n        newNums = []\\n        newNums.append(nums[0])\\n        nums.pop(0)\\n        i = 1\\n\\n        while len(nums) >= 1:\\n            if nums[0] <= newNums[ans - 1] + k:\\n                nums.pop(0)\\n            else:\\n                ans += 1\\n                newNums.append(nums[0])\\n                nums.pop(0)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112187,
                "title": "c-sort-the-array-and-then-compare",
                "content": "Don\\'t get confused by subsequence. we can re-arrange things as we just need to group numbers where diff between min and max should be less than or equal to k.\\n\\nHence we can sort the numbers.\\n\\n```\\npublic int PartitionArray(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int count = 1;\\n        int min = nums[0];\\n        for(int i = 1; i < nums.Length; i++){\\n            if(nums[i]-min <= k){\\n                continue;\\n            }\\n            else{\\n                count++;\\n                min = nums[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int PartitionArray(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int count = 1;\\n        int min = nums[0];\\n        for(int i = 1; i < nums.Length; i++){\\n            if(nums[i]-min <= k){\\n                continue;\\n            }\\n            else{\\n                count++;\\n                min = nums[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2112170,
                "title": "using-binary-search-cpp-o-n-log-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0,s=nums.size()-1;\\n        int cnt=0;\\n        while(i<nums.size()){\\n        \\n            int mid;\\n            int start=i,end=s;\\n            int res;\\n            \\n            while(start<=end){\\n                mid=start+(end-start)/2;\\n                \\n                if(nums[mid]-nums[i]==k){\\n                    res=mid;\\n                    start=mid+1;\\n                }\\n                else if(nums[mid]-nums[i]<k){\\n                    res=mid;\\n                    start=mid+1;\\n                }\\n                \\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            \\n            i=res+1;\\n            cnt++;\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        \\n        sort(nums.begin(),nums.end());\\n        int i=0,s=nums.size()-1;\\n        int cnt=0;\\n        while(i<nums.size()){\\n        \\n            int mid;\\n            int start=i,end=s;\\n            int res;\\n            \\n            while(start<=end){\\n                mid=start+(end-start)/2;\\n                \\n                if(nums[mid]-nums[i]==k){\\n                    res=mid;\\n                    start=mid+1;\\n                }\\n                else if(nums[mid]-nums[i]<k){\\n                    res=mid;\\n                    start=mid+1;\\n                }\\n                \\n                else{\\n                    end=mid-1;\\n                }\\n            }\\n            \\n            i=res+1;\\n            cnt++;\\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112161,
                "title": "c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        if(nums.size()==1)\\n            return 1;\\n        sort(nums.begin(),nums.end());\\n        int ans=1;\\n        int i=1;\\n        int mn=nums[0];\\n        while(i<nums.size())\\n        {\\n            if(abs(mn-nums[i])>k)\\n            {\\n                ans++;\\n                mn=nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        if(nums.size()==1)\\n            return 1;\\n        sort(nums.begin(),nums.end());\\n        int ans=1;\\n        int i=1;\\n        int mn=nums[0];\\n        while(i<nums.size())\\n        {\\n            if(abs(mn-nums[i])>k)\\n            {\\n                ans++;\\n                mn=nums[i];\\n            }\\n            i++;\\n        }\\n        \\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112157,
                "title": "this-was-good-to-be-the-2nd-problem-in-contest-interesting-solution",
                "content": "int partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int count=1,start=0,end;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]-nums[start]>k)\\n            {\\n                end=i;\\n                start=i+1;\\n                count++;\\n            }\\n                \\n        }\\n        return count;\\n        \\n    }",
                "solutionTags": [],
                "code": "int partitionArray(vector<int>& nums, int k) {\\n        \\n        sort(nums.begin(),nums.end());\\n        int count=1,start=0,end;\\n        \\n        for(int i=0;i<nums.size()-1;i++)\\n        {\\n            if(nums[i+1]-nums[start]>k)\\n            {\\n                end=i;\\n                start=i+1;\\n                count++;\\n            }\\n                \\n        }\\n        return count;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2112145,
                "title": "c-with-logic",
                "content": "```\\n// 1- first sort the array \\n// 2- traverse the array and take the mininum so far and if the difference become greater than k increment the count and update the minimum as nums[i].\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=1;\\n        sort(nums.begin(),nums.end());\\n        int mn=nums[0],mx=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n           if(nums[i]-mn>k)\\n           {\\n               mn=nums[i];\\n               cnt++;\\n           }\\n            else\\n                mn=min(mn,nums[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\n// 1- first sort the array \\n// 2- traverse the array and take the mininum so far and if the difference become greater than k increment the count and update the minimum as nums[i].\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n=nums.size();\\n        int cnt=1;\\n        sort(nums.begin(),nums.end());\\n        int mn=nums[0],mx=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n           if(nums[i]-mn>k)\\n           {\\n               mn=nums[i];\\n               cnt++;\\n           }\\n            else\\n                mn=min(mn,nums[i]);\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112055,
                "title": "c-easiest-solution-upper-bound-concept",
                "content": "class Solution {\\npublic:\\n    \\n\\tint partitionArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int c = 0;\\n        for(int i=0;i<n;i++){\\n            int ind = upper_bound(nums.begin(),nums.end(),nums[i]+k)-nums.begin();\\n            c++;\\n            i = ind-1;\\n        }\\n        return c;\\n    }\\n};\\n// plz Upvote if you like !!!",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    \\n\\tint partitionArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int c = 0;\\n        for(int i=0;i<n;i++){\\n            int ind = upper_bound(nums.begin(),nums.end(),nums[i]+k)-nums.begin();\\n            c++;\\n            i = ind-1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2112039,
                "title": "easy-solution",
                "content": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end(),greater<int>());//sort the array dec order\\n        int c=0;int s=nums[0];\\n        for(int i=1;i<nums.size();++i){\\n            if(s-nums[i]>k){\\n                s=nums[i];\\n                c++;\\n            }\\n        }\\n        c++;\\n        return c;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end(),greater<int>());//sort the array dec order\\n        int c=0;int s=nums[0];\\n        for(int i=1;i<nums.size();++i){\\n            if(s-nums[i]>k){\\n                s=nums[i];\\n                c++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2112024,
                "title": "sort-and-twopointer-approach-to-keep-track-of-subsequence-size",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i = 0;\\n        int j = 1;\\n        \\n        int count = 1;\\n        \\n        while(j < nums.length)\\n        {\\n            if(nums[j] - nums[i] > k)\\n            {\\n                count++;\\n                i = j;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        \\n        int i = 0;\\n        int j = 1;\\n        \\n        int count = 1;\\n        \\n        while(j < nums.length)\\n        {\\n            if(nums[j] - nums[i] > k)\\n            {\\n                count++;\\n                i = j;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2112023,
                "title": "what-is-the-time-complexity-requirment-o-nlog-n",
                "content": "```\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ct = 0;\\n        for(int i = 0;i < n;){\\n            \\n            int j = i;\\n            while(i < n && nums[i] - nums[j] <= k)i++;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ct = 0;\\n        for(int i = 0;i < n;){\\n            \\n            int j = i;\\n            while(i < n && nums[i] - nums[j] <= k)i++;\\n            ct++;\\n        }\\n        return ct;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111999,
                "title": "java-sort",
                "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        int current=nums[0],c=1;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>current+k)\\n            {\\n                c++;\\n                current =nums[i];\\n            }\\n        }\\n        \\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        \\n        Arrays.sort(nums);\\n        int current=nums[0],c=1;\\n        for(int i=1;i<nums.length;i++)\\n        {\\n            if(nums[i]>current+k)\\n            {\\n                c++;\\n                current =nums[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2111985,
                "title": "javascript-binary-search",
                "content": "```js\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nconst partitionArray = function (nums, k) {\\n  nums.sort((a, b) => a - b)\\n  let result = 0\\n  if (nums[nums.length - 1] - nums[0] <= k) {\\n    return result + 1\\n  }\\n  // console.log(nums)\\n  const find = (start = 0) => {\\n    let left = start\\n    let right = nums.length - 1\\n    let next = -1\\n    while (left <= right) {\\n      const middle = Math.floor((left + right) / 2)\\n\\n      if (nums[middle] - nums[start] > k) {\\n        next = middle\\n        right = middle - 1\\n      } else {\\n        left = middle + 1\\n      }\\n    }\\n    if (next !== -1) {\\n      result += 1\\n      find(next)\\n    }\\n  }\\n  find(0)\\n  return result + 1\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @return {number}\\n */\\nconst partitionArray = function (nums, k) {\\n  nums.sort((a, b) => a - b)\\n  let result = 0\\n  if (nums[nums.length - 1] - nums[0] <= k) {\\n    return result + 1\\n  }\\n  // console.log(nums)\\n  const find = (start = 0) => {\\n    let left = start\\n    let right = nums.length - 1\\n    let next = -1\\n    while (left <= right) {\\n      const middle = Math.floor((left + right) / 2)\\n\\n      if (nums[middle] - nums[start] > k) {\\n        next = middle\\n        right = middle - 1\\n      } else {\\n        left = middle + 1\\n      }\\n    }\\n    if (next !== -1) {\\n      result += 1\\n      find(next)\\n    }\\n  }\\n  find(0)\\n  return result + 1\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2111905,
                "title": "java-sorting",
                "content": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int n = nums.length;\\n        int i=1;\\n        int min=nums[0];\\n        int count=1;\\n        while(i<n){\\n            if(nums[i]-min>k){\\n                min=nums[i];\\n                count++;\\n            }\\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        \\n        int n = nums.length;\\n        int i=1;\\n        int min=nums[0];\\n        int count=1;\\n        while(i<n){\\n            if(nums[i]-min>k){\\n                min=nums[i];\\n                count++;\\n            }\\n            i++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2111892,
                "title": "c-sort-and-count",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\t\\tsort(begin(nums),end(nums),greater<int>());\\n\\t\\t\\tint res = 1,prev = nums[0];\\n\\t\\t\\tfor(int i=1;i<size(nums);i++){\\n\\t\\t\\t\\tif(prev-nums[i]>k){\\n\\t\\t\\t\\t\\tprev = nums[i];\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint partitionArray(vector<int>& nums, int k) {\\n\\t\\t\\tsort(begin(nums),end(nums),greater<int>());\\n\\t\\t\\tint res = 1,prev = nums[0];\\n\\t\\t\\tfor(int i=1;i<size(nums);i++){\\n\\t\\t\\t\\tif(prev-nums[i]>k){\\n\\t\\t\\t\\t\\tprev = nums[i];\\n\\t\\t\\t\\t\\tres++;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 4091237,
                "title": "optimal-partitioning-minimize-subarray-differences",
                "content": "# Intuition\\nThe problem requires us to partition an array into subarrays such that the difference between consecutive elements in each subarray is less than or equal to a given value \\'k\\'. In other words, we need to find the minimum number of partitions required to satisfy this condition. To do this efficiently, we can sort the array and identify points where a new partition should begin.\\n\\n# Approach\\n1. Sort the input array \\'nums\\' in ascending order. Sorting is essential as it helps identify the points where a new partition is needed.\\n\\n2. Initialize \\'answer\\' to 1 since, at a minimum, we\\'ll have one partition.\\n\\n3. Initialize \\'mini\\' to the first element of the sorted array. This variable keeps track of the minimum value within the current partition.\\n\\n4. Loop through each element in the sorted array:\\n   - Check if the difference between the current element and \\'mini\\' is greater than \\'k\\'. If it is, this means we need to start a new partition.\\n   - Update \\'mini\\' with the current element\\'s value to start a new partition.\\n   - Increment \\'answer\\' to keep track of the number of partitions.\\n\\n5. Return the \\'answer,\\' which represents the minimum number of partitions required to satisfy the given condition.\\n\\n# Complexity\\n- Time complexity:\\n    - The most time-consuming operation is sorting the \\'nums\\' array, which takes O(NlogN) time, where N is the number of elements in \\'nums.\\'\\n    - The subsequent loop through \\'nums\\' takes O(N) time since we examine each element once.\\n    Therefore, the overall time complexity is O(NlogN).\\n\\n- Space complexity:\\n    - The algorithm uses a constant amount of extra space for variables \\'answer\\' and \\'mini.\\'\\n    - Thus, the space complexity is O(1), indicating that the space used by the algorithm is independent of the input size.\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // Function to partition an array into subarrays where the difference\\n    // between consecutive elements is less than or equal to \\'k\\'.\\n    int partitionArray(vector<int>& nums, int k) {\\n        // Sort the input \\'nums\\' array in ascending order.\\n        sort(nums.begin(), nums.end());\\n\\n        // Initialize \\'answer\\' to 1 since we\\'ll have at least one partition.\\n        int answer = 1;\\n\\n        // Initialize \\'mini\\' to the first element of the sorted array.\\n        int mini = nums[0];\\n\\n        // Loop through each element in the sorted array.\\n        for (int i = 0; i < nums.size(); i++) {\\n            // If the difference between the current element and \\'mini\\' is greater than \\'k\\',\\n            // it means we need to start a new partition, so we update \\'mini\\' and increment \\'answer\\'.\\n            if (nums[i] - mini > k) {\\n                mini = nums[i];\\n                ++answer;\\n            }\\n        }\\n\\n        // Return the total number of partitions.\\n        return answer;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to partition an array into subarrays where the difference\\n    // between consecutive elements is less than or equal to \\'k\\'.\\n    int partitionArray(vector<int>& nums, int k) {\\n        // Sort the input \\'nums\\' array in ascending order.\\n        sort(nums.begin(), nums.end());\\n\\n        // Initialize \\'answer\\' to 1 since we\\'ll have at least one partition.\\n        int answer = 1;\\n\\n        // Initialize \\'mini\\' to the first element of the sorted array.\\n        int mini = nums[0];\\n\\n        // Loop through each element in the sorted array.\\n        for (int i = 0; i < nums.size(); i++) {\\n            // If the difference between the current element and \\'mini\\' is greater than \\'k\\',\\n            // it means we need to start a new partition, so we update \\'mini\\' and increment \\'answer\\'.\\n            if (nums[i] - mini > k) {\\n                mini = nums[i];\\n                ++answer;\\n            }\\n        }\\n\\n        // Return the total number of partitions.\\n        return answer;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070186,
                "title": "greedy",
                "content": "Using Greedy technique\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n# Code\\n```\\nclass Solution {\\n    fun partitionArray(nums: IntArray, k: Int): Int {\\n        nums.sort()\\n        var result = 1\\n        var x = nums[0]\\n\\n        for(i in 1 until nums.size){\\n            if(nums[i] - x > k){\\n                x = nums[i]\\n                result++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun partitionArray(nums: IntArray, k: Int): Int {\\n        nums.sort()\\n        var result = 1\\n        var x = nums[0]\\n\\n        for(i in 1 until nums.size){\\n            if(nums[i] - x > k){\\n                x = nums[i]\\n                result++\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045109,
                "title": "c-simplest-easiest-optimal-solution-using-sorting",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n\\n      sort(nums.begin(), nums.end());\\n\\n      int Min = nums[0];\\n\\n      int ans = 1;\\n\\n      for(int i=1; i<nums.size(); i++) {\\n        if(nums[i] - Min > k) {\\n          Min = nums[i];\\n          ans++;\\n        }\\n      }\\n\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n\\n      sort(nums.begin(), nums.end());\\n\\n      int Min = nums[0];\\n\\n      int ans = 1;\\n\\n      for(int i=1; i<nums.size(); i++) {\\n        if(nums[i] - Min > k) {\\n          Min = nums[i];\\n          ans++;\\n        }\\n      }\\n\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045086,
                "title": "c-simplest-solution-using-sorting-clean-and-concise-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n\\n      sort(nums.begin(), nums.end());\\n\\n      int Min = nums[0];\\n\\n      int ans = 1;\\n\\n      for(int i=1; i<nums.size(); i++) {\\n        if(nums[i] - Min > k) {\\n          Min = nums[i];\\n          ans++;\\n        }\\n      }\\n\\n      return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n\\n      sort(nums.begin(), nums.end());\\n\\n      int Min = nums[0];\\n\\n      int ans = 1;\\n\\n      for(int i=1; i<nums.size(); i++) {\\n        if(nums[i] - Min > k) {\\n          Min = nums[i];\\n          ans++;\\n        }\\n      }\\n\\n      return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4038952,
                "title": "easy-explanation-with-comments-and-approach-binary-search-optimised-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n We have to find minimun number of partition ,so we have to  \\n    include maximum valid element in our partition and we have \\n    to just focus on getting the minimum and maximum element in \\n    the partition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n * log(n) )\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n/*\\n\\n    We have to find minimun number of partition ,so we have to  \\n    include maximum valid element in our partition and we have \\n    to just focus on getting the minimum and maximum element in \\n    the partition\\n\\n*/\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int i=0;\\n        int cnt=0;\\n        //So that duplicates element can come together and we can easily include them in our partition\\n        sort(nums.begin(),nums.end());\\n\\n        while(i<n){\\n            \\n            //Since we have sorted the array we just need to find the greatest valid element in the array and we will get our partition\\n            int target=k+nums[i];\\n\\n            //Upper bound to get the last index of target(if array have duplicates element)\\n            int idx=upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n\\n            //If target is there in array we have got out partition so our new possible partition can start from next index\\n            if(idx<n && nums[idx]==target){\\n                idx++;\\n            }\\n\\n            //If target not found then upper bound will automaically give us index of next element so we dont need to do idx++\\n            i=idx;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n/*\\n\\n    We have to find minimun number of partition ,so we have to  \\n    include maximum valid element in our partition and we have \\n    to just focus on getting the minimum and maximum element in \\n    the partition\\n\\n*/\\n    int partitionArray(vector<int>& nums, int k) {\\n        \\n        int n=nums.size();\\n        int i=0;\\n        int cnt=0;\\n        //So that duplicates element can come together and we can easily include them in our partition\\n        sort(nums.begin(),nums.end());\\n\\n        while(i<n){\\n            \\n            //Since we have sorted the array we just need to find the greatest valid element in the array and we will get our partition\\n            int target=k+nums[i];\\n\\n            //Upper bound to get the last index of target(if array have duplicates element)\\n            int idx=upper_bound(nums.begin(),nums.end(),target)-nums.begin();\\n\\n            //If target is there in array we have got out partition so our new possible partition can start from next index\\n            if(idx<n && nums[idx]==target){\\n                idx++;\\n            }\\n\\n            //If target not found then upper bound will automaically give us index of next element so we dont need to do idx++\\n            i=idx;\\n            cnt++;\\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4033734,
                "title": "java-30ms-beats-96-98-sort-nums-then-use-greedy-strategy",
                "content": "Importantly, we don\\'t keep track of which numbers go in each subsequence, since we don\\'t care. We just need how many subsequences there will be. This is an analysis, not a simulation.\\n\\n\\n# Code\\n```\\n// 30ms Beats 96.98%\\n\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n\\n        // strategy: sort array, then use a greedy approach to counting subsequences\\n\\n        Arrays.sort(nums);\\n        int numSS = 1;  // SS == subsequences; what we\\'ll return\\n\\n        int leastNumInCurSS = nums[0];\\n        for (int n : nums) {\\n            if (n - leastNumInCurSS <= k) {\\n                // add `n` to current SS\\n            } else {\\n                // close out current SS and start a new SS\\n                ++numSS;\\n                leastNumInCurSS = n;\\n            }\\n        }\\n\\n        if (nums[nums.length - 1] - leastNumInCurSS > k) {  // last number needs its own subsequence\\n            return 1 + numSS;\\n        } else {  // last number belongs in the last subsequence already counted\\n            return numSS;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// 30ms Beats 96.98%\\n\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n\\n        // strategy: sort array, then use a greedy approach to counting subsequences\\n\\n        Arrays.sort(nums);\\n        int numSS = 1;  // SS == subsequences; what we\\'ll return\\n\\n        int leastNumInCurSS = nums[0];\\n        for (int n : nums) {\\n            if (n - leastNumInCurSS <= k) {\\n                // add `n` to current SS\\n            } else {\\n                // close out current SS and start a new SS\\n                ++numSS;\\n                leastNumInCurSS = n;\\n            }\\n        }\\n\\n        if (nums[nums.length - 1] - leastNumInCurSS > k) {  // last number needs its own subsequence\\n            return 1 + numSS;\\n        } else {  // last number belongs in the last subsequence already counted\\n            return numSS;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019495,
                "title": "easy-python-solution-using-greedy-beats-92-18-in-runtime-and-memory",
                "content": "# Approach\\nSort the nums and define `counter`, `minVal`. Greedily check if `currentVal - minVal <= k`. Else increment the `counter` and update `minVal`.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```py\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        counter, minVal = 0, -1\\n        for num in nums : \\n            if minVal == -1 : \\n                counter, minVal = counter + 1, num\\n            elif num - minVal > k : \\n                counter, minVal = counter + 1, num\\n                    \\n        return counter \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```py\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        counter, minVal = 0, -1\\n        for num in nums : \\n            if minVal == -1 : \\n                counter, minVal = counter + 1, num\\n            elif num - minVal > k : \\n                counter, minVal = counter + 1, num\\n                    \\n        return counter \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018627,
                "title": "easy-solution-using-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int res=1,mn=nums[0],mx=nums[0];\\n        for(int a: nums){\\n            mn=min(mn,a);\\n            mx=max(mx,a);\\n            if(mx-mn > k){\\n                res++;mn=mx=a;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int res=1,mn=nums[0],mx=nums[0];\\n        for(int a: nums){\\n            mn=min(mn,a);\\n            mx=max(mx,a);\\n            if(mx-mn > k){\\n                res++;mn=mx=a;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018601,
                "title": "sliding-window-on-subsequence",
                "content": "\\n```\\nclass Solution\\n{\\n    public:\\n        int partitionArray(vector<int> &nums, int k)\\n        {\\n            int n = nums.size();\\n            sort(nums.begin(), nums.end());\\n            int head = 1, tail = 0;\\n            int diff, cnt = 1;\\n            while (head < n)\\n            {\\n                diff = nums[head] - nums[tail];\\n                if (diff > k)\\n                {\\n                    cnt++;\\n                    tail = head;\\n                }\\n                head++;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int partitionArray(vector<int> &nums, int k)\\n        {\\n            int n = nums.size();\\n            sort(nums.begin(), nums.end());\\n            int head = 1, tail = 0;\\n            int diff, cnt = 1;\\n            while (head < n)\\n            {\\n                diff = nums[head] - nums[tail];\\n                if (diff > k)\\n                {\\n                    cnt++;\\n                    tail = head;\\n                }\\n                head++;\\n            }\\n            return cnt;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3999023,
                "title": "simple-intuitive-python-solution-with-detailed-explanation",
                "content": "# Intuition\\nWhen I first read the problem and noticed the word subsequence, I immediately though no sorting then. But as I start penning down ideas, it occured to me we only need to track min and max of any partition. Once you sort the input answer comes to you.\\n\\nLearning - dont rule out sorting just because problem statement mentions subsequence\\n\\n# Approach\\nSort the array.\\n\\nFor example, [3, 6, 1, 2, 5] becomes [1, 2, 5, 3, 6]\\n\\nNow we have to be greedy as we need minimum number of partitions. Then I thought of sliding window technique - \\n\\nAs we start our first window will be [1] - this will always fullfil the window as minimum value of k is 0 from problem statement contraints\\n\\nIncrease the window size till window is valid \\n\\npartition[min] - partiion[max] <= k \\ntransalates into \\nwindow[left] - window[right] <= k (as elements are sorted)\\n\\nbreak when the condition is violated and create a new window (left set to right)\\n\\n# Complexity\\n- Time complexity:\\nO(nlgn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        # sliding window but first we sort\\n\\n        nums.sort()\\n\\n        left = 0\\n        min_partition = 0\\n\\n        for right in range(len(nums)):\\n            # new partition starts as current window becomes invalid\\n            if (nums[right] - nums[left]) > k:\\n                left = right\\n                min_partition += 1\\n\\n        # we will have to add 1 as we need to count the last window\\n        return min_partition + 1\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        # sliding window but first we sort\\n\\n        nums.sort()\\n\\n        left = 0\\n        min_partition = 0\\n\\n        for right in range(len(nums)):\\n            # new partition starts as current window becomes invalid\\n            if (nums[right] - nums[left]) > k:\\n                left = right\\n                min_partition += 1\\n\\n        # we will have to add 1 as we need to count the last window\\n        return min_partition + 1\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3997491,
                "title": "99-5-optimal-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>&n , int k){\\n        sort(n.begin(),n.end());\\n        int c=0 , mn=n[0] , i=0;\\n        while(i<n.size()){\\n            if(n[i]-mn<=k){\\n                i++;\\n            }\\n            else{\\n                c++;\\n                mn=n[i];\\n            }\\n        }\\n        return c+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>&n , int k){\\n        sort(n.begin(),n.end());\\n        int c=0 , mn=n[0] , i=0;\\n        while(i<n.size()){\\n            if(n[i]-mn<=k){\\n                i++;\\n            }\\n            else{\\n                c++;\\n                mn=n[i];\\n            }\\n        }\\n        return c+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989317,
                "title": "easy-sorting-solution-for-beginners",
                "content": "# Intuition\\nKeeping track of diffrences and the lowest number is the ley to this solution.\\n\\n# Approach\\nI sorted the vector in ascending order and then kept track of the difference and when it exceeded teh difference it was time to update counter and the value of the lowest of the next partition.\\n\\nKindly upvote the solution if you found it easy, precise and concise!\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int c=1;\\n        int low=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int diff=nums[i]-low;\\n            if(diff>k)\\n            {\\n                c++;\\n                low=nums[i];\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int c=1;\\n        int low=nums[0];\\n        for(int i=1;i<n;i++)\\n        {\\n            int diff=nums[i]-low;\\n            if(diff>k)\\n            {\\n                c++;\\n                low=nums[i];\\n            }\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3987953,
                "title": "java-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem says hey u can pick any element in  `nums` and u  need to make some groups where difference between minimum value and maximum value of any  group should be less than or equal to `k`.Now tell me how many groups u can form in an efiiecient manner .\\n\\nWhat i learned ? \\n\\nThe trick behind this problem is noticing that order of elements i n subsequence will change if we sort the array but the minimum and maximum part of the subsequence can and will  remain same irrespective of the order of element in an subsequence . \\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        // you can pick up any element u want !\\n        // easier way is sort the element and choose greedily\\n        Arrays.sort(nums);\\n        int res=  0 ,  min  = nums[0]  , max =  nums[0];\\n        for( var el :nums){\\n            min = Math.min(el , min);\\n            max = Math.max(el  ,max);\\n            if( max - min > k){\\n                res++;\\n                min = el ; max = el; \\n            }\\n        }\\n        return res+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        // you can pick up any element u want !\\n        // easier way is sort the element and choose greedily\\n        Arrays.sort(nums);\\n        int res=  0 ,  min  = nums[0]  , max =  nums[0];\\n        for( var el :nums){\\n            min = Math.min(el , min);\\n            max = Math.max(el  ,max);\\n            if( max - min > k){\\n                res++;\\n                min = el ; max = el; \\n            }\\n        }\\n        return res+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984165,
                "title": "simple-and-easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        if(nums.length == 1) return 1;\\n        int start = nums[0], ans =1;;\\n        for(int i=1;i<nums.length;i++){\\n            if((nums[i] - start) > k){\\n                start = nums[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        if(nums.length == 1) return 1;\\n        int start = nums[0], ans =1;;\\n        for(int i=1;i<nums.length;i++){\\n            if((nums[i] - start) > k){\\n                start = nums[i];\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980003,
                "title": "sorting-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n\\n        int mini = nums[0];\\n        int i = 1;\\n        int count = 1;\\n        while (i < nums.size()) {\\n            if (nums[i] - mini > k) {\\n                count++;\\n                mini = nums[i];\\n            }\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n\\n        int mini = nums[0];\\n        int i = 1;\\n        int count = 1;\\n        while (i < nums.size()) {\\n            if (nums[i] - mini > k) {\\n                count++;\\n                mini = nums[i];\\n            }\\n            i++;\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3965722,
                "title": "java-simple-sorting-pointer-manipulation",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int start = 0, count = 1;\\n        for(int i = start+1;i<nums.length;i++){\\n            if(nums[i] - nums[start] > k){\\n                count++;\\n                start = i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int start = 0, count = 1;\\n        for(int i = start+1;i<nums.length;i++){\\n            if(nums[i] - nums[start] > k){\\n                count++;\\n                start = i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961524,
                "title": "simple-sol",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int mini=INT32_MIN,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]-k>mini)\\n            {\\n                mini=nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int mini=INT32_MIN,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]-k>mini)\\n            {\\n                mini=nums[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3943671,
                "title": "using-pointers-only",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        count=0\\n        nums.sort()\\n        print(nums)\\n        i,j=0,1\\n        if len(nums)==1:\\n            return 1\\n        while(i<len(nums)):\\n            if j==len(nums)-1 and nums[j]-nums[i]<=k:\\n                count=count+1\\n                return count\\n            elif j==len(nums)-1 and nums[j]-nums[i]>k:\\n                count=count+2\\n                return count\\n            elif nums[j]-nums[i]<=k:\\n                j=j+1\\n            else:\\n                i=j\\n                j=j+1\\n                count=count+1\\n            print(count,i,j)\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        count=0\\n        nums.sort()\\n        print(nums)\\n        i,j=0,1\\n        if len(nums)==1:\\n            return 1\\n        while(i<len(nums)):\\n            if j==len(nums)-1 and nums[j]-nums[i]<=k:\\n                count=count+1\\n                return count\\n            elif j==len(nums)-1 and nums[j]-nums[i]>k:\\n                count=count+2\\n                return count\\n            elif nums[j]-nums[i]<=k:\\n                j=j+1\\n            else:\\n                i=j\\n                j=j+1\\n                count=count+1\\n            print(count,i,j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3916430,
                "title": "without-greedy-easiest-solution-using-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Stack<Integer> st=new Stack<>();\\n        int count=1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(st.size()==0){\\n                st.push(nums[i]);\\n\\n            }\\n            else if((int)Math.abs(st.peek()-nums[i])>k){\\n                st.clear();\\n                st.push(nums[i]);\\n                count=count+1;\\n\\n            }\\n            \\n        }\\n        int resul=count;\\n        return resul;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Stack<Integer> st=new Stack<>();\\n        int count=1;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length;i++){\\n            if(st.size()==0){\\n                st.push(nums[i]);\\n\\n            }\\n            else if((int)Math.abs(st.peek()-nums[i])>k){\\n                st.clear();\\n                st.push(nums[i]);\\n                count=count+1;\\n\\n            }\\n            \\n        }\\n        int resul=count;\\n        return resul;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3903249,
                "title": "c-easy-solution-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTwo pointer technique\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int start=0;\\n        int end=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int min_val=INT_MAX;\\n        int max_val=INT_MIN;\\n        int count=1;\\n        while(end<n){\\n            min_val=min(min_val,nums[end]);\\n            max_val=max(max_val,nums[end]);\\n            if(max_val-min_val<=k){\\n                end++;\\n            }\\n            else{\\n                count++;\\n                start=end;\\n                min_val=INT_MAX;\\n                max_val=INT_MIN;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int start=0;\\n        int end=0;\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int min_val=INT_MAX;\\n        int max_val=INT_MIN;\\n        int count=1;\\n        while(end<n){\\n            min_val=min(min_val,nums[end]);\\n            max_val=max(max_val,nums[end]);\\n            if(max_val-min_val<=k){\\n                end++;\\n            }\\n            else{\\n                count++;\\n                start=end;\\n                min_val=INT_MAX;\\n                max_val=INT_MIN;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3892777,
                "title": "golang-133ms-100-8-3m-73-simple-2-solutions-comb",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nChoose solution with len(nums)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstd pdq_sort -> count sort\\n# Complexity\\n- Time complexity: O(nlogn) -> O(??)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) -> O(??)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc partitionArray(nums []int, k int) int {\\n    if len(nums) < 5000 {\\n        return sortResolution(nums, k)\\n    }\\n\\n    arr := make([]bool, 100001)\\n    for _, v := range nums {\\n        arr[v] = true\\n    }\\n\\n    var (\\n        result int\\n        pre  = -k - 1\\n    )\\n\\n    for i := 0; i < len(arr); i++ {\\n        if !arr[i] || i - pre <= k {\\n            continue\\n        }\\n\\n        pre = i\\n        result++\\n    }\\n    return result\\n}\\n\\nfunc sortResolution(nums []int, k int) int {\\n    sort.Ints(nums)\\n\\n    var (\\n        result = 1\\n        pre  = nums[0]\\n    )\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] - pre <= k {\\n            continue\\n        }\\n\\n        pre = nums[i]\\n        result++\\n    }\\n    return result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc partitionArray(nums []int, k int) int {\\n    if len(nums) < 5000 {\\n        return sortResolution(nums, k)\\n    }\\n\\n    arr := make([]bool, 100001)\\n    for _, v := range nums {\\n        arr[v] = true\\n    }\\n\\n    var (\\n        result int\\n        pre  = -k - 1\\n    )\\n\\n    for i := 0; i < len(arr); i++ {\\n        if !arr[i] || i - pre <= k {\\n            continue\\n        }\\n\\n        pre = i\\n        result++\\n    }\\n    return result\\n}\\n\\nfunc sortResolution(nums []int, k int) int {\\n    sort.Ints(nums)\\n\\n    var (\\n        result = 1\\n        pre  = nums[0]\\n    )\\n\\n    for i := 1; i < len(nums); i++ {\\n        if nums[i] - pre <= k {\\n            continue\\n        }\\n\\n        pre = nums[i]\\n        result++\\n    }\\n    return result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3879640,
                "title": "python-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 1\\n        curr = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] - curr > k:\\n                curr = nums[i]\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        ans = 1\\n        curr = nums[0]\\n        for i in range(1, len(nums)):\\n            if nums[i] - curr > k:\\n                curr = nums[i]\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856900,
                "title": "sort-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to divide the array into partitions such that the maximum difference between elements in each partition is at most k. Sorting the array helps ensure smaller differences between adjacent elements. Using a sliding window approach, maintain a window where the difference between the maximum and minimum elements is at most k. When this condition is violated, increment the output counter, indicating a new partition. Slide the window by updating the start and end pointers. Continue until the end of the array. The output counter will give the minimum number of partitions required.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the array to facilitate smaller differences.\\nInitialize a sliding window with start and end pointers.\\nExtend the window as long as the difference between nums[end] and nums[start] is within k.\\nIf the difference condition is violated, increment output and move start to end.\\nContinue sliding the window until the end of the array.\\nThe output counter represents the minimum number of partitions needed.\\n\\n# Complexity\\n- Time complexity: O(N*logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int output = 0;\\n        sort(nums.begin() , nums.end());\\n\\n        // sliding window\\n        int start = 0;\\n        int end = 0;\\n        while(end < nums.size()){\\n            // we can extend this window\\n            if(nums[end] - nums[start] <= k){\\n                end++;\\n            }\\n            // we cannot extend this window as doing so will give us a subsequence with range greater than k\\n            else{\\n                output++;\\n                start = end;\\n            }\\n        }\\n        // don\\'t miss the last output\\n        output++;\\n\\n        return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int output = 0;\\n        sort(nums.begin() , nums.end());\\n\\n        // sliding window\\n        int start = 0;\\n        int end = 0;\\n        while(end < nums.size()){\\n            // we can extend this window\\n            if(nums[end] - nums[start] <= k){\\n                end++;\\n            }\\n            // we cannot extend this window as doing so will give us a subsequence with range greater than k\\n            else{\\n                output++;\\n                start = end;\\n            }\\n        }\\n        // don\\'t miss the last output\\n        output++;\\n\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3844406,
                "title": "c-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int PartitionArray(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int partition = 1;\\n        \\n        for (int end = 1, start = 0; end < nums.Length; end++)\\n        {\\n            if (nums[end] - nums[start] > k)\\n            {\\n                start = end;\\n                partition++;\\n            }\\n        }\\n\\n        return partition;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int PartitionArray(int[] nums, int k) {\\n        Array.Sort(nums);\\n        int partition = 1;\\n        \\n        for (int end = 1, start = 0; end < nums.Length; end++)\\n        {\\n            if (nums[end] - nums[start] > k)\\n            {\\n                start = end;\\n                partition++;\\n            }\\n        }\\n\\n        return partition;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837849,
                "title": "c-sorting-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0;\\n        int ans=0;\\n        while(j<nums.size()){\\n            if(nums[j]-nums[i]<=k){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i=0,j=0;\\n        int ans=0;\\n        while(j<nums.size()){\\n            if(nums[j]-nums[i]<=k){\\n                j++;\\n            }\\n            else{\\n                ans++;\\n                i=j;\\n            }\\n        }\\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3834683,
                "title": "python3-very-easy-solution",
                "content": "# Intuition\\n![please upvote.jpg](https://assets.leetcode.com/users/images/3264e373-3e9f-448e-923c-7850de0c6a94_1690650158.6361108.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n log n)\\n\\n- Space complexity:\\n    o(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        nums.sort()\\n        prev = float(\"-inf\")\\n        for i in nums:\\n            if i - prev > k:\\n                ans+=1\\n                prev = i\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        ans = 0\\n        nums.sort()\\n        prev = float(\"-inf\")\\n        for i in nums:\\n            if i - prev > k:\\n                ans+=1\\n                prev = i\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3830041,
                "title": "greedy-beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int count = 0;\\n        int n = nums.size();\\n        int i=0;\\n        while(i<n){\\n            int curr = nums[i];\\n            while(i<n && nums[i] - curr <= k){\\n                i++;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int count = 0;\\n        int n = nums.size();\\n        int i=0;\\n        while(i<n){\\n            int curr = nums[i];\\n            while(i<n && nums[i] - curr <= k){\\n                i++;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828633,
                "title": "easy-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n      int i=0;\\n      int j=0;\\n      int ans=0;\\n      while(i<n&&j<n){\\n           while(i<n&&nums[i]-nums[j]<=k){\\n             i++;\\n           }\\n           ans++;\\n           j=i;\\n      }    \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n      int i=0;\\n      int j=0;\\n      int ans=0;\\n      while(i<n&&j<n){\\n           while(i<n&&nums[i]-nums[j]<=k){\\n             i++;\\n           }\\n           ans++;\\n           j=i;\\n      }    \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3810743,
                "title": "easy-sorting-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst sort the elements and find the max number for which the diff between them is not greater than the k.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nI have used sorting and then upper bound function to find the greater element for element.\\nlike int the case 3,6,1,2,5 the sorted one is 1,2,3,5,6 and k is 2 so the upeer bound of a[0](1)+k(2) will be 5 ane then we will decrease the pos by 1 for equal or less elements which is needed.\\nand then we will increase the cnt and set the i=pos.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& a, int k) {\\n        int n=a.size();\\n        int cnt=0;\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int pos=upper_bound(a.begin(),a.end(),a[i]+k)-a.begin();\\n            pos--;\\n            i=pos;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& a, int k) {\\n        int n=a.size();\\n        int cnt=0;\\n        sort(a.begin(),a.end());\\n        for(int i=0;i<n;i++)\\n        {\\n            int pos=upper_bound(a.begin(),a.end(),a[i]+k)-a.begin();\\n            pos--;\\n            i=pos;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807908,
                "title": "c-two-pointer-approch-on-sorted-array",
                "content": "# Approach\\nTo solve this problem, we can follow the following steps:\\n1. Sort the input array `nums` in ascending order.\\n2. Initialize two pointers, `i` and `j`, both pointing to the start of the sorted array.\\n3. Initialize a variable `result` to keep track of the minimum number of subsequences needed. Set it to 1 initially.\\n4. Traverse the sorted array with the `j` pointer while checking the difference between `nums[j]` and `nums[i]`. If the difference exceeds `k`, we increment the `result` variable by 1 and move the `i` pointer to `j`. Otherwise, we increment the `j` pointer to keep checking the next elements.\\n5. Continue this process until the `j` pointer reaches the end of the array.\\n6. After the loop ends, return the `result` variable, which represents the minimum number of subsequences needed to satisfy the conditions.\\n\\n# Complexity\\n- Time complexity: The sorting step takes O(n log n), and the while loop runs in O(n) time. Thus, the overall time complexity is O(n log n).\\n- Space complexity: The sorting step takes O(n) additional space. Hence, the space complexity is O(n).\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int result = 1, i = 0, j = 0;\\n\\n        while (j < nums.size()) {\\n            if (nums[j] - nums[i] > k) {\\n                result++;\\n                i = j;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```\\n\\n# Example Walkthroughs\\n## Example 1\\nGiven input: `nums = [3, 6, 1, 2, 5]`, `k = 2`.\\n- After sorting: `[1, 2, 3, 5, 6]`\\n- Initialize `i = 0`, `j = 0`, and `result = 1`.\\n    - Check `nums[j] - nums[i] = 1 - 1 = 0 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 2 - 1 = 1 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 3 - 1 = 2 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 5 - 1 = 4 > k`, increment `result` and set `i = j = 3`.\\n    - Check `nums[j] - nums[i] = 6 - 5 = 1 <= k`, increment `j`.\\n    - `j` reaches the end of the array, terminate the loop.\\n- Return `result = 2`.\\n\\n## Example 2\\nGiven input: `nums = [1, 2, 3]`, `k = 1`.\\n- After sorting: `[1, 2, 3]`\\n- Initialize `i = 0`, `j = 0`, and `result = 1`.\\n    - Check `nums[j] - nums[i] = 1 - 1 = 0 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 2 - 1 = 1 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 3 - 1 = 2 > k`, increment `result` and set `i = j = 2`.\\n    - `j` reaches the end of the array, terminate the loop.\\n- Return `result = 2`.\\n\\n## Example 3\\nGiven input: `nums = [2, 2, 4, 5]`, `k = 0`.\\n- After sorting: `[2, 2, 4, 5]`\\n- Initialize `i = 0`, `j = 0`, and `result = 1`.\\n    - Check `nums[j] - nums[i] = 2 - 2 = 0 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 2 - 2 = 0 <= k`, increment `j`.\\n    - Check `nums[j] - nums[i] = 4 - 2 = 2 > k`, increment `result` and set `i = j = 2`.\\n    - Check `nums[j] - nums[i] = 5 - 4 = 1 <= k`, increment `j`.\\n    - `j` reaches the end of the array, terminate the loop.\\n- Return `result = 3`.",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(), nums.end());\\n        int result = 1, i = 0, j = 0;\\n\\n        while (j < nums.size()) {\\n            if (nums[j] - nums[i] > k) {\\n                result++;\\n                i = j;\\n            } else {\\n                j++;\\n            }\\n        }\\n\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3780830,
                "title": "c-greedy-solution-time-complexity-o-n-with-explanation",
                "content": "# Intuition\\nThe intuition is to put as many elements in a single group as long as the difference between the maximum and the minimum element in the group is at most `k`. After sorting the given vector, the minimum element is `nums[0]`. Iterate over the sorted vector and check the elements if they satisfy the property. If yes, just go to the next element. If no, then you need to form a new group and also update the minimum element of the new group.\\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int res = 1;\\n        int mn = nums[0];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - mn <= k)\\n                continue;\\n            mn = nums[i];\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\nPlease upvote if the solution is help to you :)",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int res = 1;\\n        int mn = nums[0];\\n        for(int i = 1; i < n; i++)\\n        {\\n            if(nums[i] - mn <= k)\\n                continue;\\n            mn = nums[i];\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777743,
                "title": "4-lines-simple-and-concise",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int c=0,mn=nums[0],mx;\\n         for(int i=0;i<nums.size();i++){\\n           if(nums[i]-mn>k){\\n               c++;\\n               mn=nums[i];\\n           }\\n         }\\n         return c+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int c=0,mn=nums[0],mx;\\n         for(int i=0;i<nums.size();i++){\\n           if(nums[i]-mn>k){\\n               c++;\\n               mn=nums[i];\\n           }\\n         }\\n         return c+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767305,
                "title": "qsort-and-check",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nqsort and check return\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlog(n))\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1\\n# Code\\n```\\nint comp (const  void * elem1, const void *elem2){\\n    int f = *((int*)elem1);\\n    int s = *((int*)elem2);\\n    if (f>s) return 1;\\n    if (f<s) return -1;\\n    return 0;\\n}\\nint partitionArray(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int ret=1;\\n    int j=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]-nums[j]>k){\\n            ret++;\\n            j=i;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint comp (const  void * elem1, const void *elem2){\\n    int f = *((int*)elem1);\\n    int s = *((int*)elem2);\\n    if (f>s) return 1;\\n    if (f<s) return -1;\\n    return 0;\\n}\\nint partitionArray(int* nums, int numsSize, int k){\\n    qsort(nums, numsSize, sizeof(int), comp);\\n    int ret=1;\\n    int j=0;\\n    for(int i=0;i<numsSize;i++){\\n        if(nums[i]-nums[j]>k){\\n            ret++;\\n            j=i;\\n        }\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3755758,
                "title": "beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int count=1;\\n        ios::sync_with_stdio(0);\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int f=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(k<(nums[i]-f))\\n            {\\n                count++;\\n                f=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        int count=1;\\n        ios::sync_with_stdio(0);\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int f=nums[0];\\n        for(int i=0;i<n;i++)\\n        {\\n            if(k<(nums[i]-f))\\n            {\\n                count++;\\n                f=nums[i];\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3744722,
                "title": "simple-cpp-solution-in-4statements",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int past=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            if(nums[i]-past>k){count++;past=nums[i];}\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int count=1;\\n        int past=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n            if(nums[i]-past>k){count++;past=nums[i];}\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716375,
                "title": "simple-code-using-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0,j = 0;\\n        int n = nums.size();\\n        int ans = 0;\\n        while(i<n){\\n            while(i<n and nums[i]-nums[j]<=k)i++;\\n            ans++;\\n            j = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0,j = 0;\\n        int n = nums.size();\\n        int ans = 0;\\n        while(i<n){\\n            while(i<n and nums[i]-nums[j]<=k)i++;\\n            ans++;\\n            j = i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710598,
                "title": "java-solution-simple-solution-easy",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        int count = 1;\\n\\n        for(int i = 1; i < nums.length; i++)\\n            if(nums[i] - min > k){\\n                count++;\\n                min = nums[i];\\n            }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n        int min = nums[0];\\n        int count = 1;\\n\\n        for(int i = 1; i < nums.length; i++)\\n            if(nums[i] - min > k){\\n                count++;\\n                min = nums[i];\\n            }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3685968,
                "title": "sort-python",
                "content": "# Intuition\\nsort it and check the diff\\n\\n# Approach\\nif diff >k, increase the counter\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)\\n\\n- Space complexity:\\n$$O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        # print(nums)\\n        c=0\\n        start= nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i]-start>k:\\n                c=c+1\\n                start= nums[i]\\n        return (c+1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def partitionArray(self, nums: List[int], k: int) -> int:\\n        nums.sort()\\n        # print(nums)\\n        c=0\\n        start= nums[0]\\n\\n        for i in range(1, len(nums)):\\n            if nums[i]-start>k:\\n                c=c+1\\n                start= nums[i]\\n        return (c+1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3661955,
                "title": "only-use-one-for-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort (nums.begin(), nums.end());   \\n        int i=0,ans=1;\\n        \\n        for(int j=1;j<nums.size();j++){\\n            if (nums[j] > nums[i]+k) {\\n                i=j;\\n                ans++;        \\n            }         \\n        } \\n        return ans; \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int partitionArray(vector<int>& nums, int k) {\\n        sort (nums.begin(), nums.end());   \\n        int i=0,ans=1;\\n        \\n        for(int j=1;j<nums.size();j++){\\n            if (nums[j] > nums[i]+k) {\\n                i=j;\\n                ans++;        \\n            }         \\n        } \\n        return ans; \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717549,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 1802881,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 2048444,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 1821080,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 1789326,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            },
            {
                "id": 1778894,
                "content": [
                    {
                        "username": "user3238Gj",
                        "content": "what a weird question , probably you would need to ask interviewer many clarifying questions"
                    },
                    {
                        "username": "mkprajapati1614",
                        "content": "`hint` Sorting then traversing "
                    },
                    {
                        "username": "swecpp",
                        "content": "I think two pointers technique can be added for this question"
                    },
                    {
                        "username": "vizzy205",
                        "content": "wow I am the only one who used deque ;-;"
                    },
                    {
                        "username": "jaiyadav",
                        "content": "Sort the array  "
                    },
                    {
                        "username": "shouvik32",
                        "content": "class Solution {\\n    public int partitionArray(int[] nums, int k) {\\n        Arrays.sort(nums);\\n\\t\\tint count=1;\\n\\t\\tint start=0;\\n\\t\\tfor(int i=1; i<nums.length; i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(nums[i]-nums[start]>k)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\tstart=i;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\treturn count;\\n    }\\n}"
                    },
                    {
                        "username": "Grishound",
                        "content": "Come on man read the first rule of Discussion."
                    }
                ]
            }
        ]
    }
]