[
    {
        "title": "Swap Nodes in Pairs",
        "question_content": "Given a&nbsp;linked list, swap every two adjacent nodes and return its head. You must solve the problem without&nbsp;modifying the values in the list's nodes (i.e., only nodes themselves may be changed.)\n&nbsp;\nExample 1:\n\nInput: head = [1,2,3,4]\nOutput: [2,1,4,3]\n\nExample 2:\n\nInput: head = []\nOutput: []\n\nExample 3:\n\nInput: head = [1]\nOutput: [1]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the&nbsp;list&nbsp;is in the range [0, 100].\n\t0 <= Node.val <= 100",
        "solutions": [
            {
                "id": 1775033,
                "title": "swapping-nodes-not-just-the-values-visual-explanation-well-explained-c",
                "content": "As mentioned in the question we have to **exchange the nodes itself (and not just their values)**, and this solution follows this constraint.\\n\\nI will be placing a `dummy node` before the head node so that the code we write can also be applicable to the head node also, and we don\\'t have to specifically write different conditions for the head node.\\n\\n#### Example:\\n***Given Linked List***\\n\\n![image](https://assets.leetcode.com/users/images/d4219c57-0fa8-4d02-8c75-e437d1613be0_1644993781.493073.jpeg)\\n\\n ***Final Linked List***\\n\\n![image](https://assets.leetcode.com/users/images/88cece9e-8fff-4f5f-807f-dcabecebe71e_1644993901.1494746.jpeg)\\n\\n\\nLet\\'s now understand the **approach**\\n\\n1. As mentioned earlier, we will place a `dummyNode` before the head node.\\n\\n![image](https://assets.leetcode.com/users/images/b06f77f0-507a-42ac-af35-04ebbd4a71b0_1644993113.5176115.jpeg)\\n\\n\\n2. Now, let the head be our `currNode`. That means the `node with value 1` is the currNode, and we have to swap it with the `node with value 2`. So for this, we will also have to keep track of the node previous to the currNode, let it be `prevNode`, as it\\'s next pointer value will have to change after we swap the currNode and the node next to currNode.\\n\\n![image](https://assets.leetcode.com/users/images/00a5d82c-ce1f-4d73-afb2-0ce20d23fb26_1644993239.638449.jpeg)\\n\\n3. Now the very first thing to do is change the `next pointer of prevNode to point to currNode->next`. Why?? Because in the answer we want the `node with value 2` after the dummyNode. Right? So we will have to connect `dummyNode` (prevNode) to the `node with value  2` (currNode->next). This means\\n```cpp\\nprevNode->next = currNode->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/5a4ce313-4f60-48f4-857d-ca141e48c103_1644993309.3371558.jpeg)\\n\\n\\n4. Now, in our finl answer `node with value 1` should be at the place of `node with value 2`. So the next pointer of `node with value 1` should point to whatever the `node with value 2` is pointing to originally. That means we will have to change `currNode->next` to the `next of next of prevNode`, as currently prevNode is dummyNode, prevNode->next is node with value 2 and prevNode->next->next = next of node with value 2. This means\\n```cpp\\ncurrNode->next = prevNode->next->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e531a190-a0cd-4117-ab66-4c5ed08047d9_1644993389.8530746.jpeg)\\n\\n\\n5. Now, as in the answer the `node with value 2` should point to `node with value 1`. That means\\n```cpp\\nprevNode->next->next = currNode\\n```\\n\\n![image](https://assets.leetcode.com/users/images/11fda637-3c1c-4f41-82a5-598f41540429_1644993447.1567922.jpeg)\\n\\n\\n6. After this iteration, nodes 1 and 2 will get swapped and our linked list will look like this.\\n\\n![image](https://assets.leetcode.com/users/images/eba94308-ed4a-4542-aed6-ef8f4eb1f807_1644993522.337313.jpeg)\\n\\n\\n7. Now for the next iteration, we have to swap `nodes with values 3 and 4`. For that the `prevNode` should point to `node with value 1` and the `currNode` should point to `node with value 3`. This means\\n```cpp\\nprevNode = currNode\\ncurrNode = currNode->next\\n```\\n\\n![image](https://assets.leetcode.com/users/images/e73873b6-a236-4171-ac89-52f0c5d63164_1645010559.588748.jpeg)\\n\\n\\n\\n\\n8. We should stop this procedure when either there is no nodes left to swap or there is only one node left which cannot be swapped with any node.\\n\\n9. At the end, as we can see that our head of the list has been misplaced in the procedure of swapping, so we can return `dummyNode->next` to return the swapped linked list.\\n\\n\\n#### Code\\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\\n\\t\\t\\n        ListNode* dummyNode = new ListNode();\\n        \\n        ListNode* prevNode=dummyNode;\\n        ListNode* currNode=head;\\n        \\n        while(currNode && currNode->next){\\n            prevNode->next = currNode->next;\\n            currNode->next = prevNode->next->next;\\n            prevNode->next->next = currNode;\\n            \\n            prevNode = currNode;\\n            currNode = currNode->next;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n\\n```\\n\\n#### Complexity:\\n***TC*** **= O(n)**\\n***SC*** **= O(1)**\\n\\n***Plz upvote if you liked the post***\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```cpp\\nprevNode->next = currNode->next\\n```\n```cpp\\ncurrNode->next = prevNode->next->next\\n```\n```cpp\\nprevNode->next->next = currNode\\n```\n```cpp\\nprevNode = currNode\\ncurrNode = currNode->next\\n```\n```cpp\\nListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head; //If there are less than 2 nodes in the given nodes, then no need to do anything just return the list as it is.\\n\\t\\t\\n        ListNode* dummyNode = new ListNode();\\n        \\n        ListNode* prevNode=dummyNode;\\n        ListNode* currNode=head;\\n        \\n        while(currNode && currNode->next){\\n            prevNode->next = currNode->next;\\n            currNode->next = prevNode->next->next;\\n            prevNode->next->next = currNode;\\n            \\n            prevNode = currNode;\\n            currNode = currNode->next;\\n        }\\n        \\n        return dummyNode->next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774708,
                "title": "c-visual-image-how-links-change-explained-every-step-commented-code",
                "content": "***Brief note about Question-***\\n* We have to *swap every two adjacent nodes and return its head*.\\n```\\nLet\\'s take an example not given in question -\\nSuppose our head pointer given to us as [1,9,2,8,3,7]\\n\\nSo, we have to swap every two adjcant nodes,\\nthe answer should be [9,1,8,2,7,3]\\n```\\n_______________\\n***Solution - I (using recursion, Accepted)-***\\n* The very basic thing that is given to us is, **it is given in form of linked list**.\\n* We have a advantage by having linked list, How?\\n* For swapping every two adjcant nodes, we will be able to just change the link of nodes.\\n* See how we change links on the first example.\\n![image](https://assets.leetcode.com/users/images/53a7a769-ce39-4d7d-9e37-cd0420f72bf0_1644988593.5987253.jpeg)\\n\\n\\n* I have mention everything in image itself, and also add comment in code also, but if u have still doubt or suggestion,please put that in comment part.\\n ____________\\n**Code (C++)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if head is NULL OR just having a single node, then no need to change anything \\n        if(head == NULL || head -> next == NULL) \\n        {\\n            return head;\\n        }\\n            \\n        ListNode* temp; // temporary pointer to store head -> next\\n        temp = head->next; // give temp what he want\\n        \\n        head->next = swapPairs(head->next->next); // changing links\\n        temp->next = head; // put temp -> next to head\\n        \\n        return temp; // now after changing links, temp act as our head\\n    }\\n};\\n```\\n***`If u find this useful , please consider to give a upvote!!`***\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nLet\\'s take an example not given in question -\\nSuppose our head pointer given to us as [1,9,2,8,3,7]\\n\\nSo, we have to swap every two adjcant nodes,\\nthe answer should be [9,1,8,2,7,3]\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if head is NULL OR just having a single node, then no need to change anything \\n        if(head == NULL || head -> next == NULL) \\n        {\\n            return head;\\n        }\\n            \\n        ListNode* temp; // temporary pointer to store head -> next\\n        temp = head->next; // give temp what he want\\n        \\n        head->next = swapPairs(head->next->next); // changing links\\n        temp->next = head; // put temp -> next to head\\n        \\n        return temp; // now after changing links, temp act as our head\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774318,
                "title": "python3-i-hate-linked-lists-not-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38-_-\\'), If you have any question, feel free to ask.**\\n\\nJust a bunch of placeholders, edge cases, and strange errors about a cycle meanwhile :(\\n\\nprev cur cur porev next cur prev pasdfaslfjgnzdsf;ljgfsdaz;lkjkfgn\\n\\nTime: **O(n)** - iterate\\nSpace: **O(1)**\\n\\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38-_-\\'), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11030,
                "title": "my-accepted-java-code-used-recursion",
                "content": "    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if ((head == null)||(head.next == null))\\n                return head;\\n            ListNode n = head.next;\\n            head.next = swapPairs(head.next.next);\\n            n.next = head;\\n            return n;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if ((head == null)||(head.next == null))\\n                return head;\\n            ListNode n = head.next;\\n            head.next = swapPairs(head.next.next);\\n            n.next = head;\\n            return n;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11019,
                "title": "7-8-lines-c-python-ruby",
                "content": "Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don't know all three languages.\\n\\nAll three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list.\\n\\n---\\n\\n**C++**\\n\\nPointer-pointer `pp`  points to the pointer to the current node. So at first, `pp` points to `head`, and later it points to the `next` field of ListNodes. Additionally, for convenience and clarity, pointers `a` and `b` point to the current node and the next node.\\n\\nWe need to go from `*pp == a -> b -> (b->next)` to `*pp == b -> a -> (b->next)`. The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves `pp` to the next pair.\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode **pp = &head, *a, *b;\\n        while ((a = *pp) && (b = a->next)) {\\n            a->next = b->next;\\n            b->next = a;\\n            *pp = b;\\n            pp = &(a->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\n**Python**\\n\\nHere, `pre` is the previous node. Since the head doesn't have a previous node, I just use `self` instead. Again, `a` is the current node and `b` is the next node.\\n\\nTo go from `pre -> a -> b -> b.next` to `pre -> b -> a -> b.next`, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once.\\n\\n    def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next\\n\\n---\\n\\n**Ruby**\\n\\nAgain, `pre` is the previous node, but here I create a dummy as previous node of the head. And again, `a` is the current node and `b` is the next node. This time I go one node further and call it `c`.\\n\\nTo go from `pre -> a -> b -> c` to `pre -> b -> a -> c`, we need to change those three references. Here I chain the assignments, pretty much directly saying \"`pre` points to `b`, which points to `a`, which points to `c`\".\\n\\n    def swap_pairs(head)\\n        pre = dummy = ListNode.new 0\\n        pre.next = head\\n        while a = pre.next and b = a.next\\n            c = b.next\\n            ((pre.next = b).next = a).next = c\\n            pre = a\\n        end\\n        dummy.next\\n    end",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Ruby"
                ],
                "code": "Three different implementations of the same algorithm, taking advantage of different strengths of the three languages. I suggest reading all three, even if you don't know all three languages.\\n\\nAll three of course work swap the current node with the next node by rearranging pointers, then move on to the next pair, and repeat until the end of the list.\\n\\n---\\n\\n**C++**\\n\\nPointer-pointer `pp`  points to the pointer to the current node. So at first, `pp` points to `head`, and later it points to the `next` field of ListNodes. Additionally, for convenience and clarity, pointers `a` and `b` point to the current node and the next node.\\n\\nWe need to go from `*pp == a -> b -> (b->next)` to `*pp == b -> a -> (b->next)`. The first three lines inside the loop do that, setting those three pointers (from right to left). The fourth line moves `pp` to the next pair.\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode **pp = &head, *a, *b;\\n        while ((a = *pp) && (b = a->next)) {\\n            a->next = b->next;\\n            b->next = a;\\n            *pp = b;\\n            pp = &(a->next);\\n        }\\n        return head;\\n    }\\n\\n---\\n\\n**Python**\\n\\nHere, `pre` is the previous node. Since the head doesn't have a previous node, I just use `self` instead. Again, `a` is the current node and `b` is the next node.\\n\\nTo go from `pre -> a -> b -> b.next` to `pre -> b -> a -> b.next`, we need to change those three references. Instead of thinking about in what order I change them, I just change all three at once.\\n\\n    def swapPairs(self, head):\\n        pre, pre.next = self, head\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return self.next\\n\\n---\\n\\n**Ruby**\\n\\nAgain, `pre` is the previous node, but here I create a dummy as previous node of the head. And again, `a` is the current node and `b` is the next node. This time I go one node further and call it `c`.\\n\\nTo go from `pre -> a -> b -> c` to `pre -> b -> a -> c`, we need to change those three references. Here I chain the assignments, pretty much directly saying \"`pre` points to `b`, which points to `a`, which points to `c`\".\\n\\n    def swap_pairs(head)\\n        pre = dummy = ListNode.new 0\\n        pre.next = head\\n        while a = pre.next and b = a.next\\n            c = b.next\\n            ((pre.next = b).next = a).next = c\\n            pre = a\\n        end\\n        dummy.next\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 11046,
                "title": "my-simple-java-solution-for-share",
                "content": "    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n        while (current.next != null && current.next.next != null) {\\n            ListNode first = current.next;\\n            ListNode second = current.next.next;\\n            first.next = second.next;\\n            current.next = second;\\n            current.next.next = first;\\n            current = current.next.next;\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode current = dummy;\\n        while (current.next != null && current.next.next != null) {\\n            ListNode first = current.next;\\n            ListNode second = current.next.next;\\n            first.next = second.next;\\n            current.next = second;\\n            current.next.next = first;\\n            current = current.next.next;\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 171788,
                "title": "python-dummynode",
                "content": "### 24. Swap Nodes in Pairs\\n\\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur = dummy\\n        \\n        while cur.next and cur.next.next:\\n            first = cur.next\\n            sec = cur.next.next\\n            cur.next = sec\\n            first.next = sec.next\\n            sec.next = first\\n            cur = cur.next.next\\n        return dummy.next       \\n```\\n![](https://raw.githubusercontent.com/yuzhoujr/spazzatura/master/img_box/24.jpg)\\n\\n#### Recursive\\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        new_start = head.next.next\\n        head, head.next = head.next, head\\n        head.next.next = self.swapPairs(new_start)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        cur = dummy\\n        \\n        while cur.next and cur.next.next:\\n            first = cur.next\\n            sec = cur.next.next\\n            cur.next = sec\\n            first.next = sec.next\\n            sec.next = first\\n            cur = cur.next.next\\n        return dummy.next       \\n```\n```python\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next: return head\\n        new_start = head.next.next\\n        head, head.next = head.next, head\\n        head.next.next = self.swapPairs(new_start)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11271,
                "title": "simple-implementation-with-c",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            if(head->next == NULL)\\n                return head;\\n            \\n            ListNode* next = head->next;\\n            head->next = swapPairs(next->next);\\n            next->next = head;\\n            \\n            return next;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(head == NULL)\\n                return NULL;\\n            if(head->next == NULL)\\n                return head;\\n            \\n            ListNode* next = head->next;\\n            head->next = swapPairs(next->next);\\n            next->next = head;\\n            \\n            return next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11183,
                "title": "c-solution-with-graph-explanation",
                "content": "    /*\\n           #---->@---->@---->@---->@---->@---->@\\n                       ^     ^\\n                       pre   cur\\n\\n          1. pre->next = cur->next\\n                        __________\\n                       /          \\\\\\n           #---->@---->@     @---->@---->@---->@\\n                       ^     ^\\n                       pre   cur\\n\\n          2. pre = pre->next\\n                        __________\\n                       /          \\\\\\n          #---->@---->@      @---->@---->@---->@\\n                             ^     ^\\n                             cur   pre\\n\\n          3. cur->next = pre->next\\n                        __________\\n                       /          \\\\\\n           #---->@---->@     @     @---->@---->@\\n                              \\\\_________/\\n                             ^     ^\\n                             cur   pre\\n\\n          4. pre->next = cur\\n                       __________\\n                      /          \\\\\\n          #---->@---->@     @<----@     @---->@\\n                             \\\\_________/\\n                            ^     ^\\n                            cur   pre\\n        \\n          5. pre = cur; cur = cur->next\\n                       __________\\n                      /          \\\\\\n          #---->@---->@     @<----@     @---->@\\n                             \\\\_________/\\n                            ^           ^\\n                            pre         cur\\n     */\\n    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode tmp(0);\\n            tmp.next = head;\\n            ListNode *pre = &tmp, *cur = head;\\n            while(cur && cur->next){\\n                pre->next = cur->next;\\n                pre = pre->next;\\n                cur->next = pre->next;\\n                pre->next = cur;\\n                pre = cur;\\n                cur = cur->next;\\n            }\\n            return tmp.next;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if(!head) return NULL;\\n            ListNode tmp(0);\\n            tmp.next = head;\\n            ListNode *pre = &tmp, *cur = head;\\n            while(cur && cur->next){\\n                pre->next = cur->next;\\n                pre = pre->next;\\n                cur->next = pre->next;\\n                pre->next = cur;\\n                pre = cur;\\n                cur = cur->next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11312,
                "title": "python-concise-iterative-and-recursive-solutions",
                "content": "    # Iteratively\\n    def swapPairs1(self, head):\\n        dummy = p = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            tmp = head.next\\n            head.next = tmp.next\\n            tmp.next = head\\n            p.next = tmp\\n            head = head.next\\n            p = tmp.next\\n        return dummy.next\\n     \\n    # Recursively    \\n    def swapPairs(self, head):\\n        if head and head.next:\\n            tmp = head.next\\n            head.next = self.swapPairs(tmp.next)\\n            tmp.next = head\\n            return tmp\\n        return head",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    # Iteratively\\n    def swapPairs1(self, head):\\n        dummy = p = ListNode(0)\\n        dummy.next = head\\n        while head and head.next:\\n            tmp = head.next\\n            head.next = tmp.next\\n            tmp.next = head\\n            p.next = tmp\\n            head = head.next\\n            p = tmp.next\\n        return dummy.next\\n     \\n    # Recursively    \\n    def swapPairs(self, head):\\n        if head and head.next:\\n            tmp = head.next\\n            head.next = self.swapPairs(tmp.next)\\n            tmp.next = head\\n            return tmp\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 11111,
                "title": "java-simple-recursive-solution",
                "content": "Starting to see that recursion is the perfect tool for (many) linked list problems (this one + merging list problem).\\n\\n    /**\\n     * Definition for singly-linked list.\\n     * public class ListNode {\\n     *     int val;\\n     *     ListNode next;\\n     *     ListNode(int x) { val = x; }\\n     * }\\n     */\\n    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode second = head.next;\\n            ListNode third = second.next;\\n            \\n            second.next = head;\\n            head.next = swapPairs(third);\\n            \\n            return second;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) return head;\\n            ListNode second = head.next;\\n            ListNode third = second.next;\\n            \\n            second.next = head;\\n            head.next = swapPairs(third);\\n            \\n            return second;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 344445,
                "title": "c-recursive-solution-faster-than-100-of-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp;\\n        temp = head->next;\\n        head->next = swapPairs(head->next->next);\\n        temp->next = head;\\n        \\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next) return head;\\n        ListNode* temp;\\n        temp = head->next;\\n        head->next = swapPairs(head->next->next);\\n        temp->next = head;\\n        \\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11223,
                "title": "javascript-solution-beats-94-44-of-all-submissions",
                "content": "    var swapPairs = function(head) {\\n        if(!head || !head.next) return head;\\n        var v1 = head, v2 = head.next, v3 = v2.next;\\n        v2.next = v1;\\n        v1.next = swapPairs(v3);\\n        return v2;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var swapPairs = function(head) {\\n        if(!head || !head.next) return head;\\n        var v1 = head, v2 = head.next, v3 = v2.next;\\n        v2.next = v1;\\n        v1.next = swapPairs(v3);\\n        return v2;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3528791,
                "title": "python-java-c-simple-solution-easy-to-understand",
                "content": "**!! BIG ANNOUNCEMENT !!**\\nI am currently Giving away my premium content well-structured assignments and study materials to clear interviews at top companies related to computer science and data science to my current Subscribers. This is only for first 10,000 Subscribers.  **DON\\'T FORGET** to Subscribe\\n\\n# Search \\uD83D\\uDC49 `Tech Wired Leetcode` to Subscribe\\n\\n# Video Solution\\n\\n# Search \\uD83D\\uDC49 `Swap Nodes in Pairs by Tech Wired`\\n\\n# or\\n\\n# Click the Link in my Profile\\n\\n# Approach:\\nThe approach used in the code is to traverse the linked list and swap adjacent pairs of nodes. This is done iteratively by maintaining a current pointer that points to the previous node before the pair to be swapped. The swapping is done by modifying the next pointers of the nodes.\\n\\n# Intuition:\\nThe intuition behind the code is to break down the problem into smaller subproblems. By swapping two nodes at a time, we can gradually swap adjacent pairs throughout the linked list. This is achieved by manipulating the next pointers of the nodes.\\n\\nThe use of a dummy node helps in handling the edge case where the head of the list needs to be swapped. It serves as a placeholder for the new head of the modified list.\\n\\nThe while loop iterates as long as there are at least two nodes remaining in the list. In each iteration, the current pair of nodes is swapped by adjusting the next pointers accordingly.\\n\\n\\n\\n```Python []\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not head or not head.next: return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = dummy\\n\\n        while curr.next and curr.next.next:\\n            first = curr.next\\n            second = curr.next.next\\n            curr.next = second\\n            first.next = second.next\\n            second.next = first\\n            curr = curr.next.next\\n        \\n        return dummy.next\\n```\\n```Java []\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode first = curr.next;\\n            ListNode second = curr.next.next;\\n            curr.next = second;\\n            first.next = second.next;\\n            second.next = first;\\n            curr = curr.next.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n        \\n        while (curr->next != nullptr && curr->next->next != nullptr) {\\n            ListNode* first = curr->next;\\n            ListNode* second = curr->next->next;\\n            curr->next = second;\\n            first->next = second->next;\\n            second->next = first;\\n            curr = curr->next->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```\\n# An Upvote will be encouraging \\uD83D\\uDC4D\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List"
                ],
                "code": "```Python []\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not head or not head.next: return head\\n\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        curr = dummy\\n\\n        while curr.next and curr.next.next:\\n            first = curr.next\\n            second = curr.next.next\\n            curr.next = second\\n            first.next = second.next\\n            second.next = first\\n            curr = curr.next.next\\n        \\n        return dummy.next\\n```\n```Java []\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode curr = dummy;\\n        \\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode first = curr.next;\\n            ListNode second = curr.next.next;\\n            curr.next = second;\\n            first.next = second.next;\\n            second.next = first;\\n            curr = curr.next.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == nullptr || head->next == nullptr) {\\n            return head;\\n        }\\n        \\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        ListNode* curr = dummy;\\n        \\n        while (curr->next != nullptr && curr->next->next != nullptr) {\\n            ListNode* first = curr->next;\\n            ListNode* second = curr->next->next;\\n            curr->next = second;\\n            first->next = second->next;\\n            second->next = first;\\n            curr = curr->next->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11028,
                "title": "my-straight-forward-java-solution-without-recursion-or-dummy-nodes-0ms",
                "content": "- The idea is straightforward: use two pointers and swap\\n - `a.next = b.next`, `b.next = a`.\\n - Then continue the next pair, `b = a.next.next`, `a=a.next`\\n - Remember to check `null`\\n - Remember to track new `head`\\n - Remember to link the new pair after the prior nodes. \\n\\nAttached is the accepted code.\\n\\n\\n    public class Solution {\\n      public ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode newHead = head.next, a=head,b=a.next,pre = null;\\n        while(a!=null && b!=null){\\n          a.next = b.next;\\n          b.next = a;\\n          if(pre!=null) pre.next = b;\\n          if(a.next==null) break;\\n          b = a.next.next;\\n          pre = a;\\n          a = a.next;\\n        }\\n        return newHead;\\n      }\\n    }\\n\\n- AC, 0ms",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) return head;\\n        ListNode newHead = head.next, a=head,b=a.next,pre = null;\\n        while(a!=null && b!=null){\\n          a.next = b.next;\\n          b.next = a;\\n          if(pre!=null) pre.next = b;\\n          if(a.next==null) break;\\n          b = a.next.next;\\n          pre = a;\\n          a = a.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 486804,
                "title": "python-simple-solution-memory-usage-less-than-100",
                "content": "Given:\\n**prev->a->b->c**\\n\\nChange it to:\\n**prev->b->a->c**\\n\\nSince the first node does not have any previous node, we create a dummy node at the beginning.\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n\\t\\t\\n        while prev.next and prev.next.next:\\n            a = prev.next\\n            b = prev.next.next\\n            c = prev.next.next.next\\n            prev.next = b\\n            prev.next.next = a\\n            prev.next.next.next = c\\n            prev = prev.next.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n\\t\\t\\n        while prev.next and prev.next.next:\\n            a = prev.next\\n            b = prev.next.next\\n            c = prev.next.next.next\\n            prev.next = b\\n            prev.next.next = a\\n            prev.next.next.next = c\\n            prev = prev.next.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11320,
                "title": "my-simple-recursive-solution",
                "content": "My solution is quite simple. Just find the reverse job is the same for every 2 nodes.\\n\\n    public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            \\n            ListNode newhd = head.next;\\n            head.next = swapPairs(newhd.next);\\n            newhd.next = head;\\n            return newhd;\\n    }",
                "solutionTags": [],
                "code": "My solution is quite simple. Just find the reverse job is the same for every 2 nodes.\\n\\n    public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            \\n            ListNode newhd = head.next;\\n            head.next = swapPairs(newhd.next);\\n            newhd.next = head;\\n            return newhd;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 265325,
                "title": "java-recursive-solution-beats-100-with-explanation",
                "content": "The idea is simple:\\neach we take two first elements of (sub)sequence, swap them using two additional variables, and call the function recursively from the tail. For example:\\n![image](https://assets.leetcode.com/users/olsh/image_1553979740.png)\\n\\nThe code of this solution:\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next==null)return head;\\n        ListNode tempNext = head.next.next;\\n        ListNode tempFirst = head.next;\\n        ListNode tempSecond = head;\\n        head = tempFirst;\\n        head.next = tempSecond;\\n        head.next.next = swapPairs(tempNext);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next==null)return head;\\n        ListNode tempNext = head.next.next;\\n        ListNode tempFirst = head.next;\\n        ListNode tempSecond = head;\\n        head = tempFirst;\\n        head.next = tempSecond;\\n        head.next.next = swapPairs(tempNext);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11331,
                "title": "4ms-easy-c-iterative-solution",
                "content": "Well, since the `head` pointer may also been modified, we create a `new_head` that points to it to facilitate the swapping process.\\n\\nFor the example list `1 -> 2 -> 3 -> 4` in the problem statement, it will become `0 -> 1 -> 2 -> 3 -> 4` (we init `new_head -> val` to be `0`). Then we set a pointer `pre` to `new_head` and another `cur` to `head`. Each time, we will swap `pre -> next` and `cur -> next` using the following piece of code.\\n\\n    pre -> next = cur -> next;\\n    cur -> next = cur -> next -> next;\\n    pre -> next -> next = cur;\\n\\nAfter swapping them, we update as follows:\\n\\n    pre = cur; \\n    cur = pre -> next; \\n\\nto swap the next two nodes.\\n\\nFinally, we return `new_head -> next`.\\n\\nThe complete code is as follows.\\n\\n    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) { \\n            if (!head || !(head -> next)) return head;\\n            ListNode* new_head = new ListNode(0);\\n            new_head -> next = head;\\n            ListNode* pre = new_head; \\n            ListNode* cur = head;\\n            while (pre -> next && cur -> next) {\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = cur;\\n                pre = cur;\\n                cur = pre -> next;\\n            }\\n            return new_head -> next;\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Iterator"
                ],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) { \\n            if (!head || !(head -> next)) return head;\\n            ListNode* new_head = new ListNode(0);\\n            new_head -> next = head;\\n            ListNode* pre = new_head; \\n            ListNode* cur = head;\\n            while (pre -> next && cur -> next) {\\n                pre -> next = cur -> next;\\n                cur -> next = cur -> next -> next;\\n                pre -> next -> next = cur;\\n                pre = cur;\\n                cur = pre -> next;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 486026,
                "title": "java-0-ms-beating-100-simple-iterative-solution-with-diagram-and-explanation",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        ListNode prevNode = new ListNode(0);    //Node situated before the two to-be-swapped nodes\\n        prevNode.next = head;                   //Starting before head\\n        ListNode newHead = prevNode;            //Storing a reference for returning\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null){\\n            \\n            //Declare                                           // ...[prev]-->[node1]-->[node2]-->[next]...\\n            ListNode node1 = prevNode.next;                     \\n            ListNode node2 = node1.next;\\n            ListNode nextNode = node2.next;\\n            \\n            //Swap\\n            prevNode.next = node2;                              // ...[prev]-->[node2]<--[node1]   [next]...\\n            node2.next = node1;                                 // ...[prev]-->[node2]<-->[node1]  [next]...\\n            node1.next = nextNode;                              // ...[prev]-->[node2]-->[node1]-->[next]...\\n            \\n            //Move \\n            prevNode = node1;                                   // ...[...]-->[node2]-->[node1/prev]-->[next]...\\n        }\\n        \\n        return newHead.next;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        ListNode prevNode = new ListNode(0);    //Node situated before the two to-be-swapped nodes\\n        prevNode.next = head;                   //Starting before head\\n        ListNode newHead = prevNode;            //Storing a reference for returning\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null){\\n            \\n            //Declare                                           // ...[prev]-->[node1]-->[node2]-->[next]...\\n            ListNode node1 = prevNode.next;                     \\n            ListNode node2 = node1.next;\\n            ListNode nextNode = node2.next;\\n            \\n            //Swap\\n            prevNode.next = node2;                              // ...[prev]-->[node2]<--[node1]   [next]...\\n            node2.next = node1;                                 // ...[prev]-->[node2]<-->[node1]  [next]...\\n            node1.next = nextNode;                              // ...[prev]-->[node2]-->[node1]-->[next]...\\n            \\n            //Move \\n            prevNode = node1;                                   // ...[...]-->[node2]-->[node1/prev]-->[next]...\\n        }\\n        \\n        return newHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11175,
                "title": "c-recursive-and-iterative-solutions",
                "content": "    \\n    // recursively\\n    ListNode* swapPairs1(ListNode* head) {\\n        if (!head || !(head->next))\\n            return head;\\n        ListNode *res = head->next;\\n        head->next = swapPairs(res->next);\\n        res->next = head;\\n        return res;\\n    }\\n    \\n    // iteratively\\n    ListNode *swapPairs(ListNode *head) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        dummy->next = head;\\n        while (head && head->next) {\\n            ListNode *nxt = head->next;\\n            head->next = nxt->next;\\n            nxt->next = head;\\n            node->next = nxt;\\n            node = head;\\n            head = node->next;\\n        }\\n        return dummy->next;\\n    }",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Iterator"
                ],
                "code": "    \\n    // recursively\\n    ListNode* swapPairs1(ListNode* head) {\\n        if (!head || !(head->next))\\n            return head;\\n        ListNode *res = head->next;\\n        head->next = swapPairs(res->next);\\n        res->next = head;\\n        return res;\\n    }\\n    \\n    // iteratively\\n    ListNode *swapPairs(ListNode *head) {\\n        ListNode *dummy = new ListNode(0), *node;\\n        node = dummy;\\n        dummy->next = head;\\n        while (head && head->next) {\\n            ListNode *nxt = head->next;\\n            head->next = nxt->next;\\n            nxt->next = head;\\n            node->next = nxt;\\n            node = head;\\n            head = node->next;\\n        }\\n        return dummy->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529293,
                "title": "c-easy-recursion",
                "content": "# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp=swapPairs(head->next->next);\\n        ListNode* t=head;\\n        head=head->next;\\n        head->next=t;\\n        head->next->next=temp;\\n        return head;\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/425d38ef-1ecd-4fe2-966c-1df715fb51d0_1684210746.862829.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp=swapPairs(head->next->next);\\n        ListNode* t=head;\\n        head=head->next;\\n        head->next=t;\\n        head->next->next=temp;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529474,
                "title": "easy-solution-beginner-friendly-easy-to-understand-beats-100-java-python-3-c-js-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraverse the list and swap pairs of nodes one by one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The node \"ans\" is to point to the head of the original list. It then uses a \"curr\" node to traverse the list and swap pairs of nodes. The loop continues as long as there are at least two more nodes to swap.\\n\\n- Inside the loop, the solution uses two temporary nodes, \"t1\" and \"t2\", to hold the first and second nodes of the pair. Then, it updates the pointers to swap the nodes, and moves \"curr\" two nodes ahead. At the end, it returns the modified list starting from the next node of the  \"ans\" node.\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n          if (head == null || head.next == null) {\\n            return head;\\n        }\\n    ListNode ans =new ListNode(0);\\n    ans.next=head;\\n    ListNode curr=ans;\\n   while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }  \\n      return ans.next;\\n    }\\n}\\n```\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        ans = ListNode(0)\\n        ans.next = head\\n        curr = ans\\n        \\n        while curr.next and curr.next.next:\\n            t1 = curr.next\\n            t2 = curr.next.next\\n            curr.next = t2\\n            t1.next = t2.next\\n            t2.next = t1\\n            curr = curr.next.next\\n        \\n        return ans.next\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n    }\\n};\\n```\\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};\\n```\\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode ans = new ListNode(0);\\n        ans.next = head;\\n        ListNode curr = ans;\\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }\\n        return ans.next;    \\n    }\\n}\\n```\\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n         if (head == null || head.next == null) {\\n            return head\\n        }\\n        val ans = ListNode(0)\\n        ans.next = head\\n        var curr: ListNode? = ans\\n        while (curr?.next != null && curr.next?.next != null) {\\n            val t1 = curr.next\\n            val t2 = curr.next?.next\\n            curr.next = t2\\n            t1.next = t2?.next\\n            t2?.next = t1\\n            curr = curr.next?.next\\n        }\\n        return ans.next\\n    }\\n}\\n```\\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n}\\n```\\n\\nUPVOTES ARE ENCOURAGING!",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript",
                    "Kotlin"
                ],
                "code": "```java []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n          if (head == null || head.next == null) {\\n            return head;\\n        }\\n    ListNode ans =new ListNode(0);\\n    ans.next=head;\\n    ListNode curr=ans;\\n   while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }  \\n      return ans.next;\\n    }\\n}\\n```\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n        \\n        ans = ListNode(0)\\n        ans.next = head\\n        curr = ans\\n        \\n        while curr.next and curr.next.next:\\n            t1 = curr.next\\n            t2 = curr.next.next\\n            curr.next = t2\\n            t1.next = t2.next\\n            t2.next = t1\\n            curr = curr.next.next\\n        \\n        return ans.next\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n    }\\n};\\n```\n```Javascript []\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    let ans = new ListNode(0);\\n    ans.next = head;\\n    let curr = ans;\\n    while (curr.next != null && curr.next.next != null) {\\n        let t1 = curr.next;\\n        let t2 = curr.next.next;\\n        curr.next = t2;\\n        t1.next = t2.next;\\n        t2.next = t1;\\n        curr = curr.next.next;\\n    }\\n    return ans.next;\\n};\\n```\n```C# []\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public int val;\\n *     public ListNode next;\\n *     public ListNode(int val=0, ListNode next=null) {\\n *         this.val = val;\\n *         this.next = next;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode ans = new ListNode(0);\\n        ans.next = head;\\n        ListNode curr = ans;\\n        while (curr.next != null && curr.next.next != null) {\\n            ListNode t1 = curr.next;\\n            ListNode t2 = curr.next.next;\\n            curr.next = t2;\\n            t1.next = t2.next;\\n            t2.next = t1;\\n            curr = curr.next.next;\\n        }\\n        return ans.next;    \\n    }\\n}\\n```\n```Kotlin []\\n/**\\n * Example:\\n * var li = ListNode(5)\\n * var v = li.`val`\\n * Definition for singly-linked list.\\n * class ListNode(var `val`: Int) {\\n *     var next: ListNode? = null\\n * }\\n */\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n         if (head == null || head.next == null) {\\n            return head\\n        }\\n        val ans = ListNode(0)\\n        ans.next = head\\n        var curr: ListNode? = ans\\n        while (curr?.next != null && curr.next?.next != null) {\\n            val t1 = curr.next\\n            val t2 = curr.next?.next\\n            curr.next = t2\\n            t1.next = t2?.next\\n            t2?.next = t1\\n            curr = curr.next?.next\\n        }\\n        return ans.next\\n    }\\n}\\n```\n```C []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n if (head == NULL || head->next == NULL) {\\n        return head;\\n    }\\n    struct ListNode* ans = (struct ListNode*) malloc(sizeof(struct ListNode));\\n    ans->next = head;\\n    struct ListNode* curr = ans;\\n    while (curr->next != NULL && curr->next->next != NULL) {\\n        struct ListNode* t1 = curr->next;\\n        struct ListNode* t2 = curr->next->next;\\n        curr->next = t2;\\n        t1->next = t2->next;\\n        t2->next = t1;\\n        curr = curr->next->next;\\n    }\\n    return ans->next;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1656816,
                "title": "solution-swift-swap-nodes-in-pairs-test-cases",
                "content": "```swift\\nclass Solution {\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        var head = head, node = head, pre: ListNode?\\n        \\n        while node != nil, let next = node!.next {\\n            let cur = next, tmp = cur.next\\n            pre == nil ? (head = cur) : (pre!.next = cur)\\n            cur.next = node\\n            node!.next = tmp\\n            pre = node\\n            node = tmp\\n        }\\n        return head\\n    }\\n}\\n```\\n\\n---\\n\\n<p><details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.012 (0.014) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.swapPairs(ListNode([1,2,3,4]))\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.swapPairs(ListNode([]))\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n    \\n    func test2() {\\n        let value = solution.swapPairs(ListNode([1]))\\n        XCTAssertEqual(value?.val, ListNode([1])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details></p>\\n\\n<p><details>\\n<summary>\\n<b>ListNode</b>\\n</summary>\\n\\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n\\n\\tpublic init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        var head = head, node = head, pre: ListNode?\\n        \\n        while node != nil, let next = node!.next {\\n            let cur = next, tmp = cur.next\\n            pre == nil ? (head = cur) : (pre!.next = cur)\\n            cur.next = node\\n            node!.next = tmp\\n            pre = node\\n            node = tmp\\n        }\\n        return head\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.swapPairs(ListNode([1,2,3,4]))\\n        XCTAssertEqual(value?.val, ListNode([2,1,4,3])?.val)\\n    }\\n    \\n    func test1() {\\n        let value = solution.swapPairs(ListNode([]))\\n        XCTAssertEqual(value?.val, ListNode([])?.val)\\n    }\\n    \\n    func test2() {\\n        let value = solution.swapPairs(ListNode([1]))\\n        XCTAssertEqual(value?.val, ListNode([1])?.val)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\n```swift\\npublic class ListNode {\\n    public var val: Int\\n    public var next: ListNode?\\n    public init() { self.val = 0; self.next = nil; }\\n    public init(_ val: Int) { self.val = val; self.next = nil; }\\n    public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n\\n\\tpublic init?(_ array: [Int]) {\\n        guard !array.isEmpty else { return nil }\\n        self.val = array[0]\\n        var prev: ListNode = self\\n        for i in 1..<array.count {\\n            let new = ListNode(array[i])\\n            prev.next = new\\n            prev = new\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984266,
                "title": "c-c-simple-short-and-easy-recursive-solution-0ms-faster-than-100",
                "content": "```\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if ((!head) || (!head->next))\\n        return head;\\n    \\n    struct ListNode* tmp = head;\\n    head = head->next;\\n    tmp->next = head->next;\\n    head->next = tmp;\\n    \\n    head->next->next = swapPairs(head->next->next);\\n    return head;\\n}\\n```\\n**Like it? please upvote!\\nHave any comments? I\\'d love to hear...**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if ((!head) || (!head->next))\\n        return head;\\n    \\n    struct ListNode* tmp = head;\\n    head = head->next;\\n    tmp->next = head->next;\\n    head->next = tmp;\\n    \\n    head->next->next = swapPairs(head->next->next);\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163702,
                "title": "python3-simple-recursive-solution-beats-95-00-easily-understandable-with-figure-explanation",
                "content": "## Idea\\n**Recursion**\\n- Base case: list is empty or contains only one node. (In this case there\\'s no need to swap anything)\\n- Recursive case: If the nodes after the first two nodes are already done swapping in pairs,  we just need to swap the first two nodes and then we\\'re done!\\n\\n## Implementation\\n\\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # recursive case\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        \\n        return _next\\n```\\n\\n## Visualization\\n\\n![image](https://assets.leetcode.com/users/images/399f06f6-0361-4b86-a29d-823f0d42a04a_1618696569.132693.png)\\n\\n## Complexity\\n- Time: O(n)\\n- Space: O(n)\\n\\n\\nIf you think this is helpful, please give it a vote.\\n",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # base case\\n        if not head or not head.next:\\n            return head\\n        \\n        # recursive case\\n        _next = head.next\\n        head.next = self.swapPairs(_next.next)\\n        _next.next = head\\n        \\n        return _next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984392,
                "title": "python-o-n-solution-explained",
                "content": "As with a lot of other linked lists, it is good idea to add dummy node before list to avoid cases. Imagine, we have list `1, 2, 3, 4, 5, 6`, let us add `0` node in the beginning, so we have `0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6` now.\\n\\nNow, let us look at the main step of algorithm (for simplicity I will call nodes by its values)\\n1. `pre = 0`, whe check if `pre.next` and `pre.next.next` exists, they are, so define `a = 1` and `b = 2`.\\n2. Now, we need to rewrite links: `0 -> 2`, `2 -> 1` and `1 -> 3`. Note, that we do it all in one step.\\n3. Finally, we say, that `pre = 1`. Also, our list now looks like `0 -> 2 -> 1 -> 3 -> 4 -> 5 -> 6` and as I said `pre = 1` now, so we swapped first two elements and now we on element number 2, which is exaclty what we have previously for smaller list.\\n4. On next step we have `0 -> 2 -> 1 -> 4 -> 3 -> 5 -> 6` and finally `0 -> 2 -> 1 -> 4 -> 3 -> 6 -> 5`, this is exaclty what we need to return.\\n\\n**Complexity**: time complexity is `O(n)`: we iterate over our list once, space complexity is `O(1)`: we did not add any new space and reused already existing nodes.\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pre = dummy\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return dummy.next\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n        pre = dummy\\n        while pre.next and pre.next.next:\\n            a = pre.next\\n            b = a.next\\n            pre.next, b.next, a.next = b, a, b.next\\n            pre = a\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774508,
                "title": "c-easy-to-understand-short-simple-10-lines",
                "content": "# 24. Swap Nodes in Pairs\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\\n\\n[LeetCode](https://github.com/knockcat/Leetcode)\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n**CODE WITH EXPLANATION**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n         ListNode* p = head;   // p pointing to head\\n        ListNode* res = head->next; // res is pointed to head -> next\\n        ListNode* q; ListNode* temp; // temporary nodes for links updation\\n        \\n        while(true)\\n        {\\n\\t\\t// for eg 1 2 3 4\\n\\t\\t//this iteration temp is point to 3 and 2 -> 1 will be acheived \\n\\t\\t// more explanation read after end of code\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n\\t\\t// if statement of temp won\\'t execute \\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n       \\n    }\\n};\\n```\\n\\n```\\n{\\n// 1\\'s link with 4 will extablished & value of temp i.e 3 will be stored in p.\\n\\n// now p contains 3 that points to 4.\\n\\n// Same way 2nd iteration will execute and 3->4 will turn into 4->3\\n\\n// if statement inside while loop will execute as temp has become null, \\n\\n// p->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n\\n// return res , which will give 2 -> 1 -> 4 -> 3 -> NULL\\n}\\n```\\n\\n**ANOTHER APPROACH BY SWAPPING VALUES**\\n\\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n        ListNode* temp = head;    // temporary pointer so that we don\\'t loose reference to head\\n        \\n        while(temp)        // while temp != NULL\\n        {\\n            if(temp->next != NULL)       \\n            {\\n\\t\\t\\t   // if list contain odd no of nodes than at last node the temp->next,\\n\\t\\t\\t   //will be pointing to null and the code crashes, as there is no other node,\\n\\t\\t\\t   // to perform swap opearation\\n                swap(temp->val, temp->next->val);    // swap with the adjacent node\\n                temp = temp->next->next;                 //incrementing pointer with 2 step\\n            }\\n\\t\\t\\t\\telse    // break because last pair of list is odd \\n\\t\\t\\t\\t\\tbreak;\\n        }\\n        \\n        return head;    // return head\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Please Upvote if it helps\\u2B06\\uFE0F\\n4. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n         ListNode* p = head;   // p pointing to head\\n        ListNode* res = head->next; // res is pointed to head -> next\\n        ListNode* q; ListNode* temp; // temporary nodes for links updation\\n        \\n        while(true)\\n        {\\n\\t\\t// for eg 1 2 3 4\\n\\t\\t//this iteration temp is point to 3 and 2 -> 1 will be acheived \\n\\t\\t// more explanation read after end of code\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n\\t\\t// if statement of temp won\\'t execute \\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n       \\n    }\\n};\\n```\n```\\n{\\n// 1\\'s link with 4 will extablished & value of temp i.e 3 will be stored in p.\\n\\n// now p contains 3 that points to 4.\\n\\n// Same way 2nd iteration will execute and 3->4 will turn into 4->3\\n\\n// if statement inside while loop will execute as temp has become null, \\n\\n// p->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n\\n// return res , which will give 2 -> 1 -> 4 -> 3 -> NULL\\n}\\n```\n```\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head-> next == NULL)  // if list contain 0 nodes or a single node return head\\n            return head;\\n        \\n        ListNode* temp = head;    // temporary pointer so that we don\\'t loose reference to head\\n        \\n        while(temp)        // while temp != NULL\\n        {\\n            if(temp->next != NULL)       \\n            {\\n\\t\\t\\t   // if list contain odd no of nodes than at last node the temp->next,\\n\\t\\t\\t   //will be pointing to null and the code crashes, as there is no other node,\\n\\t\\t\\t   // to perform swap opearation\\n                swap(temp->val, temp->next->val);    // swap with the adjacent node\\n                temp = temp->next->next;                 //incrementing pointer with 2 step\\n            }\\n\\t\\t\\t\\telse    // break because last pair of list is odd \\n\\t\\t\\t\\t\\tbreak;\\n        }\\n        \\n        return head;    // return head\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751194,
                "title": "javascript-iterative-time-o-n-space-o-1-explanation",
                "content": "```\\nvar swapPairs = function(head) {\\n    // Store head to return list, Only instance of new data so space is O(1)\\n    let dummy = new ListNode(-1);\\n    dummy.next = head;\\n    \\n    let prev = dummy\\n    \\n    // Traverse list\\n    while (head && head.next) {\\n        \\n    // Declare\\n    let n1 = head\\n    let n2 = head.next\\n        \\n        // Swap\\n        prev.next = n2\\n        n1.next = n2.next\\n        n2.next = n1\\n        \\n        // Assign\\n        prev = n1\\n        head = n1.next\\n    }\\n    \\n    // The variable prev has been used to create the dummy list. dummy.next is still the head of new list\\n    return dummy.next;\\n};\\n```\\ntime: O(n)\\nspace: O(1)",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    // Store head to return list, Only instance of new data so space is O(1)\\n    let dummy = new ListNode(-1);\\n    dummy.next = head;\\n    \\n    let prev = dummy\\n    \\n    // Traverse list\\n    while (head && head.next) {\\n        \\n    // Declare\\n    let n1 = head\\n    let n2 = head.next\\n        \\n        // Swap\\n        prev.next = n2\\n        n1.next = n2.next\\n        n2.next = n1\\n        \\n        // Assign\\n        prev = n1\\n        head = n1.next\\n    }\\n    \\n    // The variable prev has been used to create the dummy list. dummy.next is still the head of new list\\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233501,
                "title": "rust-0ms-100",
                "content": "```\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        head.and_then(|mut n| {\\n            match n.next {\\n                Some(mut m) => {\\n                    n.next = Solution::swap_pairs(m.next);\\n                    m.next = Some(n);\\n                    Some(m)\\n                },\\n                None => Some(n)\\n            }\\n        })\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        head.and_then(|mut n| {\\n            match n.next {\\n                Some(mut m) => {\\n                    n.next = Solution::swap_pairs(m.next);\\n                    m.next = Some(n);\\n                    Some(m)\\n                },\\n                None => Some(n)\\n            }\\n        })\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2481145,
                "title": "go-many-clean-solutions-with-images-in-go-golang-0ms-100",
                "content": "Hello Gophers!\\n\\nStart:\\n![swap-nodes-start.png](https://assets.leetcode.com/users/images/f5bbe08e-42e8-42ce-9977-d5f2a58bc653_1690834893.7782896.png)\\n\\nSwap:\\n\\n![swap-nodes-swap.png](https://assets.leetcode.com/users/images/7085cfe8-e298-435b-bc12-739668f3580f_1690834907.7661934.png)\\n\\nEnd:\\n![swap-nodes-end.png](https://assets.leetcode.com/users/images/78c9effb-98e4-4594-b2ff-b91bce480211_1690834920.5882404.png)\\n\\n\\n## Solution 1: Recursive (Easy-Medium)\\n\\nCleaner, but worst space complexity.\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(n)` (recursion)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\thead, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n\\n\\treturn head\\n}\\n\\n```\\n\\nor\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head != nil && head.Next != nil {\\n        head, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n    }\\n    return head\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fb93b1d2-41f9-44b6-a05d-f24d58f76c8f_1661481740.6021497.jpeg)\\n![image](https://assets.leetcode.com/users/images/edacf671-cf94-4da0-8569-d55c1d682b51_1661481740.3160453.jpeg)\\n\\n\\n## Solution 2: Iterative (Medium-Hard)\\n\\n\\nIteration (`for` loop) instead of recursivity (function calling itself).  \\nUglier (imo), but better space complexity.\\n\\n\\nTime Complexity: `O(n)`\\nSpace Complexity: `O(1)`\\n\\n### Solution 2.1: with temp nodes (Medium)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\n### Solution 2.2: Without temp nodes (Hard)\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nHow did I get to solution 2.2?\\n\\nStart:\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nRemove \"temp nodes\" `firstNode` and `secondNode`:\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tprev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nBut because `prev` can be nil:\\n\\n```go\\nif prev != nil {\\n    prev.Next = secondNode\\n}\\n```\\n\\nWe need a \"first step\":\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n    // Start\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\n    // Firtst Step (prev is nil)\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\n    // All Next Steps\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\nIt works \\uD83E\\uDD2F\\n\\nStart:\\n![swap-nodes-1.png](https://assets.leetcode.com/users/images/d5342873-a9b1-4b5e-938d-7294231bcf9e_1690831346.3609188.png)\\n\\nFirst iteration:\\n![swap-nodes-2.png](https://assets.leetcode.com/users/images/6f6aa2b9-35b1-48eb-abd2-06e701276bca_1690831364.0310698.png)\\n\\nTODO: Finish this\\n\\nI hope it helped!",
                "solutionTags": [
                    "Go",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\thead, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n\\n\\treturn head\\n}\\n\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head != nil && head.Next != nil {\\n        head, head.Next, head.Next.Next = head.Next, swapPairs(head.Next.Next), head\\n    }\\n    return head\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tfirstNode, secondNode := curr, curr.Next\\n\\t\\tfirstNode.Next, secondNode.Next = secondNode.Next, firstNode\\n\\n\\t\\tif prev != nil {\\n\\t\\t\\tprev.Next = secondNode\\n\\t\\t}\\n\\n\\t\\tprev, curr = firstNode, firstNode.Next\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\tfor curr != nil && curr.Next != nil {\\n\\t\\tprev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```go\\nif prev != nil {\\n    prev.Next = secondNode\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\t\\n    // Start\\n\\tvar prev, curr, newHead *ListNode = nil, head, head.Next\\n\\n    // Firtst Step (prev is nil)\\n\\tprev, curr, curr.Next, curr.Next.Next = curr, curr.Next.Next, curr.Next.Next, curr\\n\\n    // All Next Steps\\n\\tfor curr != nil && curr.Next != nil {\\n        prev, prev.Next, curr, curr.Next, curr.Next.Next = curr, curr.Next, curr.Next.Next, curr.Next.Next, curr\\n\\t}\\n\\n\\treturn newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3517577,
                "title": "c-java-python-javascript-swapping-nodes-fully-explained",
                "content": "# Approach\\n\\n1. Check if the list is empty or contains only one node. If so, there is no need to perform any swaps, so the original head is returned.\\n2. Initialize three pointers: `newHead` to store the new head after swapping, `prev` to keep track of the previous node, and `curr` to iterate through the list.\\n3. Enter a loop that continues as long as both `curr` and `curr->next` are not null.\\n4. Inside the loop, create a pointer `next` to store the next node after `curr`.\\n5. Update the next pointers of `curr` and `next` to perform the swap. Set `curr->next` to `next->next` to connect `curr` with the next pair of nodes.\\n6. Set `next->next` to `curr` to swap the positions of `curr` and `next`.\\n7. If `prev` is not null, update its `next` pointer to `next` to connect the previous pair with the swapped pair.\\n8. Update `prev` to `curr` and `curr` to `curr->next` to move forward in the list.\\n9. After the loop ends, return `newHead`, which stores the new head of the swapped list.\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this algorithm is O(n), where n is the number of nodes in the linked list. This is because the algorithm iterates through the list once. The space complexity is O(1) because it uses a constant amount of additional space to store the pointers.\\n\\n# C++\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        ListNode* newHead = head->next;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr && curr->next) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = curr;\\n            \\n            if (prev) {\\n                prev->next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode newHead = head.next;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null && curr.next != null) {\\n            ListNode next = curr.next;\\n            curr.next = next.next;\\n            next.next = curr;\\n            \\n            if (prev != null) {\\n                prev.next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}\\n```\\n---\\n# Python\\n```\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        new_head = head.next\\n        prev = None\\n        curr = head\\n        \\n        while curr and curr.next:\\n            next = curr.next\\n            curr.next = next.next\\n            next.next = curr\\n            \\n            if prev:\\n                prev.next = next\\n            \\n            prev = curr\\n            curr = curr.next\\n        \\n        return new_head\\n```\\n---\\n# JavaScript\\n```\\nvar swapPairs = function(head) {\\n    if (!head || !head.next) {\\n        return head;\\n    }\\n    \\n    var newHead = head.next;\\n    var prev = null;\\n    var curr = head;\\n    \\n    while (curr && curr.next) {\\n        var next = curr.next;\\n        curr.next = next.next;\\n        next.next = curr;\\n        \\n        if (prev) {\\n            prev.next = next;\\n        }\\n        \\n        prev = curr;\\n        curr = curr.next;\\n    }\\n    \\n    return newHead;\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (!head || !head->next) {\\n            return head;\\n        }\\n        ListNode* newHead = head->next;\\n        ListNode* prev = nullptr;\\n        ListNode* curr = head;\\n        \\n        while (curr && curr->next) {\\n            ListNode* next = curr->next;\\n            curr->next = next->next;\\n            next->next = curr;\\n            \\n            if (prev) {\\n                prev->next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr->next;\\n        }\\n        \\n        return newHead;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        \\n        ListNode newHead = head.next;\\n        ListNode prev = null;\\n        ListNode curr = head;\\n        \\n        while (curr != null && curr.next != null) {\\n            ListNode next = curr.next;\\n            curr.next = next.next;\\n            next.next = curr;\\n            \\n            if (prev != null) {\\n                prev.next = next;\\n            }\\n            \\n            prev = curr;\\n            curr = curr.next;\\n        }\\n        \\n        return newHead;\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        new_head = head.next\\n        prev = None\\n        curr = head\\n        \\n        while curr and curr.next:\\n            next = curr.next\\n            curr.next = next.next\\n            next.next = curr\\n            \\n            if prev:\\n                prev.next = next\\n            \\n            prev = curr\\n            curr = curr.next\\n        \\n        return new_head\\n```\n```\\nvar swapPairs = function(head) {\\n    if (!head || !head.next) {\\n        return head;\\n    }\\n    \\n    var newHead = head.next;\\n    var prev = null;\\n    var curr = head;\\n    \\n    while (curr && curr.next) {\\n        var next = curr.next;\\n        curr.next = next.next;\\n        next.next = curr;\\n        \\n        if (prev) {\\n            prev.next = next;\\n        }\\n        \\n        prev = curr;\\n        curr = curr.next;\\n    }\\n    \\n    return newHead;\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774796,
                "title": "java-0ms-recursive-code-faster-than-100-of-the-solutions-with-comments",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        /**\\n        * The base condition will be triggered when there is no node left or there is just 1 node.\\n        * If there is just 1 node left, there is nothing that can be swapped, hence we return the node\\n        * itself.\\n        */\\n        if(head == null || head.next == null) return head;\\n        \\n        /**\\n        * If there are more than 1 nodes remaining, we would recursively call the method by passing the\\n        * next.next element.\\n        * This is because we would be swapping the head and the head.next element.\\n        * So, to call the method we would pass the head.next.next element.\\n        * This call will return a head which we would have to attach it to the current head.next element,\\n        AFTER SWAPPING.\\n        */\\n        ListNode tHead = swapPairs(head.next.next);\\n        \\n        /**\\n        * Here, we would write the swapping logic.\\n        * The node which is returned from the above line of code, will be connected with the nodes after\\n        * swapping here.\\n        */\\n        \\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        /**\\n        * The base condition will be triggered when there is no node left or there is just 1 node.\\n        * If there is just 1 node left, there is nothing that can be swapped, hence we return the node\\n        * itself.\\n        */\\n        if(head == null || head.next == null) return head;\\n        \\n        /**\\n        * If there are more than 1 nodes remaining, we would recursively call the method by passing the\\n        * next.next element.\\n        * This is because we would be swapping the head and the head.next element.\\n        * So, to call the method we would pass the head.next.next element.\\n        * This call will return a head which we would have to attach it to the current head.next element,\\n        AFTER SWAPPING.\\n        */\\n        ListNode tHead = swapPairs(head.next.next);\\n        \\n        /**\\n        * Here, we would write the swapping logic.\\n        * The node which is returned from the above line of code, will be connected with the nodes after\\n        * swapping here.\\n        */\\n        \\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830851,
                "title": "swift-recursive-iterative",
                "content": "**Simple recursion**\\nTime: O(n), Space: O(n)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tif let next = head.next {\\n\\t\\thead.next = swapPairs(next.next)\\n\\t\\tnext.next = head\\n\\t\\treturn next\\n\\t} else {\\n\\t   return head \\n\\t}\\n}\\n```\\n---\\nHow about iterative?\\n**Iterative**\\nTime: O(n), Space: O(n)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tif head == nil || head?.next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlet newHead = head!.next\\n\\n\\tvar stack = [ListNode]()\\n\\tvar node = head\\n\\twhile let cur = node, let next = cur.next { // 2 at a time\\n\\t\\tstack.append(cur)\\n\\t\\tstack.append(next)\\n\\t\\tnode = next.next\\n\\t}\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet next = stack.popLast()!\\n\\t\\tlet cur = stack.popLast()!\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tif let prev = stack.last {\\n\\t\\t\\tprev.next = next\\n\\t\\t}\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\\n\\n**Iterative without a stack**\\nTime: O(n), Space: O(1)\\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tvar dummy = ListNode()\\n\\tvar prev = dummy\\n\\tprev.next = head\\n\\twhile let cur = prev.next, let next = cur.next {\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tprev.next = next\\n\\t\\tprev = cur\\n\\t}\\n\\n\\treturn dummy.next\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tguard let head = head else { return nil }\\n\\tif let next = head.next {\\n\\t\\thead.next = swapPairs(next.next)\\n\\t\\tnext.next = head\\n\\t\\treturn next\\n\\t} else {\\n\\t   return head \\n\\t}\\n}\\n```\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tif head == nil || head?.next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tlet newHead = head!.next\\n\\n\\tvar stack = [ListNode]()\\n\\tvar node = head\\n\\twhile let cur = node, let next = cur.next { // 2 at a time\\n\\t\\tstack.append(cur)\\n\\t\\tstack.append(next)\\n\\t\\tnode = next.next\\n\\t}\\n\\n\\twhile !stack.isEmpty {\\n\\t\\tlet next = stack.popLast()!\\n\\t\\tlet cur = stack.popLast()!\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tif let prev = stack.last {\\n\\t\\t\\tprev.next = next\\n\\t\\t}\\n\\t}\\n\\n\\treturn newHead\\n}\\n```\n```\\nfunc swapPairs(_ head: ListNode?) -> ListNode? {\\n\\tvar dummy = ListNode()\\n\\tvar prev = dummy\\n\\tprev.next = head\\n\\twhile let cur = prev.next, let next = cur.next {\\n\\t\\tcur.next = next.next\\n\\t\\tnext.next = cur\\n\\t\\tprev.next = next\\n\\t\\tprev = cur\\n\\t}\\n\\n\\treturn dummy.next\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 557411,
                "title": "python-recursive-solution-faster-than-99-72",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head:                                           # first (head) node exists\\n            h = head.next                                  # second node\\n            if h:                                          # second node exists => a pair exists\\n                h.next, head.next = head, h.next           # swap node pair, first node with second => \\'h\\' is new head\\n                h.next.next = self.swapPairs(h.next.next)  # recurse on next pair head\\n                return h              # returns the new head of a swapped node pair\\n        return head                   # returns when a node pair doesn\\'t exist\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head:                                           # first (head) node exists\\n            h = head.next                                  # second node\\n            if h:                                          # second node exists => a pair exists\\n                h.next, head.next = head, h.next           # swap node pair, first node with second => \\'h\\' is new head\\n                h.next.next = self.swapPairs(h.next.next)  # recurse on next pair head\\n                return h              # returns the new head of a swapped node pair\\n        return head                   # returns when a node pair doesn\\'t exist\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529642,
                "title": "c-beats-100-image-explanation-using-dummy-head-and-dummy-tail",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will convert the list into the list with dummy head and dummy tail. It will help us to maintain pointer and will save us from writing edge cases for null pointers.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nEg. Given list is `1 -> 2 -> 3 -> 4`. We will convert it to `-1 -> 1 -> 2 -> 3 -> 4 -> -1`. Now our head will point to dummy head.\\n\\nWe will keep track of three pointer and will reverse every pair of elements,\\n1. prev - which will link the reversed element (from a pair of elements), this pointer is immediate left of the current pair\\n2. cur - first element of current pair\\n3. next - second element of current pair\\n\\nIf we look at this example `-1 -> 1 -> 2 -> 3 -> 4 -> -1`, then in the first iteration prev would be -1, cur would be 1 and next would be 2.\\n\\nAfter swapping a pair list will look like this `-1 -> 2 -> 1 -> 3 -> 4 -> -1`. Now we will have our next pair which is `3 -> 4`. So prev would be 1, curr would be at 3 and next would be at 4. \\n\\nAfter second iteration list will look like `-1 -> 2 -> 1 -> 4 -> 3 -> -1`.\\n\\nNow, The list is swapped in pairs of two elements. We just have to remove dummy head and dummy tail.\\n\\nFinal answer: `2 -> 1 -> 4 -> 3`\\n\\n**NOTE 1:** ***Odd size list handled in the code. Just emit the last element from being swapped with dummy tail.***\\n**NOTE 2:** ***Code is self explanatory.***\\n\\n### Iteration Steps Explanation\\n![image.png](https://assets.leetcode.com/users/images/2deeb1b9-a52a-4694-9bbd-6e681c855146_1684217143.7158692.png)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n    - As we are traversing list only once (ignore adding and deleting dummy head and dummy tail)\\n\\n- Space complexity: $$O(1)$$\\n    - As we have not used any space (containers) except the pointers.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if list is null or contains one element then return the list itself (null => null & `1` => `1`)\\n        if (!head or !head->next)\\n            return head;\\n\\n        // Adding dummy head\\n        ListNode *dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        head = dummyHead;\\n\\n        // Adding dummy tail\\n        ListNode *dummyTail = new ListNode(-1);\\n        ListNode *ptr = head;\\n        while (ptr->next)\\n            ptr = ptr->next;\\n        ptr->next = dummyTail;\\n\\n        // assigning prev, cur and next for first iteration\\n        ListNode *prev = head, *cur = head->next, *next = head->next->next;\\n        while (next and next->val != -1)\\n        {\\n            // Check above image\\n            ListNode *nextCur = next->next; // 1\\n            prev->next = next; // 2\\n            cur->next = next->next; // 3\\n            next->next = cur; // 4\\n\\n            prev = cur; // 5\\n            cur = nextCur; // 6\\n            next = cur->next; // 7\\n        }   \\n\\n        // Remove dummy tail\\n        ListNode *remove = head;\\n        while(remove->next->val != -1)\\n            remove = remove->next;\\n        remove->next = NULL;\\n\\n        // remove dummy head\\n        return head = head->next;\\n    }\\n};\\n```\\n### Upvote if it helped you !!!\\n![image.png](https://assets.leetcode.com/users/images/58838411-f6e7-4acb-b98b-a8427e7453da_1684217764.5259085.png)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // if list is null or contains one element then return the list itself (null => null & `1` => `1`)\\n        if (!head or !head->next)\\n            return head;\\n\\n        // Adding dummy head\\n        ListNode *dummyHead = new ListNode(-1);\\n        dummyHead->next = head;\\n        head = dummyHead;\\n\\n        // Adding dummy tail\\n        ListNode *dummyTail = new ListNode(-1);\\n        ListNode *ptr = head;\\n        while (ptr->next)\\n            ptr = ptr->next;\\n        ptr->next = dummyTail;\\n\\n        // assigning prev, cur and next for first iteration\\n        ListNode *prev = head, *cur = head->next, *next = head->next->next;\\n        while (next and next->val != -1)\\n        {\\n            // Check above image\\n            ListNode *nextCur = next->next; // 1\\n            prev->next = next; // 2\\n            cur->next = next->next; // 3\\n            next->next = cur; // 4\\n\\n            prev = cur; // 5\\n            cur = nextCur; // 6\\n            next = cur->next; // 7\\n        }   \\n\\n        // Remove dummy tail\\n        ListNode *remove = head;\\n        while(remove->next->val != -1)\\n            remove = remove->next;\\n        remove->next = NULL;\\n\\n        // remove dummy head\\n        return head = head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528838,
                "title": "easy-solution-of-java-100-faster-code-beginner-friendly",
                "content": "\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n\\n```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        ListNode d = new ListNode(0), a;\\n        d.next = head;\\n        a=d;\\n        while(head!=null&&head.next!=null) {\\n            a.next = head.next;\\n            head.next = head.next.next;\\n            a.next.next = head;\\n            a = a.next.next;\\n            head =  head.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null)return head;\\n        ListNode d = new ListNode(0), a;\\n        d.next = head;\\n        a=d;\\n        while(head!=null&&head.next!=null) {\\n            a.next = head.next;\\n            head.next = head.next.next;\\n            a.next.next = head;\\n            a = a.next.next;\\n            head =  head.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 477540,
                "title": "python-recursive-solution-w-step-by-step-thought-process",
                "content": "Is the point of Leetcode to come up with intensely technical and condensed code, or is it to help us practice systematically solving problems and showing our thought process? Its the latter. This may not be the most condensed solution, but the thought process is clear and sequential.\\n\\n**Overall Thought Process**\\n1. Write out ideally how the algorithm would execute. It\\'ll be easier to see the pattern this way\\n2. Then, I look at pairs and try to come up with a pseudocode\\n3. From that, I can come up with a rough recursive algorithm. To simplify this, I\\'m not thinking of edge cases \\n4. Add in conditionals to account for edge cases\\n5. Convert algorithm into code\\n\\n<br>\\n\\n\\n**Walking through each Step**\\n\\n\\n**1. Write out ideally how the algorithm would execute. It\\'ll be easier to see the pattern this way**\\n\\n```\\nFor linked list -> 1 - 2\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4\\n4.next = 3\\n3.next = None\\n2.next = 1\\n1.next = 4\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4 - 5\\n4.next = 3\\n3.next = 5\\n2.next = 1\\n1.next = 4\\nreturn 2\\n```\\n\\n\\n**2. Then, I look at pairs and try to come up with a pseudocode**\\n```\\nfor each pair (a, b):\\n    a.next = whatever is the first of next pair\\n    b.next = a\\n    return b\\n```\\n\\n**3. From that, I can come up with a rough recursive algorithm. To simplify this, I\\'m not thinking of edge cases yet**\\n```\\nswap_pair(head):\\n    first = head\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\\n\\n**4. Add in conditionals to account for edge cases**\\n```\\nswap_pair(head):\\n    if not head:\\n        return None\\n\\n    first = head\\n    \\n    if not first.next:\\n        return first\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\\n\\n**5. Convert algorithm into code**\\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n\\n        first = head\\n        if not first.next:\\n            return first\\n        second = first.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        return second\\n```",
                "solutionTags": [],
                "code": "```\\nFor linked list -> 1 - 2\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3\\n2.next = 1\\n1.next = None\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4\\n4.next = 3\\n3.next = None\\n2.next = 1\\n1.next = 4\\nreturn 2\\n\\nFor linked list -> 1 - 2 - 3 - 4 - 5\\n4.next = 3\\n3.next = 5\\n2.next = 1\\n1.next = 4\\nreturn 2\\n```\n```\\nfor each pair (a, b):\\n    a.next = whatever is the first of next pair\\n    b.next = a\\n    return b\\n```\n```\\nswap_pair(head):\\n    first = head\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\n```\\nswap_pair(head):\\n    if not head:\\n        return None\\n\\n    first = head\\n    \\n    if not first.next:\\n        return first\\n    second = first.next\\n    \\n    first.next = swap_pair(second.next)\\n    second.next = first\\n    return second\\n```\n```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head:\\n            return None\\n\\n        first = head\\n        if not first.next:\\n            return first\\n        second = first.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        return second\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529141,
                "title": "day-411-brute-better-optimal-100-python-java-c-explained",
                "content": "\\n\\n\\n\\n# BRUTE\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n        List<ListNode> list = new ArrayList<>();\\n        ListNode temNode = head;\\n        while (temNode != null) {\\n            list.add(temNode);\\n            temNode = temNode.next;\\n        }\\n        for (int i = 0; i < list.size() - 1; i += 2) {\\n            int swapElement = list.get(i).val;\\n            list.get(i).val = list.get(i + 1).val;\\n            list.get(i + 1).val = swapElement;\\n        }\\n        return head;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nwe first check if the input head is null or has only one node. If so, we return the head as it is. Otherwise, we create two nodes first and second and set them to the first and second nodes of the linked list, respectively. We then recursively call the swapPairs function on the next of the second node and set the next of the first node to the result. We then swap the next pointers of the first and second nodes and return the second node.\\n\\n# BETTER\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode first = head;\\n    ListNode second = head.next;\\n    first.next = swapPairs(second.next);\\n    second.next = first;\\n    return second;\\n}\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(LOG(N))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# OPTIMAL\\nWe create a dummy node and set its next to the head. We then create a current node and initialize it to the dummy node. We use a single loop to swap every two adjacent nodes. We do this by creating two nodes first and second and swapping their next pointers. We then update the current node to point to the second node and continue the loop. Finally, we return the next of the dummy node.The time complexity of this solution is O(n) as we need to traverse the entire linked list once.\\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ListNode current = dummy;\\n    while (current.next != null && current.next.next != null) {\\n        ListNode first = current.next;\\n        ListNode second = current.next.next;\\n        first.next = second.next;\\n        second.next = first;\\n        current.next = second;\\n        current = current.next.next;\\n    }\\n    return dummy.next;\\n}\\n```\\n```c++ []\\nListNode* swapPairs(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* current = dummy;\\n    while (current->next != NULL && current->next->next != NULL) {\\n        ListNode* first = current->next;\\n        ListNode* second = current->next->next;\\n        first->next = second->next;\\n        second->next = first;\\n        current->next = second;\\n        current = current->next->next;\\n    }\\n    return dummy->next;\\n}\\n```\\n```python []\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/062630f0-ef80-4e74-abdb-302827b99235_1680054012.5054147.webp)\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D \\uD83C\\uDD99\\uD83C\\uDD99\\uD83C\\uDD99\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06  \\u2B06 \\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n        List<ListNode> list = new ArrayList<>();\\n        ListNode temNode = head;\\n        while (temNode != null) {\\n            list.add(temNode);\\n            temNode = temNode.next;\\n        }\\n        for (int i = 0; i < list.size() - 1; i += 2) {\\n            int swapElement = list.get(i).val;\\n            list.get(i).val = list.get(i + 1).val;\\n            list.get(i + 1).val = swapElement;\\n        }\\n        return head;\\n}\\n```\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode first = head;\\n    ListNode second = head.next;\\n    first.next = swapPairs(second.next);\\n    second.next = first;\\n    return second;\\n}\\n```\n```JAVA []\\npublic ListNode swapPairs(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode dummy = new ListNode(0);\\n    dummy.next = head;\\n    ListNode current = dummy;\\n    while (current.next != null && current.next.next != null) {\\n        ListNode first = current.next;\\n        ListNode second = current.next.next;\\n        first.next = second.next;\\n        second.next = first;\\n        current.next = second;\\n        current = current.next.next;\\n    }\\n    return dummy.next;\\n}\\n```\n```c++ []\\nListNode* swapPairs(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n    dummy->next = head;\\n    ListNode* current = dummy;\\n    while (current->next != NULL && current->next->next != NULL) {\\n        ListNode* first = current->next;\\n        ListNode* second = current->next->next;\\n        first->next = second->next;\\n        second->next = first;\\n        current->next = second;\\n        current = current->next->next;\\n    }\\n    return dummy->next;\\n}\\n```\n```python []\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    dummy = ListNode(0)\\n    dummy.next = head\\n    current = dummy\\n    while current.next and current.next.next:\\n        first = current.next\\n        second = current.next.next\\n        first.next = second.next\\n        second.next = first\\n        current.next = second\\n        current = current.next.next\\n    return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1902446,
                "title": "100-fastest-swift-solution-time-o-n-space-o-1",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     public var val: Int\\n *     public var next: ListNode?\\n *     public init() { self.val = 0; self.next = nil; }\\n *     public init(_ val: Int) { self.val = val; self.next = nil; }\\n *     public init(_ val: Int, _ next: ListNode?) { self.val = val; self.next = next; }\\n * }\\n */\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11236,
                "title": "very-easy-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            ListNode *l=head;\\n            if(head&&head->next){\\n                l=head->next;\\n                head->next=swapPairs(l->next);\\n                l->next=head;\\n            }\\n            return l;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            ListNode *l=head;\\n            if(head&&head->next){\\n                l=head->next;\\n                head->next=swapPairs(l->next);\\n                l->next=head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 300006,
                "title": "go-0-ms-faster-than-100-00-easy-code-recursion",
                "content": "```\\ntype ListNode struct {\\n\\tVal  int\\n\\tNext *ListNode\\n}\\n\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tresult := head.Next\\n\\thead.Next = swapPairs(head.Next.Next)\\n\\tresult.Next = head\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Recursion"
                ],
                "code": "```\\ntype ListNode struct {\\n\\tVal  int\\n\\tNext *ListNode\\n}\\n\\nfunc swapPairs(head *ListNode) *ListNode {\\n\\tif head == nil || head.Next == nil {\\n\\t\\treturn head\\n\\t}\\n\\tresult := head.Next\\n\\thead.Next = swapPairs(head.Next.Next)\\n\\tresult.Next = head\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 298168,
                "title": "java-clean-recursive-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode newHead = head.next;\\n        head.next = swapPairs(newHead.next);\\n        newHead.next = head;\\n        return newHead;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        ListNode newHead = head.next;\\n        head.next = swapPairs(newHead.next);\\n        newHead.next = head;\\n        return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 278452,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        first = head.next\\n        second = head\\n        second.next = self.swapPairs(first.next)\\n        first.next = second\\n        return first\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        first = head.next\\n        second = head\\n        second.next = self.swapPairs(first.next)\\n        first.next = second\\n        return first\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11361,
                "title": "share-my-accepted-java-solution",
                "content": "    public class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }\\n            ListNode first = head, last = head.next;\\n            first.next = swapPairs(last.next);\\n            last.next = first;\\n            return last;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public ListNode swapPairs(ListNode head) {\\n            if (head == null || head.next == null) {\\n                return head;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 11216,
                "title": "my-accepted-solution-in-python-quite-fast",
                "content": "    class Solution:\\n        # @param a ListNode\\n        # @return a ListNode\\n        def swapPairs(self, head):\\n            p1 = guard = ListNode(0)\\n            guard.next = head\\n            \\n            try:\\n                while True:\\n                    p0, p1, p2 = p1, p1.next, p1.next.next\\n                    p0.next, p1.next, p2.next = p2, p2.next, p1\\n            except:\\n                return guard.next",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param a ListNode\\n        # @return a ListNode\\n        def swapPairs(self, head):\\n            p1 = guard = ListNode(0)\\n            guard.next = head\\n            \\n            try:\\n                while True:\\n                    p0, p1, p2 = p1, p1.next, p1.next.next\\n                    p0.next, p1.next, p2.next = p2, p2.next, p1\\n            except:\\n                return guard.next",
                "codeTag": "Java"
            },
            {
                "id": 11254,
                "title": "seeking-for-a-better-solution",
                "content": "Is someone has a better solution? My code can get AC, but I don't think it's good enough. Thanks~~\\n \\n   \\n\\n    public class Solution {\\n            public ListNode swapPairs(ListNode head) {\\n                ListNode cur = head, next1, next2;\\n                if(head == null) return null;\\n                if(head.next == null) return head;\\n                \\n                //head change with next is a special case, so we deal with it first\\n                ListNode temp = cur.next;\\n                cur.next = temp.next;\\n                temp.next = cur;\\n                head = temp;\\n                \\n            \\twhile(cur.next != null && cur.next.next != null) {\\n            \\t\\tnext1 = cur.next;\\n            \\t\\tnext2 = cur.next.next;\\n            \\t\\tswap(cur,next1,next2);\\n            \\t\\tcur = cur.next.next;\\n            \\t}\\n            \\treturn head;\\n            }\\n            \\n            private void swap(ListNode cur, ListNode next1, ListNode next2) {\\n            \\tcur.next = next2;\\n            \\tnext1.next = next2.next;\\n            \\tnext2.next = next1;\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public ListNode swapPairs(ListNode head) {\\n                ListNode cur = head, next1, next2;\\n                if(head == null) return null;\\n                if(head.next == null) return head;\\n                \\n                //head change with next is a special case, so we deal with it first\\n                ListNode temp = cur.next;\\n                cur.next = temp.next;\\n                temp.next = cur;\\n                head = temp;\\n                \\n            \\twhile(cur.next != null && cur.next.next != null) {\\n            \\t\\tnext1 = cur.next;\\n            \\t\\tnext2 = cur.next.next;\\n            \\t\\tswap(cur,next1,next2);\\n            \\t\\tcur = cur.next.next;\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 2596746,
                "title": "straightforward-0ms-iterative-solution-with-comments",
                "content": "Introduced 2 macros to make the algo more clear: one taking .next node as reference, and one as mutable\\n\\n```\\nmacro_rules! next_node_as_ref {\\n    ($a: expr) => {\\n        $a.as_ref().unwrap().next\\n    };\\n}\\nmacro_rules! next_node_as_mut {\\n    ($a: expr) => {\\n        $a.as_mut().unwrap().next\\n    };\\n}\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut cur_node = &mut head;\\n\\n        // while we have something to work with (.next has something)\\n        while cur_node.is_some() && next_node_as_ref!(cur_node).is_some() {\\n            // .take() Takes the value out of the option, leaving a None in its place.\\n            let mut even_node = next_node_as_mut!(cur_node).take();\\n\\n            // taking next odd node\\'s value\\n            let next_odd_node = next_node_as_mut!(even_node).take();\\n            // cur_node\\'s .next points to next odd node\\n            next_node_as_mut!(cur_node) = next_odd_node;\\n            // even node\\'s .next points to cur_node\\n            next_node_as_mut!(even_node) = cur_node.take();\\n            // switching cur_node with even node\\n            cur_node.replace(even_node.unwrap());\\n            // point cursor to .next.next\\n            cur_node = &mut next_node_as_mut!(next_node_as_mut!(cur_node));\\n        }\\n        head\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nmacro_rules! next_node_as_ref {\\n    ($a: expr) => {\\n        $a.as_ref().unwrap().next\\n    };\\n}\\nmacro_rules! next_node_as_mut {\\n    ($a: expr) => {\\n        $a.as_mut().unwrap().next\\n    };\\n}\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        if head.is_none() {\\n            return None;\\n        }\\n        let mut cur_node = &mut head;\\n\\n        // while we have something to work with (.next has something)\\n        while cur_node.is_some() && next_node_as_ref!(cur_node).is_some() {\\n            // .take() Takes the value out of the option, leaving a None in its place.\\n            let mut even_node = next_node_as_mut!(cur_node).take();\\n\\n            // taking next odd node\\'s value\\n            let next_odd_node = next_node_as_mut!(even_node).take();\\n            // cur_node\\'s .next points to next odd node\\n            next_node_as_mut!(cur_node) = next_odd_node;\\n            // even node\\'s .next points to cur_node\\n            next_node_as_mut!(even_node) = cur_node.take();\\n            // switching cur_node with even node\\n            cur_node.replace(even_node.unwrap());\\n            // point cursor to .next.next\\n            cur_node = &mut next_node_as_mut!(next_node_as_mut!(cur_node));\\n        }\\n        head\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11132,
                "title": "very-simple-c-recursive-solution",
                "content": "    class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if (head == NULL || head->next == NULL) return head;\\n            ListNode *grandChild = swapPairs(head->next->next);\\n            ListNode *child = head->next;\\n            child->next = head;\\n            head->next = grandChild;\\n            return child;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        ListNode* swapPairs(ListNode* head) {\\n            if (head == NULL || head->next == NULL) return head;\\n            ListNode *grandChild = swapPairs(head->next->next);\\n            ListNode *child = head->next;\\n            child->next = head;\\n            head->next = grandChild;\\n            return child;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1788868,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode tHead = swapPairs(head.next.next);\\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode tHead = swapPairs(head.next.next);\\n        ListNode temp = head.next;\\n        head.next = tHead;\\n        temp.next = head;\\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1776487,
                "title": "javascript-time-o-n-space-o-1-simple-approach-with-explanation",
                "content": "1. Check if we have current and next Node or not.\\n2. Do simple swapping using temp variable.\\n3. Take a temporary variable and store value of first node into that.\\n4. Take value of second node and store in first node\\n5. Move to second node and replace value of second node by temp.\\n6. repeat the swapping till end of linked list.\\n\\n```\\nvar swapPairs = function(head) {\\n    let start = new ListNode();  // Taking a pointer for keeping head of linked list safe with us\\n    start = head;  // storing head into result as we\\'ll be updating head further.\\n    while(head != undefined && head.next != undefined){  //loop for itterating through linked list\\n        let temp = head.val;                              // swapping\\n        head.val = head.next.val;                     // swapping\\n        head = head.next;                               // swapping\\n        head.val = temp;                                // swapping\\n        head = head.next;                            // increasing the pointer to next element\\n    }\\n    return start;       // return the starting point of linked list as we modified the same linked list.\\n};\\n```\\n\\nFeel free to comment down if doubts on any steps.\\n\\n**Upvote** if helped.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    let start = new ListNode();  // Taking a pointer for keeping head of linked list safe with us\\n    start = head;  // storing head into result as we\\'ll be updating head further.\\n    while(head != undefined && head.next != undefined){  //loop for itterating through linked list\\n        let temp = head.val;                              // swapping\\n        head.val = head.next.val;                     // swapping\\n        head = head.next;                               // swapping\\n        head.val = temp;                                // swapping\\n        head = head.next;                            // increasing the pointer to next element\\n    }\\n    return start;       // return the starting point of linked list as we modified the same linked list.\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517929,
                "title": "c-two-soltn-0-ms-faster-than-100-00",
                "content": "**Soln 1**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(head==0)\\n            return NULL;\\n        if(head->next==0)\\n            return head;\\n        \\n        \\n        ListNode *first=head;\\n        ListNode *second=first->next;\\n        ListNode *newhead=second;\\n        ListNode *prev=first;\\n        while(first && second)\\n        {\\n            prev=first;\\n            first->next=second->next;\\n            second->next=prev;\\n            \\n            first=first->next;\\n            if(first!=0 && first->next!=0)\\n             second=first->next;\\n            else\\n                break;\\n            prev->next=second;\\n            \\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```\\n\\n**Soln 2**\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        ListNode *temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode *curr=temp;\\n        \\n        while(curr->next && curr->next->next)\\n        {\\n            ListNode *first=curr->next;\\n            ListNode *second=curr->next->next;\\n            first->next=second->next;\\n            second->next=first;\\n            curr->next=second;\\n            curr=curr->next->next;\\n        }\\n        return temp->next;\\n        \\n    }\\n};\\n```\\n\\nIf you find any issue in understanding the solutions then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(head==0)\\n            return NULL;\\n        if(head->next==0)\\n            return head;\\n        \\n        \\n        ListNode *first=head;\\n        ListNode *second=first->next;\\n        ListNode *newhead=second;\\n        ListNode *prev=first;\\n        while(first && second)\\n        {\\n            prev=first;\\n            first->next=second->next;\\n            second->next=prev;\\n            \\n            first=first->next;\\n            if(first!=0 && first->next!=0)\\n             second=first->next;\\n            else\\n                break;\\n            prev->next=second;\\n            \\n        }\\n        return newhead;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        ListNode *temp=new ListNode(0);\\n        temp->next=head;\\n        ListNode *curr=temp;\\n        \\n        while(curr->next && curr->next->next)\\n        {\\n            ListNode *first=curr->next;\\n            ListNode *second=curr->next->next;\\n            first->next=second->next;\\n            second->next=first;\\n            curr->next=second;\\n            curr=curr->next->next;\\n        }\\n        return temp->next;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549794,
                "title": "3-solutions-easy-to-understand-faster-2-iterative-and-1-recursive-python",
                "content": "```\\ndef recursive(self, head):\\n        def rec(head):\\n            if head and head.next:\\n                rep = rec(head.next.next)\\n                second = head.next\\n                first = head\\n                if second:\\n                    first.next = rep\\n                    second.next = first\\n                    return second\\n                return first\\n            elif head: return head\\n            \\n        return rec(head)\\n    \\n    def in_place_nodes(self, head):\\n        if not head: return head\\n        prev = None\\n        first = head\\n        second = head.next\\n        while first and second:\\n            if prev:\\n                prev.next = second\\n            else:\\n                head = second\\n            forward = second.next\\n            first.next = second.next\\n            second.next = first\\n            prev = first\\n            first = forward\\n            if not first: break\\n            second = first.next\\n        return head\\n    \\n        \\n    def in_place_value(self, head):\\n        if not head: return head\\n        first = head\\n        second = head.next\\n        while first and second:\\n            first.val, second.val = second.val, first.val\\n            first = second.next\\n            if not first: break\\n            second = second.next.next\\n        return head\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef recursive(self, head):\\n        def rec(head):\\n            if head and head.next:\\n                rep = rec(head.next.next)\\n                second = head.next\\n                first = head\\n                if second:\\n                    first.next = rep\\n                    second.next = first\\n                    return second\\n                return first\\n            elif head: return head\\n            \\n        return rec(head)\\n    \\n    def in_place_nodes(self, head):\\n        if not head: return head\\n        prev = None\\n        first = head\\n        second = head.next\\n        while first and second:\\n            if prev:\\n                prev.next = second\\n            else:\\n                head = second\\n            forward = second.next\\n            first.next = second.next\\n            second.next = first\\n            prev = first\\n            first = forward\\n            if not first: break\\n            second = first.next\\n        return head\\n    \\n        \\n    def in_place_value(self, head):\\n        if not head: return head\\n        first = head\\n        second = head.next\\n        while first and second:\\n            first.val, second.val = second.val, first.val\\n            first = second.next\\n            if not first: break\\n            second = second.next.next\\n        return head\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 11078,
                "title": "easy-understand-3-lines-solutions-with-comments",
                "content": "before '=': the first node, the second and  the third node\\nafter '='   : the second node, the first  and  the third node returned by recursion.\\n\\n```\\ndef swapPairs(self, head):\\n        if head and head.next:\\n            head, head.next, head.next.next = head.next, head, self.swapPairs(head.next.next)\\n        return head",
                "solutionTags": [],
                "code": "before '=': the first node, the second and  the third node\\nafter '='   : the second node, the first  and  the third node returned by recursion.\\n\\n```\\ndef swapPairs(self, head):\\n        if head and head.next:\\n            head, head.next, head.next.next = head.next, head, self.swapPairs(head.next.next)\\n        return head",
                "codeTag": "Python3"
            },
            {
                "id": 11204,
                "title": "java-recursive-and-iterative-solutions",
                "content": "        \\n    // recursively \\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode nxt = head.next;\\n        head.next = swapPairs(nxt.next);\\n        nxt.next = head;\\n        return nxt;\\n    }\\n    \\n    // iteratively\\n    public ListNode swapPairs1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode pre = new ListNode(0), p = head, ret = head.next;\\n        while (p != null && p.next != null) {\\n            ListNode nxt = p.next;\\n            p.next = nxt.next;\\n            nxt.next = p;\\n            pre.next = nxt;\\n            pre = p;\\n            p = p.next;\\n        }\\n        return ret;\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "        \\n    // recursively \\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode nxt = head.next;\\n        head.next = swapPairs(nxt.next);\\n        nxt.next = head;\\n        return nxt;\\n    }\\n    \\n    // iteratively\\n    public ListNode swapPairs1(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }\\n        ListNode pre = new ListNode(0), p = head, ret = head.next;\\n        while (p != null && p.next != null) {\\n            ListNode nxt = p.next;\\n            p.next = nxt.next;\\n            nxt.next = p;\\n            pre.next = nxt;\\n            pre = p;\\n            p = p.next;\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2774348,
                "title": "in-o-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }\\n    head=y;\\n    while(z!=NULL && z->next!=NULL)\\n    {\\n        y->next=x;\\n        x->next=z->next;\\n        x=z;\\n        y=x->next;\\n        z=y->next;\\n    }\\n    y->next=x;\\n    x->next=z;\\n    return head;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n    return head;\\n    struct ListNode*x,*y,*z=NULL;\\n    x=head;\\n    y=head->next;\\n    if(head->next->next!=NULL)\\n    {\\n        z=head->next->next;\\n    }\\n    head=y;\\n    while(z!=NULL && z->next!=NULL)\\n    {\\n        y->next=x;\\n        x->next=z->next;\\n        x=z;\\n        y=x->next;\\n        z=y->next;\\n    }\\n    y->next=x;\\n    x->next=z;\\n    return head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775417,
                "title": "iterative-solution-with-tuples-and-no-recursion",
                "content": "Pointer swapping can be done in a modern way using tuples:\\n```csharp\\npublic class Solution\\n{\\n    public ListNode SwapPairs(ListNode head)\\n    {\\n        ListNode prev = new();\\n        var a = head;\\n        var b = head?.next;\\n\\n        head = b ?? a;\\n\\n        while (a != null && b != null)\\n        {\\n            (prev.next, a.next, b.next) = (b, b.next, a); //swap the nodes\\n            (prev, a, b) = (a, a.next, a.next?.next); //move on\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Iterator"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public ListNode SwapPairs(ListNode head)\\n    {\\n        ListNode prev = new();\\n        var a = head;\\n        var b = head?.next;\\n\\n        head = b ?? a;\\n\\n        while (a != null && b != null)\\n        {\\n            (prev.next, a.next, b.next) = (b, b.next, a); //swap the nodes\\n            (prev, a, b) = (a, a.next, a.next?.next); //move on\\n        }\\n\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1233188,
                "title": "my-simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head)return head;\\n        if(!head->next)return head;\\n        ListNode temp(0);\\n        temp.next = head;\\n        ListNode* current = &temp;\\n        while(current->next!=NULL && current->next->next!=NULL){\\n            ListNode* first = current->next;\\n            ListNode* second = current->next->next;\\n            first->next = second->next;\\n            current->next = second;\\n            current->next->next = first;\\n            current = current->next->next;\\n        }\\n        return temp.next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head)return head;\\n        if(!head->next)return head;\\n        ListNode temp(0);\\n        temp.next = head;\\n        ListNode* current = &temp;\\n        while(current->next!=NULL && current->next->next!=NULL){\\n            ListNode* first = current->next;\\n            ListNode* second = current->next->next;\\n            first->next = second->next;\\n            current->next = second;\\n            current->next->next = first;\\n            current = current->next->next;\\n        }\\n        return temp.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231784,
                "title": "javascript-recursion-solution",
                "content": "```\\nvar swapPairs = function(head) {\\n  // base case\\n  if (head === null || head.next === null) return head;\\n  let temp = head.next;\\n  head.next = temp.next;\\n  temp.next = head;\\n  head.next = swapPairs(head.next);\\n  return temp;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar swapPairs = function(head) {\\n  // base case\\n  if (head === null || head.next === null) return head;\\n  let temp = head.next;\\n  head.next = temp.next;\\n  temp.next = head;\\n  head.next = swapPairs(head.next);\\n  return temp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11094,
                "title": "simple-0ms-c-solution-beats-98-08",
                "content": "All we need to do is rearrange the links in the list.If <b>prev </b> is the pevious node,<b> head </b> is the current node,at every alternate node perform operations such that <br>\\nInitial:           prev | head | head->next|head->next->next\\nAfter swap:prev|head->next|head|head->next->next\\n\\n```\\n ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        while(head &&head->next)\\n        {\\n            ListNode* nn=head->next->next;\\n            prev->next=head->next;\\n            head->next->next=head;\\n            head->next=nn;\\n            prev=head;\\n            head=nn;\\n           \\n        }\\n        return dummy->next;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        while(head &&head->next)\\n        {\\n            ListNode* nn=head->next->next;\\n            prev->next=head->next;\\n            head->next->next=head;\\n            head->next=nn;\\n            prev=head;\\n            head=nn;\\n           \\n        }\\n        return dummy->next;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11266,
                "title": "python-solution-using-36ms-with-simple-method",
                "content": "\\nclass Solution(object):\\n\\n    def swapPairs(self, head):\\n\\n        if not head or not head.next:\\n            return head\\n      \\n        first,second = head, head.next\\n        third = second.next\\n        head = second\\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        \\n        return head",
                "solutionTags": [],
                "code": "\\nclass Solution(object):\\n\\n    def swapPairs(self, head):\\n\\n        if not head or not head.next:\\n            return head\\n      \\n        first,second = head, head.next\\n        third = second.next\\n        head = second\\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        \\n        return head",
                "codeTag": "Java"
            },
            {
                "id": 3532106,
                "title": "5-lines-0ms-easy-approach-beasts-100-stepped-explanation",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are using a very simple and easy ***recursive*** approach to solve this\\n\\n\\n**Steps:**\\n\\n1. At first we will check, if head value is null we will return null.\\n\\n    `if(head==null) return null;`\\n2. Then we check, if next head value is null we will return current head.\\n\\n    `if (head.next == null) return head;`\\n3. Later we will swap the 2 value of by creating a temp variable & recursively swapping the values.\\n    \\n    - Storing the next head to a temp ListNode that we will return at last. `ListNode temp = head.next;`\\n    - Then we  get the call the function recursively for next head. \\n     `head.next = swapPairs(temp.next);`\\n    - Then we swap value next temp with the head.\\n     `temp.next = head;`\\n4. At last we will return the temp ListNode we created .\\n \\n    `return temp;`\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if (head.next == null) return head;\\n\\n        ListNode temp = head.next;\\n        head.next = swapPairs(temp.next);\\n        temp.next = head;\\n\\n        return temp;\\n    }\\n}\\n```\\n\\n<!-- ---\\n**Iterative** \\n```\\npublic ListNode swapPairs1(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode pre = new ListNode(0), p = head, ret = head.next;\\n    while (p != null && p.next != null) {\\n        ListNode nxt = p.next;\\n        p.next = nxt.next;\\n        nxt.next = p;\\n        pre.next = nxt;\\n        pre = p;\\n        p = p.next;\\n    }\\n    return ret;\\n}\\n``` -->\\n\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e835e6d0-5193-493a-9394-e4e90c90e1b0_1684266894.6208477.jpeg)\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if(head==null) return null;\\n        if (head.next == null) return head;\\n\\n        ListNode temp = head.next;\\n        head.next = swapPairs(temp.next);\\n        temp.next = head;\\n\\n        return temp;\\n    }\\n}\\n```\n```\\npublic ListNode swapPairs1(ListNode head) {\\n    if (head == null || head.next == null) {\\n        return head;\\n    }\\n    ListNode pre = new ListNode(0), p = head, ret = head.next;\\n    while (p != null && p.next != null) {\\n        ListNode nxt = p.next;\\n        p.next = nxt.next;\\n        nxt.next = p;\\n        pre.next = nxt;\\n        pre = p;\\n        p = p.next;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530416,
                "title": "c-recursive-solution-to-swap-nodes-in-pairs-dlc-16-05-2023-all-testcases-passed",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst intuition that comes to mind is that swap the pairs of nodes and modify the next pointers for each pair of nodes.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe basic ideology of recursion\\n\"Solve the first case, other cases will be handled by Recursion.\"\\n\\nHere, solve for the first pair of nodes, i.e., swap the first two nodes and modify their next pointers. First node will now point to the node where second node was pointing to and second node will point to the first node.\\n\\nCall the function recursively and store the head (first) node of the remaining part of the linked list in the next pointer of the first node.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next==NULL){\\n            return head;\\n        }\\n\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head->next;\\n\\n        temp1->next = temp2->next;\\n        temp2->next = temp1;\\n\\n        if (temp1->next!=NULL){\\n            temp1->next = swapPairs(temp1->next);\\n        }\\n\\n        return temp2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next==NULL){\\n            return head;\\n        }\\n\\n        ListNode* temp1 = head;\\n        ListNode* temp2 = head->next;\\n\\n        temp1->next = temp2->next;\\n        temp2->next = temp1;\\n\\n        if (temp1->next!=NULL){\\n            temp1->next = swapPairs(temp1->next);\\n        }\\n\\n        return temp2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471758,
                "title": "c-very-easy-solution-100-beat",
                "content": "\\nclass Solution {\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case \\n        if(head == NULL){\\n            return NULL;\\n        }\\n        \\n        ListNode* forward = NULL;\\n        ListNode* prev = NULL;\\n        ListNode* curr = head;\\n        int count = 0;\\n        while(curr != NULL && count < 2){\\n             forward = curr->next;\\n            curr->next = prev;\\n            prev = curr;\\n            curr = forward;\\n            count++;\\n        }\\n        \\n        if(forward != NULL){\\n            head->next = swapPairs(forward);\\n        }\\n        //sb hogya abb return krde \\n        return prev;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case \\n        if(head == NULL){\\n            return NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3310367,
                "title": "java-three-line-solution-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ni have used basic concept of linkedlist and recursive call\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode prv=head;\\n        ListNode curr=head.next;\\n        ListNode next=head.next.next;\\n        head=curr;\\n        head.next=prv;\\n        head.next.next=swapPairs(next);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode prv=head;\\n        ListNode curr=head.next;\\n        ListNode next=head.next.next;\\n        head=curr;\\n        head.next=prv;\\n        head.next.next=swapPairs(next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430680,
                "title": "c-code-without-finding-length-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* hp = head;\\n        int x = 0;\\n        while(hp!=nullptr && hp->next!=nullptr){\\n            if(x%2==0){\\n              swap(hp->val , hp->next->val);\\n            }\\n            x++;\\n            hp = hp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* hp = head;\\n        int x = 0;\\n        while(hp!=nullptr && hp->next!=nullptr){\\n            if(x%2==0){\\n              swap(hp->val , hp->next->val);\\n            }\\n            x++;\\n            hp = hp->next;\\n        }\\n        return head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795879,
                "title": "simple-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode *prev = dummy, *cur = head;\\n\\n        while(cur && cur->next) {\\n        \\t// save pointers\\n        \\tListNode* nxtPair = cur->next->next;\\n        \\tListNode* second = cur->next;\\n\\n        \\t// reverse this pair\\n        \\tsecond->next = cur;\\n        \\tcur->next = nxtPair;\\n        \\tprev->next = second;\\n\\n        \\t// update pointers\\n        \\tprev = cur;\\n        \\tcur = nxtPair;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode(0, head);\\n        ListNode *prev = dummy, *cur = head;\\n\\n        while(cur && cur->next) {\\n        \\t// save pointers\\n        \\tListNode* nxtPair = cur->next->next;\\n        \\tListNode* second = cur->next;\\n\\n        \\t// reverse this pair\\n        \\tsecond->next = cur;\\n        \\tcur->next = nxtPair;\\n        \\tprev->next = second;\\n\\n        \\t// update pointers\\n        \\tprev = cur;\\n        \\tcur = nxtPair;\\n        }\\n\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774481,
                "title": "c-recursive-solutions-faster-than-100-00-of-submissions",
                "content": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n      if(head==NULL || head->next == NULL)\\n            return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next);\\n        temp->next = head;\\n        return temp;  \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n      if(head==NULL || head->next == NULL)\\n            return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next);\\n        temp->next = head;\\n        return temp;  \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1133526,
                "title": "js-iterative-and-recursive-w-explanation",
                "content": "Iterative Method\\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    // create a dummy to keep track of the new linked list\\n    let dummy = new ListNode(0, null)\\n    // tail would keep track of the dummy and move as it link more nodes\\n    let tail = dummy\\n    \\n    while (head != null && head.next != null) {\\n        let currHead = head\\n        let nextHead = head.next\\n        let skipHead = head.next.next    \\n        \\n        // reverse the second node with the first node\\n        nextHead.next = currHead\\n        currHead.next = null\\n        \\n        // nextHead = [2,1]\\n        tail.next = nextHead\\n        // dummy = [0,2,1] so tail = [1]\\n        tail = tail.next.next\\n        // point the head to the next part so it can reverse and repeat again\\n        head = skipHead\\n    }\\n    \\n    // this is for odd amount of nodes\\n    // since previous is tail.next = nextHead, which skips 2\\n    // for even, it won\\'t affect it\\n    tail.next = head\\n    \\n    // dummy.next holds the newly reversed linked list\\n    return dummy.next\\n};\\n```\\n\\n\\nRecursive Method\\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    let currHead = head\\n    let nextHead = head.next\\n    let skipHead = head.next.next\\n    \\n    // relink the second node to the first node\\n    nextHead.next = currHead\\n    \\n    // the firstNode\\'s next would be the result of the swap\\n    currHead.next = swapPairs(skipHead)\\n    \\n    // nextHead targets the 2nd node, which would be the first node if it reversed\\n    return nextHead\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    // create a dummy to keep track of the new linked list\\n    let dummy = new ListNode(0, null)\\n    // tail would keep track of the dummy and move as it link more nodes\\n    let tail = dummy\\n    \\n    while (head != null && head.next != null) {\\n        let currHead = head\\n        let nextHead = head.next\\n        let skipHead = head.next.next    \\n        \\n        // reverse the second node with the first node\\n        nextHead.next = currHead\\n        currHead.next = null\\n        \\n        // nextHead = [2,1]\\n        tail.next = nextHead\\n        // dummy = [0,2,1] so tail = [1]\\n        tail = tail.next.next\\n        // point the head to the next part so it can reverse and repeat again\\n        head = skipHead\\n    }\\n    \\n    // this is for odd amount of nodes\\n    // since previous is tail.next = nextHead, which skips 2\\n    // for even, it won\\'t affect it\\n    tail.next = head\\n    \\n    // dummy.next holds the newly reversed linked list\\n    return dummy.next\\n};\\n```\n```\\nvar swapPairs = function(head) {\\n    if (head == null || head.next == null) return head\\n    \\n    let currHead = head\\n    let nextHead = head.next\\n    let skipHead = head.next.next\\n    \\n    // relink the second node to the first node\\n    nextHead.next = currHead\\n    \\n    // the firstNode\\'s next would be the result of the swap\\n    currHead.next = swapPairs(skipHead)\\n    \\n    // nextHead targets the 2nd node, which would be the first node if it reversed\\n    return nextHead\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717219,
                "title": "go-golang-two-solutions",
                "content": ">Runtime: 0 ms, faster than 100.00% of Go online submissions for Swap Nodes in Pairs.\\nMemory Usage: 2.1 MB, less than 13.25% of Go online submissions for Swap Nodes in Pairs.\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    ans := &ListNode{0, head}\\n    dummy := ans\\n    for dummy.Next != nil && dummy.Next.Next != nil {\\n        a := dummy.Next\\n        b := dummy.Next.Next\\n        a.Next = b.Next\\n        dummy.Next = b\\n        dummy.Next.Next = a\\n        dummy = dummy.Next.Next\\n    }\\n    return ans.Next\\n}\\n```\\n\\n>Runtime: 0 ms, faster than 100.00% of Go online submissions for Swap Nodes in Pairs.\\nMemory Usage: 2.1 MB, less than 99.40% of Go online submissions for Swap Nodes in Pairs.\\n\\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil { return head }\\n    tmp := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    tmp.Next = head\\n    return tmp\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    ans := &ListNode{0, head}\\n    dummy := ans\\n    for dummy.Next != nil && dummy.Next.Next != nil {\\n        a := dummy.Next\\n        b := dummy.Next.Next\\n        a.Next = b.Next\\n        dummy.Next = b\\n        dummy.Next.Next = a\\n        dummy = dummy.Next.Next\\n    }\\n    return ans.Next\\n}\\n```\n```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil { return head }\\n    tmp := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    tmp.Next = head\\n    return tmp\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 580838,
                "title": "python-js-java-c-o-n-recursive-sol-w-visualization",
                "content": "Python/Java/JS/C++ O(n) recusrion sol.\\n\\n[Tutorial video to Swap nodes in pairs [ Chinese \\u4E2D\\u6587\\u8B1B\\u89E3\\u5F71\\u7247]](https://youtu.be/DIHuNQ-PQZg)\\n\\n---\\n\\n**Visualization**\\n\\n1. Reverse next node linkage\\n```\\nnext_node.next = node\\n```\\n  \\n2. Update node linkage to next pair\\n```\\nnode.next = helper( next_pair)\\n```\\n![image.png](https://assets.leetcode.com/users/images/b903dd7c-983c-44c2-8166-289928c97fff_1684213084.129816.png)\\n\\n\\n---\\n\\n**Hint**:\\n\\nRecurvisely reverse each pair and build new linkage between reversed pairs.\\n\\n---\\n\\n**Implementation** by Python:\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        cur = head\\n               \\n        try:\\n            \\n            # locate head of next pair\\n            next_pair = cur.next.next\\n            \\n            # reverse next pair\\n            junction = self.swapPairs( next_pair )\\n            \\n            # reverse current pair\\n            original_next = cur.next\\n            \\n            original_next.next = cur\\n            \\n            # build new linkage from current pair to next pair\\n            cur.next = junction\\n            \\n            return original_next\\n            \\n        except:\\n            \\n            # Base case:\\n            # Either one node or None remaining\\n            return cur\\n\\n```\\n\\n---\\n\\nShare another implementation:\\n\\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def helper( node ):\\n\\n            # Base case: empty node, or only one node\\n            if not node or not node.next:\\n                return node\\n\\n\\n            # General case:\\n            next_node = node.next\\n            next_pair = next_node.next\\n\\n            # Reverse next node linkage\\n            next_node.next = node\\n\\n            # Update node linkage to next pair\\n            node.next = helper( next_pair)\\n\\n            # return new head after swap\\n            return next_node\\n        \\n        # ------------------------------\\n\\n        return helper( head )\\n```\\n\\n---\\n\\n**Implementation** by Java:\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if( head == null || head.next == null){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original pointer\\n        ListNode right = head.next;\\n        ListNode nextHop = right.next;\\n        \\n        // reverse linkage of current pair\\n        right.next = head;\\n            \\n        // reverse next pair and get the node of current head\\'s next node\\n        head.next = swapPairs( nextHop );\\n            \\n        return right;\\n        \\n    }\\n}\\n```\\n\\n---\\n\\n**Implementation** by C++\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if( head == nullptr || head->next == nullptr ){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original node\\n        ListNode *right = head->next, *nextPair = head->next->next;\\n        \\n        // reverse current pair\\n        right->next = head;\\n        \\n        // swap next pair recursively\\n        head->next = swapPairs( nextPair );\\n        \\n        return right;\\n        \\n    }\\n};\\n```\\n\\n---\\n\\n**Implementation** by Javascript:\\n\\n```\\nvar swapPairs = function(head) {\\n    \\n    if( head == null || head.next == null ){\\n        \\n        // Base case aka stop condition\\n        return head;\\n    }\\n    \\n    // General cases:\\n    let [right, nextPair] = [head.next, head.next.next];\\n    \\n    // Reverse current pair\\n    right.next = head;\\n    \\n    // Reverse next pair recursively\\n    head.next = swapPairs( nextPair );\\n    \\n    return right;\\n    \\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nnext_node.next = node\\n```\n```\\nnode.next = helper( next_pair)\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        cur = head\\n               \\n        try:\\n            \\n            # locate head of next pair\\n            next_pair = cur.next.next\\n            \\n            # reverse next pair\\n            junction = self.swapPairs( next_pair )\\n            \\n            # reverse current pair\\n            original_next = cur.next\\n            \\n            original_next.next = cur\\n            \\n            # build new linkage from current pair to next pair\\n            cur.next = junction\\n            \\n            return original_next\\n            \\n        except:\\n            \\n            # Base case:\\n            # Either one node or None remaining\\n            return cur\\n\\n```\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        def helper( node ):\\n\\n            # Base case: empty node, or only one node\\n            if not node or not node.next:\\n                return node\\n\\n\\n            # General case:\\n            next_node = node.next\\n            next_pair = next_node.next\\n\\n            # Reverse next node linkage\\n            next_node.next = node\\n\\n            # Update node linkage to next pair\\n            node.next = helper( next_pair)\\n\\n            # return new head after swap\\n            return next_node\\n        \\n        # ------------------------------\\n\\n        return helper( head )\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        if( head == null || head.next == null){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original pointer\\n        ListNode right = head.next;\\n        ListNode nextHop = right.next;\\n        \\n        // reverse linkage of current pair\\n        right.next = head;\\n            \\n        // reverse next pair and get the node of current head\\'s next node\\n        head.next = swapPairs( nextHop );\\n            \\n        return right;\\n        \\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if( head == nullptr || head->next == nullptr ){\\n            \\n            // base case aka stop condition\\n            return head;\\n        }\\n        \\n        // backup original node\\n        ListNode *right = head->next, *nextPair = head->next->next;\\n        \\n        // reverse current pair\\n        right->next = head;\\n        \\n        // swap next pair recursively\\n        head->next = swapPairs( nextPair );\\n        \\n        return right;\\n        \\n    }\\n};\\n```\n```\\nvar swapPairs = function(head) {\\n    \\n    if( head == null || head.next == null ){\\n        \\n        // Base case aka stop condition\\n        return head;\\n    }\\n    \\n    // General cases:\\n    let [right, nextPair] = [head.next, head.next.next];\\n    \\n    // Reverse current pair\\n    right.next = head;\\n    \\n    // Reverse next pair recursively\\n    head.next = swapPairs( nextPair );\\n    \\n    return right;\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 273702,
                "title": "python-solution-in-place",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head and head.next:\\n            dummy = head\\n            head = head.next\\n            dummy.next = head.next\\n            head.next = dummy\\n            head.next.next = self.swapPairs(head.next.next)\\n        return head\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if head and head.next:\\n            dummy = head\\n            head = head.next\\n            dummy.next = head.next\\n            head.next = dummy\\n            head.next.next = self.swapPairs(head.next.next)\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 11194,
                "title": "java-recursive-and-iterative-solutions-both-cost-0ms",
                "content": "Recursive:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn head;\\n    \\t\\tListNode p1 = head, p2 = head.next, p3 = p2.next;\\n    \\t\\tp1.next = p3;\\n    \\t\\tp2.next = p1;\\n    \\t\\t\\n    \\t\\tif (p3 != null) {\\n    \\t\\t\\tp1.next = swapPairs(p3);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn p2;\\n    \\t}\\n\\nIterative:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn head;\\n    \\t\\tListNode curr = head;\\n    \\t\\tListNode next = head.next;\\n    \\t\\tListNode newHead = next;\\n    \\t\\t\\n    \\t\\tcurr.next = next.next;\\n    \\t\\tnext.next = curr;\\n    \\t\\t\\n    \\t\\tif (curr.next == null)\\n    \\t\\t\\treturn newHead;\\n    \\t\\t\\n    \\t\\twhile (curr.next.next != null) {\\n    \\t\\t\\tListNode prev = curr;\\n    \\t\\t\\tcurr = curr.next;\\n    \\t\\t\\tnext = curr.next;\\n    \\t\\t\\n    \\t\\t\\tprev.next = next;\\n    \\t\\t\\tcurr.next = next.next;\\n    \\t\\t\\tnext.next = curr;\\n    \\t\\t\\t\\n    \\t\\t\\tif (curr.next == null || curr.next.next == null)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn newHead;\\n    \\t}",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "Recursive:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null) \\n    \\t\\t\\treturn head;\\n    \\t\\tListNode p1 = head, p2 = head.next, p3 = p2.next;\\n    \\t\\tp1.next = p3;\\n    \\t\\tp2.next = p1;\\n    \\t\\t\\n    \\t\\tif (p3 != null) {\\n    \\t\\t\\tp1.next = swapPairs(p3);\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn p2;\\n    \\t}\\n\\nIterative:\\n\\n    public ListNode swapPairs(ListNode head) {\\n    \\t\\tif (head == null || head.next == null)\\n    \\t\\t\\treturn head;\\n    \\t\\tListNode curr = head;\\n    \\t\\tListNode next = head.next;\\n    \\t\\tListNode newHead = next;\\n    \\t\\t\\n    \\t\\tcurr.next = next.next;\\n    \\t\\tnext.next = curr;\\n    \\t\\t\\n    \\t\\tif (curr.next == null)\\n    \\t\\t\\treturn newHead;\\n    \\t\\t\\n    \\t\\twhile (curr.next.next != null) {\\n    \\t\\t\\tListNode prev = curr;\\n    \\t\\t\\tcurr = curr.next;\\n    \\t\\t\\tnext = curr.next;\\n    \\t\\t\\n    \\t\\t\\tprev.next = next;\\n    \\t\\t\\tcurr.next = next.next;\\n    \\t\\t\\tnext.next = curr;\\n    \\t\\t\\t\\n    \\t\\t\\tif (curr.next == null || curr.next.next == null)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t\\t\\t\\n    \\t\\t}\\n    \\t\\t\\n    \\t\\treturn newHead;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 11267,
                "title": "c-solution-easy-to-understand-with-comments-and-explanations",
                "content": "<h1>Renewed Solution</h1>\\n\\nThe main point is that if there are 2 more nodes (which is a pair) following, then swap them, otherwise, end the process.\\n\\n    bool SwapHelper(ListNode *p)\\n    {\\n        if (p->next and p->next->next)\\n        {\\n            ListNode *n1 = p->next;\\n            ListNode *n2 = p->next->next;\\n            \\n            p->next = n2;\\n            n1->next = n2->next;\\n            n2->next = n1;\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    ListNode *swapPairs(ListNode *head) \\n    {\\n        if (!head) \\n            return nullptr;\\n        \\n        // Create a head Node\\n        ListNode new_head(-1);\\n        new_head.next = head;\\n        \\n        ListNode *p = &new_head;\\n        \\n        // While has two more node and swap succeeded\\n        while (SwapHelper(p)) \\n            p = p->next->next;\\n        \\n        return new_head.next;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "<h1>Renewed Solution</h1>\\n\\nThe main point is that if there are 2 more nodes (which is a pair) following, then swap them, otherwise, end the process.\\n\\n    bool SwapHelper(ListNode *p)\\n    {\\n        if (p->next and p->next->next)\\n        {\\n            ListNode *n1 = p->next;\\n            ListNode *n2 = p->next->next;\\n            \\n            p->next = n2;\\n            n1->next = n2->next;\\n            n2->next = n1;\\n            \\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n\\n    ListNode *swapPairs(ListNode *head) \\n    {\\n        if (!head) \\n            return nullptr;\\n        \\n        // Create a head Node\\n        ListNode new_head(-1);\\n        new_head.next = head;\\n        \\n        ListNode *p = &new_head;\\n        \\n        // While has two more node and swap succeeded\\n        while (SwapHelper(p)) \\n            p = p->next->next;\\n        \\n        return new_head.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3529195,
                "title": "easy-java-solution-with-explanation-beating-100-in-tc",
                "content": "# Please Upvote!!!\\n\\n\\n![Screenshot 2023-05-16 at 09.08.07.png](https://assets.leetcode.com/users/images/6223796e-4c86-4b23-8b51-880f70453355_1684208465.7977593.png)\\n\\n\\n\\n# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo swap every two adjacent nodes in a linked list without modifying the node values, you can manipulate the pointers of the nodes. Here\\'s an algorithm to solve the problem:\\n\\nInitialize a dummy node and set its next pointer to the head of the given linked list. This dummy node will be useful as the new head of the modified list.\\nInitialize three pointers: prev, curr, and next. Set prev to the dummy node and curr to the head of the list.\\nIterate through the list while curr and curr.next are not null:\\nSet next to curr.next.\\nPoint curr.next to next.next.\\nPoint next.next to curr.\\nPoint prev.next to next.\\nMove prev to curr.\\nMove curr to curr.next.\\nReturn the modified list\\'s head, which is the dummy node\\'s next node.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode nodeSlow = null, nodeFast = head.next;\\n        ListNode temp = head;\\n        temp.next = nodeFast.next;\\n        nodeFast.next = temp;\\n        head = nodeFast;\\n        nodeFast = nodeFast.next;\\n        nodeSlow = head;\\n        while(nodeFast.next!=null){\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n\\n            if(nodeFast.next!=null) {\\n                nodeSlow.next = nodeFast.next;\\n                temp = nodeFast.next.next;\\n                nodeSlow.next.next = nodeFast;\\n                nodeFast.next = temp;\\n                nodeSlow = nodeSlow.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null||head.next==null){\\n            return head;\\n        }\\n        ListNode nodeSlow = null, nodeFast = head.next;\\n        ListNode temp = head;\\n        temp.next = nodeFast.next;\\n        nodeFast.next = temp;\\n        head = nodeFast;\\n        nodeFast = nodeFast.next;\\n        nodeSlow = head;\\n        while(nodeFast.next!=null){\\n            nodeSlow = nodeSlow.next;\\n            nodeFast = nodeFast.next;\\n\\n            if(nodeFast.next!=null) {\\n                nodeSlow.next = nodeFast.next;\\n                temp = nodeFast.next.next;\\n                nodeSlow.next.next = nodeFast;\\n                nodeFast.next = temp;\\n                nodeSlow = nodeSlow.next;\\n            }\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528787,
                "title": "c-best-shortest-3-lines-solution-beats-100-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nStart\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nCheck if the linked list is empty or has only one node. If so, return the head of the linked list. \\n\\nOtherwise, create a pointer next to the second node in the linked list.\\n\\nSet the next pointer of the first node to the result of recursively calling swapPairs on the third node (if it exists) and beyond.\\n\\nSet the next pointer of the next node to the first node.\\nReturn the next node as the new head of the linked list.\\nDone !!!!\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if (!head || !head->next) {\\n        return head;\\n    }\\n    ListNode* next = head->next;\\n    head->next = swapPairs(next->next);\\n    next->next = head;\\n    return next;\\n}\\n\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/ab237660-fad0-4f6c-b23d-642be5c4aa75_1684195692.93272.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion",
                    "Doubly-Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if (!head || !head->next) {\\n        return head;\\n    }\\n    ListNode* next = head->next;\\n    head->next = swapPairs(next->next);\\n    next->next = head;\\n    return next;\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528782,
                "title": "java-recursion-beats-100-12-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Recursively traverse the list to the end.\\n2. On the way back return every node at an even number position.\\n3. Update the `next` pointers for nodes at odd and even positions with their own logic.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ on the stack\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int cnt = 0;\\n\\n  public ListNode swapPairs(ListNode node) {\\n    if (node == null) return null;\\n\\n    cnt++;\\n    var ret = swapPairs(node.next);\\n\\n    if (cnt % 2 == 1 && ret != null) {\\n      // node -> the first (left) node in each pair\\n      node.next = ret.next;\\n      ret.next = node;\\n    } else {\\n      // node -> the second (right) node in each pair\\n      node.next = ret;\\n      ret = node;\\n    }\\n    cnt--;\\n    return ret;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  int cnt = 0;\\n\\n  public ListNode swapPairs(ListNode node) {\\n    if (node == null) return null;\\n\\n    cnt++;\\n    var ret = swapPairs(node.next);\\n\\n    if (cnt % 2 == 1 && ret != null) {\\n      // node -> the first (left) node in each pair\\n      node.next = ret.next;\\n      ret.next = node;\\n    } else {\\n      // node -> the second (right) node in each pair\\n      node.next = ret;\\n      ret = node;\\n    }\\n    cnt--;\\n    return ret;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142432,
                "title": "c-solution-easy-to-understand-recursion",
                "content": "# Intuition\\nA pretty simple approach using recursion\\n\\n# Approach\\n1. We have to keep in mind that while swapping, we are only working with two nodes at a time.\\n2. I have written the swapping steps under the comment in the code. Take a piece of paper and try to dry run it on two nodes, You will get it.\\n3. Now we know how I am swapping them, One case is solved, rest will be done by recursion.\\n4. After swapping the first two nodes, we will attach the result of swapping after the recursion has done it\\'s work.\\n5. we will have to return the temp as it will be pointing to the first node of the swapping result.\\n6. and we\\'re DONE !!\\n\\nMy solution is not the best, but is easy to understand for the beginners. \\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL)\\n            return NULL;\\n\\n        if(head->next == NULL)\\n            return head;\\n\\n        ListNode* tempHead = head;\\n\\n        //swapping\\n        ListNode* temp = tempHead->next;\\n        tempHead->next = tempHead->next->next;\\n        temp->next = tempHead;\\n        //tempHead = tempHead->next;\\n\\n        tempHead->next = swapPairs(tempHead->next);\\n\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL)\\n            return NULL;\\n\\n        if(head->next == NULL)\\n            return head;\\n\\n        ListNode* tempHead = head;\\n\\n        //swapping\\n        ListNode* temp = tempHead->next;\\n        tempHead->next = tempHead->next->next;\\n        temp->next = tempHead;\\n        //tempHead = tempHead->next;\\n\\n        tempHead->next = swapPairs(tempHead->next);\\n\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774660,
                "title": "easy-c-100-faster-solution",
                "content": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL or head->next==NULL) return head;\\n        ListNode* a = NULL;\\n        ListNode* b = head;\\n        ListNode* c = head->next;\\n        \\n        while(b!=NULL && c!=NULL){\\n            if(a==NULL){\\n                b->next = c->next;\\n                c->next = b;\\n                head = c;\\n            }else{\\n                a->next = c;\\n                b->next = c->next;\\n                c->next = b;\\n            }\\n            a = b;\\n            b = b->next;\\n            if(b) c = b->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL or head->next==NULL) return head;\\n        ListNode* a = NULL;\\n        ListNode* b = head;\\n        ListNode* c = head->next;\\n        \\n        while(b!=NULL && c!=NULL){\\n            if(a==NULL){\\n                b->next = c->next;\\n                c->next = b;\\n                head = c;\\n            }else{\\n                a->next = c;\\n                b->next = c->next;\\n                c->next = b;\\n            }\\n            a = b;\\n            b = b->next;\\n            if(b) c = b->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487511,
                "title": "python-easy-with-dummy-head-clean-concise",
                "content": "```python\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        \\n        def addNode(node):\\n            nonlocal curHead\\n            curHead.next = node\\n            curHead = curHead.next\\n        \\n        while head != None and head.next != None:\\n            nxt = head.next\\n            nxt2 = nxt.next\\n            \\n            addNode(nxt)  # Add nxt node\\n            addNode(head) # Add cur node\\n            \\n            head = nxt2\\n            \\n        if head != None:  # If there is a left node -> Add that node\\n            addNode(head)\\n        curHead.next = None\\n        \\n        return dummyHead.next\\n```\\nComplexity:\\n- Time: `O(N)`, where `N <= 100` is number of nodes in the linked list.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummyHead = curHead = ListNode(0)\\n        \\n        def addNode(node):\\n            nonlocal curHead\\n            curHead.next = node\\n            curHead = curHead.next\\n        \\n        while head != None and head.next != None:\\n            nxt = head.next\\n            nxt2 = nxt.next\\n            \\n            addNode(nxt)  # Add nxt node\\n            addNode(head) # Add cur node\\n            \\n            head = nxt2\\n            \\n        if head != None:  # If there is a left node -> Add that node\\n            addNode(head)\\n        curHead.next = None\\n        \\n        return dummyHead.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485546,
                "title": "c-easytounderstand-recursion-faster-than-100-less-memory-than-99-88",
                "content": "If you have any queries, be sure to ask \\u270C.\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next == NULL){  // If List is empty otr has only 1 node return;\\n            return head;\\n        }\\n        \\n        ListNode* first = head; // first pointer to List\\'s first node\\n        ListNode* second = head->next; // second pointer to List\\'s second node\\n        ListNode* third = head->next->next; // third pointer to List\\'s third node\\n        \\n        second->next = first; // Made second\\'s next point to first instead of third. So, it\\'s like first\\'s next and second\\'s next are pointing to second and first respectively.\\n\\t\\t\\n        first->next = swapPairs(third); // made first\\'s next point to swapPairs(third), because we assume, recursion will swap the rest of the pairs and whatever it will return first\\'s next will point to that node.\\n        \\n        return second;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next == NULL){  // If List is empty otr has only 1 node return;\\n            return head;\\n        }\\n        \\n        ListNode* first = head; // first pointer to List\\'s first node\\n        ListNode* second = head->next; // second pointer to List\\'s second node\\n        ListNode* third = head->next->next; // third pointer to List\\'s third node\\n        \\n        second->next = first; // Made second\\'s next point to first instead of third. So, it\\'s like first\\'s next and second\\'s next are pointing to second and first respectively.\\n\\t\\t\\n        first->next = swapPairs(third); // made first\\'s next point to swapPairs(third), because we assume, recursion will swap the rest of the pairs and whatever it will return first\\'s next will point to that node.\\n        \\n        return second;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430366,
                "title": "c-well-commented",
                "content": "```\\nLets take an example : 1 2 3 4\\nBase condition at top is if linked list has no element or 1 element just return the head itself .\\nNow we have 2 pointers p pointing to head i.e. 1 and res pointing to head->next i.e. 2\\nTwo more pointers q and temp of ListNode type.\\nWhile(true)\\n{\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n\\t\\t\\t\\nthis above statements simply means in first iteration :  temp will point to 3 and 2->1 will be achieved , if statement of temp wont execute \\n\\n            p->next = temp->next;\\n            p = temp;\\n\\t\\t\\t\\nAbove 2 statements means : 1\\'s link with 4 will be established and value of temp i.e 3 will be stored in p, so now p contains 3 that points to 4.\\nSame way 2nd iteration will execute and 3->4 will turn into 4->3 and this time if statement inside while loop will execute as temp has become null, \\np->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n}\\nWe are returning res as it points to 2 which can give us entire linked list i.e : 2 -> 1 -> 4 -> 3 -> NULL\\nupvote if u like it .\\n```\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) \\n            return head;\\n        \\n        ListNode* p = head;\\n        ListNode* res = head->next;\\n        ListNode* q; ListNode* temp;\\n        \\n        while(true)\\n        {\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\nLets take an example : 1 2 3 4\\nBase condition at top is if linked list has no element or 1 element just return the head itself .\\nNow we have 2 pointers p pointing to head i.e. 1 and res pointing to head->next i.e. 2\\nTwo more pointers q and temp of ListNode type.\\nWhile(true)\\n{\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n\\t\\t\\t\\nthis above statements simply means in first iteration :  temp will point to 3 and 2->1 will be achieved , if statement of temp wont execute \\n\\n            p->next = temp->next;\\n            p = temp;\\n\\t\\t\\t\\nAbove 2 statements means : 1\\'s link with 4 will be established and value of temp i.e 3 will be stored in p, so now p contains 3 that points to 4.\\nSame way 2nd iteration will execute and 3->4 will turn into 4->3 and this time if statement inside while loop will execute as temp has become null, \\np->next = temp means terminate the linked list by attaching NULL to last element 3 and break out of while loop.\\n}\\nWe are returning res as it points to 2 which can give us entire linked list i.e : 2 -> 1 -> 4 -> 3 -> NULL\\nupvote if u like it .\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) \\n            return head;\\n        \\n        ListNode* p = head;\\n        ListNode* res = head->next;\\n        ListNode* q; ListNode* temp;\\n        \\n        while(true)\\n        {\\n            q = p->next;\\n            temp = q->next;\\n            q->next = p;\\n            \\n            if(temp == NULL || temp->next == NULL) {\\n                p->next = temp;\\n                break;\\n            }\\n            p->next = temp->next;\\n            p = temp;\\n        }\\n        return res;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1422154,
                "title": "c-easy-to-understand-swap-nodes-two-methods",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n\\n**Iterative**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if(head==NULL)\\n    return NULL;\\n    if(head->next==NULL)\\n    return head;\\n    ListNode *dummy=new ListNode(-1);\\n    ListNode* curr=head;\\n    ListNode* prev=dummy;    \\n    prev->next=curr;\\n    while(curr&&curr->next)\\n    {\\n    prev->next=curr->next;\\n    curr->next=curr->next->next;\\n    prev->next->next=curr;\\n    prev=prev->next->next;\\n    curr=curr->next;\\n    }   \\n return dummy->next;   \\n}\\n};\\n```\\n**Recursive**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        //base case\\n        if(!head || !head->next) return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next); \\n        temp->next = head;\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n    if(head==NULL)\\n    return NULL;\\n    if(head->next==NULL)\\n    return head;\\n    ListNode *dummy=new ListNode(-1);\\n    ListNode* curr=head;\\n    ListNode* prev=dummy;    \\n    prev->next=curr;\\n    while(curr&&curr->next)\\n    {\\n    prev->next=curr->next;\\n    curr->next=curr->next->next;\\n    prev->next->next=curr;\\n    prev=prev->next->next;\\n    curr=curr->next;\\n    }   \\n return dummy->next;   \\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        //base case\\n        if(!head || !head->next) return head;\\n        ListNode *temp = head->next;\\n        head->next = swapPairs(temp->next); \\n        temp->next = head;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1301987,
                "title": "c-solution",
                "content": "**Intuition**\\nSwap the node pairs is not difficult, but link node paris after swapping is tricky. We need to use ```prev``` to record the first node ```s1``` of the previous node pair, and then link it to the next node pair.\\n\\n![image](https://assets.leetcode.com/users/images/773756a7-225c-41cb-895b-aecc89dddfa2_1634282202.369622.png)\\n\\n**complexity**\\n- time: O(N)\\n- space: O(1)\\n\\n**implementation**\\n```\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode s1 = null;\\n        ListNode s2 = null;\\n        \\n        while(prev != null && prev.next != null && prev.next.next != null)\\n        {\\n            s1 = prev.next;\\n            s2 = prev.next.next;\\n            prev.next = s2;\\n            s1.next = s2.next;\\n            s2.next = s1;\\n            prev = s1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```prev```\n```s1```\n```\\npublic class Solution {\\n    public ListNode SwapPairs(ListNode head) {\\n        \\n        if(head == null || head.next == null)\\n            return head;\\n        \\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        ListNode s1 = null;\\n        ListNode s2 = null;\\n        \\n        while(prev != null && prev.next != null && prev.next.next != null)\\n        {\\n            s1 = prev.next;\\n            s2 = prev.next.next;\\n            prev.next = s2;\\n            s1.next = s2.next;\\n            s2.next = s1;\\n            prev = s1;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 683353,
                "title": "javascript",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let cur = head;\\n    let newHead = head && head.next ? head.next : head;\\n        \\n    while (cur && cur.next) {\\n        let next = cur.next;\\n        let temp = next.next;\\n        \\n        next.next = cur;\\n        cur.next = temp && temp.next ? temp.next : temp;\\n        \\n        cur = temp;\\n    }\\n\\n    \\n    return newHead;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let cur = head;\\n    let newHead = head && head.next ? head.next : head;\\n        \\n    while (cur && cur.next) {\\n        let next = cur.next;\\n        let temp = next.next;\\n        \\n        next.next = cur;\\n        cur.next = temp && temp.next ? temp.next : temp;\\n        \\n        cur = temp;\\n    }\\n\\n    \\n    return newHead;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674270,
                "title": "c-o-n-solution-beats-100-in-time-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/swap-nodes-in-pairs/\\n    \\n    Idea is to take 2 ndoes at a time and swap them, then make the\\n    2st node connected to the 3rd node if there and continue with the 3rd node.\\n    TC: O(N), SC:O(1)\\n*/\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // We use a dummy head node to make handling head operations simpler\\n        ListNode *dummy = new ListNode(-1), *tail = dummy;\\n        // add the dummy node to list\\n        tail->next = head;\\n        \\n        while(head && head->next) {\\n            ListNode *nextptr = head->next->next;\\n            // swap the adjacent nodes\\n            // 2nd node comes to 1st pos \\n            tail->next = head->next;\\n            // connecting 2nd node to 1st node\\n            (head->next)->next = head;\\n            // make the 1st node connected to next node on list\\n            tail = head;\\n            tail->next = nextptr;\\n            head = nextptr;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/swap-nodes-in-pairs/\\n    \\n    Idea is to take 2 ndoes at a time and swap them, then make the\\n    2st node connected to the 3rd node if there and continue with the 3rd node.\\n    TC: O(N), SC:O(1)\\n*/\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // We use a dummy head node to make handling head operations simpler\\n        ListNode *dummy = new ListNode(-1), *tail = dummy;\\n        // add the dummy node to list\\n        tail->next = head;\\n        \\n        while(head && head->next) {\\n            ListNode *nextptr = head->next->next;\\n            // swap the adjacent nodes\\n            // 2nd node comes to 1st pos \\n            tail->next = head->next;\\n            // connecting 2nd node to 1st node\\n            (head->next)->next = head;\\n            // make the 1st node connected to next node on list\\n            tail = head;\\n            tail->next = nextptr;\\n            head = nextptr;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 501576,
                "title": "java-100-and-only-11-lines",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null){\\n            return head;\\n        }\\n        ListNode l = head.next;\\n        head.next = swapPairs(head.next.next);\\n        l.next = head;\\n        return l;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null){\\n            return head;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 11241,
                "title": "my-simple-recursive-c-solution-in-6-lines-4ms",
                "content": "    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL) { return NULL; }\\n        if (head ->next == NULL) { return head; }\\n        \\n        ListNode *newHead = head->next;\\n        head->next = swapPairs(head->next->next);\\n        newHead->next = head;\\n        return newHead;\\n    }",
                "solutionTags": [
                    "Linked List",
                    "Recursion"
                ],
                "code": "    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL) { return NULL; }\\n        if (head ->next == NULL) { return head; }\\n        \\n        ListNode *newHead = head->next;\\n        head->next = swapPairs(head->next->next);\\n        newHead->next = head;\\n        return newHead;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11278,
                "title": "ac-java-solution",
                "content": "    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode n1 = head;\\n        ListNode n2 = head.next;\\n        \\n        n1.next = n2.next;\\n        n2.next = n1;\\n        \\n        n1.next = swapPairs(n1.next);\\n        \\n        return n2;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) return head;\\n        \\n        ListNode n1 = head;\\n        ListNode n2 = head.next;\\n        \\n        n1.next = n2.next;\\n        n2.next = n1;\\n        \\n        n1.next = swapPairs(n1.next);\\n        \\n        return n2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3531484,
                "title": "think-recursive-python-c-golang",
                "content": "# Intuition\\nLet\\'s solve a very basic problem, like if we have only two nodes in linked list something like this\\n![Screenshot from 2023-05-16 21-18-05.png](https://assets.leetcode.com/users/images/1d8eaf14-3512-4e3d-bc46-57e3dd6746f0_1684253393.1944199.png)\\n\\nThen, our approach is divided into 3 steps\\n* ***Step1*** Set CurrNode\\'s next to NextNode\\'s next\\n![Screenshot from 2023-05-16 21-21-08.png](https://assets.leetcode.com/users/images/0409e8be-a0f4-49de-8ca8-7cf14ba869be_1684253489.2341714.png)\\n\\n* ***Step2*** Set NextNode\\'s next to CurrNode\\n![Screenshot from 2023-05-16 21-25-06.png](https://assets.leetcode.com/users/images/362d02de-00fc-4e49-a1c2-2c80404593c9_1684253531.1400237.png)\\n\\n* ***Step3*** We are done with swapping now, we have to return the NextNode as our new head.\\n![Screenshot from 2023-05-16 21-28-32.png](https://assets.leetcode.com/users/images/dc72258a-ac45-4dfe-8045-4d4cb40b279a_1684253573.5092244.png)\\n\\nWe have solved our problem, now we have to implement this logic\\n\\n# Approach\\n* If Head node is empty or Head\\'s next is empty, return Head ecause we don\\'t have anything to perform our logic\\n\\n* Set NextNode to Head->next\\n\\n* Now, Set recursion result to Head->next\\n\\n* Now, Set NextNode->next to head\\n\\n* Finally, return the NextNode which is our ans.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\nWhere n is the length of the linked list.\\n`Note: We have traversed only half linked list.`\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\nBecause we haven\\'t consumed any extra space.\\n`Note: We consumed some auxiliary space for recursion stack.`\\n\\n# Code\\n```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        nextNode = head.next\\n        head.next = self.swapPairs(head.next.next)\\n        nextNode.next = head\\n\\n        return nextNode\\n\\n```\\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head or !head->next) return head;\\n\\n        ListNode* nextNode = head->next;\\n        head->next = swapPairs(head->next->next);\\n        nextNode->next = head;\\n\\n        return nextNode;\\n    }\\n};\\n```\\n```Go []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return head\\n    }\\n\\n    nextNode := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    nextNode.Next = head\\n\\n    return nextNode    \\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Go",
                    "Recursion"
                ],
                "code": "```python []\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        nextNode = head.next\\n        head.next = self.swapPairs(head.next.next)\\n        nextNode.next = head\\n\\n        return nextNode\\n\\n```\n```C++ []\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head or !head->next) return head;\\n\\n        ListNode* nextNode = head->next;\\n        head->next = swapPairs(head->next->next);\\n        nextNode->next = head;\\n\\n        return nextNode;\\n    }\\n};\\n```\n```Go []\\n/**\\n * Definition for singly-linked list.\\n * type ListNode struct {\\n *     Val int\\n *     Next *ListNode\\n * }\\n */\\nfunc swapPairs(head *ListNode) *ListNode {\\n    if head == nil || head.Next == nil {\\n        return head\\n    }\\n\\n    nextNode := head.Next\\n    head.Next = swapPairs(head.Next.Next)\\n    nextNode.Next = head\\n\\n    return nextNode    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3528845,
                "title": "python-3-4-lines-t-m-98-65",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```\\n[https://leetcode.com/submissions/detail/582543531/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151844,
                "title": "beats-100-java-recursive-approach-swapping-nodes-simple-solution",
                "content": "# Intuition\\nWe can solve it by doing simple swapping of nodes!\\n# Complexity\\n- Time complexity:\\n0(n)\\n\\n- Space complexity:\\n0(n) [Recursion stack]\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode temp = head.next;\\n        swapper(head);\\n        return temp;\\n    }\\n    void swapper(ListNode head)\\n    {\\n        if(head == null || head.next == null) return;\\n        ListNode temp = head.next;\\n        head.next = head.next.next;\\n        temp.next = head;\\n        ListNode temp2 = null;\\n        if(head.next != null)\\n         temp2 = head.next.next;\\n        swapper(head.next);\\n        if(temp2 != null)\\n        head.next = temp2;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null) return head;\\n        ListNode temp = head.next;\\n        swapper(head);\\n        return temp;\\n    }\\n    void swapper(ListNode head)\\n    {\\n        if(head == null || head.next == null) return;\\n        ListNode temp = head.next;\\n        head.next = head.next.next;\\n        temp.next = head;\\n        ListNode temp2 = null;\\n        if(head.next != null)\\n         temp2 = head.next.next;\\n        swapper(head.next);\\n        if(temp2 != null)\\n        head.next = temp2;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3044431,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* temp=head->next;\\n        head->next=swapPairs(head->next->next);\\n        temp->next=head;\\n        return temp;\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* temp=head->next;\\n        head->next=swapPairs(head->next->next);\\n        temp->next=head;\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014145,
                "title": "100-beats-java-solution-executed-in-0ms-using-three-pointer-iterative-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Three Pointer Iterative Approach where the swapping is done with help of Three Pointers**\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe approach to solve this problem is the three pointer approach, where I have taken the three pointers and with the help of that the swapping of nodes is done, The programming language used is Java. Here the three nodes p for previous, c for current and cn for current_next is taken and also the d node is taken at the starting which will act as p in the first iteration. \\n\\nSuppose the linked list is given\\n1-->2-->3-->4-->null\\nthen first we have declared the d node such that it\\'s next pointer points to the head of the linked list hence\\nD-->1-->2-->3-->4-->null\\nNow During the first Iteration\\n![Untitled.jpg](https://assets.leetcode.com/users/images/036ca02f-24e3-4523-8a2e-61e7b6676f0a_1673101141.142306.jpeg)\\nAfter First Iteration \\n![Untitled.jpg](https://assets.leetcode.com/users/images/78144949-1a21-4c30-837d-297959ae7f54_1673101304.5513315.jpeg)\\nHence as the processing of swapping will be done the pointers will be moved as \\n![Untitled.jpg](https://assets.leetcode.com/users/images/ae9c0caf-c34e-41f3-8162-a6104bce1311_1673101484.9050355.jpeg)\\nAnd again the processing of swapping will be done\\nTill the c and cn is null.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n**Time Complexity - O(n)**\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**Space Compleixty - O(1)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode d = new ListNode(0);\\n        d.next = head;\\n        ListNode p = d;\\n        ListNode c = d.next;\\n        while(c!=null){\\n            ListNode cn = c.next;\\n            if(cn==null){\\n                break;\\n            }\\n            c.next = cn.next;\\n            cn.next=p.next;\\n            p.next = cn;\\n            p = c;\\n            c = c.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode d = new ListNode(0);\\n        d.next = head;\\n        ListNode p = d;\\n        ListNode c = d.next;\\n        while(c!=null){\\n            ListNode cn = c.next;\\n            if(cn==null){\\n                break;\\n            }\\n            c.next = cn.next;\\n            cn.next=p.next;\\n            p.next = cn;\\n            p = c;\\n            c = c.next;\\n        }\\n        return d.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882193,
                "title": "simple-rust-recursive-solution",
                "content": "# Approach\\nSwaps the first pair, then recurses to handle the rest of the list\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$ additional space\\n\\n# Code\\n```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        match head {\\n            Some(mut h) => {\\n                match h.next {\\n                    Some(mut n) => {\\n                        h.next = Solution::swap_pairs(n.next);\\n                        n.next = Some(h);\\n                        Some(n)\\n                    },\\n                    _ => Some(h),\\n                }\\n            },\\n            _ => head,\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\n// Definition for singly-linked list.\\n// #[derive(PartialEq, Eq, Clone, Debug)]\\n// pub struct ListNode {\\n//   pub val: i32,\\n//   pub next: Option<Box<ListNode>>\\n// }\\n// \\n// impl ListNode {\\n//   #[inline]\\n//   fn new(val: i32) -> Self {\\n//     ListNode {\\n//       next: None,\\n//       val\\n//     }\\n//   }\\n// }\\nimpl Solution {\\n    pub fn swap_pairs(head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        match head {\\n            Some(mut h) => {\\n                match h.next {\\n                    Some(mut n) => {\\n                        h.next = Solution::swap_pairs(n.next);\\n                        n.next = Some(h);\\n                        Some(n)\\n                    },\\n                    _ => Some(h),\\n                }\\n            },\\n            _ => head,\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2374316,
                "title": "easy-to-understand-simple-java-0ms-100-faster-solution-singlylinkedlist-space",
                "content": "**Please  \\uD83D\\uDC4D this.solution if(you understood == true)**\\n\\n```\\n// Best Approach : Recursive\\n// Space Complexity : O(n)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if ((head == null)||(head.next == null))\\n            return head;\\n        ListNode n = head.next;\\n        head.next = swapPairs(head.next.next);\\n        n.next = head;\\n        return n;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\n// Best Approach : Recursive\\n// Space Complexity : O(n)\\n// Author - Nikhil Sharma\\n// LinkedIn - https://www.linkedin.com/in/nikhil-sharma-41a287226/\\n// Twitter - https://twitter.com/Sharma_Nikh12\\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if ((head == null)||(head.next == null))\\n            return head;\\n        ListNode n = head.next;\\n        head.next = swapPairs(head.next.next);\\n        n.next = head;\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2303855,
                "title": "easy-0-ms-100-faster-fully-explained-c-java-c-language-js",
                "content": "# **C++ Solution:**\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode* tmp = new ListNode(0);\\n        tmp->next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode* curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr->next && curr->next->next){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode* n1 = curr->next;\\n            ListNode* n2 = curr->next->next;\\n            \\n            n1->next = n2->next;              // Point the next of n1 to the node after n2\\n            curr->next = n2;                 // Now n2 node should be the curr.next node.\\n            curr->next->next = n1;            // Linking n2 to the n1 node.\\n            curr = curr->next->next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp->next;    //at last return the tmp.next\\n    }\\n};\\n```\\n\\n# **Java Solution:**\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        //Base condition\\n        if(head == null || head.next == null)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode tmp = new ListNode(0);\\n        tmp.next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr.next != null && curr.next.next != null){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode n1 = curr.next;\\n            ListNode n2 = curr.next.next;\\n            \\n            n1.next = n2.next;              // Point the next of n1 to the node after n2\\n            curr.next = n2;                 // Now n2 node should be the curr.next node.\\n            curr.next.next = n1;            // Linking n2 to the n1 node.\\n            curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp.next;    //at last return the tmp.next\\n    }\\n}\\n```\\n\\n# **C Language:**\\n```\\n//Another approach is here...\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    struct ListNode* temp = head->next;\\n    head->next = swapPairs(temp->next);  //call recursively.\\n    temp->next = head;\\n    return temp;\\n}\\n```\\n\\n# **Javascript Solution:**\\n```\\nvar swapPairs = function(head) {\\n    \\n    //Base condition\\n    if(head == null || head.next == null)   \\n    return head;\\n        \\n    //Create a tmp node whose next pointer will point to the current head\\n    const tmp = new ListNode(0);\\n    tmp.next = head;\\n        \\n    //Now take a curr node which will be used to traverse the list\\n    let curr = tmp;\\n        \\n    // Loop until we reach to the second last node...\\n    while(curr.next != null && curr.next.next != null){\\n            \\n        //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n        let n1 = curr.next;\\n        let n2 = curr.next.next;\\n            \\n        n1.next = n2.next;              // Point the next of n1 to the node after n2\\n        curr.next = n2;                 // Now n2 node should be the curr.next node.\\n        curr.next.next = n1;            // Linking n2 to the n1 node.\\n        curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n    return tmp.next;    //at last return the tmp.next\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        //Base condition\\n        if(!head || !head->next)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode* tmp = new ListNode(0);\\n        tmp->next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode* curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr->next && curr->next->next){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode* n1 = curr->next;\\n            ListNode* n2 = curr->next->next;\\n            \\n            n1->next = n2->next;              // Point the next of n1 to the node after n2\\n            curr->next = n2;                 // Now n2 node should be the curr.next node.\\n            curr->next->next = n1;            // Linking n2 to the n1 node.\\n            curr = curr->next->next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp->next;    //at last return the tmp.next\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        \\n        //Base condition\\n        if(head == null || head.next == null)   \\n        return head;\\n        \\n        //Create a tmp node whose next pointer will point to the current head\\n        ListNode tmp = new ListNode(0);\\n        tmp.next = head;\\n        \\n        //Now take a curr node which will be used to traverse the list\\n        ListNode curr = tmp;\\n        \\n        // Loop until we reach to the second last node...\\n        while(curr.next != null && curr.next.next != null){\\n            \\n            //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n            ListNode n1 = curr.next;\\n            ListNode n2 = curr.next.next;\\n            \\n            n1.next = n2.next;              // Point the next of n1 to the node after n2\\n            curr.next = n2;                 // Now n2 node should be the curr.next node.\\n            curr.next.next = n1;            // Linking n2 to the n1 node.\\n            curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n \\n    return tmp.next;    //at last return the tmp.next\\n    }\\n}\\n```\n```\\n//Another approach is here...\\nstruct ListNode* swapPairs(struct ListNode* head){\\n    if(head==NULL || head->next==NULL)\\n        return head;\\n    struct ListNode* temp = head->next;\\n    head->next = swapPairs(temp->next);  //call recursively.\\n    temp->next = head;\\n    return temp;\\n}\\n```\n```\\nvar swapPairs = function(head) {\\n    \\n    //Base condition\\n    if(head == null || head.next == null)   \\n    return head;\\n        \\n    //Create a tmp node whose next pointer will point to the current head\\n    const tmp = new ListNode(0);\\n    tmp.next = head;\\n        \\n    //Now take a curr node which will be used to traverse the list\\n    let curr = tmp;\\n        \\n    // Loop until we reach to the second last node...\\n    while(curr.next != null && curr.next.next != null){\\n            \\n        //In each iteration, take two nodes, n1 = curr.next and n2 = curr.next.next.\\n        let n1 = curr.next;\\n        let n2 = curr.next.next;\\n            \\n        n1.next = n2.next;              // Point the next of n1 to the node after n2\\n        curr.next = n2;                 // Now n2 node should be the curr.next node.\\n        curr.next.next = n1;            // Linking n2 to the n1 node.\\n        curr = curr.next.next;    // Move the pointer two nodes ahead\\n    }\\n    return tmp.next;    //at last return the tmp.next\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260102,
                "title": "2-pointer-approach-with-diagram-in-c",
                "content": "![image](https://assets.leetcode.com/users/images/61041d00-400c-4eaf-b071-a8a9355894cf_1657454552.3188987.png)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        ListNode* prev = dummy;\\n        \\n        ListNode* curr = head;\\n        ListNode *second, *nextPair;\\n        \\n        if(head == NULL || head -> next == NULL)\\n            return head;\\n        \\n        while(curr && curr -> next){\\n            second = curr -> next;\\n            nextPair = curr -> next -> next;\\n            \\n            second -> next = curr;\\n            curr -> next = nextPair;\\n            prev -> next = second;\\n            \\n            prev = curr;\\n            curr = nextPair;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```\\n\\n[Further Explanation : NeetCode](https://youtu.be/o811TZLAWOo)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* dummy = new ListNode();\\n        dummy -> next = head;\\n        ListNode* prev = dummy;\\n        \\n        ListNode* curr = head;\\n        ListNode *second, *nextPair;\\n        \\n        if(head == NULL || head -> next == NULL)\\n            return head;\\n        \\n        while(curr && curr -> next){\\n            second = curr -> next;\\n            nextPair = curr -> next -> next;\\n            \\n            second -> next = curr;\\n            curr -> next = nextPair;\\n            prev -> next = second;\\n            \\n            prev = curr;\\n            curr = nextPair;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2150670,
                "title": "fastest-100-faster-0ms-java-solution",
                "content": "ListNode cur=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        ListNode first=head;\\n        int c=1;\\n        while(cur!=null&&c<3){\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n            if(c==2)\\n                first.next=swapPairs(cur);\\n            c++;\\n        }\\n        return prev;",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "ListNode cur=head;\\n        ListNode next=null;\\n        ListNode prev=null;\\n        ListNode first=head;\\n        int c=1;\\n        while(cur!=null&&c<3){\\n            next=cur.next;\\n            cur.next=prev;\\n            prev=cur;\\n            cur=next;\\n            if(c==2)\\n                first.next=swapPairs(cur);\\n            c++;\\n        }\\n        return prev;",
                "codeTag": "Unknown"
            },
            {
                "id": 2037031,
                "title": "java-0ms-100-faster-2-methods",
                "content": "*1. First way using iteration :-*\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n       ListNode curr = head.next;\\n      ListNode prev = head;\\n      ListNode next = null;\\n      ListNode newHead = curr;\\n      while(curr != null)\\n      {\\n        next = curr.next;\\n        curr.next = prev;\\n        if(next == null || next.next == null)\\n        {\\n          prev.next = next;\\n          curr = null;\\n        }\\n        else\\n        {\\n          curr = next.next;\\n          prev.next = curr;\\n          prev = next;\\n        }\\n      }\\n      return newHead;\\n    }\\n}\\n```\\n\\n*2. Second way using recursion :-*\\n\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next = head;\\n\\t\\thead.next = swapPairs(third);\\n\\t\\treturn second;\\n\\t}\\n}\\n\\t\\t",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n      if(head == null || head.next == null)\\n        return head;\\n       ListNode curr = head.next;\\n      ListNode prev = head;\\n      ListNode next = null;\\n      ListNode newHead = curr;\\n      while(curr != null)\\n      {\\n        next = curr.next;\\n        curr.next = prev;\\n        if(next == null || next.next == null)\\n        {\\n          prev.next = next;\\n          curr = null;\\n        }\\n        else\\n        {\\n          curr = next.next;\\n          prev.next = curr;\\n          prev = next;\\n        }\\n      }\\n      return newHead;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775381,
                "title": "my-java-code-faster-than-100-without-recursion",
                "content": "```\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null){\\n            return null;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        \\n        \\n        ListNode current = head;\\n        ListNode dummy = new ListNode(-1); // dummy node\\n        ListNode prev =dummy;\\n        while(current != null && current.next != null){\\n            prev.next = current.next;\\n            current.next = current.next.next;\\n            prev.next.next = current;\\n            \\n            // now update the current and prev \\n            current = current.next;\\n            prev = prev.next.next;\\n        }\\n        return dummy.next;\\n    }\\n```\\nFor solving any linked list problem like this, it will be good to use the help of dummy node\\nSo we will create a dummy node with any value (let suppose -1 ) and we will return dummy.next because its gonna be our new head.\\n\\nDry Run - 1-->2-->3-->4 ,      dummy node ->  -1 \\ncurrent = head   ->  current is at 1 \\nprev = dummy  -> prev is at -1\\n\\nrun a for loop and check if current node and its next node not be equal to null\\n```prev.next = current.next;```  ->   -1 (prev)  --> 2(next node of current)\\n```current.next = current.next.next;```  ->   1  --> 3 \\n```prev.next.next = current;``` -> -1-->2-->1 (prev is -1, prev.next is 2 and next of 2 is set to 1)\\n\\nnow update the pointers position\\n```current = current.next;``` -> current = 3 \\n```prev = prev.next.next``` -> prev = 1\\n\\nrun all the steps again for current and prev until condition satisfy. \\nI am sharing the code for the first time. If i did any mistake in this post then please forgive me\\uD83D\\uDE42. \\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null){\\n            return null;\\n        }\\n        if(head.next == null){\\n            return head;\\n        }\\n        \\n        \\n        ListNode current = head;\\n        ListNode dummy = new ListNode(-1); // dummy node\\n        ListNode prev =dummy;\\n        while(current != null && current.next != null){\\n            prev.next = current.next;\\n            current.next = current.next.next;\\n            prev.next.next = current;\\n            \\n            // now update the current and prev \\n            current = current.next;\\n            prev = prev.next.next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```prev.next = current.next;```\n```current.next = current.next.next;```\n```prev.next.next = current;```\n```current = current.next;```\n```prev = prev.next.next```",
                "codeTag": "Unknown"
            },
            {
                "id": 1775317,
                "title": "c-c-simplest-recursive-solution-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if ((!head) || (!head->next))\\n            return head;\\n\\n        struct ListNode* tmp = head;\\n        head = head->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n\\n        head->next->next = swapPairs(head->next->next);\\n        return head;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if ((!head) || (!head->next))\\n            return head;\\n\\n        struct ListNode* tmp = head;\\n        head = head->next;\\n        tmp->next = head->next;\\n        head->next = tmp;\\n\\n        head->next->next = swapPairs(head->next->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775223,
                "title": "java-simple-recursion-faster-than-100",
                "content": "**Solution 1**\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode temp=head;\\n        while(temp!=null && temp.next!=null){\\n            int x=temp.val;\\n            temp.val=temp.next.val;\\n            temp.next.val=x;\\n            temp=temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\\n\\n**Solution 2 (without changing values)**\\n\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null)\\n            return null;\\n        return swapPairs(head,head.next);\\n    }\\n    public ListNode swapPairs(ListNode n1,ListNode n2){\\n        if(n1==null || n2==null){\\n            return n1;\\n        }\\n        n1.next=swapPairs(n1.next!=null?n1.next.next:null,n2.next!=null?n2.next.next:null);\\n        n2.next=n1;\\n        return n2;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode temp=head;\\n        while(temp!=null && temp.next!=null){\\n            int x=temp.val;\\n            temp.val=temp.next.val;\\n            temp.next.val=x;\\n            temp=temp.next.next;\\n        }\\n        return head;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head==null)\\n            return null;\\n        return swapPairs(head,head.next);\\n    }\\n    public ListNode swapPairs(ListNode n1,ListNode n2){\\n        if(n1==null || n2==null){\\n            return n1;\\n        }\\n        n1.next=swapPairs(n1.next!=null?n1.next.next:null,n2.next!=null?n2.next.next:null);\\n        n2.next=n1;\\n        return n2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1774872,
                "title": "beginner-friendly-python-solution-with-comments",
                "content": "The main logic used is the swapping of values\\n```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        \\n        node=head\\n        c=0\\n        while node:  #loop to check the length of linkedlist\\n            c+=1\\n            node=node.next\\n            \\n        node=head\\n        if c%2!=0:    #If the length of linkedlist is odd then this loop will be executed\\n            while node.next is not None:\\n                node.next.val, node.val=node.val, node.next.val  #swapping the values\\n                node=node.next.next\\n        else:\\n            while node is not None:\\n                node.val, node.next.val=node.next.val, node.val #swapping the values\\n                node=node.next.next\\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None:\\n            return head\\n        \\n        node=head\\n        c=0\\n        while node:  #loop to check the length of linkedlist\\n            c+=1\\n            node=node.next\\n            \\n        node=head\\n        if c%2!=0:    #If the length of linkedlist is odd then this loop will be executed\\n            while node.next is not None:\\n                node.next.val, node.val=node.val, node.next.val  #swapping the values\\n                node=node.next.next\\n        else:\\n            while node is not None:\\n                node.val, node.next.val=node.next.val, node.val #swapping the values\\n                node=node.next.next\\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1703662,
                "title": "c-iteration",
                "content": "C# solution by iteration \\n**Runtime: 84 ms, faster than 70.48% of C# online submissions for Swap Nodes in Pairs.\\nMemory Usage: 37.3 MB, less than 48.11% of C# online submissions for Swap Nodes in Pairs.**\\n\\n```\\npublic ListNode SwapPairs(ListNode head) {\\n       \\n\\t\\tListNode tempNode = new ListNode(-1, head);\\n        ListNode prevNode = tempNode;\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null)\\n        {\\n            ListNode firstNode = prevNode.next;\\n            ListNode secondNode= prevNode.next.next;\\n            \\n            firstNode.next = secondNode.next;\\n            secondNode.next = firstNode;\\n            \\n            prevNode.next = secondNode;\\n            \\n            /*resetting the value for prevNode for iteraton*/\\n            prevNode = firstNode;\\n        }\\n        return tempNode.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode SwapPairs(ListNode head) {\\n       \\n\\t\\tListNode tempNode = new ListNode(-1, head);\\n        ListNode prevNode = tempNode;\\n        \\n        while(prevNode.next!=null && prevNode.next.next!=null)\\n        {\\n            ListNode firstNode = prevNode.next;\\n            ListNode secondNode= prevNode.next.next;\\n            \\n            firstNode.next = secondNode.next;\\n            secondNode.next = firstNode;\\n            \\n            prevNode.next = secondNode;\\n            \\n            /*resetting the value for prevNode for iteraton*/\\n            prevNode = firstNode;\\n        }\\n        return tempNode.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1534508,
                "title": "iterative-easy-soln-runtime-0-ms-faster-than-100-00-of-c",
                "content": "\\n\\n        \\n\\tListNode* swapPairs(ListNode* head)\\n\\t{\\n\\t\\tListNode* dummy = new ListNode(-1);\\n\\t\\tdummy->next = head;\\n\\t\\tListNode* prev = dummy;\\n        while(prev->next !=NULL && prev->next->next !=NULL)\\n        {\\n            ListNode* curr = prev->next;\\n            ListNode* forw = curr->next;\\n            ListNode* temp = forw->next;\\n            \\n            prev->next = forw;\\n            forw->next = curr;\\n            curr->next = temp;\\n            \\n            prev = curr;\\n        }\\n        return dummy->next;\\n        \\n    }\\n\\t",
                "solutionTags": [],
                "code": "\\n\\n        \\n\\tListNode* swapPairs(ListNode* head)\\n\\t{\\n\\t\\tListNode* dummy = new ListNode(-1);\\n\\t\\tdummy->next = head;\\n\\t\\tListNode* prev = dummy;\\n        while(prev->next !=NULL && prev->next->next !=NULL)\\n        {\\n            ListNode* curr = prev->next;\\n            ListNode* forw = curr->next;\\n            ListNode* temp = forw->next;\\n            \\n            prev->next = forw;\\n            forw->next = curr;\\n            curr->next = temp;\\n            \\n            prev = curr;\\n        }\\n        return dummy->next;\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1101344,
                "title": "python-recursion",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # recursion\\n        if not head or not head.next: return head\\n        new_head = head.next\\n        head.next = self.swapPairs(new_head.next)\\n        new_head.next = head\\n        return new_head\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        # recursion\\n        if not head or not head.next: return head\\n        new_head = head.next\\n        head.next = self.swapPairs(new_head.next)\\n        new_head.next = head\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910322,
                "title": "javascript-solution-24",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet swapPairs = function(head) {\\n    let dummy=new ListNode();\\n    dummy.next = head;\\n    let result = dummy;\\n    while(dummy.next && dummy.next.next){\\n        let p=dummy.next,q = dummy.next.next;\\n        dummy.next = q;\\n        p.next = q.next;\\n        q.next = p;\\n        dummy = p\\n    }\\n    return result.next\\n};\\n```\\n\\n**Runtime: 72 ms, faster than 87.88% of JavaScript online submissions for Swap Nodes in Pairs.**\\n\\n**Memory Usage: 38.8 MB, less than 40.76% of JavaScript online submissions for Swap Nodes in Pairs.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nlet swapPairs = function(head) {\\n    let dummy=new ListNode();\\n    dummy.next = head;\\n    let result = dummy;\\n    while(dummy.next && dummy.next.next){\\n        let p=dummy.next,q = dummy.next.next;\\n        dummy.next = q;\\n        p.next = q.next;\\n        q.next = p;\\n        dummy = p\\n    }\\n    return result.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 748467,
                "title": "python-clean-recursive-and-iterative-solution",
                "content": "Variable names should help understand the solutions easily.\\nRecursive:\\n```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    if head is None or head.next is None:\\n        return head\\n    newHead = head.next\\n    head.next = self.swapPairs(newHead.next)\\n    newHead.next = head\\n    return newHead\\n```\\nE.g: [1,2,3,4] -> [2,1,4,3]\\nThere will be 3 calls to swapPairs ( 1 normal call + 2 recursive calls)\\n```\\nswapPairs(1)\\n         swapPairs(3)\\n                  swapPairs(None):\\n                  returns None # swapPairs(None)\\n         returns 4 #swapPairs(3)\\nreturns 2 #swapPairs(1)\\n```\\n\\nIterative:\\n```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n\\tif head is None or head.next is None:\\n\\t\\treturn head\\n\\tfirst, newHead, previous = head, head.next, None\\n\\twhile first and first.next:\\n\\t\\tif previous:\\n\\t\\t\\tprevious.next = first.next\\n\\t\\tsecond = first.next\\n\\t\\tfirst.next = second.next\\n\\t\\tsecond.next = first\\n\\t\\tprevious = first\\n\\t\\tfirst = first.next\\n\\treturn newHead\\n",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef swapPairs(self, head: ListNode) -> ListNode:\\n    if head is None or head.next is None:\\n        return head\\n    newHead = head.next\\n    head.next = self.swapPairs(newHead.next)\\n    newHead.next = head\\n    return newHead\\n```\n```\\nswapPairs(1)\\n         swapPairs(3)\\n                  swapPairs(None):\\n                  returns None # swapPairs(None)\\n         returns 4 #swapPairs(3)\\nreturns 2 #swapPairs(1)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 655218,
                "title": "c-100-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        // get length \\n        ListNode* cur = head; int len=0;\\n        while(cur) {\\n            cur=cur->next; ++len;\\n        }\\n        \\n        ListNode* cur1 = head;   ListNode* cur2 = head->next;  ListNode* head2 = cur2;\\n        ListNode* cur3=NULL;\\n        \\n        while (cur2->next!=NULL) {\\n            \\n            cur1->next = cur2->next;\\n            cur2->next = cur1;\\n            \\n            cur3 = cur1;\\n            \\n            if(cur1->next->next!=NULL) { // so that cur2 is not NULL\\n                cur1 = cur1->next;\\n                cur2 = cur1->next;\\n          \\n                cur3->next = cur2;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        if(len%2==0) {\\n            cur2->next = cur1;\\n            cur1->next = NULL;\\n        }\\n        \\n        return head2;\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/duttaani/image_1590587889.png)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        if(!head || !head->next) return head;\\n        \\n        // get length \\n        ListNode* cur = head; int len=0;\\n        while(cur) {\\n            cur=cur->next; ++len;\\n        }\\n        \\n        ListNode* cur1 = head;   ListNode* cur2 = head->next;  ListNode* head2 = cur2;\\n        ListNode* cur3=NULL;\\n        \\n        while (cur2->next!=NULL) {\\n            \\n            cur1->next = cur2->next;\\n            cur2->next = cur1;\\n            \\n            cur3 = cur1;\\n            \\n            if(cur1->next->next!=NULL) { // so that cur2 is not NULL\\n                cur1 = cur1->next;\\n                cur2 = cur1->next;\\n          \\n                cur3->next = cur2;\\n            }\\n            else\\n                break;\\n        }\\n        \\n        if(len%2==0) {\\n            cur2->next = cur1;\\n            cur1->next = NULL;\\n        }\\n        \\n        return head2;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 284762,
                "title": "js-solution-faster-than-100",
                "content": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n    //dummy node\\n    dummy = new ListNode(0)\\n    dummy.next = head\\n\\n    current = dummy\\n    while (current.next && current.next.next) {\\n        temp1 = current.next\\n        temp2 = current.next.next\\n\\n        current.next.next = current.next.next.next\\n        current.next = temp2\\n        current.next.next = temp1\\n\\n        //current move to next 2 pos\\n        current = current.next.next\\n    }\\n\\n    return dummy.next\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function (head) {\\n    //dummy node\\n    dummy = new ListNode(0)\\n    dummy.next = head\\n\\n    current = dummy\\n    while (current.next && current.next.next) {\\n        temp1 = current.next\\n        temp2 = current.next.next\\n\\n        current.next.next = current.next.next.next\\n        current.next = temp2\\n        current.next.next = temp1\\n\\n        //current move to next 2 pos\\n        current = current.next.next\\n    }\\n\\n    return dummy.next\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 176015,
                "title": "simple-go-solution",
                "content": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n        list := &ListNode{Next: head}\\n        for prev, node := list, list.Next; node != nil; node = node.Next {\\n                if node.Next != nil {\\n                        swapNode(prev, node, node.Next)\\n                        prev = node\\n                }\\n        }\\n        return list.Next\\n}\\n\\nfunc swapNode(prev, node, next *ListNode) {\\n        prev.Next = next\\n        node.Next = next.Next\\n        next.Next = node\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc swapPairs(head *ListNode) *ListNode {\\n        list := &ListNode{Next: head}\\n        for prev, node := list, list.Next; node != nil; node = node.Next {\\n                if node.Next != nil {\\n                        swapNode(prev, node, node.Next)\\n                        prev = node\\n                }\\n        }\\n        return list.Next\\n}\\n\\nfunc swapNode(prev, node, next *ListNode) {\\n        prev.Next = next\\n        node.Next = next.Next\\n        next.Next = node\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 11195,
                "title": "java-0ms-using-recusion",
                "content": "    public ListNode swapPairs(ListNode head) {\\n\\t\\tif(head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode p1 = head, p2 = head.next, p3 = null;\\n\\t\\tp3 = p2.next;\\n\\t\\tp2.next = null;\\n\\t\\tp1.next.next = p1;\\n\\t\\tp1.next = p3;\\n\\t\\t\\n\\t\\tif(p3 != null)\\n\\t\\t\\tp1.next = swapPairs(p3);\\n\\t\\t\\n\\t\\treturn p2;\\n\\t}",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "    public ListNode swapPairs(ListNode head) {\\n\\t\\tif(head == null || head.next == null)\\n\\t\\t\\treturn head;\\n\\t\\t\\n\\t\\tListNode p1 = head, p2 = head.next, p3 = null;\\n\\t\\tp3 = p2.next;\\n\\t\\tp2.next = null;\\n\\t\\tp1.next.next = p1;\\n\\t\\tp1.next = p3;\\n\\t\\t\\n\\t\\tif(p3 != null)\\n\\t\\t\\tp1.next = swapPairs(p3);\\n\\t\\t\\n\\t\\treturn p2;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 11222,
                "title": "my-solution-c",
                "content": "        ListNode* swapPairs(ListNode* head) {\\n            ListNode* p1;       \\n            if(head && head->next){  \\n                p1 = head->next; \\n                head->next = swapPairs(head->next->next);\\n                p1->next = head;\\n                head = p1; \\n           }\\n           return head;\\n    }",
                "solutionTags": [],
                "code": "        ListNode* swapPairs(ListNode* head) {\\n            ListNode* p1;       \\n            if(head && head->next){  \\n                p1 = head->next; \\n                head->next = swapPairs(head->next->next);\\n                p1->next = head;\\n                head = p1; \\n           }\\n           return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 11343,
                "title": "runtime-0ms-in-c",
                "content": "struct ListNode* swapPairs(struct ListNode* head) {\\n    \\n    struct ListNode* dummy=head;\\n    struct ListNode* prev=NULL;\\n    struct ListNode* Nextnode=NULL;\\n\\n\\n    if(!dummy)\\n          return head;\\n    \\n    while(dummy!=NULL && dummy->next!=NULL){\\n        \\n        Nextnode=dummy->next;\\n        dummy->next=Nextnode->next;\\n        \\n        if(prev)\\n          prev->next=Nextnode;\\n        else\\n          head=Nextnode;\\n          \\n        Nextnode->next=dummy;\\n        \\n        prev=dummy;\\n\\n        dummy=dummy->next;\\n           \\n           \\n    }\\n    \\n    return head;\\n}",
                "solutionTags": [],
                "code": "struct ListNode* swapPairs(struct ListNode* head) {\\n    \\n    struct ListNode* dummy=head;\\n    struct ListNode* prev=NULL;\\n    struct ListNode* Nextnode=NULL;\\n\\n\\n    if(!dummy)\\n          return head;\\n    \\n    while(dummy!=NULL && dummy->next!=NULL){\\n        \\n        Nextnode=dummy->next;\\n        dummy->next=Nextnode->next;\\n        \\n        if(prev)\\n          prev->next=Nextnode;\\n        else\\n          head=Nextnode;\\n          \\n        Nextnode->next=dummy;\\n        \\n        prev=dummy;\\n\\n        dummy=dummy->next;\\n           \\n           \\n    }\\n    \\n    return head;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 3585152,
                "title": "best-o-n-solution",
                "content": "# Approach\\nOptimal Approach\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        while (head != NULL && head->next != NULL) {\\n            ListNode* cur = head->next->next;\\n            temp->next = head->next;\\n            temp = head;\\n            head->next->next = head;\\n            head->next = cur;\\n            head = cur;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head == NULL || head->next == NULL)\\n            return head;\\n        ListNode* dummy = new ListNode();\\n        ListNode* temp = dummy;\\n        while (head != NULL && head->next != NULL) {\\n            ListNode* cur = head->next->next;\\n            temp->next = head->next;\\n            temp = head;\\n            head->next->next = head;\\n            head->next = cur;\\n            head = cur;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534681,
                "title": "100-beats-c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        ListNode* p = head,*q=head->next;\\n        while(true){\\n            swap(p->val,q->val);\\n            if(!(q->next && q->next->next))break;\\n            p = p->next->next;\\n            q = q->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(!head || !head->next){\\n            return head;\\n        }\\n        ListNode* p = head,*q=head->next;\\n        while(true){\\n            swap(p->val,q->val);\\n            if(!(q->next && q->next->next))break;\\n            p = p->next->next;\\n            q = q->next->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531446,
                "title": "c-by-swapping-the-values-of-the-adjacent-nodes-t-c-o-n",
                "content": "# Intuition\\nTraverse the list and swap pairs of nodes one by one.\\n# Approach\\n![53a7a769-ce39-4d7d-9e37-cd0420f72bf0_1644988593.5987253.jpeg](https://assets.leetcode.com/users/images/1c079065-d5e5-478f-80bb-c20f4881d340_1684253393.321737.jpeg)\\n\\n\\n# Complexity\\n- Time complexity:\\nO(N)(where n is number of nodes in the linked list)\\n\\n- Space complexity:\\nO(1)-> since we are just changing the value of the nodes by swapping so no extra space is used.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n    class Solution {\\n\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n\\n        if(head==NULL)return head;\\n\\n        if(head->next==NULL)return head;\\n\\n        \\n\\n        ListNode*curr=head->next;\\n\\n        ListNode*prev=head;\\n\\n        swap(curr->val,prev->val);\\n\\n        while(prev->next->next!=NULL&&curr->next->next!=NULL){\\n\\n            prev=prev->next->next;\\n\\n            curr=curr->next->next;\\n\\n            swap(curr->val,prev->val);\\n\\n        }\\n\\n        return head;\\n\\n        \\n\\n    }\\n\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\n    class Solution {\\n\\npublic:\\n\\n    ListNode* swapPairs(ListNode* head) {\\n\\n        if(head==NULL)return head;\\n\\n        if(head->next==NULL)return head;\\n\\n        \\n\\n        ListNode*curr=head->next;\\n\\n        ListNode*prev=head;\\n\\n        swap(curr->val,prev->val);\\n\\n        while(prev->next->next!=NULL&&curr->next->next!=NULL){\\n\\n            prev=prev->next->next;\\n\\n            curr=curr->next->next;\\n\\n            swap(curr->val,prev->val);\\n\\n        }\\n\\n        return head;\\n\\n        \\n\\n    }\\n\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531230,
                "title": "python-3-4-lines-recursion-t-m-98-65",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```\\n[https://leetcode.com/submissions/detail/582543531/](http://)\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head):\\n\\n        if not(head and head.next): return head \\n\\n        newHead = head.next\\n        head.next, newHead.next = self.swapPairs(head.next.next), head\\n\\n        return newHead\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531172,
                "title": "easy-solution-java-iterative-swap",
                "content": "# Approach\\nThe provided code implements a method called `swapPairs` in a class. This method swaps adjacent pairs of nodes in a singly linked list. Here\\'s the breakdown of the approach used:\\n\\n1. The method takes a parameter `head`, which represents the head node of the linked list.\\n\\n2. The first step is to check if the `head` is `null` or if there is only one node in the list (`head.next == null`). In either case, there is no need to swap any nodes, so the method returns the `head` as it is.\\n\\n3. If there are at least two nodes in the list, a new dummy node called `ans` is created with a value of 0. The `ans.next` is set to the original `head` of the list. This dummy node serves as the new head of the modified list, which will make it easier to handle the edge case of swapping the first two nodes.\\n\\n4. Two pointers, `temp` and `temp1`, are initialized with `head` and `ans` respectively. These pointers will be used to traverse the list and perform the node swaps.\\n\\n5. The main loop runs as long as `temp` is not `null` and `temp.next` is not `null`. This loop processes pairs of nodes in the list until there are no more pairs left to swap.\\n\\n6. Inside the loop, a new node `forw` is assigned as the next node after `temp`. This node represents the second node of the current pair.\\n\\n7. The following steps perform the swapping:\\n   - `temp.next` is updated to skip the second node (`forw`).\\n   - `forw.next` is set to `temp`, making `temp` the second node in the pair.\\n   - `temp1.next` is set to `forw`, connecting the swapped pair to the modified list.\\n   - `temp1` is updated to `temp`, so it now represents the last node that was swapped.\\n   - `temp` is updated to `temp.next` to move to the next pair of nodes.\\n\\n8. Once the loop is completed, the modified list is obtained by accessing `ans.next`. This returns the head of the modified linked list.\\n\\n9. Finally, the modified list is returned as the result.\\n\\nOverall, this approach uses iterative traversal and manipulation of the linked list to swap adjacent pairs of nodes. It employs a dummy node to simplify the handling of the first pair.\\n\\n# Complexity\\n- Time complexity:\\n    - The time complexity of the swapPairs method is O(n).\\n- Space complexity:\\n    - The space complexity of the method is O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }        \\n        ListNode ans = new ListNode(0);\\n        ans.next = head;       \\n        ListNode temp = head;\\n        ListNode temp1 = ans;\\n        \\n        while (temp != null && temp.next != null) {\\n            ListNode forw = temp.next;\\n            temp.next = forw.next;\\n            forw.next = temp;\\n            temp1.next = forw;\\n            temp1 = temp;\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n            return head;\\n        }        \\n        ListNode ans = new ListNode(0);\\n        ans.next = head;       \\n        ListNode temp = head;\\n        ListNode temp1 = ans;\\n        \\n        while (temp != null && temp.next != null) {\\n            ListNode forw = temp.next;\\n            temp.next = forw.next;\\n            forw.next = temp;\\n            temp1.next = forw;\\n            temp1 = temp;\\n            temp = temp.next;\\n        }\\n        \\n        return ans.next;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529795,
                "title": "beats-100-time-ands-90-space",
                "content": "**Italic**# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ans(ListNode*&temp,ListNode*&curr,ListNode*a){\\n        a=curr;\\n        if(temp==NULL || temp->next==NULL)return;\\n        temp->next=NULL;\\n        temp->next=curr->next;\\n        curr->next=temp;\\n        ListNode*prev = temp;\\n\\n        temp=temp->next;\\n        if(temp==NULL || temp->next==NULL)return;\\n        curr=temp->next;\\n        prev->next=curr;\\n        ans(temp,curr,a);\\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return head;\\n        ListNode*temp=head;\\n        ListNode*curr = head->next;\\n        ListNode*a=curr;\\n        ans(temp,curr,a);\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void ans(ListNode*&temp,ListNode*&curr,ListNode*a){\\n        a=curr;\\n        if(temp==NULL || temp->next==NULL)return;\\n        temp->next=NULL;\\n        temp->next=curr->next;\\n        curr->next=temp;\\n        ListNode*prev = temp;\\n\\n        temp=temp->next;\\n        if(temp==NULL || temp->next==NULL)return;\\n        curr=temp->next;\\n        prev->next=curr;\\n        ans(temp,curr,a);\\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL)return NULL;\\n        if(head->next==NULL)return head;\\n        ListNode*temp=head;\\n        ListNode*curr = head->next;\\n        ListNode*a=curr;\\n        ans(temp,curr,a);\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529774,
                "title": "easy-java-solution-detailed-explanation-two-pointers-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this question by two ways that are Two Pointers and Recursion.\\nHere I have use two pointer approach, Folks who does not wanted recursive space can go through my approach.  \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere I have taken dummy Node which next will points to head of LikedList. Use of this dummy node is that we have to return head of LinkedList and if we swap then head will change, so we can return dummy.next (new head).\\n1. I have taken two pointers that are pre and curr, pre will points to dummy node and curr will points head of LinkedList\\n![WhatsApp Image 2023-05-16 at 11.29.57 AM.jpeg](https://assets.leetcode.com/users/images/05ec86d4-6fc7-4c8b-80b2-17d9c22e173b_1684219328.4818847.jpeg)\\n\\n2. Here I have done connetion of pre\\'s next node to curr\\'s node next node.\\n```java []\\npre.next=curr.next;\\n```\\n\\n![WhatsApp Image 2023-05-16 at 11.38.00 AM.jpeg](https://assets.leetcode.com/users/images/af90cb2b-1003-4027-ae43-3e67f2a59cca_1684219425.2694046.jpeg)\\n\\n3. After this, I break curr\\'s next node (node 2) connection and establish it\\'s next connection to pre\\'s next of next node (node 3).\\n```java []\\ncurr.next=pre.next.next;\\n```\\n\\n![WhatsApp Image 2023-05-16 at 11.45.00 AM.jpeg](https://assets.leetcode.com/users/images/f62f9709-1fa5-42bc-8523-07cb507f1e42_1684219589.7843626.jpeg)\\n\\n4. This is the main step, here the swapping of node are done by doing pre\\'s next of next node to curr node.\\n```java []\\npre.next.next=curr;\\n```\\n![WhatsApp Image 2023-05-16 at 11.53.43 AM.jpeg](https://assets.leetcode.com/users/images/43ca3fc2-d1ec-47a5-85d9-bd6eddc3ce47_1684219689.5950298.jpeg)\\n\\n5. Here we simply update our pre node (node 0) to curr node (node 1) and curr node (node 1) to pre next node (node 3).\\n```java []\\npre=curr;\\ncurr=pre.next;\\n```\\n![WhatsApp Image 2023-05-16 at 12.00.35 PM.jpeg](https://assets.leetcode.com/users/images/a4910cb9-5d0c-45bd-a08e-b181626953cf_1684219778.19854.jpeg)\\n\\n6. While loop will get false when either curr will become null of curr next node will beacome null, and last dummy\\'s next node will return.\\n```java []\\nreturn dummy.next;\\n```\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        ListNode curr=pre.next;\\n\\n        while(curr!=null && curr.next!=null){\\n            pre.next=curr.next;\\n            curr.next=pre.next.next;\\n            pre.next.next=curr;\\n\\n            pre=curr;\\n            curr=pre.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Two Pointers",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java []\\npre.next=curr.next;\\n```\n```java []\\ncurr.next=pre.next.next;\\n```\n```java []\\npre.next.next=curr;\\n```\n```java []\\npre=curr;\\ncurr=pre.next;\\n```\n```java []\\nreturn dummy.next;\\n```\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next=head;\\n        ListNode pre=dummy;\\n        ListNode curr=pre.next;\\n\\n        while(curr!=null && curr.next!=null){\\n            pre.next=curr.next;\\n            curr.next=pre.next.next;\\n            pre.next.next=curr;\\n\\n            pre=curr;\\n            curr=pre.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3529173,
                "title": "very-easy-c-soln-beats-100-beginner-friendly",
                "content": "**Please upVote if it helps.**\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* prev=head,*curr=head->next,*ans=head->next;\\n        \\n        while(1)\\n        {\\n            prev->next = curr->next;\\n            curr->next=prev;\\n            ListNode* temp=prev->next;\\n            if(temp==NULL)\\n                break;\\n            curr=temp->next;\\n            if(curr==NULL)\\n                break;\\n            prev->next=curr;\\n            prev=temp;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* prev=head,*curr=head->next,*ans=head->next;\\n        \\n        while(1)\\n        {\\n            prev->next = curr->next;\\n            curr->next=prev;\\n            ListNode* temp=prev->next;\\n            if(temp==NULL)\\n                break;\\n            curr=temp->next;\\n            if(curr==NULL)\\n                break;\\n            prev->next=curr;\\n            prev=temp;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3132394,
                "title": "easy-python-solution-using-lists-runtime-97",
                "content": "\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        ans=[]\\n        for i in range(0,len(lst),2):\\n            val=lst[i:i+2]\\n            ans+=val[::-1]\\n        final=ListNode(0)\\n        tmp=final\\n        for i in ans:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        lst=[]\\n        while head:\\n            lst.append(head.val)\\n            head=head.next\\n        ans=[]\\n        for i in range(0,len(lst),2):\\n            val=lst[i:i+2]\\n            ans+=val[::-1]\\n        final=ListNode(0)\\n        tmp=final\\n        for i in ans:\\n            tmp.next=ListNode(i)\\n            tmp=tmp.next\\n        return final.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070647,
                "title": "95-javascript-very-easy-to-understand-with-video-explanation",
                "content": "Here is video for explain if it is helpful please subscribe! :\\n\\nhttps://youtu.be/p8x7qjD1wEM\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\\n    \\n    for(let i =0; i <len; i++){\\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\\n        else copy.next = new ListNode(arr[i-1])\\n        copy = copy.next;\\n    }\\n    if(arr.length % 2 ==1){\\n        copy.next = new ListNode(arr[arr.length-1])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar swapPairs = function(head) {\\n    let arr = []\\n    let res = new ListNode()\\n    let copy = res;\\n    while(head){\\n        arr.push(head.val)\\n        head = head.next;\\n    }\\n    let len = arr.length % 2 ==0 ? arr.length : arr.length-1;\\n    \\n    for(let i =0; i <len; i++){\\n        if(i % 2 == 0) copy.next = new ListNode(arr[i+1])\\n        else copy.next = new ListNode(arr[i-1])\\n        copy = copy.next;\\n    }\\n    if(arr.length % 2 ==1){\\n        copy.next = new ListNode(arr[arr.length-1])\\n        copy = copy.next;\\n    }\\n    return res.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2955805,
                "title": "c-easy-recursive-solution",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* node1 = head;\\n        ListNode* node2 = head->next;\\n        node1->next = swapPairs(node2->next);\\n        node2->next = node1;\\n        return node2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n            return head;\\n        ListNode* node1 = head;\\n        ListNode* node2 = head->next;\\n        node1->next = swapPairs(node2->next);\\n        node2->next = node1;\\n        return node2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2654022,
                "title": "24-super-easy-connection",
                "content": "**time complexity - O(n) space-O(1)**\\n\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # MAKE a dummy node\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n        \\n        # prev-a-b-c-d-e\\n        # prev-b-a-c\\n        while head and head.next:\\n            a = head \\n            b = a.next \\n            c = b.next \\n            \\n            prev.next = b \\n            b.next = a \\n            a.next = c\\n            \\n            prev= a\\n            head= c\\n        \\n        \\n        return dummy.next\\n\\t\\t\\n\\t\\t\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        # MAKE a dummy node\\n        dummy = prev = ListNode(0)\\n        prev.next = head\\n        \\n        # prev-a-b-c-d-e\\n        # prev-b-a-c\\n        while head and head.next:\\n            a = head \\n            b = a.next \\n            c = b.next \\n            \\n            prev.next = b \\n            b.next = a \\n            a.next = c\\n            \\n            prev= a\\n            head= c\\n        \\n        \\n        return dummy.next\\n\\t\\t\\n\\t\\t\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2588735,
                "title": "recursion-7-lines-python-solution",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def swap(node):\\n            if not node or not node.next:\\n                return node\\n            first, second = node, node.next\\n            first.next, second.next = second.next,first\\n            first.next = swap(first.next)\\n            return second\\n       \\n        return swap(head)\\n   ```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        def swap(node):\\n            if not node or not node.next:\\n                return node\\n            first, second = node, node.next\\n            first.next, second.next = second.next,first\\n            first.next = swap(first.next)\\n            return second\\n       \\n        return swap(head)\\n   ```",
                "codeTag": "Java"
            },
            {
                "id": 2420385,
                "title": "java-solution-with-pointer",
                "content": "The code is commented and if you are familiar with using pointers and linkedlist you may be able to understand it \\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode currentPtr = dummy ; // for iteration\\n        \\n        while(currentPtr.next != null && currentPtr.next.next != null ){\\n            ListNode firstNode = currentPtr.next ; \\n            ListNode secondNode  = currentPtr.next.next;\\n            // swaping nodes by replacing next wrt the currentPtr, which points to dummy atm\\n            firstNode.next = secondNode.next;\\n            currentPtr.next = secondNode;\\n            currentPtr.next.next = firstNode; \\n            \\n            // now, currentPtr will move to the 2nd node, then currentPtr.next will become first             //   node for the second pair\\n            currentPtr = currentPtr.next.next;\\n            \\n        }\\n        // our dummy is empty so after that lies our first node(head of the new list)\\n        return dummy.next;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null) return null;\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        ListNode currentPtr = dummy ; // for iteration\\n        \\n        while(currentPtr.next != null && currentPtr.next.next != null ){\\n            ListNode firstNode = currentPtr.next ; \\n            ListNode secondNode  = currentPtr.next.next;\\n            // swaping nodes by replacing next wrt the currentPtr, which points to dummy atm\\n            firstNode.next = secondNode.next;\\n            currentPtr.next = secondNode;\\n            currentPtr.next.next = firstNode; \\n            \\n            // now, currentPtr will move to the 2nd node, then currentPtr.next will become first             //   node for the second pair\\n            currentPtr = currentPtr.next.next;\\n            \\n        }\\n        // our dummy is empty so after that lies our first node(head of the new list)\\n        return dummy.next;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347917,
                "title": "c-100-faster-recursive-solution",
                "content": "```\\nvoid swa(ListNode*head)\\n    {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n            return;\\n        ListNode*t=head->next;\\n        head->next=t->next;\\n        t->next=t->next->next;\\n        head->next->next=t;\\n        swa(head->next->next);\\n        \\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        // return NULL;\\n        if(!head || !head->next)return head;\\n       ListNode*temp=head->next;\\n        head->next=temp->next;\\n        temp->next=head;\\n        head=temp;\\n        swa(head->next);\\n       return head;\\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid swa(ListNode*head)\\n    {\\n        if(head==NULL || head->next==NULL || head->next->next==NULL)\\n            return;\\n        ListNode*t=head->next;\\n        head->next=t->next;\\n        t->next=t->next->next;\\n        head->next->next=t;\\n        swa(head->next->next);\\n        \\n    }\\n    ListNode* swapPairs(ListNode* head) {\\n        // return NULL;\\n        if(!head || !head->next)return head;\\n       ListNode*temp=head->next;\\n        head->next=temp->next;\\n        temp->next=head;\\n        head=temp;\\n        swa(head->next);\\n       return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2245683,
                "title": "simple-python-reccursion-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        third = second.next\\n        \\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        return second\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head == None or head.next == None:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        third = second.next\\n        \\n        second.next = first\\n        first.next = self.swapPairs(third)\\n        return second\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1990913,
                "title": "java-c-python-javascript-kotlin-swift-o-n-time-beats-99-97-memory-speed-0ms-april-2022",
                "content": "```\\n```\\n\\n(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* ***Java***\\n```\\npublic ListNode swapPairs(ListNode leftNode){\\n        if (leftNode == null || leftNode.next == null){\\n            return leftNode;\\n        }\\n        \\n        ListNode rightNode = leftNode.next;\\n        leftNode.next = swapPairs(rightNode.next);\\n        rightNode.next = leftNode;\\n        return rightNode;\\n    }\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 7.0MB*** (beats 100.00% / 100.00%).\\n* ***C++***\\n```\\nclass Solution {\\npublic:\\n\\tListNode* swapPairs(ListNode* head) {\\n\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\n\\t\\tListNode* prev=head;ListNode* curr=head;\\n\\t\\thead=head->next;\\n\\t\\twhile(curr && curr->next){\\n\\t\\t\\tprev->next=curr->next;\\n\\n\\t\\t\\tprev=curr;\\n\\t\\t\\tcurr=curr->next;\\n\\t\\t\\tprev->next=curr->next;\\n\\t\\t\\tcurr->next=prev;\\n\\t\\t\\tcurr=curr->next->next;}\\n\\t\\treturn head;\\n\\n\\t}\\n};\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n\\nThe best result for the code below is ***26ms / 12.2MB*** (beats 95.42% / 82.32%).\\n* ***Python***\\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***51ms / 34.2MB*** (beats 100.00% / 84.12%).\\n* ***JavaScript***\\n```\\nconst swapPairs = data => {\\n  let current = data;\\n  let count = 0;\\n  while (current) {\\n    if (count % 2 === 0 && current.next) {\\n      const tmp = current.val;\\n      current.val = current.next.val;\\n      current.next.val = tmp; \\n    }\\n    count++;\\n    current = current.next;\\n  }\\n  return data;\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***68ms / 44.2MB*** (beats 100.00% / 45.25%).\\n* ***Kotlin***\\n```\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n\\t\\n\\t\\t// if we got empty list return null\\n        head ?: return null\\n\\n\\t\\t// create a pointer, pointing to second element in the list \\n\\t\\t// we will handle the case of swapping first two elements\\n\\t\\t// in the list later\\n        var ptr: ListNode? = head?.next\\n\\n        // in case of list with single element, return the list as\\n\\t\\t// swapping is not possible with just one element\\n        ptr ?: return head\\n\\n        while (ptr?.next != null) {\\n\\t\\t\\t// assign a temp pointer pointing to first of the two elements\\n\\t\\t\\t// to be swapped (we\\'re swapping in chunks on two in entire list)\\n\\t\\t\\t// so, for eg, if the list is 1 -> 2 -> 3 -> 4 -> 5, variable ptr \\n\\t\\t\\t// will point to 2 and variable temp will point to 3 in first pass\\n\\t\\t\\t// of this while loop\\n            val temp = ptr?.next \\n\\n\\t\\t\\t// check if the next chunk of two numbers exist or not\\n\\t\\t\\t// this check will handle lists with odd number of nodes\\n\\t\\t\\t// as the last nodes will not end up being swapped\\n            if (ptr?.next?.next != null) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the two nodes\\n                ptr?.next = ptr?.next?.next \\n                temp?.next = ptr?.next?.next \\n                ptr?.next?.next = temp\\n            }\\n\\n\\t\\t\\t// move the pointer by two nodes, remember we\\'re swapping\\n\\t\\t\\t// in chunks of two?\\n            ptr = ptr?.next?.next\\n        }\\n\\n        // swap elements at head\\n        ptr = head\\n        val temp: ListNode? = head?.next\\n        ptr?.next = temp?.next\\n        temp?.next = ptr\\n        return temp\\n    }\\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\nThe best result for the code below is ***12ms / 32.2MB*** (beats 95% / 84%).\\n* ***Swift***\\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Swift",
                    "Kotlin"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\n```\n```\\npublic ListNode swapPairs(ListNode leftNode){\\n        if (leftNode == null || leftNode.next == null){\\n            return leftNode;\\n        }\\n        \\n        ListNode rightNode = leftNode.next;\\n        leftNode.next = swapPairs(rightNode.next);\\n        rightNode.next = leftNode;\\n        return rightNode;\\n    }\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\npublic:\\n\\tListNode* swapPairs(ListNode* head) {\\n\\t\\tif(!head || !head->next) return head;\\n\\t\\t\\n\\t\\tListNode* prev=head;ListNode* curr=head;\\n\\t\\thead=head->next;\\n\\t\\twhile(curr && curr->next){\\n\\t\\t\\tprev->next=curr->next;\\n\\n\\t\\t\\tprev=curr;\\n\\t\\t\\tcurr=curr->next;\\n\\t\\t\\tprev->next=curr->next;\\n\\t\\t\\tcurr->next=prev;\\n\\t\\t\\tcurr=curr->next->next;}\\n\\t\\treturn head;\\n\\n\\t}\\n};\\n```\n```\\n```\n```\\n```\n```\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\tif not head: return head\\n\\n\\tprev, cur, ans = None, head, head.next\\n\\twhile cur and cur.next:\\n\\t\\tadj = cur.next\\n\\t\\tif prev: prev.next = adj\\n\\n\\t\\tcur.next, adj.next = adj.next, cur\\n\\t\\tprev, cur = cur, cur.next\\n\\n\\treturn ans or head\\n```\n```\\n```\n```\\n```\n```\\nconst swapPairs = data => {\\n  let current = data;\\n  let count = 0;\\n  while (current) {\\n    if (count % 2 === 0 && current.next) {\\n      const tmp = current.val;\\n      current.val = current.next.val;\\n      current.next.val = tmp; \\n    }\\n    count++;\\n    current = current.next;\\n  }\\n  return data;\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    fun swapPairs(head: ListNode?): ListNode? {\\n\\t\\n\\t\\t// if we got empty list return null\\n        head ?: return null\\n\\n\\t\\t// create a pointer, pointing to second element in the list \\n\\t\\t// we will handle the case of swapping first two elements\\n\\t\\t// in the list later\\n        var ptr: ListNode? = head?.next\\n\\n        // in case of list with single element, return the list as\\n\\t\\t// swapping is not possible with just one element\\n        ptr ?: return head\\n\\n        while (ptr?.next != null) {\\n\\t\\t\\t// assign a temp pointer pointing to first of the two elements\\n\\t\\t\\t// to be swapped (we\\'re swapping in chunks on two in entire list)\\n\\t\\t\\t// so, for eg, if the list is 1 -> 2 -> 3 -> 4 -> 5, variable ptr \\n\\t\\t\\t// will point to 2 and variable temp will point to 3 in first pass\\n\\t\\t\\t// of this while loop\\n            val temp = ptr?.next \\n\\n\\t\\t\\t// check if the next chunk of two numbers exist or not\\n\\t\\t\\t// this check will handle lists with odd number of nodes\\n\\t\\t\\t// as the last nodes will not end up being swapped\\n            if (ptr?.next?.next != null) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// swap the two nodes\\n                ptr?.next = ptr?.next?.next \\n                temp?.next = ptr?.next?.next \\n                ptr?.next?.next = temp\\n            }\\n\\n\\t\\t\\t// move the pointer by two nodes, remember we\\'re swapping\\n\\t\\t\\t// in chunks of two?\\n            ptr = ptr?.next?.next\\n        }\\n\\n        // swap elements at head\\n        ptr = head\\n        val temp: ListNode? = head?.next\\n        ptr?.next = temp?.next\\n        temp?.next = ptr\\n        return temp\\n    }\\n}\\n```\n```\\n```\n```\\n```\n```\\nclass Solution {\\n    // - Complexity:\\n    //   - time: O(n), where n is the number of nodes in the linked list.\\n    //   - space: O(1), only constant space is used.\\n\\n    func swapPairs(_ head: ListNode?) -> ListNode? {\\n        if head == nil || head?.next == nil { return head }\\n        let res = head?.next\\n        head?.next = swapPairs(res?.next)\\n        res?.next = head\\n        return res\\n    }\\n    \\n}\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1965896,
                "title": "python-iterative-solution-w-o-temporary-variables",
                "content": "```\\n def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(val=None,next=head)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n        while cur and cur.next:\\n            \\n            prev.next, cur.next.next, cur.next, prev, cur = cur.next, cur, cur.next.next, cur, cur.next.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Iterator"
                ],
                "code": "```\\n def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        \\n        dummy = ListNode(val=None,next=head)\\n        \\n        prev = dummy\\n        cur = head\\n        \\n        while cur and cur.next:\\n            \\n            prev.next, cur.next.next, cur.next, prev, cur = cur.next, cur, cur.next.next, cur, cur.next.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1775864,
                "title": "c-o-n-simple-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp = new ListNode;\\n        temp->next = head;\\n        ListNode* prev = temp;\\n        ListNode* cur = head;\\n        while(cur && cur->next){\\n            prev->next = cur->next;\\n            prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)return head;\\n        ListNode* temp = new ListNode;\\n        temp->next = head;\\n        ListNode* prev = temp;\\n        ListNode* cur = head;\\n        while(cur && cur->next){\\n            prev->next = cur->next;\\n            prev = prev->next;\\n            cur->next = prev->next;\\n            prev->next = cur;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        return temp->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775090,
                "title": "2-java-solution-with-comments-recursive-and-iterative",
                "content": "1.take three pointers. prev, curr, next. and create arbitary node with dummy value and point it to head. by this we don\\'t need to handle head conditions.\\n2.initially curr will point to head and prev to dummynode and next to curr.next node.\\n3.loop till we curr and curr.next available. and perform below step.\\n4.just swap nodes next and curr. and after that reassign values of prev, curr and next to right position so that we can again swap curr with next.\\n\\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) {\\n            return head;\\n        }\\n        ListNode tempHead = new ListNode(-1);\\n        ListNode prev = tempHead;\\n        ListNode curr=head;\\n        while(curr!=null && curr.next!=null) {\\n            ListNode next=curr.next;\\n            curr.next=next.next;\\n            next.next=curr;\\n            prev.next=next;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return tempHead.next;\\n    }\\n```\\n\\nRecursive ->\\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next=(head);\\n\\t\\thead.next=(swapPairs(third));\\n\\t\\treturn second;\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\npublic ListNode swapPairs(ListNode head) {\\n        if(head==null || head.next==null) {\\n            return head;\\n        }\\n        ListNode tempHead = new ListNode(-1);\\n        ListNode prev = tempHead;\\n        ListNode curr=head;\\n        while(curr!=null && curr.next!=null) {\\n            ListNode next=curr.next;\\n            curr.next=next.next;\\n            next.next=curr;\\n            prev.next=next;\\n            prev=curr;\\n            curr=curr.next;\\n        }\\n        return tempHead.next;\\n    }\\n```\n```\\npublic ListNode swapPairs(ListNode head) {\\n        if (head == null || head.next == null) {\\n\\t\\t\\treturn head;\\n\\t\\t}\\n\\t\\tListNode second = head.next;\\n\\t\\tListNode third = second.next;\\n\\t\\tsecond.next=(head);\\n\\t\\thead.next=(swapPairs(third));\\n\\t\\treturn second;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1774677,
                "title": "c-code-using-a-vector",
                "content": "-> used a vector to store sum of every pair node. \\n-> the traverse through the vector and current node value is replaced by (v[i] - (curr->val)\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* temp = curr;\\n        vector<int> v;\\n        while(head && head->next )\\n        {\\n            v.push_back(head->val + head->next->val);\\n            head = head->next->next;\\n        }\\n        int k = v.size();\\n        int i = 0;\\n        while(i<k)\\n        {\\n            curr->val = v[i]-(curr->val);\\n            curr->next->val = v[i]-(curr->next->val);\\n            curr = curr->next->next;\\n            i++;\\n        }\\n        \\n        return temp;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* curr = head;\\n        ListNode* temp = curr;\\n        vector<int> v;\\n        while(head && head->next )\\n        {\\n            v.push_back(head->val + head->next->val);\\n            head = head->next->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1722643,
                "title": "four-recursive-and-iterative-solutions-in-python",
                "content": "## Approach 1. recursion with modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n\\n            self.swapPairs(head.next.next)\\n\\n        return head\\n```\\n## Approach 2. iteration with modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            curr.val, curr.next.val = curr.next.val, curr.val\\n\\n            curr = curr.next.next\\n\\n        return head\\n```\\n\\n## Approach 3. recursion without modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(n)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        first, second = head, head.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n\\n        return second\\n```\\n\\n## Approach 4. iteration without modification of node values\\n---\\n##### Time complexity: O(n)\\n##### Space complexity: O(1)\\n\\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n\\n        prev = dummy\\n\\n        while head and head.next:\\n            first, second = head, head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = head.first\\n\\n        return dummy.next\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n\\n            self.swapPairs(head.next.next)\\n\\n        return head\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        curr = head\\n\\n        while curr and curr.next:\\n            curr.val, curr.next.val = curr.next.val, curr.val\\n\\n            curr = curr.next.next\\n\\n        return head\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head or not head.next:\\n            return head\\n\\n        first, second = head, head.next\\n\\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n\\n        return second\\n```\n```python\\n# Definition of a singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        dummy = ListNode(-1)\\n        dummy.next = head\\n\\n        prev = dummy\\n\\n        while head and head.next:\\n            first, second = head, head.next\\n\\n            prev.next = second\\n            first.next = second.next\\n            second.next = first\\n\\n            prev = first\\n            head = head.first\\n\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1585587,
                "title": "python-recursion-with-example",
                "content": "```\\ndef swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        \\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        \\n        return second\\n```\\n\\nThe recursive function is called on the 1st node of each pair. The recursive flow will be as follows:\\n\\nConsider the example : 1 --> 2 --> 3 --> 4 --> 5\\n\\n```\\nswap(1) --> first = 1\\n\\t\\t\\tsecond = 2\\n\\t\\t\\t1.next = swap(3) --> first = 3\\n\\t\\t\\t2.next = 1           second = 4\\n\\t\\t\\treturn 2\\t\\t\\t 3.next = swap(5) -- > return 5\\n\\t\\t\\t\\t\\t\\t\\t\\t 4.next = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t return 4\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef swapPairs(self, head):\\n        if not head or not head.next:\\n            return head\\n        \\n        first = head\\n        second = head.next\\n        \\n        first.next = self.swapPairs(second.next)\\n        second.next = first\\n        \\n        return second\\n```\n```\\nswap(1) --> first = 1\\n\\t\\t\\tsecond = 2\\n\\t\\t\\t1.next = swap(3) --> first = 3\\n\\t\\t\\t2.next = 1           second = 4\\n\\t\\t\\treturn 2\\t\\t\\t 3.next = swap(5) -- > return 5\\n\\t\\t\\t\\t\\t\\t\\t\\t 4.next = 3\\n\\t\\t\\t\\t\\t\\t\\t\\t return 4\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1489575,
                "title": "easy-c-solution",
                "content": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL) return head;\\n        int sum=0;\\n        ListNode* start=head,*temp=head;\\n        start=head;\\n        while(start){\\n            sum++;\\n            start=start->next;\\n        }\\n        if(sum==1) return head;\\n        else if(sum%2==0){\\n            start=head;\\n            while(start){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }else if(sum%2==1){\\n            start=head;\\n            while(start->next){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* swapPairs(ListNode* head) {\\n        if(head==NULL) return head;\\n        int sum=0;\\n        ListNode* start=head,*temp=head;\\n        start=head;\\n        while(start){\\n            sum++;\\n            start=start->next;\\n        }\\n        if(sum==1) return head;\\n        else if(sum%2==0){\\n            start=head;\\n            while(start){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }else if(sum%2==1){\\n            start=head;\\n            while(start->next){\\n                int x=start->val;\\n                start->val=start->next->val;\\n                start->next->val=x;\\n                start=start->next->next;\\n            }\\n            return head;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1453499,
                "title": "java-beats-100-simple-solution",
                "content": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        \\n        ListNode dummyHead = new ListNode(-1);\\n        ListNode prev = dummyHead;\\n        ListNode curr = head;\\n        \\n        while(curr != null && curr.next != null){\\n            prev.next = curr.next;\\n            curr.next = curr.next.next;\\n            prev.next.next = curr;\\n            curr = curr.next;\\n            prev = prev.next.next;\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {\\n        if(head == null || head.next == null){\\n            return head;\\n        }\\n        \\n        ListNode dummyHead = new ListNode(-1);\\n        ListNode prev = dummyHead;\\n        ListNode curr = head;\\n        \\n        while(curr != null && curr.next != null){\\n            prev.next = curr.next;\\n            curr.next = curr.next.next;\\n            prev.next.next = curr;\\n            curr = curr.next;\\n            prev = prev.next.next;\\n        }\\n        \\n        return dummyHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1318487,
                "title": "python-easy-solution-with-comments-and-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        \\n        # dummy -> A -> B -> C \\n        \\n        # we want to swap A and B so we have to make dummy to point towards B and B towards A and A towards C \\n        \\n        \\n        # dummy >>>>> B\\n        # B >>>>> A\\n        # A >>>>> C \\n        # all steps simultaneously\\n        \\n        \\n        dummy = ListNode(0)\\n        \\n        dummy.next = head\\n        \\n        start = dummy\\n        \\n        \\n        while dummy.next and dummy.next.next:\\n            \\n            temp1 = dummy.next # A\\n            temp2 = temp1.next # B\\n            \\n            dummy.next ,temp2.next , temp1.next = temp2 , temp1, temp2.next\\n            \\n            dummy = temp1\\n            \\n        return start.next\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        \\n        # dummy -> A -> B -> C \\n        \\n        # we want to swap A and B so we have to make dummy to point towards B and B towards A and A towards C \\n        \\n        \\n        # dummy >>>>> B\\n        # B >>>>> A\\n        # A >>>>> C \\n        # all steps simultaneously\\n        \\n        \\n        dummy = ListNode(0)\\n        \\n        dummy.next = head\\n        \\n        start = dummy\\n        \\n        \\n        while dummy.next and dummy.next.next:\\n            \\n            temp1 = dummy.next # A\\n            temp2 = temp1.next # B\\n            \\n            dummy.next ,temp2.next , temp1.next = temp2 , temp1, temp2.next\\n            \\n            dummy = temp1\\n            \\n        return start.next\\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269068,
                "title": "python-solution-using-recursion",
                "content": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        else:\\n            # Swap the 2 nodes\\n            temp = head \\n            head = head.next\\n            temp.next = head.next\\n            head.next = temp\\n            \\n            # call function recursively for next nodes\\n            temp.next = self.swapPairs(temp.next)\\n        \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        \\n        if head is None or head.next is None:\\n            return head\\n        else:\\n            # Swap the 2 nodes\\n            temp = head \\n            head = head.next\\n            temp.next = head.next\\n            head.next = temp\\n            \\n            # call function recursively for next nodes\\n            temp.next = self.swapPairs(temp.next)\\n        \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984754,
                "title": "easy-understandable-python-solution",
                "content": "```\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        head2 = head\\n        while head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n            head = head.next.next\\n            \\n        return head2\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        head2 = head\\n        while head and head.next:\\n            head.val, head.next.val = head.next.val, head.val\\n            head = head.next.next\\n            \\n        return head2\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 984473,
                "title": "python-o-n-easy-clear-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef swapPairs(self, head: ListNode) -> ListNode:\\n\\t\\t\\tif not head or not head.next:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\t\\n\\t\\t\\ttmp = head\\n\\t\\t\\thead = head.next\\n\\t\\t\\ttmp.next = head.next\\n\\t\\t\\thead.next = tmp\\n\\t\\t\\t\\n\\t\\t\\ttmp.next = self.swapPairs(tmp.next)\\n\\t\\t\\t\\n\\t\\t\\treturn head",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef swapPairs(self, head: ListNode) -> ListNode:\\n\\t\\t\\tif not head or not head.next:\\n\\t\\t\\t\\treturn head\\n\\t\\t\\t\\n\\t\\t\\ttmp = head\\n\\t\\t\\thead = head.next\\n\\t\\t\\ttmp.next = head.next\\n\\t\\t\\thead.next = tmp\\n\\t\\t\\t\\n\\t\\t\\ttmp.next = self.swapPairs(tmp.next)\\n\\t\\t\\t\\n\\t\\t\\treturn head",
                "codeTag": "Java"
            },
            {
                "id": 984443,
                "title": "swap-nodes-in-pair-c-faster-than-100-00-solutions-o-n-time-o-1-space-0ms-runtime",
                "content": "Time: O(n)\\nSpace: O(1)\\nThis is a very easy-to-follow solution. It beats 100% of the submitted C++ solutions according to my submission on Leetcode:\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```\\n\\nAny question let me know. If you like the post please upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        \\n        // If NULL, then return\\n        if(head == NULL)\\n            return head;\\n        \\n        // An iterator node for traversing the LinkedList\\n        ListNode* it = head;\\n        \\n        // A previous pointer to store the second node of the previous pair \\n        ListNode* prev = NULL;\\n        \\n        while(it != NULL && it->next != NULL)\\n        {\\n            // Front and back pointers for the two nodes of the pair to be swapped\\n            ListNode* back = it;\\n            ListNode* front = back->next;\\n            \\n            // Pointing Back node to the node next to Front \\n            back->next = front->next;\\n            \\n            // If it\\'s the start of the Linked List\\n            if(prev == NULL)\\n            {\\n                front->next = back;\\n                // point the head to Front since Front is not swapped back\\n                head = front;\\n            }\\n            else\\n            {\\n                // If it\\'s not the start of the linkedlist,\\n                // point the Prev pointer to the Front\\n                // And, Front pointer to the Back.\\n                prev->next = front;\\n                front->next = back;\\n            }\\n            \\n            // Update the Prev pointer\\n            prev = back;\\n            \\n            // Shift it to Front and two nodes ahead\\n            it = front;\\n            it = it->next->next;\\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 877607,
                "title": "rust-straightforward-non-recursive-i-e-o-1-space",
                "content": "```rust\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut curr: &mut Option<Box<ListNode>> = &mut head;\\n        // Man, if-let chains or box patterns would be so nice...\\n        while curr.is_some() && curr.as_ref().unwrap().next.is_some() {\\n            let mut node1 = curr.take().unwrap();\\n            let mut node2 = node1.next.take().unwrap();\\n            let rest = node2.next.take();\\n            node1.next = rest;\\n            node2.next = Some(node1);\\n            *curr = Some(node2);\\n            curr = &mut curr.as_mut().unwrap().next.as_mut().unwrap().next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n    pub fn swap_pairs(mut head: Option<Box<ListNode>>) -> Option<Box<ListNode>> {\\n        let mut curr: &mut Option<Box<ListNode>> = &mut head;\\n        // Man, if-let chains or box patterns would be so nice...\\n        while curr.is_some() && curr.as_ref().unwrap().next.is_some() {\\n            let mut node1 = curr.take().unwrap();\\n            let mut node2 = node1.next.take().unwrap();\\n            let rest = node2.next.take();\\n            node1.next = rest;\\n            node2.next = Some(node1);\\n            *curr = Some(node2);\\n            curr = &mut curr.as_mut().unwrap().next.as_mut().unwrap().next;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820212,
                "title": "c-monster-oneliner-solution-vs-iterative-approach-explained-100-time-90-space",
                "content": "This is a rather simple to understand and not necessarily trivial to solve problem, so I decided to give myself a good extra challenge and to solve it first of all with a recursive approach.\\n\\nAnd doing it in one line.\\n\\nMy original code, the blasphemous oneliner:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head, ListNode *originalHead = NULL, ListNode *tmp = NULL) {\\n        return (originalHead = originalHead ? originalHead : head && head->next ? head->next : head, head) && head->next ? swapPairs(head->next->next, originalHead, (tmp = head->next, head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next, tmp->next = head)) : originalHead;\\n    }\\n};\\n```\\n\\nNow, for the sake of exercise and possibly for the joy of some of my most affectionate readers, I converted it into an iterative approach.\\n\\nFirst of all we move the variable declaration where they belong (in the recursive approach, I used the trick of setting them as additional parameters).\\n\\nAnd we get the first tricky part: `originalHead` needs to be `head->next` (because we are going to swap the first 2 elements too), provided it exists, otherwise it is going to be just `head` (if it is a valid node or `NULL`), so we initialise it to `head && head->next ? head->next : head`; `tmp` does not need to be initialised. And anyway nobody ever loved `tmp` and its parent were not even proud of `tmp`, so `tmp` does not deserve any initial value! In this version we will also need another pointer that I could avoid using previously, `nextHead`.\\n\\nBut enough with pointers\\' drama: we move on and convert the bulk of the rest of the logic to fit into a `while` loop with a `head && head->next` condition, again matching the logic of our oversized oneliner.\\n\\nInside our loop we can first of all store the value of the element after the current `head` in `tmp` and the value of the next `head` into `nextHead`.\\n\\nThen we have to update `head->next`: it has to be an element 3 steps to the right, if such an element exist, otherwise it is going to be an element 2 steps to the right (as it is the case for when we encounter the last element in an odd-lengthed list).\\n\\nTime to switch, so we set `tmp->next = head` and, since we are done with the logic for this run, all that we are missing is just to set it for the next iteration, with `head = nextHead`.\\n\\nOnce we are done looping, we can just return `originalHead`.\\n\\nThe refactored (and significantly more readable) code, which curiously seems to run a bit slower:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head) {\\n        ListNode *originalHead = head && head->next ? head->next : head, *tmp, *nextHead;\\n        while (head && head->next) {\\n            // storing the current value of the node following head\\n            tmp = head->next;\\n            // storing the head of the next loop\\n            nextHead = head->next->next;\\n            // updating head->next\\n            head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next;\\n            // switching head and its previous next position\\n            tmp->next = head;\\n            // setting the head of the next loop\\n            head = nextHead;\\n        }\\n        return originalHead;\\n    }\\n};\\n```\\n\\nAnd that was me months ago; I forgot about having solved the problem already, so I came up with another solution using one less variable.\\n\\nIn it I just declare `nextHead`, initialised to be `head->next`, provided both it and `head` exist, then I assign `head->next` the result of a recursive call, swap `head` and `nextHead` and return the latter.\\n\\nThe updated code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case: we are at the end of the line\\n        if (!head || !head->next) return head; \\n        // support variable\\n        ListNode *nextHead = head->next;\\n        // swapping positions\\n        head->next = swapPairs(nextHead->next);\\n        nextHead->next = head;\\n        return nextHead;\\n    }\\n};\\n```\\n\\nEven turning it into one liner is much more concise \\uD83D\\uDE09 :\\n\\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head, ListNode *nextHead = NULL) {\\n        return head && head->next ? nextHead = head->next, head->next = swapPairs(nextHead->next), nextHead->next = head, nextHead : head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head, ListNode *originalHead = NULL, ListNode *tmp = NULL) {\\n        return (originalHead = originalHead ? originalHead : head && head->next ? head->next : head, head) && head->next ? swapPairs(head->next->next, originalHead, (tmp = head->next, head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next, tmp->next = head)) : originalHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode *head) {\\n        ListNode *originalHead = head && head->next ? head->next : head, *tmp, *nextHead;\\n        while (head && head->next) {\\n            // storing the current value of the node following head\\n            tmp = head->next;\\n            // storing the head of the next loop\\n            nextHead = head->next->next;\\n            // updating head->next\\n            head->next = head->next->next && head->next->next->next ? head->next->next->next : head->next->next;\\n            // switching head and its previous next position\\n            tmp->next = head;\\n            // setting the head of the next loop\\n            head = nextHead;\\n        }\\n        return originalHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        // base case: we are at the end of the line\\n        if (!head || !head->next) return head; \\n        // support variable\\n        ListNode *nextHead = head->next;\\n        // swapping positions\\n        head->next = swapPairs(nextHead->next);\\n        nextHead->next = head;\\n        return nextHead;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head, ListNode *nextHead = NULL) {\\n        return head && head->next ? nextHead = head->next, head->next = swapPairs(nextHead->next), nextHead->next = head, nextHead : head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 793729,
                "title": "3-lines-in-python-recursion",
                "content": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next\\n        return head\\n```\\n\\nAnd, non-recursion in 5 lines:\\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        prev, cur = dummy, dummy.next = ListNode(0), head\\n        while cur and cur.next:\\n            cur.next.next, cur.next, prev.next = prev.next, cur.next.next, cur.next\\n            prev, cur = cur, cur.next\\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        if not head or not head.next: return head\\n        head.next.next, head.next, head = head, self.swapPairs(head.next.next), head.next\\n        return head\\n```\n```python\\nclass Solution:\\n    def swapPairs(self, head: ListNode) -> ListNode:\\n        prev, cur = dummy, dummy.next = ListNode(0), head\\n        while cur and cur.next:\\n            cur.next.next, cur.next, prev.next = prev.next, cur.next.next, cur.next\\n            prev, cur = cur, cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393307,
                "title": "very-short-line-of-kotlin-code",
                "content": "Hope if you guys love it\\n\\n```\\nfun swapPairs(head: ListNode?): ListNode? {\\n    if(head?.next == null) return head\\n    val remaining = swapPairs(head.next?.next)\\n    val newHead = head.next!!\\n    newHead.next = head\\n    newHead.next!!.next = remaining\\n    return newHead\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfun swapPairs(head: ListNode?): ListNode? {\\n    if(head?.next == null) return head\\n    val remaining = swapPairs(head.next?.next)\\n    val newHead = head.next!!\\n    newHead.next = head\\n    newHead.next!!.next = remaining\\n    return newHead\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 303149,
                "title": "c-recursive-solution-short-simple-with-comments",
                "content": "```\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head != NULL && head->next != NULL)\\n        {\\n            ListNode *temp = head->next;                // temp = 2\\n            head->next = swapPairs(head->next->next);   // 1->3\\n            temp->next = head;                          // 2->1 \\n            head = temp;                                // head = 2\\n        }\\n        return head; // if head is NULL, head->next is NULL, or we\\'re done swapping\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    ListNode* swapPairs(ListNode* head) {\\n        if (head != NULL && head->next != NULL)\\n        {\\n            ListNode *temp = head->next;                // temp = 2\\n            head->next = swapPairs(head->next->next);   // 1->3\\n            temp->next = head;                          // 2->1 \\n            head = temp;                                // head = 2\\n        }\\n        return head; // if head is NULL, head->next is NULL, or we\\'re done swapping\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1574728,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895922,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566737,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1783820,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1836468,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1827949,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566051,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895437,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1671797,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1571062,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1574728,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895922,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566737,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1783820,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1836468,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1827949,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1566051,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895437,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1671797,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1571062,
                "content": [
                    {
                        "username": "karthiko",
                        "content": "Does anyone here also thinks this should be marked Easy (and not Medium)?"
                    },
                    {
                        "username": "nikalinov",
                        "content": "try doing it iteratively and not recursively with O(1) space ;)"
                    },
                    {
                        "username": "AlirezaShk",
                        "content": "Actually I struggled with it quite a lot. Knowing how to handle the assignment precedence, as well as the reference points was quite difficult. I think Medium is the right difficulty."
                    },
                    {
                        "username": "djslim",
                        "content": "optimum is quite hard"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "It seems like somewhere between Easy and Medium."
                    },
                    {
                        "username": "djaquels",
                        "content": "It\\'s easy for some no optimal implementations, but for the optimal one (no additional memory) it requires a little bit of thinking, so I\\'d say medium is ok."
                    },
                    {
                        "username": "charonme",
                        "content": "haha I crashed the solution checker by creating a loop in the linked list"
                    },
                    {
                        "username": "Leelour",
                        "content": "Is there any grantee that there will always be even number of nodes?"
                    },
                    {
                        "username": "vadidam",
                        "content": "[@logrhythmic](/logrhythmic) No need to check for odd nodes. during the swap - I check if the node1.next == null then just break out of the loop. you are done. It\\'s a linked list so take advantage of its structure."
                    },
                    {
                        "username": "logrhythmic",
                        "content": "No.  You can test this by entering an odd number of nodes as a test case."
                    },
                    {
                        "username": "skadam183",
                        "content": "I am javascript guy. Simple looking problem at first turned out very tough. I have checked others solution but  most of them are swapping values or using separate list which is not correct solution as per question even if platform accepted it as correct one. "
                    },
                    {
                        "username": "Glasseater90",
                        "content": "You should not be swapping values or creating a separate list, correct. The actual solution is fairly simple anyway, just swap \"next\", that\\'s what they mean by swapping nodes."
                    },
                    {
                        "username": "zawarvyankatesh132",
                        "content": "Solve this like reverse LL in K groups question, simply consider k as 2; done same code easy peasy"
                    },
                    {
                        "username": "user3120p",
                        "content": "there are simpler ways to solve this"
                    },
                    {
                        "username": "dumb_me",
                        "content": "bro that question is hard \\uD83D\\uDE13"
                    },
                    {
                        "username": "Swapnil07072000",
                        "content": "Just solved the problem with O(1) SC ! ! !"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "[@soycow](/soycow) bol to aese rha hai jaise O(1) space se bhi km space use kiya ho \\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "soycow",
                        "content": "[@Jatin145](/Jatin145) check my solution"
                    },
                    {
                        "username": "Jatin145",
                        "content": "how bro ?\\n"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 16.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/swap-nodes-in-pairs/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Approach\n\n  \n**Approach 2:** Iterative Approach\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "jwonz",
                        "content": "One of the top solutions modifies the values in the nodes... Tsk tsk."
                    },
                    {
                        "username": "Anandoganiya",
                        "content": "why im getting run time error when i do head.next in js"
                    },
                    {
                        "username": "surovikov",
                        "content": "[@user4401C](/user4401C) [@Anandoganiya](/Anandoganiya) because by default the code runs against all the test cases when you click \"Run\" and one of them is an empty linked list which is causing the error.\nTook me some time to realise this as well."
                    },
                    {
                        "username": "user4401C",
                        "content": "Same with Python3"
                    },
                    {
                        "username": "hualiang2",
                        "content": "What happens if the node number is odd? Should we swap the last node with NULL?"
                    },
                    {
                        "username": "Dev_Salvi",
                        "content": "if it is odd leave the node as it is\\n Ex 1->2->3\\nresult : 2->1->3\\n"
                    },
                    {
                        "username": "trj_842004",
                        "content": "[@logrhythm no on that case head->next==NULL will work and return head;"
                    },
                    {
                        "username": "logrhythmic",
                        "content": "Try entering an odd number of nodes as a test case and see what the expected answer is."
                    }
                ]
            },
            {
                "id": 1895928,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1576659,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1896284,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1573008,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2057965,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2034957,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 2013646,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1997607,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1988499,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1985704,
                "content": [
                    {
                        "username": "charonme",
                        "content": "they should have made the val property private and if this was an easy problem also add a public getter to enable creating dummy nodes"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "C++ | Java | Python Solution \\nhttps://www.nileshblog.tech/2022/04/22/leet-code-swap-nodes-in-pairs-java-c-python-solution/"
                    },
                    {
                        "username": "BimanDas",
                        "content": "Not so medium level, it seems quite easy."
                    },
                    {
                        "username": "coding_medved",
                        "content": "Topic says for itself"
                    },
                    {
                        "username": "earmstrong2002",
                        "content": "Why my shizz work when I run it in vs code but not here... sad face :("
                    },
                    {
                        "username": "kabdurrahman2002",
                        "content": "i have one doubt if the length of the linked list is odd in which element is not satisfy the swapping condition either that is middle element or last element\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "[@kabdurrahman2002](/kabdurrahman2002)\n\n> swap **every two** adjacent nodes\n\nIt means \"swap nodes is **each pair**\". Imagine the list as the array of pairs:\n```\n[1, 2, 3, 4] => [(1,2), (3,4)]\n[1, 2, 3] => [(1,2), (3)]\n```\nIn that case we would need to swap elements in each item:\n```\n[(1,2), (3,4)] => [(2,1), (4,3)]\n[(1,2), (3)] => [(2,1), (3)]\n```"
                    },
                    {
                        "username": "Shrikant_1729",
                        "content": "# Please help me i don't know where i am wrong!!!!\n```C++\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        vector<int>v;\n        if(head == NULL) return NULL;\n        ListNode*temp = head;\n        while(temp != NULL){\n            v.push_back(head->val);\n            temp=temp->next;\n        }\n        for(int i=0; i<v.size()-1; i+=2){\n            swap(v[i],v[i+1]);\n        }\n        ListNode*ans = new ListNode(-1);\n        ListNode*curr = ans;\n        for(int i=0; i<v.size(); i++){\n            ListNode*t = new ListNode(v[i]);\n            curr->next = t;\n            curr=curr->next;\n        }\n        ans=ans->next;\n        return ans;\n    }\n};\n\n```"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1. Look closely at `v.push_back(head->val)`\n2. There's no need in \"dummy\" node `ListNode(-1)`. Since you have already checked `head` for `NULL`, there will always be at least 1 node, so you may simply create the `v[0]` node, start the loop with 1 and then return `ans`.\n\nP.S. You don't use `head`, so I suppose there's no need in `temp` node."
                    },
                    {
                        "username": "ManasT4",
                        "content": "took me hours to come up with O(n) time and constant space solution. feels good!"
                    },
                    {
                        "username": "Pratik92",
                        "content": "This one should be marked as easy."
                    },
                    {
                        "username": "overchenkoag",
                        "content": "Solve \"Reverse Nodes in k-Group\" at first (although that is a hard task). This one is \"Reverse Nodes in k-Group\" with k=2."
                    }
                ]
            },
            {
                "id": 1984894,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1972364,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1972265,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1968740,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1958756,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1896214,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895915,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895810,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895807,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895616,
                "content": [
                    {
                        "username": "sk4142",
                        "content": "1 -> 2 -> 3 is also a good edge case to consider. Drawing out what links have to be swapped really helped me arrive at a solution, even though it\\'s kinda ugly to look at. "
                    },
                    {
                        "username": "NiranjanBhosale",
                        "content": " `your inline code...your inline code...`\\nclass Solution:\\n    def swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if head is None or head.next is None:\\n            return head\\n\\n        count = 0\\n        currNode = head\\n\\n        while currNode.next:\\n            if count%2 == 0:\\n                oddNode = currNode\\n\\n            else:\\n                temp = currNode.next\\n                oddNode.next = temp\\n                currNode.next = oddNode\\n\\n            count+=1\\n            currNode = oddNode.next\\n\\n        return head\\n\\nIn my above mentioned solution, I am performing the following actions:\\n1) If I am at any odd position then I will store its value in \"oddNode\" variable\\n2) If I am at any even position then I will store my current nodes next in a temp variable\\n3) Then I am breaking the link between \"oddNode\" and \"currNode\" and the next of \"oddNode\" will have my temp value\\n4) Also I will make sure that my currNodes next is pointing to now new oddNode but this is not working (line 21 : currNode.next = oddNode)\\n\\nCan anyone help me understand what I might be doing wrong?"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Let\\'s take a pen and a list of paper. Imagine that we have (0, -> ( 1, -> ( 2, -> (3, -> (4, Nil))))). Let\\'s go.\\n\\n````\\n  currNode = 0\\n  count = 0\\n  \\n  1. count % 2 == 0\\n     oddNode = head = 0\\n     \\n     count = 1\\n     currNode = oddNode.Next = head.Next = 1\\n     \\n  2. count % 2 != 0\\n     \\n     temp = currNode.next = 2\\n     oddNode.Next = temp = 2 // head.next = 2 // 0 -> 2\\n     currNode.next = oddNode = head = 0 // 1 -> 0 -> 2\\n     \\n     count = 2\\n     currNode = oddNode.next = 2\\n     \\n  3. count % 2 == 0\\n      \\n      oddNode = currNode = 2\\n      \\n      count = 3\\n      currNode = oddNode.next = 3\\n      \\n  4.  count % 2 != 0\\n  \\n      temp = currNode.next = 4\\n      oddNode.next = 4 // 2 -> 4\\n      currNode.next = oddNode = 2; // 3 -> 2\\n      \\n      count = 4\\n      currNode = 4\\n````      \\nAt this step we have `1 -> 0 -> 2 -> 4` and `3 -> 2` but `0` doesn\\'t point to `3`.   "
                    },
                    {
                        "username": "soumyajit_0",
                        "content": "I think they problem should also give an example test case for odd no. of nodes greater than 1."
                    },
                    {
                        "username": "0x6B0",
                        "content": "Finally got it, and used very little extra variables to keep track of what goes where, yet only beat 14% of the submissions in c#. People here are blazingly fast :)"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Look at the comparison charts more closely. The ranges are 64 - 97 ms and 37.6 - 38.5 MB. I think that almost all the results are pretty much the same."
                    },
                    {
                        "username": "jason3410",
                        "content": "lmao somebody just change the val of two nodes."
                    },
                    {
                        "username": "A-V-Jagannathan",
                        "content": "Did in O(1) space complexity but used like 8 variables lol"
                    },
                    {
                        "username": "wyldbill",
                        "content": "Don\\'t be afraid of recursion.... There\\'s a maximum of 100 nodes here, your stack won\\'t blow up, and it makes for tidy code...."
                    },
                    {
                        "username": "Abhay1708",
                        "content": "Easiest Solution \\n\\n  ListNode* swapPairs(ListNode* head) {\\n        if(head==NULL || head->next==NULL)\\n        return head;\\n       ListNode* temp=head->next;\\n       head->next=swapPairs(head->next->next);\\n      temp->next=head;\\n      return temp;\\n    } "
                    },
                    {
                        "username": "bit_weiser",
                        "content": "swapping value again????????????? "
                    },
                    {
                        "username": "anubhavanand",
                        "content": "lots of swapping this week..."
                    }
                ]
            },
            {
                "id": 1895609,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895543,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895531,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895521,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895482,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895451,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895446,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1895389,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1883859,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1817742,
                "content": [
                    {
                        "username": "diggaamitoo7",
                        "content": "A question put without research. Looks easy not medium. No examples for edge cases. 1M people read it, most of them would be unsure of the case of list having odd length."
                    },
                    {
                        "username": "theRadFad",
                        "content": "You can always try to add any testcase / edge case of your choice and see the expected solution."
                    },
                    {
                        "username": "Sashi_sharma",
                        "content": "It\\'s Linked list week\\n"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "Happy **LinkedList** week"
                    },
                    {
                        "username": "UVSinghK",
                        "content": "I guess, LinkedList days are here "
                    },
                    {
                        "username": "Manish_kumar10",
                        "content": "MY code is giving following error why??\\nplease anybody help me\\n\\nLine 22: Char 14: error: no viable overloaded \\'=\\'\\n        temp2=head->next;\\n        ~~~~~^~~~~~~~~~~~~\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit copy assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'const ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^\\n/leetcode/precompiled/ListNode.h:5:8: note: candidate function (the implicit move assignment operator) not viable: no known conversion from \\'ListNode *\\' to \\'ListNode\\' for 1st argument; dereference the argument with *\\nstruct ListNode {\\n       ^"
                    },
                    {
                        "username": "jskat",
                        "content": "Does anyone have any tips on how to think about swapping ? I feel like it would take me a long time to figure out something like this on my own in an interview"
                    },
                    {
                        "username": "jwonz",
                        "content": "Rip some pieces of paper from a notebook, write pointer names on them like \"current\", \"next\", \"temp\", and move them around on a hand-drawn linked list.\\n\\nAs you change pointers on the linked list erase and redraw them; realize you lose connections to nodes later in the list hence you need a pointer to grab back onto those for future operations.\\n\\nUsually whenever you are about to change a linked list next pointer you will need your own pointer remembering where you snipped."
                    },
                    {
                        "username": "psionl0",
                        "content": "This problem is a lot easier to code if you attach a dummy node to the front of the list."
                    },
                    {
                        "username": "Maang-io",
                        "content": "So this is going to be Linked List week :-) tomorrow Reverse Nodes in K-Groups :-)"
                    },
                    {
                        "username": "Cerebral",
                        "content": "Think recursion."
                    },
                    {
                        "username": "bob-skywalker",
                        "content": "needed sometime to think but overall still doable i guess"
                    }
                ]
            },
            {
                "id": 1808252,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1804363,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1803290,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1799258,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1786274,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1785572,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1764185,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1763737,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1760984,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            },
            {
                "id": 1760448,
                "content": [
                    {
                        "username": "Nikunj_Gupta777",
                        "content": "Can anyone tell what\\'s wrong in this :\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n        if(head == NULL || head->next==NULL){\\n            return head;\\n        }\\n        ListNode* curr=head;\\n        ListNode* prev=NULL;\\n        ListNode* fwrd=curr->next;\\n        ListNode* fwrd2=fwrd->next;\\n        while( curr != NULL && fwrd !=NULL ){\\n            fwrd=curr->next;\\n            fwrd2=fwrd->next;\\n            if(prev!=NULL){\\n                prev->next=fwrd;\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }else{\\n                curr->next=fwrd2;\\n                fwrd->next=curr;\\n                curr=fwrd2;\\n                prev=fwrd;\\n            }\\n        }\\n    return head;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "1\\. Format the code\n2\\. You return `head`, which is the first node, but your new list should point to the second node.\n3\\. As always, take a pen, a list of paper and debug. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))).\na) on the 1st iteration you have\n```\nfwrd  = curr->next == h0->next == h1;\nfwrd2 = fwrd->next == h1->next == h2;\n\ncurr->next = fwrd2 == h2; h0 -> h2; OK\nfwrd->next = curr  == h0; h1 -> h0; OK\n\ncurr = fwrd2 == h2;\nprev = fwrd  == h1;\n```\nb) on the 2nd iteration you have\n```\nfwrd  = curr->next == h3;\nfwrd2 = fwrd->next == NULL;\n\nprev->next = fwrd  == h3;   h1 -> h3; WRONG, h1 should point to h0, and h0 shoud point to h3\ncurr->next = fwrd2 == NULL; h2 -> NULL; OK\nfwrd->next = curr  == h2;   h3 -> h2; OK\n\ncurr = fwrd2 == NULL\nprev = fwrd  == h3\n\n```\n\nBefore exit you have `h0` pointing to `h2` and don't have a node pointing to `h0`.\n\n4\\. So\na) at the beginning after NULL-checks you should save `head->next` and then return it.\nb) try replacing `prev->next = fwrd` with `prev->next->next = fwrd`\nc) think about odd nodes count"
                    },
                    {
                        "username": "bhushannalawade318",
                        "content": "\\ncan anyone tells what\\'s wrong in this code?\\n\\n\\nclass Solution {\\npublic:\\n    ListNode* swapPairs(ListNode* head) {\\n         \\n         ListNode* slow = head;\\n         ListNode* dummy = new ListNode(0,head);\\n\\n        ListNode* prev = dummy;\\n         ListNode* fast = head->next;\\n         if(head==NULL || head->next==NULL){\\n             return head;\\n         }\\n         while(fast!=NULL && fast->next!=NULL){\\n        \\n           \\n                prev->next = fast;\\n                prev = prev->next;\\n                prev->next  =slow;\\n            \\n             fast = fast->next->next;\\n             slow = slow->next->next;\\n             prev = prev->next;\\n         }\\n         return dummy->next;\\n    }\\n};"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Have you tried debugging?\n\n0\\.\n```\n  ListNode* fast = head->next;\n    \n\tif(head==NULL || head->next==NULL){\n    return head;\n  }\n```\n\nHere you assign `fast = head->next` before checking `head == null`\n\n1\\. Imagine you have a list h0 = (0, h1 = (1, h2 = (2, h3 = (3, Null )))). Go step by step in debugger. Or/and take a pen and a list of paper.\na) slow = h0\nb) fast = h1\nc) the first iteration:\n```\n  prev = h1\n  prev->next = h0; so h1->next = h0; Now you have h0 -> h1 and h1 -> h0\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\nd) the second iteration:\n```\n  prev->next = fast; h0->next = h1;\n  prev = prev->next = h1;\n  \n  fast = fast->next->next = h1->next->next = h0->next = h1;\n  slow = slow->next->next = h0->next->next = h1->next = h0;\n  prev = prev->next = h0;\n```\ne) etc. Infinite loop.\n"
                    },
                    {
                        "username": "kanishk--",
                        "content": "first take dummy node and put it before the current node for every iteration \\ndon\\'t start thinking with the first two nodes assume they are done and start thinking with next pair.\\nex-\\n1                     2                  3                4      \\n101/102       102/103       103/104     104/Null\\n\\n 2                        1                 3             4\\n102/101         101/103      103/104     104/Null\\n"
                    },
                    {
                        "username": "SharmaAyush",
                        "content": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   \\n    ListNode* swapPairs(ListNode* node)\\n{\\n    if(node == NULL || node->next ==NULL){\\n        return node;\\n    }\\n\\n    ListNode* next_pair = swapPairs(node->next->next);\\n\\n    ListNode* another  = node->next;\\n    another->next =node;\\n    node->next=next_pair;\\n\\n    return another;\\n\\n\\n}\\n};"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Hey, can someone explain me why this doesn\\xB4t work: ListNode *ptr, *list;\\n        if(!head) return NULL;\\n        list = new ListNode(0, head);\\n        ptr = list;\\n        ptr->next = head;\\n        while(head && head->next){\\n            ListNode *curr = head, *temp = head->next;\\n            ptr->next = temp;\\n            ptr = curr;\\n            head = head->next;\\n        }\\n        return list->next;"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "Try debug and you will see that you actually get 2 separate lists. E.g. input list is [0, 1, 2, 3]. On the second interation h0 points to h2. On the third h1 points to h3. You return list->next which points to h1, so result is [1, 3]"
                    },
                    {
                        "username": "Darshan119",
                        "content": "what is wrong in this code?  \\n\\n    ListNode* swapPairs(ListNode* head) {\\n        ListNode* temp = head;\\n        while(head->next != NULL ){\\n            ListNode* tempnode1 = head;\\n            ListNode* tempnode2 = head->next;\\n\\n            head->next = tempnode1 ;\\n            head = tempnode2;\\n\\n            head = head ->next ->next;\\n            delete(tempnode1);\\n            delete(tempnode2);\\n        }\\n        return temp;\\n    }\\n"
                    },
                    {
                        "username": "Dreamoochy",
                        "content": "IMHO, at least\\n1. temp should point to head->next, as long as head and head->next will be swapped.\\n2. head->next->next should be saved before chaging head\\n3. tempnodes are pointers, why do you delete them?"
                    },
                    {
                        "username": "GeekErra",
                        "content": "CLEAR VIDEO EXPLANATION\\n\\nClick this link to Subscribe to my YouTube Channel https://tinyurl.com/4e2nj4vr\\n\\nhttps://youtu.be/4l2JBfAO2xs"
                    },
                    {
                        "username": "tiwarijgm66",
                        "content": "solution in java \\n\\nclass Solution {\\n    public ListNode swapPairs(ListNode head) {  \\n\\n        ListNode z = new ListNode();  \\n        ListNode current = head;   \\n        ListNode previous = z; \\n        if(current == null || current.next == null){ \\n            return head ;\\n        }\\n        while(current !=null && current.next != null){  \\n           previous.next = current.next; \\n           current.next = previous.next.next; \\n           previous.next.next = current; // link between 1 n 2\\n           // update  \\n           previous = current; \\n           current = current.next;\\n        } \\n        return z.next;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    },
                    {
                        "username": "kolhar",
                        "content": "Why my code is not working here. On my PC and online IDE\\'s it\\'s working perfectly fine.\\n\\ndef swapPairs(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fir = head\\n        sec = head.next\\n        new_head = sec\\n        while True:\\n            if sec.next != None:\\n                third = sec.next\\n                sec.next = fir\\n                fir.next = third.next\\n                fir = third\\n                sec = third.next\\n            else:\\n                sec.next = fir\\n                fir.next = None\\n                break\\n        return new_head\\n"
                    }
                ]
            }
        ]
    }
]