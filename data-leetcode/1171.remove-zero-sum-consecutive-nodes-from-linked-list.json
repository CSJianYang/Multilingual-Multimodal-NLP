[
    {
        "title": "Linked List Components",
        "question_content": "You are given the head of a linked list containing unique integer values and an integer array nums that is a subset of the linked list values.\nReturn the number of connected components in nums where two values are connected if they appear consecutively in the linked list.\n&nbsp;\nExample 1:\n\nInput: head = [0,1,2,3], nums = [0,1,3]\nOutput: 2\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\n\nExample 2:\n\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\nOutput: 2\nExplanation: 0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the linked list is n.\n\t1 <= n <= 104\n\t0 <= Node.val < n\n\tAll the values Node.val are unique.\n\t1 <= nums.length <= n\n\t0 <= nums[i] < n\n\tAll the values of nums are unique.",
        "solutions": [
            {
                "id": 123842,
                "title": "c-java-python-easy-and-concise-solution-with-explanation",
                "content": "Take second example in the description:\\nliked list: `0->1`->2->`3->4`\\nI highlighed the subset G in linked list with color red.\\nThe problem is just to count how many red part there are.\\nOne red part is one connected components.\\nTo do this, we just need to count tails of red parts.\\n\\n**C++:**\\n```\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```\\n**Java:**\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> setG = new HashSet<>();\\n        for (int i: G) setG.add(i);\\n        int res = 0;\\n        while (head != null) {\\n            if (setG.contains(head.val) && (head.next == null || !setG.contains(head.next.val))) res++;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```\\n**Python:**\\n```\\n    def numComponents(self, head, G):\\n        setG = set(G)\\n        res = 0\\n        while head:\\n            if head.val in setG and (head.next == None or head.next.val not in setG):\\n                res += 1\\n            head = head.next\\n        return res\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> setG = new HashSet<>();\\n        for (int i: G) setG.add(i);\\n        int res = 0;\\n        while (head != null) {\\n            if (setG.contains(head.val) && (head.next == null || !setG.contains(head.next.val))) res++;\\n            head = head.next;\\n        }\\n        return res;\\n    }\\n```\n```\\n    def numComponents(self, head, G):\\n        setG = set(G)\\n        res = 0\\n        while head:\\n            if head.val in setG and (head.next == None or head.next.val not in setG):\\n                res += 1\\n            head = head.next\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 541885,
                "title": "a-thinking-on-how-to-understand-this-problem",
                "content": "The description is not clear, which makes it difficult to understand this problem. \\nOnce you understand this problem it is easy to solve.\\n\\nIf you use the concepts from Union-Find, it becomes easy to understand.\\nG is the initail state of a Union-Find problem, each number in G is a node, every nodes is disjointed from other nodes.\\nWhenever we Union two nodes, components decrease by 1. \\nHow do we know which two nodes to Union?  Description says \"two values are connected if they appear consecutively in the linked list.\" So we traverse the linked list, for each edge, if both vals are in G, we decrease components by 1. \\n\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : G) set.add(n);\\n        \\n        ListNode cur = head;\\n        int res = set.size();\\n        while (cur.next != null) {\\n            if (set.contains(cur.val) && set.contains(cur.next.val)) res--;\\n            cur = cur.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int n : G) set.add(n);\\n        \\n        ListNode cur = head;\\n        int res = set.size();\\n        while (cur.next != null) {\\n            if (set.contains(cur.val) && set.contains(cur.next.val)) res--;\\n            cur = cur.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1658560,
                "title": "c-easy-and-concise-solution-with-explanation",
                "content": "Our intuition behind this problem is to put the **nums** vector into a hashmap, and then interate over the linked-list and find if any node is in components (side by side) with another, which must be present in the **nums** vector!\\n\\n# Code:-\\n```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode *curr = head;\\n        unordered_map<int, bool> mpp;\\n        for(int i=0; i<nums.size(); i++)\\n            mpp[nums[i]] = true;\\n        int count = 0, streak = 0;\\n        while(curr) {\\n            if(mpp[curr->val]==true) {\\n                streak++;\\n            } else {\\n                if(streak>0) {\\n                    count++;\\n                }\\n                streak = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        if(streak>0) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```\\n\\nAt every position we\\'re taking a **streak** variable which updates and if the value of the Node was not in nums, then we check if the **streak** is greater than 0, if yes we increment the **count(final answer)**, and make the present **streak** back to 0.\\nFinally, we return the **count(ans)**.\\n",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode *curr = head;\\n        unordered_map<int, bool> mpp;\\n        for(int i=0; i<nums.size(); i++)\\n            mpp[nums[i]] = true;\\n        int count = 0, streak = 0;\\n        while(curr) {\\n            if(mpp[curr->val]==true) {\\n                streak++;\\n            } else {\\n                if(streak>0) {\\n                    count++;\\n                }\\n                streak = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        if(streak>0) {\\n            count++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123879,
                "title": "single-check-per-element",
                "content": "We increase our counter when we start a new connection:\\n- current item is in the list, and\\n- previous item is not (!connected).\\n\\nNote that this approach allows checking the set just once per an element.\\n\\n**C++**\\n```cpp\\nint numComponents(ListNode* h, vector<int>& nums) {\\n    unordered_set<int> s(begin(nums), end(nums));\\n    int res = 0, connected = 0;\\n    for (; h != nullptr; h = h->next) {\\n        if (s.count(h->val)) {\\n            res += !connected;\\n            connected = true;\\n        }\\n        else\\n            connected = false;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint numComponents(ListNode* h, vector<int>& nums) {\\n    unordered_set<int> s(begin(nums), end(nums));\\n    int res = 0, connected = 0;\\n    for (; h != nullptr; h = h->next) {\\n        if (s.count(h->val)) {\\n            res += !connected;\\n            connected = true;\\n        }\\n        else\\n            connected = false;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123889,
                "title": "python-using-two-pointers",
                "content": "```\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p, prev, count, G = head, False, 0, set(G)\\n        while p:\\n            if p.val in G and not prev:\\n                count += 1\\n            prev, p = p.val in G, p.next;\\n        \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        p, prev, count, G = head, False, 0, set(G)\\n        while p:\\n            if p.val in G and not prev:\\n                count += 1\\n            prev, p = p.val in G, p.next;\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123918,
                "title": "java-solution-using-hashset",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : G) {\\n            set.add(i);\\n        }\\n        int count = 0;\\n        while (head != null) {\\n            ListNode cur = head;\\n            boolean found = false;\\n            while (cur != null && set.contains(cur.val)) {\\n                found = true;\\n                cur = cur.next;\\n            }\\n            if (found) {\\n                count++;\\n            }\\n            head = cur == null ? cur : cur.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : G) {\\n            set.add(i);\\n        }\\n        int count = 0;\\n        while (head != null) {\\n            ListNode cur = head;\\n            boolean found = false;\\n            while (cur != null && set.contains(cur.val)) {\\n                found = true;\\n                cur = cur.next;\\n            }\\n            if (found) {\\n                count++;\\n            }\\n            head = cur == null ? cur : cur.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123855,
                "title": "c-one-traversal-using-unordered-set",
                "content": "    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> subset;\\n        int connected_components = 0;\\n        \\n        for(auto n : G)\\n            subset.insert(n);\\n        \\n        while(head) {\\n            if (subset.count(head->val) && (head->next == NULL || !subset.count(head->next->val)))\\n                connected_components++;\\n            head = head->next;\\n        }   \\n        return connected_components;\\n    }",
                "solutionTags": [],
                "code": "    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> subset;\\n        int connected_components = 0;\\n        \\n        for(auto n : G)\\n            subset.insert(n);\\n        \\n        while(head) {\\n            if (subset.count(head->val) && (head->next == NULL || !subset.count(head->next->val)))\\n                connected_components++;\\n            head = head->next;\\n        }   \\n        return connected_components;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2673359,
                "title": "easy-cpp-solution-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        map<int,int> hs ;\\n        \\n        for (auto i :nums)\\n            hs[i]++;\\n        \\n        ListNode* tmp = head;\\n        \\n        int ans = 0;\\n        \\n        while(tmp)\\n        {\\n            if(hs[tmp->val] !=0 )\\n            {\\n                while(tmp->next && hs[tmp->next->val] != 0 )\\n                {\\n                    tmp = tmp->next;\\n                }\\n                ans++;\\n            }\\n            tmp = tmp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        map<int,int> hs ;\\n        \\n        for (auto i :nums)\\n            hs[i]++;\\n        \\n        ListNode* tmp = head;\\n        \\n        int ans = 0;\\n        \\n        while(tmp)\\n        {\\n            if(hs[tmp->val] !=0 )\\n            {\\n                while(tmp->next && hs[tmp->next->val] != 0 )\\n                {\\n                    tmp = tmp->next;\\n                }\\n                ans++;\\n            }\\n            tmp = tmp->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1659231,
                "title": "java-easy-to-understand",
                "content": "**We\\'re given with**  the `head` of the LinkedList containing unique integer values and an integer `array` nums that is a subset(means all the element of array must be taken from LinkedList) of the linked list values.\\n**We\\'ve to find** the number of connected components in `nums array` where two values are connected if they appear  in the `linked list`.\\n**Understanding** `find` function\\nIt\\'s there to check if  the `ith` value of `nums array` and `LinkedList` are same. If it\\'s same then it will return `true` else `false`.\\n**Understanding** `numComponents` function\\nIn this function we\\'re traversing the entire LinkedList with the `head` node provided to us. While traversing we\\'ll keep on checking if the  `ith` value of `nums array` and `LinkedList` are same using the helper function (named: find). \\nIf we get true from the `find` function  then we will increase the count of `found`  by 1 and then we\\'ve to check if the count of `found` is 1 then it\\'s obvious that we got one connected component because if there will be 1 element then also we\\'ve to return 1 as number of connected components. \\nIf the `ith` value didn\\'t matched with the element of array and LinkedList then we\\'ve to assign 0 to `found counter` because we can\\'t have that answer,  according to the question: we have to return continous connected components but our continuety broke.\\n\\n\\n```\\nclass Solution {\\n    \\n\\t// helper function to check if the element of our LinkedList matches the element in the array\\n    public static boolean find(int[] arr, int target){\\n        for(int i=0; i<arr.length; i++){\\n            if(target == arr[i]){\\n\\t\\t\\t//returning true if it matches\\n                return true;\\n            }\\n        }\\n\\t\\t// returning false if itdoesn\\'t  matches any\\n        return false;\\n    } \\n    // given function\\n    public int numComponents(ListNode head, int[] nums) {\\n        int connected = 0;\\n        int found = 0;\\n\\t\\t\\n\\t\\t//traversing the linkedlist\\n        while(head != null){\\n            if(find(nums, head.val)){\\n\\t\\t\\t// if the element of array matched with LinkedList\\n\\t\\t\\t//then we will increase our found variable by 1\\n                found++;\\n\\t\\t\\t\\t// whenever we increase our found variable for the first time, it means we got atleast one connected item\\n                if(found == 1){\\n                    connected++;\\n                }\\n            }\\n\\t\\t\\t// Assigning found with 0 is imp because if we didn\\'t found any match then our found variable will increase everytime \\n\\t\\t\\t// And this will never allow the connected variable to increase. \\n            else{\\n                found=0;\\n            }\\n            head = head.next;\\n        }\\n\\t\\t//returning the number of count of how many times our found variable increased \\n        return connected;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\n    \\n\\t// helper function to check if the element of our LinkedList matches the element in the array\\n    public static boolean find(int[] arr, int target){\\n        for(int i=0; i<arr.length; i++){\\n            if(target == arr[i]){\\n\\t\\t\\t//returning true if it matches\\n                return true;\\n            }\\n        }\\n\\t\\t// returning false if itdoesn\\'t  matches any\\n        return false;\\n    } \\n    // given function\\n    public int numComponents(ListNode head, int[] nums) {\\n        int connected = 0;\\n        int found = 0;\\n\\t\\t\\n\\t\\t//traversing the linkedlist\\n        while(head != null){\\n            if(find(nums, head.val)){\\n\\t\\t\\t// if the element of array matched with LinkedList\\n\\t\\t\\t//then we will increase our found variable by 1\\n                found++;\\n\\t\\t\\t\\t// whenever we increase our found variable for the first time, it means we got atleast one connected item\\n                if(found == 1){\\n                    connected++;\\n                }\\n            }\\n\\t\\t\\t// Assigning found with 0 is imp because if we didn\\'t found any match then our found variable will increase everytime \\n\\t\\t\\t// And this will never allow the connected variable to increase. \\n            else{\\n                found=0;\\n            }\\n            head = head.next;\\n        }\\n\\t\\t//returning the number of count of how many times our found variable increased \\n        return connected;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628700,
                "title": "c-clean-code-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n    if(nums.size()==1) return 1;  \\n    map<int,bool> mp;\\n    \\n    for(int ele : nums)  mp[ele]= true;\\n        \\n       int ans = 0;\\n       bool flag = false;  \\n       ListNode* tmp = head;\\n        \\n      while(tmp){\\n          int x = tmp->val;\\n          if(mp[x]){\\n              if(!flag) {ans++; flag= true;}\\n            }\\n          else flag = false;\\n          tmp = tmp->next;\\n      }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n    if(nums.size()==1) return 1;  \\n    map<int,bool> mp;\\n    \\n    for(int ele : nums)  mp[ele]= true;\\n        \\n       int ans = 0;\\n       bool flag = false;  \\n       ListNode* tmp = head;\\n        \\n      while(tmp){\\n          int x = tmp->val;\\n          if(mp[x]){\\n              if(!flag) {ans++; flag= true;}",
                "codeTag": "Java"
            },
            {
                "id": 1302687,
                "title": "java-5ms-using-hashset-easy-to-understand",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++) set.add(nums[i]);\\n        \\n        ListNode n=head;\\n        while(n!=null){\\n            if(n.next!=null){\\n                int v=n.next.val;\\n                if(set.contains(v)){\\n                    set.remove(n.val);\\n                }\\n            }\\n            n=n.next;\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<nums.length;i++) set.add(nums[i]);\\n        \\n        ListNode n=head;\\n        while(n!=null){\\n            if(n.next!=null){\\n                int v=n.next.val;\\n                if(set.contains(v)){\\n                    set.remove(n.val);\\n                }\\n            }\\n            n=n.next;\\n        }\\n        return set.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2621553,
                "title": "using-unoredred-map-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>map(nums.begin(),nums.end());\\n        int ans = 0;\\n        bool lastMatch = 0;\\n        while(head){\\n            if( map.find(head->val) == map.end() ){\\n                lastMatch=0;\\n            }else{\\n                if(!lastMatch) {\\n                    ans++;\\n                    lastMatch=1;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>map(nums.begin(),nums.end());\\n        int ans = 0;\\n        bool lastMatch = 0;\\n        while(head){\\n            if( map.find(head->val) == map.end() ){\\n                lastMatch=0;\\n            }else{\\n                if(!lastMatch) {\\n                    ans++;\\n                    lastMatch=1;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545830,
                "title": "java-9ms-solution-82-faster-hashset-o-n-time-and-space-solution",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums) set.add(n);\\n        int components = 0, connected = 0;\\n        ListNode temp = head;\\n        \\n        while(temp != null){\\n            if(set.contains(temp.val))\\n               connected++; \\n            else if(connected > 0){\\n                components++;\\n                connected = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        if(connected == 0) return components;\\n        return components+1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int n : nums) set.add(n);\\n        int components = 0, connected = 0;\\n        ListNode temp = head;\\n        \\n        while(temp != null){\\n            if(set.contains(temp.val))\\n               connected++; \\n            else if(connected > 0){\\n                components++;\\n                connected = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        if(connected == 0) return components;\\n        return components+1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2311593,
                "title": "c-best-approach-shortest-solution-tc-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(),nums.end());\\n        \\n        ListNode*ptr=head;\\n        int count=0;\\n        int res=0;\\n        while(ptr){\\n            count=0;\\n            while(ptr && s.find(ptr->val)!=s.end()){\\n                count++;\\n                ptr=ptr->next;\\n            }\\n            if(count>0){\\n                res+=1;\\n            }\\n            if(ptr)ptr=ptr->next;\\n        }\\n        return res;\\n    }\\n};\\n// UPVOTE IF YOU LIKE : )\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        unordered_set<int>s(nums.begin(),nums.end());\\n        \\n        ListNode*ptr=head;\\n        int count=0;\\n        int res=0;\\n        while(ptr){\\n            count=0;\\n            while(ptr && s.find(ptr->val)!=s.end()){\\n                count++;\\n                ptr=ptr->next;\\n            }\\n            if(count>0){\\n                res+=1;\\n            }\\n            if(ptr)ptr=ptr->next;\\n        }\\n        return res;\\n    }\\n};\\n// UPVOTE IF YOU LIKE : )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465771,
                "title": "ez-python-code-using-sets",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        itr=head\\n        c=0\\n        s=set(nums)\\n        while itr:\\n            if itr.val in s and (itr.next==None or itr.next.val not in s):\\n                c+=1\\n            itr=itr.next\\n        return c\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Ordered Set"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        itr=head\\n        c=0\\n        s=set(nums)\\n        while itr:\\n            if itr.val in s and (itr.next==None or itr.next.val not in s):\\n                c+=1\\n            itr=itr.next\\n        return c\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456660,
                "title": "java-o-n-very-ez-approach-using-hashset",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet();\\n        for (int i = 0; i < nums.length; i ++) {\\n            numSet.add(nums[i]);\\n        }\\n        int count = 0;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            if (numSet.contains(curr.val)) {\\n                while (curr.next != null && numSet.contains(curr.next.val)) {\\n                    curr = curr.next;\\n                }\\n                count ++;\\n            }\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet();\\n        for (int i = 0; i < nums.length; i ++) {\\n            numSet.add(nums[i]);\\n        }\\n        int count = 0;\\n        ListNode curr = head;\\n        while (curr != null) {\\n            if (numSet.contains(curr.val)) {\\n                while (curr.next != null && numSet.contains(curr.next.val)) {\\n                    curr = curr.next;\\n                }\\n                count ++;\\n            }\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 933679,
                "title": "python3-counting-end-of-component",
                "content": "Algo \\nSince the problem is to count number of continuous components, one could count the beginning or end of a continuous piece. Here, to count the beginning is more tedious for the singly-linked list. Instead, we count the end of component like below. \\n\\nImplementation \\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gs = set(G)\\n        ans = 0\\n        while head: \\n            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1\\n            head = head.next \\n        return ans \\n```\\n\\nAnalysis\\nTime complexity `O(M+N)` where `M` is length of `G` and `N` is length of linked list\\nSpace complexity `O(M)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gs = set(G)\\n        ans = 0\\n        while head: \\n            if head.val in Gs and (head.next is None or head.next.val not in Gs): ans += 1\\n            head = head.next \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 672843,
                "title": "python3-simple-and-straightforward-o-n-soluiton",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        result = 0\\n        G = set(G)\\n        t = 0\\n        while head:\\n            if head.val in G:\\n                t+=1\\n            else:\\n                if t!=0:\\n                    result+=1\\n                    t = 0\\n            head = head.next\\n        if t!=0:\\n            result+=1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        result = 0\\n        G = set(G)\\n        t = 0\\n        while head:\\n            if head.val in G:\\n                t+=1\\n            else:\\n                if t!=0:\\n                    result+=1\\n                    t = 0\\n            head = head.next\\n        if t!=0:\\n            result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3936452,
                "title": "easy-c-solution-beats-99-users-in-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& v) {\\n        ListNode* temp=head;\\n        bool component=false;\\n        int counter=0;\\n       while(temp)\\n       {\\n            if(count(v.begin(),v.end(),temp->val)>0&& component==false)\\n            {\\n                counter++;\\n                component =true;\\n            }\\n            else if( !count(v.begin(),v.end(),temp->val))\\n            component=false;\\n           temp=temp->next;\\n       }\\n       return counter;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& v) {\\n        ListNode* temp=head;\\n        bool component=false;\\n        int counter=0;\\n       while(temp)\\n       {\\n            if(count(v.begin(),v.end(),temp->val)>0&& component==false)\\n            {\\n                counter++;\\n                component =true;\\n            }\\n            else if( !count(v.begin(),v.end(),temp->val))\\n            component=false;\\n           temp=temp->next;\\n       }\\n       return counter;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925563,
                "title": "letcode-solution-beats-86-online-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,bool>m;\\n        for(auto it : nums){\\n            m[it] = true;\\n        }\\n        int ct = 0;\\n        ListNode* temp = head;\\n\\n        bool flag = false;\\n\\n        while(temp){\\n            if(m[temp -> val]){\\n                flag = true;\\n            }\\n            else{\\n                if(flag){\\n                    flag = false;\\n                    ct++;\\n                }\\n            }\\n            temp = temp -> next;\\n        }\\n        if(flag) ct++;\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,bool>m;\\n        for(auto it : nums){\\n            m[it] = true;\\n        }\\n        int ct = 0;\\n        ListNode* temp = head;\\n\\n        bool flag = false;\\n\\n        while(temp){\\n            if(m[temp -> val]){\\n                flag = true;\\n            }\\n            else{\\n                if(flag){\\n                    flag = false;\\n                    ct++;\\n                }\\n            }\\n            temp = temp -> next;\\n        }\\n        if(flag) ct++;\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652569,
                "title": "easiest-python-solution",
                "content": "\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\t\\n        pointer = head\\n\\t\\t#prev is the pointer that stores boolean value: if the previous node\\'s value exists in the nums list\\n        prev = None\\n        counter = 0\\n        while pointer != None:\\n\\t\\t\\t#check if pointer\\'s value exist in the nums list\\n            if pointer.val in nums:\\n                if not prev:\\n\\t\\t\\t\\t\\t#increase counter if only previous node\\'s value doesn\\'t exist in list,ie, prev=False\\n                    counter += 1\\n\\t\\t\\t\\t#set prev as True for next node\\t\\n                prev = True\\n            else:\\n\\t\\t\\t\\t#set prev as False for next node\\n                prev = False\\n            pointer = pointer.next\\n        return counter\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\t\\n        pointer = head\\n\\t\\t#prev is the pointer that stores boolean value: if the previous node\\'s value exists in the nums list\\n        prev = None\\n        counter = 0\\n        while pointer != None:\\n\\t\\t\\t#check if pointer\\'s value exist in the nums list\\n            if pointer.val in nums:\\n                if not prev:\\n\\t\\t\\t\\t\\t#increase counter if only previous node\\'s value doesn\\'t exist in list,ie, prev=False\\n                    counter += 1\\n\\t\\t\\t\\t#set prev as True for next node\\t\\n                prev = True\\n            else:\\n\\t\\t\\t\\t#set prev as False for next node\\n                prev = False\\n            pointer = pointer.next\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2289937,
                "title": "java-easy-set",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        int n = nums.length;\\n        int components = 0;\\n        Set<Integer> numsSet = new HashSet<>();\\n        for(int num : nums) {\\n            numsSet.add(num);\\n        }\\n        \\n        while(head != null) {\\n            boolean isPresentNode = false;\\n            while(head != null && numsSet.contains(head.val)) {\\n                isPresentNode = true;\\n                head = head.next;\\n            }\\n            \\n            if(isPresentNode) {\\n                components++;\\n            } if(head!=null) {\\n                head = head.next;\\n            }\\n        }\\n        \\n        return components;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        int n = nums.length;\\n        int components = 0;\\n        Set<Integer> numsSet = new HashSet<>();\\n        for(int num : nums) {\\n            numsSet.add(num);\\n        }\\n        \\n        while(head != null) {\\n            boolean isPresentNode = false;\\n            while(head != null && numsSet.contains(head.val)) {\\n                isPresentNode = true;\\n                head = head.next;\\n            }\\n            \\n            if(isPresentNode) {\\n                components++;\\n            } if(head!=null) {\\n                head = head.next;\\n            }\\n        }\\n        \\n        return components;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1898261,
                "title": "easy-solution-c",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        vector<int>v(10001,0);\\n        if(!head)\\n            return 0;\\n        for(auto i:nums)\\n        {\\n            v[i]=1;\\n        }\\n        int cnt=0;\\n        while(head)\\n        {\\n            if(v[head->val]==1)\\n            {\\n                while(head and v[head->val]==1)\\n                {\\n                    head=head->next;\\n                } \\n                cnt++;\\n            }\\n            else                \\n                head=head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n**Upvote if it helped :)**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        vector<int>v(10001,0);\\n        if(!head)\\n            return 0;\\n        for(auto i:nums)\\n        {\\n            v[i]=1;\\n        }\\n        int cnt=0;\\n        while(head)\\n        {\\n            if(v[head->val]==1)\\n            {\\n                while(head and v[head->val]==1)\\n                {\\n                    head=head->next;\\n                } \\n                cnt++;\\n            }\\n            else                \\n                head=head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1695600,
                "title": "c-solution-better-memory-usage-than-99-49",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(!head) return 0;\\n        if(!head->next) return 1;\\n        \\n        int count = 0;\\n        bool consecutive=false;\\n        while(head){\\n            if(find(nums.begin(), nums.end(), head->val) != nums.end()){\\n                if(!consecutive) count++;\\n                consecutive = true;\\n            }else{\\n                consecutive = false;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(!head) return 0;\\n        if(!head->next) return 1;\\n        \\n        int count = 0;\\n        bool consecutive=false;\\n        while(head){\\n            if(find(nums.begin(), nums.end(), head->val) != nums.end()){\\n                if(!consecutive) count++;\\n                consecutive = true;\\n            }else{\\n                consecutive = false;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1673692,
                "title": "simple-beginner-s-solution-using-vector-with-comment",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        //Initializing vector\\n        vector<int> v(10001,0);\\n        for(int i=0;i<nums.size();i++){\\n            v[nums[i]]=1;\\n        }\\n        int ans=0;\\n        while(head){ //Iterate linked list\\n            if(v[head->val]){ \\n        //if the val in node is present in nums array checking if the consecutives nodes vals are present in nums.\\n            while(head && v[head->val]){\\n                head=head->next;\\n            }\\n            //For all the consecutive nodes and their val present in nums we increase ans by 1 (1-component).\\n                ans++;\\n            }\\n            if(head && head->next) head=head->next; //Iterating the linked list \\n            else break; //handling null node which we might get from previous while loop\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        //Initializing vector\\n        vector<int> v(10001,0);\\n        for(int i=0;i<nums.size();i++){\\n            v[nums[i]]=1;\\n        }\\n        int ans=0;\\n        while(head){ //Iterate linked list\\n            if(v[head->val]){ \\n        //if the val in node is present in nums array checking if the consecutives nodes vals are present in nums.\\n            while(head && v[head->val]){\\n                head=head->next;\\n            }\\n            //For all the consecutive nodes and their val present in nums we increase ans by 1 (1-component).\\n                ans++;\\n            }\\n            if(head && head->next) head=head->next; //Iterating the linked list \\n            else break; //handling null node which we might get from previous while loop\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236331,
                "title": "this-is-probably-the-most-unclear-question-i-ever-came-across",
                "content": "**First thoughts on the prompt** : We basically have to check if each consecutive nodes possess values that are present in the subset and return the count of such connected components.\\n\\nBut then I look at example 1, which says:\\n```Input: \\nhead: 0->1->2->3\\nnums = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\\n3 is connected to what? For a moment lets suppose that in such cases the last node would be treated as in individual candidate since it possess a value present in the subset and it connects to **Null**. Cool?\\n\\nExample 2 also complies with our assumption and original prompt.\\n```Input: \\nhead: 0->1->2->3->4\\nnums = [0, 3, 1, 4]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\\n```\\nWhich is clear.\\n\\nTherefore I wrote the code below and checked it against a custom output.\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count, nums, flag = 0, set(nums), 0\\n        while head.next:\\n            if head.val in nums and head.next.val in nums:\\n                count += 1\\n                flag = 1\\n            else:\\n                flag = 0\\n            head = head.next\\n        if flag == 1:\\n            return count\\n        return count+1 if head.val in nums else count\\n```\\nIt passes for all our assumptions but when checked against a custom output, which was:\\n```\\nWrong Answer Runtime: 26 ms\\nYour input\\n[0,1,2]\\n[0,2]\\nOutput\\n1\\nExpected\\n2\\n```\\nWhy does it expect **2** as a result coz it is clear that combining the prompt and assumption, only the last node is eligible to be counted (as an individual node).  \\n  \\nPlease walk me through if I\\'m going wrong.\\n",
                "solutionTags": [],
                "code": "```Input: \\nhead: 0->1->2->3\\nnums = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\n```Input: \\nhead: 0->1->2->3->4\\nnums = [0, 3, 1, 4]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\\n```\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count, nums, flag = 0, set(nums), 0\\n        while head.next:\\n            if head.val in nums and head.next.val in nums:\\n                count += 1\\n                flag = 1\\n            else:\\n                flag = 0\\n            head = head.next\\n        if flag == 1:\\n            return count\\n        return count+1 if head.val in nums else count\\n```\n```\\nWrong Answer Runtime: 26 ms\\nYour input\\n[0,1,2]\\n[0,2]\\nOutput\\n1\\nExpected\\n2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1160065,
                "title": "easy-c-approach",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& g) {\\n        if(head==NULL or g.size()<=1) {\\n            return 1;\\n        }\\n        \\n        unordered_set<int> out;\\n        \\n        for(int i=0; i<g.size(); i++) {\\n            out.insert(g[i]);\\n        }\\n        \\n        ListNode*curr = head;\\n        int ans = 0;\\n        \\n        while(curr) {\\n            if(out.count(curr->val)) {\\n                ans++;\\n\\n                while(curr->next and out.count(curr->next->val)) {\\n                    curr = curr->next;\\n                }                \\n            } \\n            curr = curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& g) {\\n        if(head==NULL or g.size()<=1) {\\n            return 1;\\n        }\\n        \\n        unordered_set<int> out;\\n        \\n        for(int i=0; i<g.size(); i++) {\\n            out.insert(g[i]);\\n        }\\n        \\n        ListNode*curr = head;\\n        int ans = 0;\\n        \\n        while(curr) {\\n            if(out.count(curr->val)) {\\n                ans++;\\n\\n                while(curr->next and out.count(curr->next->val)) {\\n                    curr = curr->next;\\n                }                \\n            } \\n            curr = curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606715,
                "title": "my-cpp-soln-using-hasmap-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_map<int,int> mp;\\n        int count = 0;\\n        for(auto a:G)\\n        {\\n            mp[a]++;\\n        }\\n        while(head)\\n        {\\n            bool flag = false;\\n            while(mp[head->val]!=0)\\n            {\\n                mp[head->val]--;\\n                head = head->next;\\n                flag = true;\\n                if(!head)\\n                {\\n                    return ++count;\\n                }\\n            }\\n            if(flag) count++;\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_map<int,int> mp;\\n        int count = 0;\\n        for(auto a:G)\\n        {\\n            mp[a]++;\\n        }\\n        while(head)\\n        {\\n            bool flag = false;\\n            while(mp[head->val]!=0)\\n            {\\n                mp[head->val]--;\\n                head = head->next;\\n                flag = true;\\n                if(!head)\\n                {\\n                    return ++count;\\n                }\\n            }\\n            if(flag) count++;\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178928,
                "title": "javascript-solution",
                "content": "The description doesn\\'t explain the problem well, for an explanation of what they\\'re looking click  [here](http://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case/167790). What we\\'re looking for is nodes (or groups of nodes) that are in G but not connected to each other. \\n\\nIn my solution I have a notConnected variable and a counter variable. \\n\\nFor the first node in the linked list that is in G we will increment the counter by one and set notConnected to false. \\n\\nWhen we find a node that is not in G we have found a break in the chain. We set notConnected to true. Now if we find another node that is in G we can increment the counter again.\\n\\n```\\n    let notConnected = true;\\n    let counter = 0;\\n    \\n    while(head){\\n        if (G.includes(head.val) && notConnected){\\n            counter++;\\n            notConnected = false;\\n        } else if (!G.includes(head.val)){\\n            notConnected = true;\\n        }\\n        head = head.next\\n    }\\n    \\n    return counter;\\n```",
                "solutionTags": [],
                "code": "```\\n    let notConnected = true;\\n    let counter = 0;\\n    \\n    while(head){\\n        if (G.includes(head.val) && notConnected){\\n            counter++;\\n            notConnected = false;\\n        } else if (!G.includes(head.val)){\\n            notConnected = true;\\n        }\\n        head = head.next\\n    }\\n    \\n    return counter;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3477753,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* cur = head;\\n        int n = 0;\\n        while (cur) {\\n            n++;\\n            cur = cur->next;\\n        }\\n        std::vector<int> found (n);\\n        for (auto& val : nums) {\\n            found[val] = 1;\\n        }\\n        int ans = 0;\\n        cur = head;\\n        bool connected = false;\\n        while (cur) {\\n            if (connected and found[cur->val] == 0) {\\n                ans++;\\n                connected = false;\\n            }\\n            else if (!connected and found[cur->val] == 1) {\\n                connected = true;\\n            }\\n            cur = cur->next;\\n        }\\n        if (connected) {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        numsSet:set = {num for num in nums}\\n        \\n        isInLoop = False\\n        componentsCounter = 0\\n        \\n        while (head != None):\\n            if head.val in numsSet:\\n                isInLoop = True\\n            else:\\n                if isInLoop:\\n                    componentsCounter += 1\\n                    isInLoop = False\\n            head = head.next\\n        \\n        if isInLoop:\\n            return componentsCounter+1\\n        return componentsCounter \\n```\\n\\n```Java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        boolean[] map = new boolean[10001];\\n        for (int num : nums) {\\n            map[num] = true;\\n        }\\n        ListNode it = head;\\n        int counter = 0;\\n        int len = 0;\\n        while (it != null) {\\n            if (map[it.val]) {\\n                len++;\\n            }\\n            else {\\n                if (len != 0) {\\n                    counter++;\\n                }\\n                len = 0;\\n            }\\n            it = it.next;\\n        }\\n        if (len != 0) {\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* cur = head;\\n        int n = 0;\\n        while (cur) {\\n            n++;\\n            cur = cur->next;\\n        }\\n        std::vector<int> found (n);\\n        for (auto& val : nums) {\\n            found[val] = 1;\\n        }\\n        int ans = 0;\\n        cur = head;\\n        bool connected = false;\\n        while (cur) {\\n            if (connected and found[cur->val] == 0) {\\n                ans++;\\n                connected = false;\\n            }\\n            else if (!connected and found[cur->val] == 1) {\\n                connected = true;\\n            }\\n            cur = cur->next;\\n        }\\n        if (connected) {\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        numsSet:set = {num for num in nums}\\n        \\n        isInLoop = False\\n        componentsCounter = 0\\n        \\n        while (head != None):\\n            if head.val in numsSet:\\n                isInLoop = True\\n            else:\\n                if isInLoop:\\n                    componentsCounter += 1\\n                    isInLoop = False\\n            head = head.next\\n        \\n        if isInLoop:\\n            return componentsCounter+1\\n        return componentsCounter \\n```\n```Java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        boolean[] map = new boolean[10001];\\n        for (int num : nums) {\\n            map[num] = true;\\n        }\\n        ListNode it = head;\\n        int counter = 0;\\n        int len = 0;\\n        while (it != null) {\\n            if (map[it.val]) {\\n                len++;\\n            }\\n            else {\\n                if (len != 0) {\\n                    counter++;\\n                }\\n                len = 0;\\n            }\\n            it = it.next;\\n        }\\n        if (len != 0) {\\n            counter++;\\n        }\\n        return counter;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446312,
                "title": "0-n-simple-java-solution-using-hashset",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        ListNode parent = null;\\n        int count=0;\\n        Set<Integer> hashset = new HashSet<Integer>();\\n\\n        for(int i : nums){\\n            hashset.add(i);\\n        }\\n\\n        while(curr!=null){\\n\\n            if(parent==null && curr!=null){\\n                if(hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n            else{\\n                if(!hashset.contains(parent.val) && hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n\\n            parent = curr;\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        ListNode parent = null;\\n        int count=0;\\n        Set<Integer> hashset = new HashSet<Integer>();\\n\\n        for(int i : nums){\\n            hashset.add(i);\\n        }\\n\\n        while(curr!=null){\\n\\n            if(parent==null && curr!=null){\\n                if(hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n            else{\\n                if(!hashset.contains(parent.val) && hashset.contains(curr.val)){\\n                    count++;\\n                }\\n            }\\n\\n            parent = curr;\\n            curr = curr.next;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323499,
                "title": "c-easy-intermidate-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:o(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(auto it: nums) s.insert(it);\\n        bool conn=false;\\n        int total=0;\\n        while(head){\\n            int val= head->val;\\n            if(s.count(val)&& conn==false){\\n                conn=true;\\n                total++;\\n            }\\n            else if(s.count(val)==0&& conn==true)conn=false;\\n            head=head->next;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s;\\n        for(auto it: nums) s.insert(it);\\n        bool conn=false;\\n        int total=0;\\n        while(head){\\n            int val= head->val;\\n            if(s.count(val)&& conn==false){\\n                conn=true;\\n                total++;\\n            }\\n            else if(s.count(val)==0&& conn==true)conn=false;\\n            head=head->next;\\n\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302514,
                "title": "easy-solution-o-n-space-and-time-complexity",
                "content": "\\n> # Approach\\nWe need to find number of contigious subsequent element in the linked list which are exist in the array.To check the element exist in the array or not on O(1) time complexity ,hashing is the better way for that so i have created a hashset and add all array elements into it.Now by traversing the linked list ones we can find the number of continious sequence of elements easily.\\n<!-- Describe your approach to solving the problem. -->\\n\\n> # Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n> # Code\\n```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hash = new HashSet<>();\\n        for(int itr : nums){\\n            hash.add(itr);\\n        }\\n        int common = 0;\\n        int size = 0;\\n        while(head!=null){\\n            if(hash.contains(head.val)){\\n                size++;\\n            }\\n            else{\\n                if(size>0){\\n                    common++;\\n                }\\n                size=0;\\n            }\\n            head=head.next;\\n        }\\n        if(size>0){\\n            common+=1;\\n        }\\n        return common;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hash = new HashSet<>();\\n        for(int itr : nums){\\n            hash.add(itr);\\n        }\\n        int common = 0;\\n        int size = 0;\\n        while(head!=null){\\n            if(hash.contains(head.val)){\\n                size++;\\n            }\\n            else{\\n                if(size>0){\\n                    common++;\\n                }\\n                size=0;\\n            }\\n            head=head.next;\\n        }\\n        if(size>0){\\n            common+=1;\\n        }\\n        return common;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094168,
                "title": "java-using-hashset-easy-and-explained-beats-95",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        // Using Set to store the nums values\\n        HashSet<Integer> set = new HashSet<>();\\n    \\n        int count =0;\\n        for(int num: nums)\\n        {\\n            set.add(num);\\n        }\\n        boolean flag = false;\\n        \\n        // we just check if the value occurs in the set and keep it flowing till we dont find the value in the set \\n        \\n        while(curr!=null)\\n        {\\n            while(curr!=null && set.contains(curr.val))\\n            {\\n                flag = true;\\n                curr = curr.next;\\n            }\\n            \\n            \\n            if(flag == true)\\n                count++;\\n           \\n            // reseting the flag \\n            flag = false;\\n            \\n        \\n            if(curr!=null)\\n            curr = curr.next;\\n            \\n        }\\n\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        ListNode curr = head;\\n        // Using Set to store the nums values\\n        HashSet<Integer> set = new HashSet<>();\\n    \\n        int count =0;\\n        for(int num: nums)\\n        {\\n            set.add(num);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3035281,
                "title": "c-beginner-friendly-map",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for(auto x : nums) seen.insert(x);\\n\\n        int answer = 0, cnt = 0;\\n        while(head) {\\n            if(seen.count(head->val)) cnt++;\\n            else {\\n                if(cnt) answer++;\\n                cnt = 0;\\n            }\\n            head = head -> next;\\n        }\\n        if(cnt) answer++;\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> seen;\\n        for(auto x : nums) seen.insert(x);\\n\\n        int answer = 0, cnt = 0;\\n        while(head) {\\n            if(seen.count(head->val)) cnt++;\\n            else {\\n                if(cnt) answer++;\\n                cnt = 0;\\n            }\\n            head = head -> next;\\n        }\\n        if(cnt) answer++;\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975596,
                "title": "c-faster-than-90-hashing-easy-implementation-clean-concise-code",
                "content": "\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n\\n       unordered_map<int,bool>mpp;\\n\\n       for(auto &it : nums) mpp[it] = true;\\n\\n       int res = nums.size();\\n       int cnt = 0;\\n\\n       while(head != NULL)\\n       {\\n           if(mpp[head->val] == true) cnt++;\\n\\n           else\\n           {\\n             if(cnt > 1) res -= cnt - 1;\\n             cnt = 0;   \\n           }\\n           head = head->next;\\n       } \\n\\n       if(cnt > 1) res -= cnt - 1;\\n\\n       return res;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n\\n       unordered_map<int,bool>mpp;\\n\\n       for(auto &it : nums) mpp[it] = true;\\n\\n       int res = nums.size();\\n       int cnt = 0;\\n\\n       while(head != NULL)\\n       {\\n           if(mpp[head->val] == true) cnt++;\\n\\n           else\\n           {\\n             if(cnt > 1) res -= cnt - 1;\\n             cnt = 0;   \\n           }\\n           head = head->next;\\n       } \\n\\n       if(cnt > 1) res -= cnt - 1;\\n\\n       return res;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741690,
                "title": "java-1ms-runtime-faster-than-100",
                "content": "``` java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        // finding max element\\n        int max=0;\\n        for(int x:nums){\\n            max= Math.max(max,x);\\n        }\\n        // Create an array to check whether the element is present in nums or not or we can use HashSet\\n        boolean[] isPresent = new boolean[max+1];\\n        \\n        for(int x:nums)\\n            isPresent[x]=true;\\n        \\n        int count=0, components=0;\\n    \\n        // Traverse the linked list\\n        while(head!=null)\\n        {\\n            // Increase counter if the current value is present in nums array\\n            if(head.val<=max && isPresent[head.val]){\\n                count++;\\n            }\\n            else{\\n                // If there are more than one adjacent element in a component, Increase component count and reset counter.\\n                if(count>0){\\n                    components++; \\n                    count=0;\\n                }\\n            }\\n            head=head.next;\\n        }\\n        // Check if there is any remaining component at the end of the linked list\\n        if(count>0)\\n            components++;\\n        return components;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "``` java []\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        // finding max element\\n        int max=0;\\n        for(int x:nums){\\n            max= Math.max(max,x);\\n        }\\n        // Create an array to check whether the element is present in nums or not or we can use HashSet\\n        boolean[] isPresent = new boolean[max+1];\\n        \\n        for(int x:nums)\\n            isPresent[x]=true;\\n        \\n        int count=0, components=0;\\n    \\n        // Traverse the linked list\\n        while(head!=null)\\n        {\\n            // Increase counter if the current value is present in nums array\\n            if(head.val<=max && isPresent[head.val]){\\n                count++;\\n            }\\n            else{\\n                // If there are more than one adjacent element in a component, Increase component count and reset counter.\\n                if(count>0){\\n                    components++; \\n                    count=0;\\n                }\\n            }\\n            head=head.next;\\n        }\\n        // Check if there is any remaining component at the end of the linked list\\n        if(count>0)\\n            components++;\\n        return components;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542916,
                "title": "89-tc-and-77-sc-easy-python-solution",
                "content": "```\\ndef numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\tcurr = head\\n\\tans = 0\\n\\ts = set(nums)\\n\\twhile(curr):\\n\\t\\tif(curr.val in s and not(curr.next and curr.next.val in s)):\\n\\t\\t\\tans += 1\\n\\t\\tcurr = curr.next\\n\\treturn ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\ndef numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\tcurr = head\\n\\tans = 0\\n\\ts = set(nums)\\n\\twhile(curr):\\n\\t\\tif(curr.val in s and not(curr.next and curr.next.val in s)):\\n\\t\\t\\tans += 1\\n\\t\\tcurr = curr.next\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2334662,
                "title": "java-o-n-hashset-easy-understanding",
                "content": "\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int ans = 0;\\n\\n        while (head != null) {\\n            if (set.contains(head.val)){\\n                ans++;\\n                while (head != null && set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            } else {\\n                while (head != null && !set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            set.add(nums[i]);\\n        }\\n        int ans = 0;\\n\\n        while (head != null) {\\n            if (set.contains(head.val)){\\n                ans++;\\n                while (head != null && set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            } else {\\n                while (head != null && !set.contains(head.val)){\\n                    head = head.next;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1946978,
                "title": "intuitive-and-consice-python-solution-o-n-time-o-1-space",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        nums = set(nums)\\n        cur = head\\n        res = 0\\n        connected = False\\n        \\n        while cur:\\n            if cur.val in nums:\\n                if not connected:\\n                    res += 1\\n                    connected = True\\n            else:\\n                connected = False\\n            cur = cur.next\\n            \\n        return(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        nums = set(nums)\\n        cur = head\\n        res = 0\\n        connected = False\\n        \\n        while cur:\\n            if cur.val in nums:\\n                if not connected:\\n                    res += 1\\n                    connected = True\\n            else:\\n                connected = False\\n            cur = cur.next\\n            \\n        return(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1829845,
                "title": "linked-list-easy-code",
                "content": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        if(head == NULL) return false ;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast) return true;\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool hasCycle(ListNode *head) {\\n        ListNode *slow = head;\\n        ListNode *fast = head;\\n        if(head == NULL) return false ;\\n        while(fast && fast->next){\\n            slow = slow->next;\\n            fast = fast->next->next;\\n            if(slow==fast) return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1689039,
                "title": "c-solution",
                "content": "Map the componets to get if numbers present in array.\\nTraverse Linked List, and keep updating count accordingly.\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i: nums)\\n            mp[i]++;\\n        int count=0;\\n        ListNode* tmp = head;\\n        int prev=0;\\n        while(tmp!=NULL)\\n        {\\n            if(mp[tmp->val]!=0)\\n            {\\n                if(prev==0)\\n                    prev=1,count++;\\n            }\\n            else\\n                prev=0;\\n            tmp=tmp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto i: nums)\\n            mp[i]++;\\n        int count=0;\\n        ListNode* tmp = head;\\n        int prev=0;\\n        while(tmp!=NULL)\\n        {\\n            if(mp[tmp->val]!=0)\\n            {\\n                if(prev==0)\\n                    prev=1,count++;\\n            }\\n            else\\n                prev=0;\\n            tmp=tmp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628810,
                "title": "new-approach-and-easy-using-set-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans = 0;\\n\\t\\t\\n        unordered_set<int> st(nums.begin(),nums.end()); \\n\\t\\t\\n        for(ListNode * i = head;i != NULL;i = i->next){\\n\\t\\t\\n            //check last node for all possible components \\n            //so increse ans if node is last or next node of the current node is not present in nums vector\\n            if(st.count(i->val) and (!i->next or !st.count(i->next->val)))\\n                ans++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans = 0;\\n\\t\\t\\n        unordered_set<int> st(nums.begin(),nums.end()); \\n\\t\\t\\n        for(ListNode * i = head;i != NULL;i = i->next){\\n\\t\\t\\n            //check last node for all possible components \\n            //so increse ans if node is last or next node of the current node is not present in nums vector\\n            if(st.count(i->val) and (!i->next or !st.count(i->next->val)))\\n                ans++;\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584918,
                "title": "c-solution-using-hashmap",
                "content": "```\\n int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto &i:nums){\\n            mp[i]++;\\n        }\\n        int count=0;\\n        while(head!=NULL){\\n            if(mp[head->val]!=0){\\n                while(head!=NULL && mp[head->val]!=0){\\n                    head=head->next;\\n                }\\n                count++;\\n            }\\n            else{\\n                head=head->next;\\n            }\\n        }\\n        return count;\\n    }\\n```\\nFor More LeetCode Problem\\'s Solution(Topic-Wise)Please Check Out;\\nhttps://github.com/Ariyanlaskar/DSA/tree/master/LeetCode",
                "solutionTags": [
                    "C",
                    "Hash Table"
                ],
                "code": "```\\n int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        for(auto &i:nums){\\n            mp[i]++;\\n        }\\n        int count=0;\\n        while(head!=NULL){\\n            if(mp[head->val]!=0){\\n                while(head!=NULL && mp[head->val]!=0){\\n                    head=head->next;\\n                }\\n                count++;\\n            }\\n            else{\\n                head=head->next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1312496,
                "title": "c-simple-single-pass",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n         int ans=0;\\n        unordered_set<int>st;\\n        for(auto & i:nums)\\n            st.insert(i);\\n        while(head)\\n        {\\n            if(st.find(head->val)!=st.end())\\n            {\\n                ans++;\\n                while( head && st.find(head->val)!=st.end())\\n                    head=head->next;\\n            }\\n            else\\n                head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nDo UPVOTE if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n         int ans=0;\\n        unordered_set<int>st;\\n        for(auto & i:nums)\\n            st.insert(i);\\n        while(head)\\n        {\\n            if(st.find(head->val)!=st.end())\\n            {\\n                ans++;\\n                while( head && st.find(head->val)!=st.end())\\n                    head=head->next;\\n            }\\n            else\\n                head=head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214392,
                "title": "solution-in-java",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        int ctr=0;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int n : G){\\n            set.add(n);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                ctr++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return ctr;\\n    }\\n}\\n```\\nPlease **upvote**, if you like the solution:)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        int ctr=0;\\n        HashSet<Integer> set = new HashSet<Integer>();\\n        \\n        for(int n : G){\\n            set.add(n);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                ctr++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return ctr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1200557,
                "title": "c-simple-easy-to-understand-solution-o-n",
                "content": "* We use unordered_set so that the searching of element takes constant (O(1)) time.\\n* Then we traverse over the list, and if the current element is present in the set then we make our check variable (x), 1, otherwise, we can increase our result variable based on the condition that whether we found the previous element in the set or not.\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        \\n        int res = 0, x = 0;\\n        for(auto p = head; p; p = p->next) {\\n            bool check = s.find(p->val) != s.end();\\n            if(x == 1 || check)\\n                check ? x = 1 : (res++, x = 0);\\n        }\\n        return res + (x == 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        \\n        int res = 0, x = 0;\\n        for(auto p = head; p; p = p->next) {\\n            bool check = s.find(p->val) != s.end();\\n            if(x == 1 || check)\\n                check ? x = 1 : (res++, x = 0);\\n        }\\n        return res + (x == 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 820313,
                "title": "c-95-87-easy-to-understand",
                "content": "***Runtime: 52 ms, faster than 95.87% of C++ online submissions for Linked List Components.\\nMemory Usage: 21.4 MB, less than 80.14% of C++ online submissions for Linked List Components.***\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> elements(G.begin(), G.end());\\n        int result = 0;\\n        while(head){\\n            if(elements.count(head->val)){\\n                result++;\\n                while(head->next && elements.count(head->next->val)){\\n                   head = head->next; \\n                }\\n            }\\n            head = head->next; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> elements(G.begin(), G.end());\\n        int result = 0;\\n        while(head){\\n            if(elements.count(head->val)){\\n                result++;\\n                while(head->next && elements.count(head->next->val)){\\n                   head = head->next; \\n                }\\n            }\\n            head = head->next; \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 764360,
                "title": "c-clean-readable-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> lookup(begin(G), end(G));\\n        int count = 0;\\n        auto curNode = head;\\n        \\n        while (curNode) {\\n            auto nextNode = curNode->next;\\n            \\n            if (lookup.count(curNode->val))\\n                if (!nextNode or !lookup.count(nextNode->val))\\n                    count++;\\n            \\n            curNode = nextNode;\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> lookup(begin(G), end(G));\\n        int count = 0;\\n        auto curNode = head;\\n        \\n        while (curNode) {\\n            auto nextNode = curNode->next;\\n            \\n            if (lookup.count(curNode->val))\\n                if (!nextNode or !lookup.count(nextNode->val))\\n                    count++;\\n            \\n            curNode = nextNode;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 645465,
                "title": "c-clean-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        \\n        ListNode* r = head;\\n        unordered_set<int>s(G.begin(), G.end());\\n        int count = 0;\\n        while (r) {\\n            if (s.find(r->val) != s.end() && (r->next == NULL || s.find(r->next->val) == s.end()))\\n                count++;\\n            r = r->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        \\n        ListNode* r = head;\\n        unordered_set<int>s(G.begin(), G.end());\\n        int count = 0;\\n        while (r) {\\n            if (s.find(r->val) != s.end() && (r->next == NULL || s.find(r->next->val) == s.end()))\\n                count++;\\n            r = r->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 468700,
                "title": "python-3-three-lines-108-ms",
                "content": "```\\nclass Solution:\\n    def numComponents(self, H: ListNode, G: List[int]) -> int:\\n        S, c = set(G), 0\\n        while H != None: c, H = c + (H.val in S and (H.next == None or H.next.val not in S)), H.next\\n        return c\\n\\t\\t\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, H: ListNode, G: List[int]) -> int:\\n        S, c = set(G), 0\\n        while H != None: c, H = c + (H.val in S and (H.next == None or H.next.val not in S)), H.next\\n        return c\\n\\t\\t\\n\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 452897,
                "title": "single-traversal-constant-space-easy-and-concise",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n  if(!head) return null;\\n  let GSet = new Set(G);  \\n  let ret = 0, series = 0;\\n  while(head) {\\n    series = GSet.has(head.val) ? series + 1 : 0;\\n    if(series == 1)\\n      ret += 1;\\n    head = head.next;\\n  }\\n  return ret;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n  if(!head) return null;\\n  let GSet = new Set(G);  \\n  let ret = 0, series = 0;\\n  while(head) {\\n    series = GSet.has(head.val) ? series + 1 : 0;\\n    if(series == 1)\\n      ret += 1;\\n    head = head.next;\\n  }\\n  return ret;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 399773,
                "title": "go-golang",
                "content": "```\\n/**\\n * Approach: Count The End Node of Component\\n * Intuition\\n * Instead of thinking about connected components in G, think about them in the linked list.\\n * Connected components in G must occur consecutively in the linked list.\\n * \\n * Algorithm\\n * Scanning through the list, if node.val is in G and node.next.val isn\\'t in G (including if node.next is null),\\n * then this must be the end of a connected component.\\n * For example, if the list is 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7, and G = [0, 2, 3, 5, 7],\\n * then when scanning through the list, we fulfill the above condition at 0, 3, 5, 7, for a total answer of 4.\\n * \\n * Complexity Analysis\\n * Time Complexity : O(N+G.length), where N is the length of the linked list with root node head.\\n * Space Complexity: O(G.length), to store gMap.\\n */\\n \\nfunc numComponents(head *ListNode, G []int) int {\\n    var ans int\\n\\t\\n    var gMap = make(map[int]bool, len(G))\\n    for i := range G {\\n    \\tgMap[G[i]] = true\\n    }\\n\\n    for curr, i := head, 0; curr != nil; curr, i = curr.Next, i+1 {    \\t\\n        if _, ok := gMap[curr.Val]; !ok {\\n            continue\\n        }\\n        \\n        if curr.Next == nil {\\n            ans++\\n            continue\\n        }\\n\\n        if _, ok := gMap[curr.Next.Val]; !ok {\\n            ans++\\n        }\\n    }\\n\\n    return ans\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Approach: Count The End Node of Component\\n * Intuition\\n * Instead of thinking about connected components in G, think about them in the linked list.\\n * Connected components in G must occur consecutively in the linked list.\\n * \\n * Algorithm\\n * Scanning through the list, if node.val is in G and node.next.val isn\\'t in G (including if node.next is null),\\n * then this must be the end of a connected component.\\n * For example, if the list is 0 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7, and G = [0, 2, 3, 5, 7],\\n * then when scanning through the list, we fulfill the above condition at 0, 3, 5, 7, for a total answer of 4.\\n * \\n * Complexity Analysis\\n * Time Complexity : O(N+G.length), where N is the length of the linked list with root node head.\\n * Space Complexity: O(G.length), to store gMap.\\n */\\n \\nfunc numComponents(head *ListNode, G []int) int {\\n    var ans int\\n\\t\\n    var gMap = make(map[int]bool, len(G))\\n    for i := range G {\\n    \\tgMap[G[i]] = true\\n    }\\n\\n    for curr, i := head, 0; curr != nil; curr, i = curr.Next, i+1 {    \\t\\n        if _, ok := gMap[curr.Val]; !ok {\\n            continue\\n        }\\n        \\n        if curr.Next == nil {\\n            ans++\\n            continue\\n        }\\n\\n        if _, ok := gMap[curr.Next.Val]; !ok {\\n            ans++\\n        }\\n    }\\n\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 311872,
                "title": "javascript-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n    let map=new Map();\\n    G.map((item)=>{\\n        map.set(item,!0);\\n    });\\n    let c=0;\\n    while(head){\\n        if(map.has(head.val)){\\n\\t\\twhile(head&&map.has(head.val))\\n\\t\\thead=head.next;\\n\\t\\tc++;    \\n        }             \\n        if(head)\\n        head=head.next;\\n    }\\n    return c;  \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val) {\\n *     this.val = val;\\n *     this.next = null;\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @param {number[]} G\\n * @return {number}\\n */\\nvar numComponents = function(head, G) {\\n    let map=new Map();\\n    G.map((item)=>{\\n        map.set(item,!0);\\n    });\\n    let c=0;\\n    while(head){\\n        if(map.has(head.val)){\\n\\t\\twhile(head&&map.has(head.val))\\n\\t\\thead=head.next;\\n\\t\\tc++;    \\n        }             \\n        if(head)\\n        head=head.next;\\n    }\\n    return c;  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 123826,
                "title": "simple-java-solution-using-set",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head == null) return 0;\\n        int res = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        for(int n:G)\\n            hs.add(n);        \\n        ListNode curr = head;\\n        while(curr != null){\\n            int val = curr.val;\\n            if(!hs.contains(val)){\\n                curr = curr.next;\\n            }else{\\n                res++;\\n                while(curr != null && hs.contains(val)){\\n                    curr = curr.next;\\n                    if(curr != null)\\n                        val = curr.val;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head == null) return 0;\\n        int res = 0;\\n        Set<Integer> hs = new HashSet<>();\\n        for(int n:G)\\n            hs.add(n);        \\n        ListNode curr = head;\\n        while(curr != null){\\n            int val = curr.val;\\n            if(!hs.contains(val)){\\n                curr = curr.next;\\n            }else{\\n                res++;\\n                while(curr != null && hs.contains(val)){\\n                    curr = curr.next;\\n                    if(curr != null)\\n                        val = curr.val;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010854,
                "title": "java-solution-o-n-easy-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int count = 1;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            hs.add(nums[i]);\\n\\n        boolean bool = true;\\n        boolean bool1 = true;\\n\\n        while(head != null){\\n            if(!hs.contains(head.val) && bool){\\n                count++;\\n                bool = false;\\n            }\\n            else if(hs.contains(head.val))\\n                bool = true;\\n\\n            if(head.next == null && !hs.contains(head.val))\\n                count--;\\n\\n            if(bool1 && !hs.contains(head.val))\\n                count--;\\n\\n            bool1 = false;\\n\\n            head = head.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        int count = 1;\\n\\n        for(int i = 0; i < nums.length; i++)\\n            hs.add(nums[i]);\\n\\n        boolean bool = true;\\n        boolean bool1 = true;\\n\\n        while(head != null){\\n            if(!hs.contains(head.val) && bool){\\n                count++;\\n                bool = false;\\n            }\\n            else if(hs.contains(head.val))\\n                bool = true;\\n\\n            if(head.next == null && !hs.contains(head.val))\\n                count--;\\n\\n            if(bool1 && !hs.contains(head.val))\\n                count--;\\n\\n            bool1 = false;\\n\\n            head = head.next;\\n        }\\n\\n        return count;\\n    }\\n}\\n// UP-VOTE IF HELPFUL\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3802854,
                "title": "easiest-solution-using-loops-without-using-hashset-for-begginers",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public boolean find(int[] nums, int target){\\n        for(int i = 0; i<nums.length; i++){\\n            if(target == nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public int numComponents(ListNode head, int[] nums) {\\n        int comp = 0;\\n        int found = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            if(find(nums, curr.val)){\\n                found++;\\n                if(found == 1){\\n                    comp++;\\n                }\\n            }else{\\n                found = 0;\\n            }\\n            curr = curr.next;\\n        }\\n        return comp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public boolean find(int[] nums, int target){\\n        for(int i = 0; i<nums.length; i++){\\n            if(target == nums[i]){\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n    public int numComponents(ListNode head, int[] nums) {\\n        int comp = 0;\\n        int found = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            if(find(nums, curr.val)){\\n                found++;\\n                if(found == 1){\\n                    comp++;\\n                }\\n            }else{\\n                found = 0;\\n            }\\n            curr = curr.next;\\n        }\\n        return comp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769418,
                "title": "simple-and-easy-solution-c-linked-list-undordered-map",
                "content": "\\n\\n    class Solution {\\n    public:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }\\n        int cnt=0;\\n        while(head!=NULL){\\n            if(mp.find(head->val)!=mp.end()){\\n                while(head!=NULL and mp.find(head->val)!=mp.end()){\\n                    head=head->next;\\n                }\\n                cnt++;\\n            }\\n            if(head!=NULL){\\n                head=head->next;\\n            }\\n        }\\n        return cnt;\\n       }\\n    };",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "class Solution {\\n    public:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++){\\n            mp[nums[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3698720,
                "title": "o-n-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(head==nullptr)\\n            return 0;\\n        unordered_set<int> s{nums.begin(),nums.end()};\\n        int count=0;\\n        while(head!=nullptr){\\n            if(s.find(head->val)!=s.end()){\\n                count++;\\n                while(head->next!=nullptr && s.find(head->next->val)  !=s.end())\\n            head=head->next;\\n            }\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        if(head==nullptr)\\n            return 0;\\n        unordered_set<int> s{nums.begin(),nums.end()};\\n        int count=0;\\n        while(head!=nullptr){\\n            if(s.find(head->val)!=s.end()){\\n                count++;\\n                while(head->next!=nullptr && s.find(head->next->val)  !=s.end())\\n            head=head->next;\\n            }\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3545163,
                "title": "clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n       unordered_set<int> s (nums.begin(),nums.end());\\n       int  res = 0; \\n       ListNode* temp = head; \\n       int prev = head->val; \\n\\n       while(temp!=NULL)\\n       {\\n         if(s.find(temp->val)==s.end() && temp!=head && s.find(prev)!=s.end()) // if this node is not in array but prev node was there in array \\n// suppose this node and prev node both are not in set we don,t count them\\n         res++;\\n         prev = temp->val;\\n         temp = temp->next;\\n       }\\n       if(s.find(prev)!=s.end()) // for last node\\n       res++;\\n        \\n       return res;\\n       \\n\\n \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n       unordered_set<int> s (nums.begin(),nums.end());\\n       int  res = 0; \\n       ListNode* temp = head; \\n       int prev = head->val; \\n\\n       while(temp!=NULL)\\n       {\\n         if(s.find(temp->val)==s.end() && temp!=head && s.find(prev)!=s.end()) // if this node is not in array but prev node was there in array \\n// suppose this node and prev node both are not in set we don,t count them\\n         res++;\\n         prev = temp->val;\\n         temp = temp->next;\\n       }\\n       if(s.find(prev)!=s.end()) // for last node\\n       res++;\\n        \\n       return res;\\n       \\n\\n \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535221,
                "title": "c-iterative",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIterate over the consecutively connected nodes of the linked list.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nStart from the head and traverse the current consecutively connected nodes and increment `component` by `1`.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int components = 0;\\n        \\n        while(head)\\n        {\\n            if(s.count(head->val))\\n            {\\n                while(head && s.count(head->val))\\n                    head = head->next;\\n                components ++;\\n            }\\n            if(head)\\n                head = head->next;\\n        }\\n        return components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> s(nums.begin(), nums.end());\\n        int components = 0;\\n        \\n        while(head)\\n        {\\n            if(s.count(head->val))\\n            {\\n                while(head && s.count(head->val))\\n                    head = head->next;\\n                components ++;\\n            }\\n            if(head)\\n                head = head->next;\\n        }\\n        return components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3165971,
                "title": "c-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> set(nums.begin(),nums.end());\\n        unordered_set<int> parents;\\n        \\n        int par= head->val;\\n        while(head){\\n            if(set.count(head->val)){\\n                parents.insert(par);\\n                head= head->next;\\n            }\\n            else{\\n                while(head && set.count(head->val)==0) head= head->next;\\n                if(!head) break;\\n                par= head->val;\\n            }\\n        }\\n        \\n        return parents.size();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> set(nums.begin(),nums.end());\\n        unordered_set<int> parents;\\n        \\n        int par= head->val;\\n        while(head){\\n            if(set.count(head->val)){\\n                parents.insert(par);\\n                head= head->next;\\n            }\\n            else{\\n                while(head && set.count(head->val)==0) head= head->next;\\n                if(!head) break;\\n                par= head->val;\\n            }\\n        }\\n        \\n        return parents.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3068232,
                "title": "fully-commented-easy-o-n-solution",
                "content": "\\n# Approach\\n\\nTo approach this question, first of all think , when we have to increment our component count and when not?\\n\\n- We will not increment our count when we conme to know that the element is a part of our previous chain and increment it when it is not.\\n- Then how we get to know that element is part of chain or not??\\n- Simple,maintain your flag variable...but how??\\n- See first we will initialize our flag as true and then traverse our whole ll until the head is null to check that whether head->val is in the nums array or not..(so to check this, should we have to traverse the whole nums??..No,No..do it in constant time using map :) \\n- Now,if the element in ll is found in map and flag is true(it means elemnt is not part of any chain),increment count and set flag as false(so that futher elements in ll who is part of chain do not contribute to the component count).\\n- if element is not found in map,set flag as true so that incase we will find some element which is in map, we can increment our count.\\n\\n# Complexity\\n- Time complexity:\\nAs we are traversing our linked list only once, so time complexity is **O(n)**\\n\\n- Space complexity:\\nHere we are using unordered map to store the elements of nums array ,thus S.C is also **O(n)**\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        // traversing the nums array and mapping the elements \\n        for(auto e:nums){\\n            mp[e]++;\\n        }\\n        \\n        int count=0;\\n        bool flag=true;  //flag variable to keep a check if element belongs to the connected chain or not\\n        \\n        while(head){\\n           // if found the element in map and flag is true---\\n            // it means the element does not belong to any previous chain in ll thus increment the count variable and change flag to false\\n          if(mp.find(head->val)!=mp.end() && flag){\\n               count++;\\n               flag=false;\\n           } \\n         // if element is not in map then reset flag as true so that incase we will find some element which is in map, we can increment count\\n        else if(mp.find(head->val)==mp.end()) flag=true;\\n        head=head->next;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int>mp;\\n        // traversing the nums array and mapping the elements \\n        for(auto e:nums){\\n            mp[e]++;\\n        }\\n        \\n        int count=0;\\n        bool flag=true;  //flag variable to keep a check if element belongs to the connected chain or not\\n        \\n        while(head){\\n           // if found the element in map and flag is true---\\n            // it means the element does not belong to any previous chain in ll thus increment the count variable and change flag to false\\n          if(mp.find(head->val)!=mp.end() && flag){\\n               count++;\\n               flag=false;\\n           } \\n         // if element is not in map then reset flag as true so that incase we will find some element which is in map, we can increment count\\n        else if(mp.find(head->val)==mp.end()) flag=true;\\n        head=head->next;\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2960162,
                "title": "simple-linked-list-traversal-beats-99-python-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        my=set([])\\n        for i in nums:\\n            my.add(i)\\n        curr=head\\n        # flag=False\\n        count=0\\n        while curr!=None:\\n            flag=False\\n            while curr!=None and curr.val in my:\\n                flag=True\\n                curr=curr.next\\n            if flag==True:\\n                count+=1\\n            if curr!=None and curr.next!=None:\\n                curr=curr.next\\n            else:\\n                break\\n        return count\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        my=set([])\\n        for i in nums:\\n            my.add(i)\\n        curr=head\\n        # flag=False\\n        count=0\\n        while curr!=None:\\n            flag=False\\n            while curr!=None and curr.val in my:\\n                flag=True\\n                curr=curr.next\\n            if flag==True:\\n                count+=1\\n            if curr!=None and curr.next!=None:\\n                curr=curr.next\\n            else:\\n                break\\n        return count\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2883410,
                "title": "c",
                "content": "```\\nint depth(struct ListNode* head){\\n    if(head == NULL)\\n        return 0;\\n    else\\n        return 1 + depth(head->next);\\n}\\nint numComponents(struct ListNode* head, int* nums, int numsSize){\\n    int n = depth(head);\\n    bool* exist = calloc(n , sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        exist[nums[i]] = true;\\n    }\\n    int ans = 0;\\n    struct ListNode* tmp = head;\\n    int cn = 0;\\n    while(tmp){\\n        if(exist[tmp->val]){\\n            cn++;\\n        }\\n        else{\\n            if(cn)\\n                ans++;\\n            cn = 0;\\n        }\\n        tmp = tmp->next;\\n    }\\n    if(cn)\\n        ans++;\\n    free(exist);\\n    return ans;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint depth(struct ListNode* head){\\n    if(head == NULL)\\n        return 0;\\n    else\\n        return 1 + depth(head->next);\\n}\\nint numComponents(struct ListNode* head, int* nums, int numsSize){\\n    int n = depth(head);\\n    bool* exist = calloc(n , sizeof(int));\\n    for(int i = 0; i < numsSize; i++){\\n        exist[nums[i]] = true;\\n    }\\n    int ans = 0;\\n    struct ListNode* tmp = head;\\n    int cn = 0;\\n    while(tmp){\\n        if(exist[tmp->val]){\\n            cn++;\\n        }\\n        else{\\n            if(cn)\\n                ans++;\\n            cn = 0;\\n        }\\n        tmp = tmp->next;\\n    }\\n    if(cn)\\n        ans++;\\n    free(exist);\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2843145,
                "title": "c-easy-understandable-code",
                "content": "What we use is unordered_set just because we have to see whether the element is eligible to become a component and we cannot apply .find function on vector so what we done we define a set and assign vector values to it.\\nAfter that we traverse the whole linked list if we found a non component element we simply update our result with the flag value.\\nAnd the last condition is for remaining component if left over then for that consideration we done that if part\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>set;\\n        for(int i:nums){\\n            set.insert(i);\\n        }\\n        int res=0,flag=0;\\n        while(head){\\n            \\n            if(set.find(head->val)!=set.end()){\\n                flag=1;\\n            }\\n            else{\\n                res+=flag;\\n                flag=0;\\n            }\\n            head=head->next;\\n        }\\n        if(flag==1)res++;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int>set;\\n        for(int i:nums){\\n            set.insert(i);\\n        }\\n        int res=0,flag=0;\\n        while(head){\\n            \\n            if(set.find(head->val)!=set.end()){\\n                flag=1;\\n            }\\n            else{\\n                res+=flag;\\n                flag=0;\\n            }\\n            head=head->next;\\n        }\\n        if(flag==1)res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2261733,
                "title": "python-o-1-solution-without-hash-set",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        if not head:\\n            return 0\\n        \\n        connected_component = 0\\n        total = 0\\n        \\n        while head:\\n            if head.val in nums:\\n                connected_component+=1\\n            else:\\n                if connected_component > 0:\\n                    total+=1\\n                    connected_component = 0\\n            head = head.next\\n            \\n        if connected_component > 0:\\n            total+=1\\n            connected_component = 0\\n\\n        return total\\n                    \\n                \\n                \\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        if not head:\\n            return 0\\n        \\n        connected_component = 0\\n        total = 0\\n        \\n        while head:\\n            if head.val in nums:\\n                connected_component+=1\\n            else:\\n                if connected_component > 0:\\n                    total+=1\\n                    connected_component = 0\\n            head = head.next\\n            \\n        if connected_component > 0:\\n            total+=1\\n            connected_component = 0\\n\\n        return total\\n                    \\n                \\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2230598,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        if(head == NULL) return 0;\\n        \\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        auto it = m.begin();\\n        int count = 0, flag = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            m[nums[i]] = 1;\\n        }\\n        \\n        while(head != NULL)\\n        {\\n            it = m.find(head->val);\\n            if(it != m.end() && (*it).second == 1)\\n            {\\n                it = m.find(head->val);\\n                v.push_back(1);\\n            }\\n            else\\n            {\\n                v.push_back(0);\\n            }\\n            head = head->next;\\n        }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            if(flag != v[i])\\n            {\\n                if(v[i] == 1)\\n                {\\n                    count++;\\n                }\\n                flag = v[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        \\n        if(head == NULL) return 0;\\n        \\n        unordered_map<int, int> m;\\n        vector<int> v;\\n        auto it = m.begin();\\n        int count = 0, flag = 0;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            m[nums[i]] = 1;\\n        }\\n        \\n        while(head != NULL)\\n        {\\n            it = m.find(head->val);\\n            if(it != m.end() && (*it).second == 1)\\n            {\\n                it = m.find(head->val);\\n                v.push_back(1);\\n            }\\n            else\\n            {\\n                v.push_back(0);\\n            }\\n            head = head->next;\\n        }\\n        \\n        for(int i=0; i<v.size(); i++)\\n        {\\n            if(flag != v[i])\\n            {\\n                if(v[i] == 1)\\n                {\\n                    count++;\\n                }\\n                flag = v[i];\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2186950,
                "title": "c-few-lines-of-code-set-hashing",
                "content": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> s;\\n        //storing every lement of nums in set\\n        for(auto i:nums) s.insert(i);\\n        ListNode* temp=head;\\n        while(temp->next!=NULL and temp!=NULL){\\n            //if the value next to temp pointer is  present in set than it forms a connected component\\n            if(s.find(temp->next->val)!=s.end()){\\n                //removing current node from set so that only one node from each connected component will\\n                //be present in set\\n                s.erase(temp->val);\\n            }\\n            temp=temp->next;\\n        }\\n        return s.size();\\n    }\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> s;\\n        //storing every lement of nums in set\\n        for(auto i:nums) s.insert(i);\\n        ListNode* temp=head;\\n        while(temp->next!=NULL and temp!=NULL){\\n            //if the value next to temp pointer is  present in set than it forms a connected component\\n            if(s.find(temp->next->val)!=s.end()){\\n                //removing current node from set so that only one node from each connected component will\\n                //be present in set\\n                s.erase(temp->val);\\n            }\\n            temp=temp->next;\\n        }\\n        return s.size();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2160518,
                "title": "easy-explanation-using-hashset-o-n-with-comments",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> st;  // save all values of nums in hashset\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        if(head->next==NULL){             // check for edge case , if theirs only one node \\n            if(st.find(head->val)!=st.end()){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int count=0;\\n\\n        while(head){\\n            \\n            if(st.find(head->val)!=st.end()){ // if head->val is present in set\\n                \\n            while(st.find(head->val)!=st.end() && head && head->next){ \\n// since we need connected components we keep incrementing our pointer untill its val is present in set\\n                head=head->next;\\n            }\\n// as we get out of the while loop we increment our counter- meaning 1 component is added \\n            count++;\\n            }\\n// if head->val not in set , we simply increment our pointer to check for next node\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> st;  // save all values of nums in hashset\\n        for(auto it:nums){\\n            st.insert(it);\\n        }\\n        if(head->next==NULL){             // check for edge case , if theirs only one node \\n            if(st.find(head->val)!=st.end()){\\n                return 1;\\n            }\\n            return 0;\\n        }\\n        int count=0;\\n\\n        while(head){\\n            \\n            if(st.find(head->val)!=st.end()){ // if head->val is present in set\\n                \\n            while(st.find(head->val)!=st.end() && head && head->next){ \\n// since we need connected components we keep incrementing our pointer untill its val is present in set\\n                head=head->next;\\n            }\\n// as we get out of the while loop we increment our counter- meaning 1 component is added \\n            count++;\\n            }\\n// if head->val not in set , we simply increment our pointer to check for next node\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2093002,
                "title": "simple-logical-c-code-83-time",
                "content": "# **If you like the implementation then Please help me by increasing my reputation. By clicking the up arrow on the left of my image.**\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int> components;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            components[nums[i]]++;\\n        }\\n        int cnt = 0;\\n        bool breakpoint = false;\\n        while(head)\\n        {\\n            if(!components.count(head->val))\\n            {\\n                breakpoint = false;\\n            }\\n            else if(components.count(head->val) && !breakpoint)\\n            {\\n                cnt++;\\n                breakpoint = true;\\n            }\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_map<int,int> components;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            components[nums[i]]++;\\n        }\\n        int cnt = 0;\\n        bool breakpoint = false;\\n        while(head)\\n        {\\n            if(!components.count(head->val))\\n            {\\n                breakpoint = false;\\n            }\\n            else if(components.count(head->val) && !breakpoint)\\n            {\\n                cnt++;\\n                breakpoint = true;\\n            }\\n            head = head->next;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1941599,
                "title": "java-solution-fastser-than-90-percent-beginner-friendly",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int entry:nums){\\n            set.add(entry);\\n        }\\n        int count =0;\\n        boolean  isconnected =false;\\n        ListNode temp = head;\\n        \\n        while( temp !=null){\\n            \\n            if(set.contains(temp.val)){\\n                if(isconnected==false){\\n                    isconnected = true;\\n                    count++;\\n                }\\n            }\\n            else{\\n                isconnected = false;\\n            }\\n            temp = temp.next;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int entry:nums){\\n            set.add(entry);\\n        }\\n        int count =0;\\n        boolean  isconnected =false;\\n        ListNode temp = head;\\n        \\n        while( temp !=null){\\n            \\n            if(set.contains(temp.val)){\\n                if(isconnected==false){\\n                    isconnected = true;\\n                    count++;\\n                }\\n            }\\n            else{\\n                isconnected = false;\\n            }\\n            temp = temp.next;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1908379,
                "title": "easy-java-soln",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            numSet.add(nums[i]);\\n        }\\n        \\n        int sequences = 0;\\n        \\n        \\n        boolean inASequence = false;\\n        \\n        while(head != null) {\\n            \\n            if(inASequence) {\\n                if(numSet.contains(head.val)){ // If we are in a sequence and we encounter something part of array just continue.\\n                    head = head.next;\\n                    continue;\\n                } \\n                inASequence = false;\\n                head = head.next;\\n            } else { // If we are not in a sequence and a Sequence starts then increase sequence count and set flag to true.\\n                if(numSet.contains(head.val)) {\\n                    inASequence = true;\\n                    sequences++;\\n                }\\n                head = head.next;   \\n            }\\n        }\\n        return sequences;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> numSet = new HashSet<>();\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            numSet.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1899949,
                "title": "linked-list-components",
                "content": "\\t\\tcount=0\\n        seen=set(nums)\\n        prev=None\\n        while(head):\\n            if(head.val in seen and prev not in seen):\\n                count+=1\\n            prev,head=head.val,head.next\\n        return count",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\t\\tcount=0\\n        seen=set(nums)\\n        prev=None\\n        while(head):\\n            if(head.val in seen and prev not in seen):\\n                count+=1\\n            prev,head=head.val,head.next\\n        return count",
                "codeTag": "Unknown"
            },
            {
                "id": 1897485,
                "title": "easy-c-solution-better-runtime-than-99-86-and-better-memory-usage-than-81-48",
                "content": "The approach is simple. We first use a boolean vector to store if the elements are present or not. Then we start iterating the linked list and for each connected component, we increment the ans by 1. \\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        vector<bool> subsetNodesTrack(10000,0);\\n        for(int num:nums) subsetNodesTrack[num]=1;\\n        ListNode* curr=head;\\n        int ans=0;\\n        while(curr){\\n            if(subsetNodesTrack[curr->val]) {\\n                while(curr && subsetNodesTrack[curr->val]) curr=curr->next;\\n                ans++;\\n            }\\n            else curr=curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        vector<bool> subsetNodesTrack(10000,0);\\n        for(int num:nums) subsetNodesTrack[num]=1;\\n        ListNode* curr=head;\\n        int ans=0;\\n        while(curr){\\n            if(subsetNodesTrack[curr->val]) {\\n                while(curr && subsetNodesTrack[curr->val]) curr=curr->next;\\n                ans++;\\n            }\\n            else curr=curr->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883418,
                "title": "c-without-extra-memory-clean-concise-code",
                "content": "**Liked the code? Please do upvote it :)**\\n\\n```\\nclass Solution{\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        int cnt = 0, connect = 0, last = 0;\\n        \\n        while(head != NULL)\\n        {\\n            connect = (find(nums.begin(), nums.end(), head->val) != nums.end());\\n            \\n            if(last == 1 and connect == 0)\\n                ++cnt;\\n            \\n            last = connect;\\n            head = head->next;\\n        }\\n        \\n        cnt += (connect == 1);\\n        return cnt;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution{\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) \\n    {\\n        int cnt = 0, connect = 0, last = 0;\\n        \\n        while(head != NULL)\\n        {\\n            connect = (find(nums.begin(), nums.end(), head->val) != nums.end());\\n            \\n            if(last == 1 and connect == 0)\\n                ++cnt;\\n            \\n            last = connect;\\n            head = head->next;\\n        }\\n        \\n        cnt += (connect == 1);\\n        return cnt;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879178,
                "title": "easy-c-sol",
                "content": "int numComponents(struct ListNode* head, int* nums, int numsSize){\\n\\n    int c[10000]={0};\\n    for(int i=0;i<numsSize;i++)\\n        c[nums[i]]++;\\n    \\n    struct ListNode* next= head;\\n    \\n    int z=0;\\n    \\n    while(next!=NULL){\\n        if(next!=NULL && c[next->val]==1){\\n            while(next!=NULL && c[next->val]==1){\\n                next=next->next;\\n            }\\n            z++;\\n        }\\n        else next=next->next;\\n    }\\n    \\n    return z;\\n}",
                "solutionTags": [
                    "C"
                ],
                "code": "int numComponents(struct ListNode* head, int* nums, int numsSize){\\n\\n    int c[10000]={0};\\n    for(int i=0;i<numsSize;i++)\\n        c[nums[i]]++;\\n    \\n    struct ListNode* next= head;\\n    \\n    int z=0;\\n    \\n    while(next!=NULL){\\n        if(next!=NULL && c[next->val]==1){\\n            while(next!=NULL && c[next->val]==1){\\n                next=next->next;\\n            }\\n            z++;\\n        }\\n        else next=next->next;\\n    }\\n    \\n    return z;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 1837296,
                "title": "jave-hashset-o-n",
                "content": "```\\npublic int numComponents(ListNode head, int[] nums) {\\n        // Put all elements into a set.\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            set.add(i);\\n        }\\n        \\n        // Initialize a pointer going through the list.\\n        ListNode curr = head;       \\n        // Initialize a flag, set to true when seeing set element in linkedlist.\\n        boolean flag = false;        \\n        // Initialize result variable.\\n        int res = 0;\\n        \\n        while (curr != null) {\\n            if (set.contains(curr.val)) {\\n                // No need to count res for connected element in linkedlist.\\n                if (!flag) {\\n                    res++;\\n                }\\n                flag = true;   \\n            } else {\\n                flag = false;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int numComponents(ListNode head, int[] nums) {\\n        // Put all elements into a set.\\n        Set<Integer> set = new HashSet<>();\\n        for (int i : nums) {\\n            set.add(i);\\n        }\\n        \\n        // Initialize a pointer going through the list.\\n        ListNode curr = head;       \\n        // Initialize a flag, set to true when seeing set element in linkedlist.\\n        boolean flag = false;        \\n        // Initialize result variable.\\n        int res = 0;\\n        \\n        while (curr != null) {\\n            if (set.contains(curr.val)) {\\n                // No need to count res for connected element in linkedlist.\\n                if (!flag) {\\n                    res++;\\n                }\\n                flag = true;   \\n            } else {\\n                flag = false;\\n            }\\n            curr = curr.next;\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1805625,
                "title": "c-leetcode-817-simple-hashing-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        for(int x : arr)m[x]++;\\n        int count = 0;\\n        ListNode* node = head;\\n        while(node!=NULL){\\n            int done = 0;\\n            while(node!=NULL && m[node->val]>0){\\n                node=node->next;\\n                done = 1;\\n            }\\n            if(done)count++;\\n            while(node!=NULL && m[node->val]==0){\\n                node=node->next;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& arr) {\\n        unordered_map<int,int> m;\\n        for(int x : arr)m[x]++;\\n        int count = 0;\\n        ListNode* node = head;\\n        while(node!=NULL){\\n            int done = 0;\\n            while(node!=NULL && m[node->val]>0){\\n                node=node->next;\\n                done = 1;\\n            }\\n            if(done)count++;\\n            while(node!=NULL && m[node->val]==0){\\n                node=node->next;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1787773,
                "title": "java-o-n-using-hashset",
                "content": "```\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i : nums) set.add(i);\\n        \\n        int ans = 0;\\n        while(head != null){\\n            boolean count = true;\\n            while(set.contains(head.val)){\\n                if(count) ans++;\\n                count = false;\\n                if(head.next != null) head = head.next;\\n                else break;\\n            }\\n\\n            head = head.next;\\n            \\n        }\\n        return ans;\\n    }\\n\\t```\\n\\t\\n\\tvery ez understandble solution using a hashset to store the num array for fast lookup.\\n\\t\\n\\tTime : O(n)\\n\\tSpace : O( size of nums[] ) or O( nums.length )",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<>();\\n        \\n        for(int i : nums) set.add(i);\\n        \\n        int ans = 0;\\n        while(head != null){\\n            boolean count = true;\\n            while(set.contains(head.val)){\\n                if(count) ans++;\\n                count = false;\\n                if(head.next != null) head = head.next;\\n                else break;\\n            }\\n\\n            head = head.next;\\n            \\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1732435,
                "title": "didn-t-understand-the-test-case",
                "content": "Please explain me this test case, \\n```\\nInput: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C"
                ],
                "code": "```\\nInput: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1669475,
                "title": "python-faster-than-95",
                "content": "```\\nhashed = {}\\nfor n in nums:\\n\\thashed[n] = 0\\ncomponents = 0\\nprev_in_comp = in_comp = False\\nwhile head:\\n\\tprev_in_comp = in_comp\\n\\tif head.val in hashed:\\n\\t\\tin_comp = True\\n\\telse:\\n\\t\\tin_comp = False\\n\\tif not prev_in_comp and in_comp:\\n\\t\\tcomponents += 1\\n\\thead = head.next\\nreturn components\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nhashed = {}\\nfor n in nums:\\n\\thashed[n] = 0\\ncomponents = 0\\nprev_in_comp = in_comp = False\\nwhile head:\\n\\tprev_in_comp = in_comp\\n\\tif head.val in hashed:\\n\\t\\tin_comp = True\\n\\telse:\\n\\t\\tin_comp = False\\n\\tif not prev_in_comp and in_comp:\\n\\t\\tcomponents += 1\\n\\thead = head.next\\nreturn components\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1654638,
                "title": "java-easy-solution",
                "content": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i:nums) set.add(i);\\n        int result=0;\\n        while(head!=null){\\n            if(set.contains(head.val)){\\n                while(head!=null&&set.contains(head.val))\\n                    head=head.next;\\n                result++;\\n            }\\n            else\\n                head=head.next;\\n        }\\n        \\n       \\n        return result;       \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set=new HashSet<>();\\n        for(int i:nums) set.add(i);\\n        int result=0;\\n        while(head!=null){\\n            if(set.contains(head.val)){\\n                while(head!=null&&set.contains(head.val))\\n                    head=head.next;\\n                result++;\\n            }\\n            else\\n                head=head.next;\\n        }\\n        \\n       \\n        return result;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594482,
                "title": "python-solution-simple-one-pass-time-o-n-2-space-o-1",
                "content": "```\\n        res = 0\\n        hasConnection = False\\n        while head:\\n            if head.val in nums:\\n                hasConnection = True\\n            elif hasConnection:\\n                res += 1\\n                hasConnection = False\\n            head = head.next\\n        if hasConnection:\\n            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\n        res = 0\\n        hasConnection = False\\n        while head:\\n            if head.val in nums:\\n                hasConnection = True\\n            elif hasConnection:\\n                res += 1\\n                hasConnection = False\\n            head = head.next\\n        if hasConnection:\\n            res += 1\\n        return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1578443,
                "title": "python3-solution-with-using-hashset",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        s = set(G)\\n        res = 0\\n        \\n        while head:\\n            if head.val in s and (head.next == None or head.next.val not in s):\\n                res += 1\\n        \\n            head = head.next\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        s = set(G)\\n        res = 0\\n        \\n        while head:\\n            if head.val in s and (head.next == None or head.next.val not in s):\\n                res += 1\\n        \\n            head = head.next\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1536475,
                "title": "python",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        \\n        nums = set(nums)\\n        curr = False\\n        count = 0\\n        \\n        while head :\\n            top = head.val\\n            if top in nums :\\n                if not curr :\\n                    count += 1\\n                    curr = True       \\n            else :\\n                curr = False\\n            head = head.next\\n                \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        \\n        nums = set(nums)\\n        curr = False\\n        count = 0\\n        \\n        while head :\\n            top = head.val\\n            if top in nums :\\n                if not curr :\\n                    count += 1\\n                    curr = True       \\n            else :\\n                curr = False\\n            head = head.next\\n                \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1496457,
                "title": "rust-4ms-iterator-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\npub fn num_components(head: Option<Box<ListNode>>, nums: Vec<i32>) -> i32 {\\n    let nums: HashSet<_> = nums.into_iter().collect();\\n    (0..).scan(&head, |node, _| node.as_deref().map(|ListNode { val, next }| {\\n            *node = next;\\n            nums.contains(&val)\\n        })).fuse()\\n        .fold((0, false), |(cnt, pre), b| (i32::from(b && !pre) + cnt, b)).0\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\npub fn num_components(head: Option<Box<ListNode>>, nums: Vec<i32>) -> i32 {\\n    let nums: HashSet<_> = nums.into_iter().collect();\\n    (0..).scan(&head, |node, _| node.as_deref().map(|ListNode { val, next }| {\\n            *node = next;\\n            nums.contains(&val)\\n        })).fuse()\\n        .fold((0, false), |(cnt, pre), b| (i32::from(b && !pre) + cnt, b)).0\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1493468,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            set.add(nums[i]);\\n        }\\n        \\n        int size = 0;\\n        while(head != null){\\n            if(set.contains(head.val)){\\n                size++;\\n                while(head.next != null && set.contains(head.next.val)){\\n                    head = head.next;\\n                }\\n            }\\n            head = head.next;\\n        }\\n        \\n        return size;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int i=0; i<nums.length; i++){\\n            set.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1428337,
                "title": "simple-solution-using-a-set",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int result = 0;\\n        \\n        for(int num : nums)\\n            set.add(num);\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null) {\\n            if(set.contains(curr.val) && (curr.next == null || !set.contains(curr.next.val)))\\n                result++;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        Set<Integer> set = new HashSet<Integer>();\\n        int result = 0;\\n        \\n        for(int num : nums)\\n            set.add(num);\\n        \\n        ListNode curr = head;\\n        \\n        while(curr != null) {\\n            if(set.contains(curr.val) && (curr.next == null || !set.contains(curr.next.val)))\\n                result++;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1423495,
                "title": "hashset-hashmap-c-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans=0;\\n        auto p = head;\\n        map<int,int> m;\\n        set<int> s;\\n        for(auto x:nums) s.insert(x);\\n        while(p!=NULL && p->next!=NULL){\\n            int a = p->val;\\n            m[a]=p->next->val;\\n            p=p->next;\\n        }\\n        m[p->val]=-1;\\n        for(auto x:nums){\\n            if(s.find(m[x])!=s.end()) continue;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        int ans=0;\\n        auto p = head;\\n        map<int,int> m;\\n        set<int> s;\\n        for(auto x:nums) s.insert(x);\\n        while(p!=NULL && p->next!=NULL){\\n            int a = p->val;\\n            m[a]=p->next->val;\\n            p=p->next;\\n        }\\n        m[p->val]=-1;\\n        for(auto x:nums){\\n            if(s.find(m[x])!=s.end()) continue;\\n            ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391515,
                "title": "python3-simple-hashmap-solution",
                "content": "```\\n#TIME COMPLEXITY - O(len(nums)+N)\\n#SPACE COMPLEXITY - O(len(nums))\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        hmap={}\\n        for i in range(len(nums)):\\n            if nums[i] not in hmap:\\n                hmap[nums[i]]=1\\n            else:\\n                hmap[nums[i]]+=1\\n        temp=head\\n        cnt=0\\n        while temp:\\n            if temp.val in hmap:\\n                curr=temp\\n                while curr and curr.val in hmap:\\n                    curr=curr.next\\n                temp=curr\\n                cnt+=1\\n            else:\\n                temp=temp.next\\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n#TIME COMPLEXITY - O(len(nums)+N)\\n#SPACE COMPLEXITY - O(len(nums))\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        hmap={}\\n        for i in range(len(nums)):\\n            if nums[i] not in hmap:\\n                hmap[nums[i]]=1\\n            else:\\n                hmap[nums[i]]+=1\\n        temp=head\\n        cnt=0\\n        while temp:\\n            if temp.val in hmap:\\n                curr=temp\\n                while curr and curr.val in hmap:\\n                    curr=curr.next\\n                temp=curr\\n                cnt+=1\\n            else:\\n                temp=temp.next\\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391309,
                "title": "c-easy-solution-all-methods-faster-than-90",
                "content": "METHOD1: Using sorting and binary search (T(n) = O(nlgn) and S(n) = O(1))\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val)) {\\n                head = head->next;\\n                while (head and binary_search(nums.begin(), nums.end(), head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD2: Variant of Method1;\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val) and (!head->next or !binary_search(nums.begin(), nums.end(), head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD3 : using set (T(n) = S(n) = O(n))\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val)) {\\n                head = head->next;\\n                while (head and numbers.count(head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nMETHOD4: Variant of Method3;\\n\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val) and (!head->next or !numbers.count(head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val)) {\\n                head = head->next;\\n                while (head and binary_search(nums.begin(), nums.end(), head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (binary_search(nums.begin(), nums.end(), head->val) and (!head->next or !binary_search(nums.begin(), nums.end(), head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val)) {\\n                head = head->next;\\n                while (head and numbers.count(head->val))\\n                    head = head->next;\\n                ans++;\\n            }\\n            else\\n                head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numbers(nums.begin(), nums.end());\\n        int ans = 0;\\n        while (head) {\\n            if (numbers.count(head->val) and (!head->next or !numbers.count(head->next->val)))\\n                ans++;\\n            head = head->next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1337700,
                "title": "runtime-24ms-faster-than-98-c-solution",
                "content": "```\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++) s.insert(nums[i]);\\n        int c=0,f=0;\\n        while(head!=NULL){\\n            if(s.find(head->val)!=s.end()){\\n                if(!f)\\n                    f=1;\\n            }\\n            else{\\n                if(f){\\n                    c++;\\n                    f=0;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        if(f)\\n            c++;\\n        return c;\\n    }\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Linked List"
                ],
                "code": "```\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      unordered_set<int>s;\\n        for(int i=0;i<nums.size();i++) s.insert(nums[i]);\\n        int c=0,f=0;\\n        while(head!=NULL){\\n            if(s.find(head->val)!=s.end()){\\n                if(!f)\\n                    f=1;\\n            }\\n            else{\\n                if(f){\\n                    c++;\\n                    f=0;\\n                }\\n            }\\n            head=head->next;\\n        }\\n        if(f)\\n            c++;\\n        return c;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 1329190,
                "title": "c-solution-with-proper-explanation",
                "content": "Need to find the connected components ;\\nConditions :-\\n   1 . If there is a set of elements in nums (subset provided) is a connected sub-list in LinkedList then count it as 1.\\n   2. Count the remaining elements in nums (subset provided) which are in Linked-List as 1 for each.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> st(nums.begin(), nums.end());\\n        \\n        int count = 0;\\n        \\n        while(head!=NULL)\\n        {\\n            if(st.count(head->val))   //If an ele from num present in LinkedList\\n            {\\n                count++;     //Increase count by 1\\n                while(head!=NULL && st.count(head->val)) head = head->next;   // move all the connected elements to include in one set if available\\n            }\\n            else\\n                head = head->next;  //else simply move forward\\n        }\\n        return count;\\n    }\\n};\\n\\n```\\nPlease Upvote if it helps you. Thanks !",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int> st(nums.begin(), nums.end());\\n        \\n        int count = 0;\\n        \\n        while(head!=NULL)\\n        {\\n            if(st.count(head->val))   //If an ele from num present in LinkedList\\n            {\\n                count++;     //Increase count by 1\\n                while(head!=NULL && st.count(head->val)) head = head->next;   // move all the connected elements to include in one set if available\\n            }\\n            else\\n                head = head->next;  //else simply move forward\\n        }\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1294811,
                "title": "python-simple-solution",
                "content": "```\\ndef numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        d = set(nums)\\n        count = 0\\n        c = 0\\n        temp = head\\n        while temp:\\n            if temp.val in d:\\n                c=1\\n            else:\\n                count+=c\\n                c=0\\n            temp= temp.next\\n        return count+c",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\ndef numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        d = set(nums)\\n        count = 0\\n        c = 0\\n        temp = head\\n        while temp:\\n            if temp.val in d:\\n                c=1\\n            else:\\n                count+=c\\n                c=0\\n            temp= temp.next\\n        return count+c",
                "codeTag": "Python3"
            },
            {
                "id": 1266940,
                "title": "easy-to-understand",
                "content": "```class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        int count=0,flag=0;\\n        while(head!=NULL)\\n             {\\n             auto it=find(G.begin(),G.end(),head->val);\\n             if(it!=G.end()&&flag==0)\\n             {\\n                 count++;\\n                 flag=1;\\n             }\\n             else if(it==G.end())\\n                 flag=0;\\n        head=head->next;\\n         }\\n        return count;\\n    } \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        int count=0,flag=0;\\n        while(head!=NULL)\\n             {\\n             auto it=find(G.begin(),G.end(),head->val);\\n             if(it!=G.end()&&flag==0)\\n             {\\n                 count++;\\n                 flag=1;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1266023,
                "title": "struggling-with-explanation",
                "content": "Explanation is really bad, you can see this post for explaination (in comments) : https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\nOne You get the point, Question is really simple...\\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n     \\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            hs.add(nums[i]);\\n        }\\n        \\n        int flag = 0,ans = 0;\\n        ListNode temp = head;\\n        while(temp != null){\\n            if(flag == 0 && hs.contains(temp.val)){\\n                ans++;\\n                flag = 1; \\n            }\\n            else if(!hs.contains(temp.val)){\\n                flag = 0;\\n            }\\n            temp = temp.next;\\n        }\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n     \\n        HashSet<Integer> hs = new HashSet<>();\\n        \\n        for(int i=0; i<nums.length; i++){\\n            hs.add(nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1241184,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G)\\n    {\\n        int count=0;\\n        unordered_set<int>s(G.begin(),G.end());\\n        while(head!=NULL)\\n        {\\n            int f=0;\\n            while(head!=NULL&&s.find(head->val)!=s.end())\\n            {\\n                f=1;\\n                head=head->next;\\n            }\\n            if(f)\\n            count++;\\n            if(head!=NULL)\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G)\\n    {\\n        int count=0;\\n        unordered_set<int>s(G.begin(),G.end());\\n        while(head!=NULL)\\n        {\\n            int f=0;\\n            while(head!=NULL&&s.find(head->val)!=s.end())\\n            {\\n                f=1;\\n                head=head->next;\\n            }\\n            if(f)\\n            count++;\\n            if(head!=NULL)\\n            head=head->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1231068,
                "title": "c-solution-using-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      if(!head) return 0;\\n      \\n      int n = nums.size();\\n      \\n      if(n == 0) return 0;\\n      \\n      map<int,bool> vals;\\n      \\n      for(int i = 0; i < n; ++i) {\\n        vals[nums[i]] = true;\\n      }\\n      \\n      int noOfComponents = 0;\\n      \\n      for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next) {\\n        if(vals.find(ptr->val) != vals.end()) {\\n          while(ptr && vals.find(ptr->val) != vals.end()) {\\n            ptr = ptr->next;\\n          }\\n          ++noOfComponents;\\n        }\\n        if(!ptr) break;\\n      }\\n      \\n      return noOfComponents;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n      if(!head) return 0;\\n      \\n      int n = nums.size();\\n      \\n      if(n == 0) return 0;\\n      \\n      map<int,bool> vals;\\n      \\n      for(int i = 0; i < n; ++i) {\\n        vals[nums[i]] = true;\\n      }\\n      \\n      int noOfComponents = 0;\\n      \\n      for(ListNode* ptr = head; ptr != nullptr; ptr = ptr->next) {\\n        if(vals.find(ptr->val) != vals.end()) {\\n          while(ptr && vals.find(ptr->val) != vals.end()) {\\n            ptr = ptr->next;\\n          }\\n          ++noOfComponents;\\n        }\\n        if(!ptr) break;\\n      }\\n      \\n      return noOfComponents;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1222007,
                "title": "simple-and-easy-python",
                "content": "As long as the head.next.val is in the nums we continue without increasing the count. \\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count = 0\\n        num = set(nums)\\n        while head:\\n            if head.val in num and (head.next==None or head.next.val not in num):\\n                count+=1\\n            head = head.next\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, nums: List[int]) -> int:\\n        count = 0\\n        num = set(nums)\\n        while head:\\n            if head.val in num and (head.next==None or head.next.val not in num):\\n                count+=1\\n            head = head.next\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169662,
                "title": "java-solution",
                "content": "Scanning through head.value is present in G and head.next.val is not or including head.next==null. \\n\\n```\\npublic int numComponents(ListNode head, int[] G) {\\n        int result =0;\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<G.length;i++){\\n            set.add(G[i]);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                result++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numComponents(ListNode head, int[] G) {\\n        int result =0;\\n        \\n        if(head==null){\\n            return 0;\\n        }\\n        \\n        HashSet<Integer> set = new HashSet<Integer>();\\n        for(int i=0;i<G.length;i++){\\n            set.add(G[i]);\\n        }\\n        \\n        while(head!=null){\\n            if(set.contains(head.val) && (head.next==null || !set.contains(head.next.val))){\\n                result++;\\n                \\n            }\\n            head=head.next;\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1132678,
                "title": "java-easy-solution-hashset",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] arr) {\\n      ListNode node=head;\\n      Set<Integer> set=new HashSet<>();\\n      for(int val:arr) set.add(val);\\n    \\n      int ans=0;\\n     \\n      while(node!=null){\\n        if(set.contains(node.val) && (node.next==null ||  !set.contains(node.next.val))){\\n           ans++;\\n        }\\n        node=node.next;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] arr) {\\n      ListNode node=head;\\n      Set<Integer> set=new HashSet<>();\\n      for(int val:arr) set.add(val);\\n    \\n      int ans=0;\\n     \\n      while(node!=null){\\n        if(set.contains(node.val) && (node.next==null ||  !set.contains(node.next.val))){\\n           ans++;\\n        }\\n        node=node.next;\\n      }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095530,
                "title": "simple-java-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> hash=new HashSet<Integer>();\\n        \\n        for(int i=0;i<G.length;i++){\\n            hash.add(G[i]);\\n        }\\n        \\n        ListNode parent=null;\\n        ListNode current=head;\\n        int numOfComponents=0;\\n        \\n        while(current != null){\\n            if(parent == null){\\n                if(hash.contains(current.val))\\n                {\\n                    numOfComponents++;\\n                }\\n            }else{\\n                if(!hash.contains(parent.val) && hash.contains(current.val)){\\n                    numOfComponents++;\\n                }\\n            }\\n            parent=current;\\n            current=current.next;\\n        }\\n        return numOfComponents;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> hash=new HashSet<Integer>();\\n        \\n        for(int i=0;i<G.length;i++){\\n            hash.add(G[i]);\\n        }\\n        \\n        ListNode parent=null;\\n        ListNode current=head;\\n        int numOfComponents=0;\\n        \\n        while(current != null){\\n            if(parent == null){\\n                if(hash.contains(current.val))\\n                {\\n                    numOfComponents++;\\n                }\\n            }else{\\n                if(!hash.contains(parent.val) && hash.contains(current.val)){\\n                    numOfComponents++;\\n                }\\n            }\\n            parent=current;\\n            current=current.next;\\n        }\\n        return numOfComponents;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072342,
                "title": "java-simpple-solution-faster-than-95",
                "content": "JAVA CODE IS:\\n#    \\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int v : G)\\n            set.add(v);\\n       boolean t=false;\\n        int count=0;\\n        while(head!=null){\\n          if(set.contains(head.val))\\n             t=true;\\n          else{\\n              count+=t==true ? 1 : 0;\\n              t=false;\\n          }   \\n            head=head.next;\\n        }\\n        count+=t==true ? 1 : 0;\\n        return count;\\n    }\\n}\\n```\\nTime : O(N)\\nSpace : O(N)\\n***PLEASE,UPVOTE IF THIS IS REALLY HELPFUL FOR YOU***",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer>set=new HashSet<>();\\n        for(int v : G)\\n            set.add(v);\\n       boolean t=false;\\n        int count=0;\\n        while(head!=null){\\n          if(set.contains(head.val))\\n             t=true;\\n          else{\\n              count+=t==true ? 1 : 0;\\n              t=false;\\n          }   \\n            head=head.next;\\n        }\\n        count+=t==true ? 1 : 0;\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1018853,
                "title": "python",
                "content": "```\\n\\tdef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        flag = False\\n        cnt = 0\\n        nums = set(G)\\n        \\n        while head:\\n            if head.val in nums and not flag:\\n                flag = True\\n                cnt += 1\\n            elif head.val not in nums:\\n                flag = False\\n            head = head.next\\n            \\n        return cnt\\n```",
                "solutionTags": [],
                "code": "```\\n\\tdef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        flag = False\\n        cnt = 0\\n        nums = set(G)\\n        \\n        while head:\\n            if head.val in nums and not flag:\\n                flag = True\\n                cnt += 1\\n            elif head.val not in nums:\\n                flag = False\\n            head = head.next\\n            \\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1016745,
                "title": "c-100-time-and-space",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if (G.size() == 0) {\\n            return 0;\\n        }\\n        sort(G.begin(), G.end()); // O(G * log(G))\\n        int count = 0;\\n        bool connecting = false;\\n        \\n        // O(linked_list_length)\\n        while (head != nullptr) {\\n            \\n            // O(log(G))\\n            if (binary_search(G.begin(), G.end(), head->val)) {\\n                if (!connecting) {\\n                    connecting = true;\\n                    count++;\\n                }\\n            } else if (connecting) {\\n                connecting = false;\\n            }\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if (G.size() == 0) {\\n            return 0;\\n        }\\n        sort(G.begin(), G.end()); // O(G * log(G))\\n        int count = 0;\\n        bool connecting = false;\\n        \\n        // O(linked_list_length)\\n        while (head != nullptr) {\\n            \\n            // O(log(G))\\n            if (binary_search(G.begin(), G.end(), head->val)) {\\n                if (!connecting) {\\n                    connecting = true;\\n                    count++;\\n                }\\n            } else if (connecting) {\\n                connecting = false;\\n            }\\n            head = head->next;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 928075,
                "title": "simple-python-solution-beat-96",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]):\\n        current = head\\n        S = set(G)\\n        res = 0\\n        \\n        while current:\\n            if current.val in S and current.next is None:\\n                res += 1\\n                \\n            elif current.val in S and current.next.val not in S:\\n                res += 1\\n                \\n            current = current.next\\n            \\n        return res",
                "solutionTags": [
                    "Python",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]):\\n        current = head\\n        S = set(G)\\n        res = 0\\n        \\n        while current:\\n            if current.val in S and current.next is None:\\n                res += 1\\n                \\n            elif current.val in S and current.next.val not in S:\\n                res += 1\\n                \\n            current = current.next\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 914427,
                "title": "swift-simple-100",
                "content": "```\\n    func numComponents(_ head: ListNode?, _ G: [Int]) -> Int {\\n        let set = Set(G)\\n        var total = 0\\n        var connected = false\\n        var cur = head\\n        \\n        while cur != nil {\\n            \\n            //If number in subset found and it is not connected to another \\n            //number in the subset, we increase the component count by one\\n            if set.contains(cur!.val) {\\n                if connected == false { \\n                    connected = true\\n                    total += 1\\n                }\\n            }else {\\n                //Number not in subset, break connected streak\\n                connected = false\\n            } \\n            \\n            cur = cur?.next\\n        }\\n        \\n        return total\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    func numComponents(_ head: ListNode?, _ G: [Int]) -> Int {\\n        let set = Set(G)\\n        var total = 0\\n        var connected = false\\n        var cur = head\\n        \\n        while cur != nil {\\n            \\n            //If number in subset found and it is not connected to another \\n            //number in the subset, we increase the component count by one\\n            if set.contains(cur!.val) {\\n                if connected == false { \\n                    connected = true\\n                    total += 1\\n                }\\n            }else {\\n                //Number not in subset, break connected streak\\n                connected = false\\n            } \\n            \\n            cur = cur?.next\\n        }\\n        \\n        return total\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 873910,
                "title": "java-1ms-100-with-comments",
                "content": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        boolean[] map = new boolean[10001];\\n        for(int num : G) {\\n            map[num] = true;\\n        }\\n        \\n        if(head == null) {\\n            return 0;\\n        }\\n        \\n        ListNode runner = head;\\n        \\n        // slide runner to the next possible component\\n        while(runner != null && !map[runner.val]) {\\n            runner = runner.next;\\n        }\\n        \\n        // no connected components\\n        if(runner == null) {\\n            return 0;\\n        }\\n        \\n        int connected = 1;\\n        while(runner != null) {\\n            if(!map[runner.val]) {\\n                // slide runner to the next possible component\\n                while(runner != null && !map[runner.val]) {\\n                    runner = runner.next;\\n                }\\n                \\n                // increase component count if we did not reach to the end\\n                // of the linked list\\n                if(runner != null) {                    \\n                    connected++;\\n                }\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        \\n        return connected;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        boolean[] map = new boolean[10001];\\n        for(int num : G) {\\n            map[num] = true;\\n        }\\n        \\n        if(head == null) {\\n            return 0;\\n        }\\n        \\n        ListNode runner = head;\\n        \\n        // slide runner to the next possible component\\n        while(runner != null && !map[runner.val]) {\\n            runner = runner.next;\\n        }\\n        \\n        // no connected components\\n        if(runner == null) {\\n            return 0;\\n        }\\n        \\n        int connected = 1;\\n        while(runner != null) {\\n            if(!map[runner.val]) {\\n                // slide runner to the next possible component\\n                while(runner != null && !map[runner.val]) {\\n                    runner = runner.next;\\n                }\\n                \\n                // increase component count if we did not reach to the end\\n                // of the linked list\\n                if(runner != null) {                    \\n                    connected++;\\n                }\\n            } else {\\n                runner = runner.next;\\n            }\\n        }\\n        \\n        return connected;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 849185,
                "title": "can-someone-explain-this-test-case",
                "content": "```\\n0->1->2\\nG= [0,2]\\n```\\n\\n`Output : 2`\\nShouldn\\'t the output be 1 when I consider the fact that only ```2 ```from the Linekd list will be counted?",
                "solutionTags": [],
                "code": "```\\n0->1->2\\nG= [0,2]\\n```\n```2 ```",
                "codeTag": "Unknown"
            },
            {
                "id": 839426,
                "title": "binary-search-solution-easy-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool binarysearch(vector<int> &G,int k){\\n        int si = 0;\\n        int ei = G.size()-1;\\n        while(si<=ei){\\n            int mid = (si+ei)/2;\\n            if(G[mid]==k) return true;\\n            else if(G[mid]<k) si=mid+1;\\n            else ei = mid-1;\\n        }\\n        return false;\\n    }\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        sort(G.begin(),G.end());\\n        ListNode *temp = head;\\n        int components = 0;\\n        int currsize = 0;\\n        while(temp){\\n            int val = temp->val;\\n            bool b = binarysearch(G,val);\\n            if(b){\\n               currsize++; \\n            }else{\\n                if(currsize) components++;\\n                currsize = 0;\\n            }\\n            temp = temp->next;\\n        }\\n        if(currsize) components++;\\n        return components;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool binarysearch(vector<int> &G,int k){\\n        int si = 0;\\n        int ei = G.size()-1;\\n        while(si<=ei){\\n            int mid = (si+ei)/2;\\n            if(G[mid]==k) return true;\\n            else if(G[mid]<k) si=mid+1;\\n            else ei = mid-1;\\n        }\\n        return false;\\n    }\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        sort(G.begin(),G.end());\\n        ListNode *temp = head;\\n        int components = 0;\\n        int currsize = 0;\\n        while(temp){\\n            int val = temp->val;\\n            bool b = binarysearch(G,val);\\n            if(b){\\n               currsize++; \\n            }else{\\n                if(currsize) components++;\\n                currsize = 0;\\n            }\\n            temp = temp->next;\\n        }\\n        if(currsize) components++;\\n        return components;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 718172,
                "title": "simple-python-no-getattr",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        graph = set(G)\\n        components = 0\\n        while head:\\n            if head.val in graph and (not head.next or head.next.val not in graph):\\n                components += 1\\n            head = head.next\\n        return components\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        graph = set(G)\\n        components = 0\\n        while head:\\n            if head.val in graph and (not head.next or head.next.val not in graph):\\n                components += 1\\n            head = head.next\\n        return components\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668565,
                "title": "python-o-n-solution-easy-to-understand",
                "content": "We use a set so we can search element in O(1)\\nNow we traverse linked list and keep track of connected elements we have seen so far.\\nIncrement when connectivity is lost.\\n```\\ndef numComponents(self, head, G):\\n        subsetVals = set(G)\\n        current = head\\n        comps = 0\\n        elementsInComp = 0\\n        while current != None:\\n            curVal = current.val\\n            if curVal in subsetVals:\\n                elementsInComp += 1\\n            else:\\n                if elementsInComp > 0:\\n                    elementsInComp = 0\\n                    comps += 1\\n            current = current.next\\n        if elementsInComp > 0:\\n            comps += 1\\n        return comps\\n```",
                "solutionTags": [],
                "code": "```\\ndef numComponents(self, head, G):\\n        subsetVals = set(G)\\n        current = head\\n        comps = 0\\n        elementsInComp = 0\\n        while current != None:\\n            curVal = current.val\\n            if curVal in subsetVals:\\n                elementsInComp += 1\\n            else:\\n                if elementsInComp > 0:\\n                    elementsInComp = 0\\n                    comps += 1\\n            current = current.next\\n        if elementsInComp > 0:\\n            comps += 1\\n        return comps\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 661254,
                "title": "python-3-two-pointer",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count = 0\\n        p1, p2 = head, head\\n        while p2:\\n            if p1.val in G:\\n                p2 = p1.next\\n                p1 = p2\\n                if not p2 or p2.val not in G:\\n                    count+=1\\n            else:\\n                p1 = p2.next\\n                p2 = p1\\n        return count\\n\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count = 0\\n        p1, p2 = head, head\\n        while p2:\\n            if p1.val in G:\\n                p2 = p1.next\\n                p1 = p2\\n                if not p2 or p2.val not in G:\\n                    count+=1\\n            else:\\n                p1 = p2.next\\n                p2 = p1\\n        return count\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 622539,
                "title": "java-simple-easy-solution-using-hashset",
                "content": "Java\\n\\n```\\n\\nThe problem has straight solution which are as follows:-\\n\\n1. First Move all  element of G  into a another datastruture which can be used to detect the presence of element of G. \\n2. This can be achieved by using creating a HashSet or by creating the array of size the max element. then putting the element in its proper position.\\n3. Then simply traverse the LinkedList and check the element present in HashSet.\\n4. If It is present in the HashSet, the simply **set = 1**. if it is not present then check set = 1 , and increment the count.\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> h = new HashSet<>();\\n        for(int num : G) {\\n            h.add(num);\\n        }\\n        int count = 0,set = 0;\\n        while(head != null) {\\n            if(h.contains(head.val)) {\\n                set = 1;\\n            }else if(set == 1) {\\n                count++;\\n                set = 0;\\n            }\\n            head = head.next;\\n        }\\n        return set==1?count+1:count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nThe problem has straight solution which are as follows:-\\n\\n1. First Move all  element of G  into a another datastruture which can be used to detect the presence of element of G. \\n2. This can be achieved by using creating a HashSet or by creating the array of size the max element. then putting the element in its proper position.\\n3. Then simply traverse the LinkedList and check the element present in HashSet.\\n4. If It is present in the HashSet, the simply **set = 1**. if it is not present then check set = 1 , and increment the count.\\n\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        Set<Integer> h = new HashSet<>();\\n        for(int num : G) {\\n            h.add(num);\\n        }\\n        int count = 0,set = 0;\\n        while(head != null) {\\n            if(h.contains(head.val)) {\\n                set = 1;\\n            }else if(set == 1) {\\n                count++;\\n                set = 0;\\n            }\\n            head = head.next;\\n        }\\n        return set==1?count+1:count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 617824,
                "title": "javascript-100-mem-95-faster",
                "content": "```\\nvar numComponents = function(head, G) {\\n    const set = new Set(G);\\n    let count = 0, prevConn = false;\\n    while(head) {\\n       const hasCon = set.has(head.val);\\n       if (!prevConn && hasCon) {\\n           count++;\\n       }\\n        prevConn = hasCon;\\n        head = head.next;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar numComponents = function(head, G) {\\n    const set = new Set(G);\\n    let count = 0, prevConn = false;\\n    while(head) {\\n       const hasCon = set.has(head.val);\\n       if (!prevConn && hasCon) {\\n           count++;\\n       }\\n        prevConn = hasCon;\\n        head = head.next;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 594744,
                "title": "100-space-and-time-super-simple-explanation",
                "content": "```\\nstatic int x = [](){ios::sync_with_stdio(false), cin.tie(NULL); return 0;}();\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& a) {\\n        \\n        bool s[10001]={};\\n        for(auto i:a)   s[i]=true;     //make hash to denote what all elements has been exists in array\\n        \\n        int ct=0;\\n        while(head)\\n        {\\n            bool b = false;\\n             while(head and s[head->val] )   // while connected \\n                   head = head->next , b = true;\\n            ct+=b;\\n            if(head)\\n                head = head->next;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstatic int x = [](){ios::sync_with_stdio(false), cin.tie(NULL); return 0;}();\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& a) {\\n        \\n        bool s[10001]={};\\n        for(auto i:a)   s[i]=true;     //make hash to denote what all elements has been exists in array\\n        \\n        int ct=0;\\n        while(head)\\n        {\\n            bool b = false;\\n             while(head and s[head->val] )   // while connected \\n                   head = head->next , b = true;\\n            ct+=b;\\n            if(head)\\n                head = head->next;\\n        }\\n        return ct;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556357,
                "title": "c",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> setG (G.begin(), G.end());\\n        int res = 0;\\n        while (head != NULL) {\\n            if (setG.count(head->val) && (head->next == NULL || !setG.count(head->next->val))) res++;\\n            head = head->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 536427,
                "title": "easy-c-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if(head == NULL || G.size() == 0) return 0;\\n        unordered_set<int> hash;\\n        for(int i : G)\\n            hash.insert(i);\\n        ListNode* curr = head;\\n        int count = 0, res = 0;\\n        while(curr != NULL){\\n            if(hash.count(curr->val))\\n                count = 1;\\n            else if(!hash.count(curr->val) && count > 0){\\n                res++;\\n                count = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        return count > 0 ? res + 1 : res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        if(head == NULL || G.size() == 0) return 0;\\n        unordered_set<int> hash;\\n        for(int i : G)\\n            hash.insert(i);\\n        ListNode* curr = head;\\n        int count = 0, res = 0;\\n        while(curr != NULL){\\n            if(hash.count(curr->val))\\n                count = 1;\\n            else if(!hash.count(curr->val) && count > 0){\\n                res++;\\n                count = 0;\\n            }\\n            curr = curr->next;\\n        }\\n        return count > 0 ? res + 1 : res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 498357,
                "title": "python3-93-14",
                "content": "```\\ndef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        if not head:\\n            return 0\\n        A = set(G)\\n        total = 0\\n        while head:\\n            if head.val in A:\\n                while head.next and head.next.val in A:\\n                    head = head.next\\n                total += 1\\n            head = head.next\\n        return total\\n```\\n\\t",
                "solutionTags": [],
                "code": "```\\ndef numComponents(self, head: ListNode, G: List[int]) -> int:\\n        if not head:\\n            return 0\\n        A = set(G)\\n        total = 0\\n        while head:\\n            if head.val in A:\\n                while head.next and head.next.val in A:\\n                    head = head.next\\n                total += 1\\n            head = head.next\\n        return total\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 444135,
                "title": "python-expand-this-idea-to-tree-s-connected-components",
                "content": "**Approach 1(TLE):**\\n\\nIntital thoughts: In a linked list, a node\\'s connected components are its previous node and next node. First, we need to loop through the list to save all the tuples of node and its neighbors in a dictionary. \\n\\nThen we check every pairs of nodes (a, b) in G, to see if b is a neighbor of a; if so, we decrement the number of connected components, which is initailly set as the number of nodes in the original list, by 1.\\n\\nComplexity: \\n* Time: O(N + M choose 2 ) where N is the length of list and M is the length of G.\\n* Space: O(N) for the dictionary\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        d = collections.defaultdict(set)\\n        prev = dummy = ListNode(-1)\\n        dummy.next = head\\n\\t\\t\\n        p, nxt = head, head.next\\n        while p:\\n            d[p.val].add(prev.val) if prev else -1\\n            d[p.val].add(nxt.val) if nxt else -1\\n            if not p.next: break\\n            prev = p\\n            p = p.next\\n            nxt = nxt.next\\n            \\n        connNum = len(G)\\n        for a, b in itertools.combinations(G, 2):\\n            if b in d[a]:\\n                connNum -= 1\\n        return connNum\\n```\\n\\n**Approach 2:**\\nInstead of looking at two directions in the original list, we can just iterate through the list and look at the next node of the current node (`nxt`). If `cur` in G and `nxt` is not in G, it indicates that the current node itself is an isolate connected component; otherwise, current node and `nxt` are in the same connected component.\\n\\nComplexity: \\n* Time: O(N + M)\\n* Space: O(M) for the `Gset`\\n\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset = set(G)\\n        cur = head\\n        ans = 0\\n        while cur:\\n            if cur.val in Gset and getattr(cur.next, \\'val\\', None) not in Gset:\\n                ans += 1\\n            cur = cur.next\\n        return ans\\n```\\n\\n```\\n\\n```\\n-----------\\n**Possible Follow-up: What if the given input is the a tree and G contains TreeNodes?  Find the number of connected components in this tree**\\n\\n\\nAlgorithm:\\n* We can recursively find the number of connected components in the left subtree and the right subtree, namely, `ccLeft` and `ccRight`.\\n* Then the number of connected component in the current tree is the sum of `ccLeft` and `ccRight` and `X`, where `X` can be calculated using the concept in **the originaly problem:** If current node is in G and its sucessor is not, we increment number of connected components by 1. \\n\\t* Thus, if current is in G and only one child is in G, we don\\'t increment `temp` \\n\\t   \\t```\\n\\t\\t\\t o\\t\\t   o\\t      o\\n\\t\\t\\t/ \\\\\\t\\t  / \\\\        / \\\\\\t\\n\\t\\t   o   x     o   x      x   o \\n\\t\\t```\\n\\t    If current is in G and two child in G, in this special case, we increment `temp` by 1 .\\n\\t\\t```\\n\\t\\t\\t\\t o\\t\\n\\t\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t\\t   o   o  \\n\\t    ``` \\n\\t\\t**if current is in G and none if its children is in G, we increment `temp` by 1.**\\n\\t   \\t```\\n\\t\\t\\t o\\t\\t \\n\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t   x   x     \\n\\t\\t```\\n\\n\\nExample:\\n\\n```\\n\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   2    3\\n\\t\\t\\t\\t  / \\\\  /\\n\\t\\t\\t\\t 4  5  6\\n\\t\\t\\t    /\\\\     /\\\\\\n\\t\\t\\t   7  8   9 10\\n\\t\\t\\t  / \\\\\\n\\t\\t\\t 11 12\\n\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t   13 14\\n\\t\\t\\t\\t  / \\\\\\n\\t\\t\\t\\t 15 16\\n\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t17    18\\n\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tans = 6\\n```\\n```\\nimport collections\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\nclass findComponentsInTree:\\n\\tdef __init__(self, G):\\n\\t\\tself.G = set(G)\\n\\n\\tdef numComponents(self, node):\\n\\t\\tprint(node.val if node else node)\\n\\t\\tif not node: return 0\\n\\t\\tcount = self.numComponents(node.left) + self.numComponents(node.right) + self.AdjustByShape(node)\\n\\t\\t#print(\"ajusted: \", node.val, self.AdjustByShape(node), count)\\n\\t\\treturn count\\n\\t\\n\\tdef AdjustByShape(self, node):\\n\\t\\tif node.val in self.G:\\n\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif not node.left:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.right)\\n\\t\\t\\telif not node.right:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.left)\\n\\t\\t\\telif node.left.val in self.G and node.right.val in self.G:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif node.left.val in self.G or node.right.val in self.G:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\nif __name__ == \"__main__\":\\n\\t# construct a tree example\\n\\troot = TreeNode(1)\\n\\troot.left, root.right = TreeNode(2), TreeNode(3)\\n\\tp, q = root.left, root.right\\n\\tp.left, p.right = TreeNode(4), TreeNode(5)\\n\\tq.left, q.right = TreeNode(6), None\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(7), TreeNode(8)\\n\\tq = q.left\\n\\tq.left, q.right = TreeNode(9), TreeNode(10)\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(11), TreeNode(12)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(13), TreeNode(14)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(15), TreeNode(16)\\n\\tp, q = p.left, p.right\\n\\tp.left, p.right = TreeNode(17), None\\n\\tq.left, q.right = None, TreeNode(18)\\n\\t\\'\\'\\'\\n\\tdef printTreeByLevel(root):\\n\\t\\tlevels = []\\n\\t\\tqueue = collections.deque([root])\\n\\t\\twhile queue:\\n\\t\\t\\tlevel = []\\n\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\tlevel.append(node.val) \\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\t\\tlevels.append(level)\\n\\t\\tprint(levels)\\n\\n\\tprintTreeByLevel(root)\\n\\t\\'\\'\\'\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tsol = findComponentsInTree(G)\\n\\tprint(\"ans: \", sol.numComponents(root))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        d = collections.defaultdict(set)\\n        prev = dummy = ListNode(-1)\\n        dummy.next = head\\n\\t\\t\\n        p, nxt = head, head.next\\n        while p:\\n            d[p.val].add(prev.val) if prev else -1\\n            d[p.val].add(nxt.val) if nxt else -1\\n            if not p.next: break\\n            prev = p\\n            p = p.next\\n            nxt = nxt.next\\n            \\n        connNum = len(G)\\n        for a, b in itertools.combinations(G, 2):\\n            if b in d[a]:\\n                connNum -= 1\\n        return connNum\\n```\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset = set(G)\\n        cur = head\\n        ans = 0\\n        while cur:\\n            if cur.val in Gset and getattr(cur.next, \\'val\\', None) not in Gset:\\n                ans += 1\\n            cur = cur.next\\n        return ans\\n```\n```\\n\\n```\n```\\n\\t\\t\\t o\\t\\t   o\\t      o\\n\\t\\t\\t/ \\\\\\t\\t  / \\\\        / \\\\\\t\\n\\t\\t   o   x     o   x      x   o \\n\\t\\t```\n```\\n\\t\\t\\t\\t o\\t\\n\\t\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t\\t   o   o  \\n\\t    ```\n```\\n\\t\\t\\t o\\t\\t \\n\\t\\t\\t/ \\\\\\t\\t\\n\\t\\t   x   x     \\n\\t\\t```\n```\\n\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t/  \\\\\\n\\t\\t\\t\\t   2    3\\n\\t\\t\\t\\t  / \\\\  /\\n\\t\\t\\t\\t 4  5  6\\n\\t\\t\\t    /\\\\     /\\\\\\n\\t\\t\\t   7  8   9 10\\n\\t\\t\\t  / \\\\\\n\\t\\t\\t 11 12\\n\\t\\t\\t\\t/ \\\\\\n\\t\\t\\t   13 14\\n\\t\\t\\t\\t  / \\\\\\n\\t\\t\\t\\t 15 16\\n\\t\\t\\t\\t /    \\\\\\n\\t\\t\\t\\t17    18\\n\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tans = 6\\n```\n```\\nimport collections\\n\\nclass TreeNode:\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\nclass findComponentsInTree:\\n\\tdef __init__(self, G):\\n\\t\\tself.G = set(G)\\n\\n\\tdef numComponents(self, node):\\n\\t\\tprint(node.val if node else node)\\n\\t\\tif not node: return 0\\n\\t\\tcount = self.numComponents(node.left) + self.numComponents(node.right) + self.AdjustByShape(node)\\n\\t\\t#print(\"ajusted: \", node.val, self.AdjustByShape(node), count)\\n\\t\\treturn count\\n\\t\\n\\tdef AdjustByShape(self, node):\\n\\t\\tif node.val in self.G:\\n\\t\\t\\tif not node.left and not node.right:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif not node.left:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.right)\\n\\t\\t\\telif not node.right:\\n\\t\\t\\t\\treturn self.AdjustByShape(node.left)\\n\\t\\t\\telif node.left.val in self.G and node.right.val in self.G:\\n\\t\\t\\t\\treturn 1\\n\\t\\t\\telif node.left.val in self.G or node.right.val in self.G:\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn 1\\n\\t\\treturn 0\\n\\nif __name__ == \"__main__\":\\n\\t# construct a tree example\\n\\troot = TreeNode(1)\\n\\troot.left, root.right = TreeNode(2), TreeNode(3)\\n\\tp, q = root.left, root.right\\n\\tp.left, p.right = TreeNode(4), TreeNode(5)\\n\\tq.left, q.right = TreeNode(6), None\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(7), TreeNode(8)\\n\\tq = q.left\\n\\tq.left, q.right = TreeNode(9), TreeNode(10)\\n\\tp = p.left\\n\\tp.left, p.right = TreeNode(11), TreeNode(12)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(13), TreeNode(14)\\n\\tp = p.right\\n\\tp.left, p.right = TreeNode(15), TreeNode(16)\\n\\tp, q = p.left, p.right\\n\\tp.left, p.right = TreeNode(17), None\\n\\tq.left, q.right = None, TreeNode(18)\\n\\t\\'\\'\\'\\n\\tdef printTreeByLevel(root):\\n\\t\\tlevels = []\\n\\t\\tqueue = collections.deque([root])\\n\\t\\twhile queue:\\n\\t\\t\\tlevel = []\\n\\t\\t\\tfor _ in range(len(queue)):\\n\\t\\t\\t\\tnode = queue.popleft()\\n\\t\\t\\t\\tlevel.append(node.val) \\n\\t\\t\\t\\tif node.left:\\n\\t\\t\\t\\t\\tqueue.append(node.left)\\n\\t\\t\\t\\tif node.right:\\n\\t\\t\\t\\t\\tqueue.append(node.right)\\n\\t\\t\\tlevels.append(level)\\n\\t\\tprint(levels)\\n\\n\\tprintTreeByLevel(root)\\n\\t\\'\\'\\'\\n\\tG = [2,3,5,6,10,11,12,14,17,18]\\n\\tsol = findComponentsInTree(G)\\n\\tprint(\"ans: \", sol.numComponents(root))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436589,
                "title": "easy-python",
                "content": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset= set()\\n        \\n        for g in G:\\n            Gset.add(g)\\n        \\n        result=0\\n        \\n        while(head and head.val not in Gset):\\n            head= head.next\\n        prev= None\\n        while(head):\\n            if head.val not in Gset:\\n                result+=1\\n                while(head and head.val not in Gset):\\n                    prev= head\\n                    head= head.next\\n            else:\\n                prev= head\\n                head= head.next\\n        if prev and prev.val in Gset:\\n            result+=1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        Gset= set()\\n        \\n        for g in G:\\n            Gset.add(g)\\n        \\n        result=0\\n        \\n        while(head and head.val not in Gset):\\n            head= head.next\\n        prev= None\\n        while(head):\\n            if head.val not in Gset:\\n                result+=1\\n                while(head and head.val not in Gset):\\n                    prev= head\\n                    head= head.next\\n            else:\\n                prev= head\\n                head= head.next\\n        if prev and prev.val in Gset:\\n            result+=1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 412720,
                "title": "c-concise-solution",
                "content": "Delete the node if it is not the last one for each groups. \\nAt the end, HashSet contains only 1 node per each group.\\n\\n```\\npublic class Solution {\\n    public int NumComponents(ListNode head, int[] G) {\\n        HashSet<int> hash = new HashSet<int>();\\n        foreach(int x in G)\\n            hash.Add(x);\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && hash.Contains(head.next.val))\\n                hash.Remove(head.val);\\n            head = head.next;\\n        }\\n        \\n        return hash.Count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int NumComponents(ListNode head, int[] G) {\\n        HashSet<int> hash = new HashSet<int>();\\n        foreach(int x in G)\\n            hash.Add(x);\\n        \\n        while(head != null)\\n        {\\n            if(head.next != null && hash.Contains(head.next.val))\\n                hash.Remove(head.val);\\n            head = head.next;\\n        }\\n        \\n        return hash.Count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 400359,
                "title": "javascript-64ms-faster-than-90",
                "content": "```js\\nconst numComponents = (head, G) => {\\n    const set = new Set(G);\\n    let pointer = head,\\n\\t\\tstack = [],\\n\\t\\tans = 0;\\n\\t\\n    while (pointer) {\\n\\t\\t// If there\\'s overlapped number, push to stack  \\n        if (set.has(pointer.val)) {\\n            stack.push(pointer.val);\\n        } else {\\n\\t\\t\\t// Once the continuous stopped and there\\'s something in the stack, ans++  \\n            if (stack.length) {\\n                ans++;\\n                stack = [];\\n            }\\n        }\\n        pointer = pointer.next;\\n    }\\n\\t\\n\\t// Check if there\\'s numbers left in stack\\n    return (stack.length) ? ans + 1 : ans;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst numComponents = (head, G) => {\\n    const set = new Set(G);\\n    let pointer = head,\\n\\t\\tstack = [],\\n\\t\\tans = 0;\\n\\t\\n    while (pointer) {\\n\\t\\t// If there\\'s overlapped number, push to stack  \\n        if (set.has(pointer.val)) {\\n            stack.push(pointer.val);\\n        } else {\\n\\t\\t\\t// Once the continuous stopped and there\\'s something in the stack, ans++  \\n            if (stack.length) {\\n                ans++;\\n                stack = [];\\n            }\\n        }\\n        pointer = pointer.next;\\n    }\\n\\t\\n\\t// Check if there\\'s numbers left in stack\\n    return (stack.length) ? ans + 1 : ans;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342745,
                "title": "why-so-many-dislikes-to-this-question",
                "content": "I mean the question is not tough but is there a reason behind so many dislikes to this question?\\nThe solution is pretty staight forward with no edge cases. What am I missing?\\n```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> set;\\n        for(int & v : G)\\n            set.insert(v);\\n        int ans = 0;\\n        ListNode * ptr = head;\\n        while(ptr)\\n        {\\n            if(set.count(ptr -> val))\\n            {\\n                ++ans;\\n                while(ptr && set.count(ptr -> val))\\n                    ptr = ptr -> next;\\n            }\\n            else ptr = ptr -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> set;\\n        for(int & v : G)\\n            set.insert(v);\\n        int ans = 0;\\n        ListNode * ptr = head;\\n        while(ptr)\\n        {\\n            if(set.count(ptr -> val))\\n            {\\n                ++ans;\\n                while(ptr && set.count(ptr -> val))\\n                    ptr = ptr -> next;\\n            }\\n            else ptr = ptr -> next;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 342550,
                "title": "c-easy-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\tint numComponents(ListNode* head, vector<int>& G) {\\n\\t\\tbool arr[10000] = { false };\\n\\t\\tfor (int i = 0; i < G.size(); i++) arr[G[i]] = true;\\n\\t\\tListNode *p = head;\\n\\t\\tint count = 0;\\n\\t\\twhile (p!= NULL) {\\n\\t\\t\\tif (arr[p->val]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\twhile (p!=NULL&&arr[p->val]) p = p->next;\\n\\t\\t\\t}\\n\\t\\t\\telse p = p->next;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\tint numComponents(ListNode* head, vector<int>& G) {\\n\\t\\tbool arr[10000] = { false };\\n\\t\\tfor (int i = 0; i < G.size(); i++) arr[G[i]] = true;\\n\\t\\tListNode *p = head;\\n\\t\\tint count = 0;\\n\\t\\twhile (p!= NULL) {\\n\\t\\t\\tif (arr[p->val]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\twhile (p!=NULL&&arr[p->val]) p = p->next;\\n\\t\\t\\t}\\n\\t\\t\\telse p = p->next;\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340145,
                "title": "python3-solution-single-pass",
                "content": "Please comment for any doubt\\n\\n```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count=0\\n        i=head\\n        while i:\\n            if i.val in G:\\n                count+=1\\n                while i and i.val in G:\\n                    i=i.next\\n            else :i=i.next\\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        count=0\\n        i=head\\n        while i:\\n            if i.val in G:\\n                count+=1\\n                while i and i.val in G:\\n                    i=i.next\\n            else :i=i.next\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 334107,
                "title": "c-9x-solution",
                "content": "It is hard to say this is a linked list problem.\\n```cpp\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        bool found = false;\\n        int n = 0;\\n        while (head != nullptr) {\\n            if (s.count(head->val)) {\\n                if (!found) {\\n                    found = true;  \\n                    n++;\\n                } \\n            } else {\\n                found = false;\\n            }\\n            head = head->next;\\n        }\\n        return n;\\n    }\\n```",
                "solutionTags": [],
                "code": "```cpp\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        unordered_set<int> s(G.begin(), G.end());\\n        bool found = false;\\n        int n = 0;\\n        while (head != nullptr) {\\n            if (s.count(head->val)) {\\n                if (!found) {\\n                    found = true;  \\n                    n++;\\n                } \\n            } else {\\n                found = false;\\n            }\\n            head = head->next;\\n        }\\n        return n;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326995,
                "title": "python-union-find",
                "content": "My solution is convoluted compared to the concise solutions that others shared here, but wanted to share that it is possible to solve the problem using Disjoint Set (Union Find).\\n\\nThe idea is to perform `union` when both the current node and next node exist in `G`, and then count total number of unique items from the disjoint set.\\n\\n```py\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        self.parent[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        def length(head):\\n            cnt = 0\\n            if not head:\\n                return 0\\n            tmp = head\\n            while tmp:\\n                tmp = tmp.next\\n                cnt += 1\\n            return cnt\\n        \\n        n = length(head)\\n        uf = UnionFind(n)\\n        tmp = head\\n        subset = set(G)\\n        while tmp:\\n            if tmp.val in subset and tmp.next and tmp.next.val in subset:\\n                uf.union(tmp.val, tmp.next.val)\\n            tmp = tmp.next\\n        \\n        unique_count = len(set(uf.find(x) for x in G))\\n        return unique_count\\n```",
                "solutionTags": [],
                "code": "```py\\nclass UnionFind:\\n    def __init__(self, n):\\n        self.parent = list(range(n))\\n        \\n    def find(self, x):\\n        if x != self.parent[x]:\\n            self.parent[x] = self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self, x, y):\\n        self.parent[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def numComponents(self, head: ListNode, G: List[int]) -> int:\\n        def length(head):\\n            cnt = 0\\n            if not head:\\n                return 0\\n            tmp = head\\n            while tmp:\\n                tmp = tmp.next\\n                cnt += 1\\n            return cnt\\n        \\n        n = length(head)\\n        uf = UnionFind(n)\\n        tmp = head\\n        subset = set(G)\\n        while tmp:\\n            if tmp.val in subset and tmp.next and tmp.next.val in subset:\\n                uf.union(tmp.val, tmp.next.val)\\n            tmp = tmp.next\\n        \\n        unique_count = len(set(uf.find(x) for x in G))\\n        return unique_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 300450,
                "title": "python-with-explanation",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # How many different case will end up to be different component:\\n        # 1. the next of curr is not in G, then the prev one will be component \\n        # 2. Once again one node in G, it will start another component\\n        # 3. Exit, reach the end.\\n        setG = set(G)\\n        count = 0\\n\\n        while head:\\n            # process curr node:\\n            if head.val in setG:\\n                count += 1\\n                while head.next:\\n                    # if we find a component, we keep moving head until the first item not in setG\\n                    if head.val in setG:\\n                        head = head.next \\n                    else:\\n                        # e.g point stoped at 2\\n                        break\\n            \\n            head = head.next\\n            \\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.next = None\\n\\nclass Solution(object):\\n    def numComponents(self, head, G):\\n        \"\"\"\\n        :type head: ListNode\\n        :type G: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # How many different case will end up to be different component:\\n        # 1. the next of curr is not in G, then the prev one will be component \\n        # 2. Once again one node in G, it will start another component\\n        # 3. Exit, reach the end.\\n        setG = set(G)\\n        count = 0\\n\\n        while head:\\n            # process curr node:\\n            if head.val in setG:\\n                count += 1\\n                while head.next:\\n                    # if we find a component, we keep moving head until the first item not in setG\\n                    if head.val in setG:\\n                        head = head.next \\n                    else:\\n                        # e.g point stoped at 2\\n                        break\\n            \\n            head = head.next\\n            \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 282708,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nBasically counting all the starting points of the chains. First while loop gets you to start of the chain, next while loop gets you to a node just past the end of the chain.\\n\\n```\\npublic int numComponents(ListNode head, int[] g) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : g)\\n            set.add(i);\\n        int count = 0;\\n        while(head != null){\\n            while(head != null && !set.contains(head.val)){\\n                head = head.next;\\n            }\\n            //new chain starting point\\n            if(head != null) ++count;\\n            while(head != null && set.contains(head.val)){\\n                set.remove(head.val);\\n                head = head.next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int numComponents(ListNode head, int[] g) {\\n        Set<Integer> set = new HashSet<>();\\n        for(int i : g)\\n            set.add(i);\\n        int count = 0;\\n        while(head != null){\\n            while(head != null && !set.contains(head.val)){\\n                head = head.next;\\n            }\\n            //new chain starting point\\n            if(head != null) ++count;\\n            while(head != null && set.contains(head.val)){\\n                set.remove(head.val);\\n                head = head.next;\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 228340,
                "title": "java-a-little-different-approach",
                "content": "After I submitted my solution, I looked at the official answer, and the Set approach is very clear and simple.  Well, I didn\\'t think of that on my own.  I used a method with some Maps.  This isn\\'t better, but it\\'s an alternate approach you might find interesting:\\n```\\n    public int numComponents(ListNode head, int[] G) {\\n        int components=0;\\n        Map<Integer,ListNode> unseenNodes = new HashMap<Integer,ListNode>();\\n        Map<Integer,ListNode> seenNodes = new HashMap<Integer,ListNode>();\\n        for( ListNode cur=head; cur!=null; cur=cur.next ) unseenNodes.put( cur.val, cur );\\n        \\n        for( int val : G ) {\\n            ListNode cur=unseenNodes.get(val);\\n            if( cur==null ) cur=seenNodes.get(val); else components++;\\n            unseenNodes.remove(val);\\n            \\n            if( cur.next!=null ) {\\n                if( unseenNodes.remove(cur.next.val)==null ) components--;\\n                seenNodes.put( cur.next.val, cur.next );\\n            }\\n        }\\n        \\n        return components;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int numComponents(ListNode head, int[] G) {\\n        int components=0;\\n        Map<Integer,ListNode> unseenNodes = new HashMap<Integer,ListNode>();\\n        Map<Integer,ListNode> seenNodes = new HashMap<Integer,ListNode>();\\n        for( ListNode cur=head; cur!=null; cur=cur.next ) unseenNodes.put( cur.val, cur );\\n        \\n        for( int val : G ) {\\n            ListNode cur=unseenNodes.get(val);\\n            if( cur==null ) cur=seenNodes.get(val); else components++;\\n            unseenNodes.remove(val);\\n            \\n            if( cur.next!=null ) {\\n                if( unseenNodes.remove(cur.next.val)==null ) components--;\\n                seenNodes.put( cur.next.val, cur.next );\\n            }\\n        }\\n        \\n        return components;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 213046,
                "title": "simple-solution-for-beginners-in-c",
                "content": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        set<int> s;\\n        for (auto t: G) s.insert(t);\\n        int ans = 0;\\n    \\tint ok = 0;\\n        int j=0;\\n        auto p=s.find(7);\\n        cout<<*p;\\n        while (head != NULL){\\n        \\tif (s.find(head->val) != s.end()){\\n        \\t\\tif (!ok){\\n        \\t\\t\\tok = 1;\\n        \\t\\t\\tans ++;\\n        \\t\\t}\\n                \\n        \\t}\\n        \\t else {ok = 0;\\n                   \\n                   j++;\\n                   //cout<<head->val;\\n                  }\\n        \\thead = head->next;\\n        }\\t\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& G) {\\n        set<int> s;\\n        for (auto t: G) s.insert(t);\\n        int ans = 0;\\n    \\tint ok = 0;\\n        int j=0;\\n        auto p=s.find(7);\\n        cout<<*p;\\n        while (head != NULL){\\n        \\tif (s.find(head->val) != s.end()){\\n        \\t\\tif (!ok){\\n        \\t\\t\\tok = 1;\\n        \\t\\t\\tans ++;\\n        \\t\\t}",
                "codeTag": "C++"
            },
            {
                "id": 190637,
                "title": "javascript",
                "content": "```\nvar numComponents = function(head, G) {\n    let result = 0;\n    let mark = false;\n    let i = 0;\n    while(head != null && i != G.length) {\n        if(G.indexOf(head.val) == -1) {\n            head = head.next;\n            mark = false;\n            continue;\n        }\n        if(mark) {\n            head = head.next;\n        } else {\n            mark = true;\n            result++;\n            head = head.next;\n        }\n        i++;\n    }\n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar numComponents = function(head, G) {\n    let result = 0;\n    let mark = false;\n    let i = 0;\n    while(head != null && i != G.length) {\n        if(G.indexOf(head.val) == -1) {\n            head = head.next;\n            mark = false;\n            continue;\n        }\n        if(mark) {\n            head = head.next;\n        } else {\n            mark = true;\n            result++;\n            head = head.next;\n        }\n        i++;\n    }\n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 182578,
                "title": "c-solution",
                "content": "```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& G) {\n        set<int> myset;\n        set<int>::iterator it;\n        for (int i = 0; i < G.size(); i++) {\n            myset.insert(G[i]);\n        }\n        int count = 0;\n        bool flag = false;\n        ListNode* tmp = head;\n        while(tmp != nullptr) {\n            int val = tmp->val;\n            it = myset.find(val);\n            if (it != myset.end()) {\n                flag = true;\n            } else {\n                if (flag == true) {\n                    count++;\n                }\n                flag = false;\n            }\n            tmp = tmp->next;\n        }\n        if (flag == true) {\n            count++;\n        }\n        return count;\n        \n    }\n};\n```",
                "solutionTags": [],
                "code": "```\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    int numComponents(ListNode* head, vector<int>& G) {\n        set<int> myset;\n        set<int>::iterator it;\n        for (int i = 0; i < G.size(); i++) {\n            myset.insert(G[i]);\n        }\n        int count = 0;\n        bool flag = false;\n        ListNode* tmp = head;\n        while(tmp != nullptr) {\n            int val = tmp->val;\n            it = myset.find(val);\n            if (it != myset.end()) {\n                flag = true;\n            } else {\n                if (flag == true) {\n                    count++;\n                }\n                flag = false;\n            }\n            tmp = tmp->next;\n        }\n        if (flag == true) {\n            count++;\n        }\n        return count;\n        \n    }\n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 178709,
                "title": "c-easy-to-understand-solution-with-reading-notes",
                "content": "```\\n    //\\n    // PROBLEM DESCRIPTION: https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\n    //  also note that the linked list nodes may not be in sorted order, although every test case depicts them to be as such.\\n    //\\n    \\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> gSet(G.begin(), G.end());\\n        \\n        int count = 0;\\n        ListNode* n = head;\\n        while (n != NULL)\\n        {\\n            if (gSet.find(n->val) != gSet.end())\\n            {\\n                count++;\\n                \\n                do \\n                {\\n                    n = n->next;\\n                } while(n != NULL && gSet.find(n->val) != gSet.end());\\n            }\\n            \\n            if (n != NULL)\\n                n = n->next;\\n        }\\n        \\n        return count;\\n        \\n    }\\n\\t\\t\\n```",
                "solutionTags": [],
                "code": "```\\n    //\\n    // PROBLEM DESCRIPTION: https://leetcode.com/problems/linked-list-components/discuss/131853/Can-someone-explain-the-test-case\\n    //  also note that the linked list nodes may not be in sorted order, although every test case depicts them to be as such.\\n    //\\n    \\n    int numComponents(ListNode* head, vector<int>& G) \\n    {\\n        unordered_set<int> gSet(G.begin(), G.end());\\n        \\n        int count = 0;\\n        ListNode* n = head;\\n        while (n != NULL)\\n        {\\n            if (gSet.find(n->val) != gSet.end())\\n            {\\n                count++;\\n                \\n                do \\n                {\\n                    n = n->next;\\n                } while(n != NULL && gSet.find(n->val) != gSet.end());\\n            }\\n            \\n            if (n != NULL)\\n                n = n->next;\\n        }\\n        \\n        return count;\\n        \\n    }\\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142854,
                "title": "java-easy-solution-time-o-n-space-o-size-of-g",
                "content": "Steps:\\n1. Add all the integer array elements to a HashSet (for easy O(1) access).\\n2. Traverse the Linked List. Check if an element exists in the hashset.\\n3. If it does exist: If not counted previuosly, Assign prev_counted to true now and increse your counter (res). \\n4. If it doesn\\'t exist, change it back to false (Starting fresh).\\n5. Keep traversing until the end of the Linked List.\\n6. Return the result (res).\\n\\n\\n```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head==null) return 0;\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        int res=0;\\n        boolean prev_counted=false;\\n        for(int num:G) hs.add(num);\\n        \\n        ListNode curr=head;\\n        while(curr!=null)\\n        {\\n            int val=curr.val;\\n            if(hs.contains(val))\\n            {\\n                if(!prev_counted) \\n                {\\n                   res++;\\n                   prev_counted=true;\\n                }\\n            }\\n            else\\n            {\\n                prev_counted=false;\\n            }\\n            curr=curr.next;\\n        }\\n        return res;  \\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int numComponents(ListNode head, int[] G) {\\n        if(head==null) return 0;\\n        HashSet<Integer> hs=new HashSet<Integer>();\\n        int res=0;\\n        boolean prev_counted=false;\\n        for(int num:G) hs.add(num);\\n        \\n        ListNode curr=head;\\n        while(curr!=null)\\n        {\\n            int val=curr.val;\\n            if(hs.contains(val))\\n            {\\n                if(!prev_counted) \\n                {\\n                   res++;\\n                   prev_counted=true;\\n                }\\n            }\\n            else\\n            {\\n                prev_counted=false;\\n            }\\n            curr=curr.next;\\n        }\\n        return res;  \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 126768,
                "title": "c-o-n-g-solution",
                "content": "```\\nint numComponents(ListNode* head, vector<int>& G) \\n    {\\n        auto gSet = unordered_set<int>{begin(G),end(G)};\\n        \\n        int maxSize = 0;\\n        bool groupStart = false;\\n        \\n        while(head!=nullptr)\\n        {\\n            if(gSet.find(head->val) != gSet.end())\\n            {\\n                if(!groupStart)\\n                {\\n                    maxSize++;\\n                    groupStart = true;\\n                }                    \\n            }\\n            else groupStart = false;\\n            head = head->next;   \\n        }\\n        return maxSize;\\n    }",
                "solutionTags": [],
                "code": "```\\nint numComponents(ListNode* head, vector<int>& G) \\n    {\\n        auto gSet = unordered_set<int>{begin(G),end(G)};\\n        \\n        int maxSize = 0;\\n        bool groupStart = false;\\n        \\n        while(head!=nullptr)\\n        {\\n            if(gSet.find(head->val) != gSet.end())\\n            {\\n                if(!groupStart)\\n                {\\n                    maxSize++;\\n                    groupStart = true;\\n                }                    \\n            }\\n            else groupStart = false;\\n            head = head->next;   \\n        }\\n        return maxSize;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 123933,
                "title": "c-13ms-linear-time-without-hash-map",
                "content": "Most solutions posted here use a hash map, which means that the linear running time is only expected. Here is a linear-time solution that does not use a hash map. It is important to exploit the fact that the list is a permutation of `[0, N - 1]`. Therefore, we can build a mask to efficiently look up whether an element belongs to `G`.\\n\\n```\\nclass Solution\\n{\\n  private:\\n    vector<bool> build_mask(size_t n, const vector<int> & G)\\n    {\\n        vector<bool> mask(n, false);\\n        \\n        for (int i : G)\\n            mask[i] = true;\\n        \\n        return mask;\\n    }\\n    \\n    size_t length(ListNode * node)\\n    {\\n        if (! node)\\n            return 0;\\n        \\n        return 1 + length(node->next);\\n    }\\n    \\n  public:\\n    int numComponents(ListNode * head, vector<int> & G)\\n    {\\n        size_t n = length(head);\\n        \\n        vector<bool> mask = build_mask(n + 1, G);\\n        \\n        static ListNode * _head = new ListNode(n);\\n        _head->val = n;\\n        _head->next = head;\\n        \\n        int c = 0;\\n        \\n        for (ListNode * node = _head; node->next; node = node->next)\\n        {\\n            if (! mask[node->val] && mask[node->next->val])\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n  private:\\n    vector<bool> build_mask(size_t n, const vector<int> & G)\\n    {\\n        vector<bool> mask(n, false);\\n        \\n        for (int i : G)\\n            mask[i] = true;\\n        \\n        return mask;\\n    }\\n    \\n    size_t length(ListNode * node)\\n    {\\n        if (! node)\\n            return 0;\\n        \\n        return 1 + length(node->next);\\n    }\\n    \\n  public:\\n    int numComponents(ListNode * head, vector<int> & G)\\n    {\\n        size_t n = length(head);\\n        \\n        vector<bool> mask = build_mask(n + 1, G);\\n        \\n        static ListNode * _head = new ListNode(n);\\n        _head->val = n;\\n        _head->next = head;\\n        \\n        int c = 0;\\n        \\n        for (ListNode * node = _head; node->next; node = node->next)\\n        {\\n            if (! mask[node->val] && mask[node->next->val])\\n                c++;\\n        }\\n        \\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 123824,
                "title": "c-very-simple-solution",
                "content": "````\\n// General idea:\\n// - iterate through the linked-list and keep track of when you are in/out of component\\n// - every time you EXIT a component, increment your count (ans)\\n// - make sure to check if you finished the list in a component\\n\\nbool in = false;\\nint ans = 0;\\n\\nint numComponents(ListNode* head, vector<int>& G) \\n{\\n    unordered_set<int> v (G.begin (), G.end ());\\n\\n    while (head) \\n    {\\n        if (v.count (head->val)) in = true;\\n        else if (in) ans++, in = false;\\n\\n        head = head->next;\\n    }\\n\\n    if (in) ans++;\\n\\n    return ans;\\n}",
                "solutionTags": [],
                "code": "````\\n// General idea:\\n// - iterate through the linked-list and keep track of when you are in/out of component\\n// - every time you EXIT a component, increment your count (ans)\\n// - make sure to check if you finished the list in a component\\n\\nbool in = false;\\nint ans = 0;\\n\\nint numComponents(ListNode* head, vector<int>& G) \\n{\\n    unordered_set<int> v (G.begin (), G.end ());\\n\\n    while (head) \\n    {\\n        if (v.count (head->val)) in = true;\\n        else if (in) ans++, in = false;\\n\\n        head = head->next;\\n    }\\n\\n    if (in) ans++;\\n\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 4100244,
                "title": "cpp-sol",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(n) where n is no. of nodes\\n\\n- Space complexity:\\nO(m) for unordered set\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numSet(nums.begin(), nums.end());\\n        ListNode* current = head;\\n        int numCount = 0;\\n        bool inComponent = false;\\n\\n        while (current != nullptr) {\\n            if (numSet.count(current->val)) {\\n                if (!inComponent) {\\n                    numCount++;\\n                    inComponent = true;\\n                }\\n            } else {\\n                inComponent = false;\\n            }\\n            current = current->next;\\n        }\\n\\n        return numCount;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        unordered_set<int> numSet(nums.begin(), nums.end());\\n        ListNode* current = head;\\n        int numCount = 0;\\n        bool inComponent = false;\\n\\n        while (current != nullptr) {\\n            if (numSet.count(current->val)) {\\n                if (!inComponent) {\\n                    numCount++;\\n                    inComponent = true;\\n                }\\n            } else {\\n                inComponent = false;\\n            }\\n            current = current->next;\\n        }\\n\\n        return numCount;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089467,
                "title": "java-hashset",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i : nums){\\n            hs.add(i);\\n        }\\n        int ans = 0;\\n        boolean prev = false;\\n        while(head != null){\\n            int a = head.val;\\n            if(hs.contains(a)){\\n                if(!prev){\\n                    ans++;\\n                    prev = true;\\n                }\\n            }else{\\n                prev = false;\\n            }\\n            head = head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Linked List"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public int numComponents(ListNode head, int[] nums) {\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int i : nums){\\n            hs.add(i);\\n        }\\n        int ans = 0;\\n        boolean prev = false;\\n        while(head != null){\\n            int a = head.val;\\n            if(hs.contains(a)){\\n                if(!prev){\\n                    ans++;\\n                    prev = true;\\n                }\\n            }else{\\n                prev = false;\\n            }\\n            head = head.next;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4081394,
                "title": "my-approach-easy-solution-in-python",
                "content": "class Solution(object):\\n    def numComponents(self, head, nums):\\n        count = 0\\n        d = {}\\n        val = head.val  # Assuming head is the head node of your linked list\\n        curr = head  # Assuming curr starts at the head node\\n        while curr:\\n            if curr.val in nums:\\n                count = 1\\n                d[val] = count\\n            else:\\n                d[curr.val] = None\\n                count = 0\\n                if curr.next:\\n                    val = curr.next.val  # Assuming curr.next is the next node in the linked list\\n            curr = curr.next  # Move to the next node in the linked list\\n        print(d)\\n        sum_of_values = sum(value for value in d.values() if value is not None)\\n        return sum_of_values",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def numComponents(self, head, nums):\\n        count = 0\\n        d = {}",
                "codeTag": "Java"
            },
            {
                "id": 4077970,
                "title": "easy-solution-using-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing a dictionary wheather the value is in nums.For this u have to convert this nums array into dictionary..\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1.At first check the length of head and nums  are same .If same then the answer is 1!!!(Because all values are eventually connected with each other).\\n2.If the first condition is False then check the consecutive values  in head are present in new_nums(dictionary) using while loop .While consecutive values are present in dictionary then head pointer is increased by head.next .Else increse count value by one.\\n3.Increment head pointer \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n).Head counter will go to the last node !!!\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        new_nums={}\\n        for value in nums:\\n            if value not in new_nums:\\n                new_nums[value]=1\\n        count=0\\n        total=0\\n        new_head=head\\n        while new_head:\\n            total+=1\\n            new_head=new_head.next\\n        while head:\\n            if head.val in new_nums:\\n                if total==len(nums):\\n                    return 1\\n                while head.next is not None and head.next.val in new_nums:\\n                    head=head.next\\n                count+=1                \\n            head=head.next\\n        return count \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        new_nums={}\\n        for value in nums:\\n            if value not in new_nums:\\n                new_nums[value]=1\\n        count=0\\n        total=0\\n        new_head=head\\n        while new_head:\\n            total+=1\\n            new_head=new_head.next\\n        while head:\\n            if head.val in new_nums:\\n                if total==len(nums):\\n                    return 1\\n                while head.next is not None and head.next.val in new_nums:\\n                    head=head.next\\n                count+=1                \\n            head=head.next\\n        return count \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4061269,
                "title": "easy-python-solution-in-o-n",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\n        temp = head\\n        count = 0\\n\\n        connected = False  \\n\\n        while(temp):\\n            if(temp.val in nums):\\n                if(connected == False):\\n                    connected = True\\n                    count += 1\\n            else:\\n                connected = False\\n\\n            temp = temp.next\\n\\n        return count\\n```\\n\\n# Explanation\\n\\n1) Traverse the linked list while keeping track of whether you are within a connected component (in this case, a connected component means a sequence of nodes with values in nums that appear consecutively).\\n\\n2) When you encounter a node with a value in nums, start or continue a connected component.\\n\\n3) When you encounter a node with a value not in nums, end the current connected component.\\n\\n4) Count the number of connected components as you traverse the linked list.\\n\\n\\n\\n##### If you find my solution helpful and worthy, please consider upvoting my solution. Upvotes play a crucial role in ensuring that this valuable content reaches others and helps them as well.\\n\\n##### Only your support motivates me to continue contributing more solutions and assisting the community further.\\n\\n##### Thank You for spending your valuable time.",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n\\n        temp = head\\n        count = 0\\n\\n        connected = False  \\n\\n        while(temp):\\n            if(temp.val in nums):\\n                if(connected == False):\\n                    connected = True\\n                    count += 1\\n            else:\\n                connected = False\\n\\n            temp = temp.next\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4060779,
                "title": "c-simple-observation-and-hashing",
                "content": "# Intuition\\nit is stated the we can connect consecutive number from the arrays and make one component so we will check if all the consective number can be a part of our result or not  For ex 0,1,2,3 :: 0 and 1 are part of subset nums also so will keep goind and include them in one subset and stop wehenever the condition is not true \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int>st(nums.begin(),nums.end());\\n         vector<int>v;\\n         while(head!=NULL)\\n          v.push_back(head->val),head=head->next;\\n          int comp=0;\\n          int sz=v.size();\\n          for(int i=0;i<sz;i++)\\n           {\\n             int j=i;\\n              while(j<sz and st.find(v[j])!=st.end())\\n                {\\n                    //one component \\n                    \\n                      j++;\\n                }\\n               \\n                if(i!=j)\\n                 comp++,i=j;\\n                  \\n           }\\n           return comp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        set<int>st(nums.begin(),nums.end());\\n         vector<int>v;\\n         while(head!=NULL)\\n          v.push_back(head->val),head=head->next;\\n          int comp=0;\\n          int sz=v.size();\\n          for(int i=0;i<sz;i++)\\n           {\\n             int j=i;\\n              while(j<sz and st.find(v[j])!=st.end())\\n                {\\n                    //one component \\n                    \\n                      j++;\\n                }\\n               \\n                if(i!=j)\\n                 comp++,i=j;\\n                  \\n           }\\n           return comp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056832,
                "title": "go-easy",
                "content": "```\\nfunc numComponents(head *ListNode, nums []int) int {\\n    targets := make(map[int]bool)\\n\\n    for _, num := range nums {\\n        targets[num] = true\\n    }\\n\\n    components := 0\\n    var prev *ListNode\\n\\n    for cur := head; cur != nil; cur = cur.Next {\\n        if prev != nil {\\n            if !targets[prev.Val] && targets[cur.Val] {\\n                components++\\n            }\\n        } else {\\n            if targets[cur.Val] {\\n                components++\\n            }\\n        }\\n        prev = cur\\n    }\\n\\n    return components\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc numComponents(head *ListNode, nums []int) int {\\n    targets := make(map[int]bool)\\n\\n    for _, num := range nums {\\n        targets[num] = true\\n    }\\n\\n    components := 0\\n    var prev *ListNode\\n\\n    for cur := head; cur != nil; cur = cur.Next {\\n        if prev != nil {\\n            if !targets[prev.Val] && targets[cur.Val] {\\n                components++\\n            }\\n        } else {\\n            if targets[cur.Val] {\\n                components++\\n            }\\n        }\\n        prev = cur\\n    }\\n\\n    return components\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4055545,
                "title": "self-explanatory-comments-using-set-hash-table-best-ever-c-solution",
                "content": "~ \\uD835\\uDE52\\uD835\\uDE5E\\uD835\\uDE69\\uD835\\uDE5D \\u2764\\uFE0F \\uD835\\uDE57\\uD835\\uDE6E \\uD835\\uDE43\\uD835\\uDE5E\\uD835\\uDE67\\uD835\\uDE5A\\uD835\\uDE63 \\uD83D\\uDE0A\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHer There! Its Easy Just Take A Look At The Code And Comments Within It, You\\'ll Get It.\\nStill Have Doubts! Feel Free To Comment, I\\'ll Definitely Reply!\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUsing Unordered-Set (Accepted)\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Program to find the number of connected components in \"nums\" where two values are connected if they appear consecutively in the linked list ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <unordered_set>\\n\\n// List template\\nstruct Node {\\n    int val;\\n    Node* next;\\n\\n    // Init constructor\\n    Node(int val, Node* next = nullptr)\\n    :\\n    val(val), next(next) {}\\n\\n    // Init destructor\\n    ~Node() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Method to find the number of connected components - O(N) & O(N) : Where N is the total number of nodes of the list\\nint numComponents(Node* head, std::vector<int> nums) {\\n    std::unordered_set<int> set(begin(nums), end(nums));\\n\\n    // Require to store the number of connected components (resultant value)\\n    int count = 0;\\n\\n    while(head) {\\n        // Increment the count if its the beginning of a new component\\n        if(set.count(head->val)) {\\n            count++;\\n            // Skip the consecutive nodes of the current component\\n            while(head && set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n        // Else, skip the non-component nodes until a potential component node is found\\n        else {\\n            while(head && !set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n// Note: There are also multiple solutions of this problem, do check it out.\\n\\n// Method to print the list using recursion\\nvoid printList(Node* head) {\\n    if(head) {\\n        std::cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating, connecting nodes and initializing their data\\n    Node* head = new Node(0, new Node(1, new Node(2, new Node(3))));\\n\\n    // Print call\\n    printList(head);\\n\\n    // Call to find the number of connected components\\n    int count = numComponents(head, {0,1,3});\\n    std::cout<<\"\\\\nThe number of connected components is : \"<<count;\\n\\n    // Deletion call\\n    delete head;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-components/description/\\n```\\n\\uD835\\uDDE8\\uD835\\uDDE3\\uD835\\uDDE9\\uD835\\uDDE2\\uD835\\uDDE7\\uD835\\uDDD8 \\uD835\\uDDDC\\uD835\\uDDD9 \\uD835\\uDDEC\\uD835\\uDDE2\\uD835\\uDDE8 \\uD835\\uDDDF\\uD835\\uDDDC\\uD835\\uDDDE\\uD835\\uDDD8 \\uD835\\uDDE7\\uD835\\uDDDB\\uD835\\uDDD8 \\uD835\\uDDE6\\uD835\\uDDE2\\uD835\\uDDDF\\uD835\\uDDE8\\uD835\\uDDE7\\uD835\\uDDDC\\uD835\\uDDE2\\uD835\\uDDE1 \\uD83D\\uDC4D",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n// Program to find the number of connected components in \"nums\" where two values are connected if they appear consecutively in the linked list ~ coded by Hiren\\n#include <iostream>\\n#include <vector>\\n#include <unordered_set>\\n\\n// List template\\nstruct Node {\\n    int val;\\n    Node* next;\\n\\n    // Init constructor\\n    Node(int val, Node* next = nullptr)\\n    :\\n    val(val), next(next) {}\\n\\n    // Init destructor\\n    ~Node() {\\n        if(next) {\\n            delete next;\\n        }\\n    }\\n};\\n\\n// Method to find the number of connected components - O(N) & O(N) : Where N is the total number of nodes of the list\\nint numComponents(Node* head, std::vector<int> nums) {\\n    std::unordered_set<int> set(begin(nums), end(nums));\\n\\n    // Require to store the number of connected components (resultant value)\\n    int count = 0;\\n\\n    while(head) {\\n        // Increment the count if its the beginning of a new component\\n        if(set.count(head->val)) {\\n            count++;\\n            // Skip the consecutive nodes of the current component\\n            while(head && set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n        // Else, skip the non-component nodes until a potential component node is found\\n        else {\\n            while(head && !set.count(head->val)) {\\n                head = head->next;\\n            }\\n        }\\n    }\\n    \\n    return count;\\n}\\n// Note: There are also multiple solutions of this problem, do check it out.\\n\\n// Method to print the list using recursion\\nvoid printList(Node* head) {\\n    if(head) {\\n        std::cout<<head->val<<\\' \\';\\n        printList(head->next);\\n    }\\n}\\n\\n// Driver code\\nint main() {\\n    // Creating, connecting nodes and initializing their data\\n    Node* head = new Node(0, new Node(1, new Node(2, new Node(3))));\\n\\n    // Print call\\n    printList(head);\\n\\n    // Call to find the number of connected components\\n    int count = numComponents(head, {0,1,3});\\n    std::cout<<\"\\\\nThe number of connected components is : \"<<count;\\n\\n    // Deletion call\\n    delete head;\\n\\n    return 0;\\n}\\n// Link: https://leetcode.com/problems/linked-list-components/description/\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4051027,
                "title": "python-my-approach",
                "content": "# Intuition\\n  use a current pointer to traverse the linked list\\n  fill the stack if you find a element common in linked list and array\\n  when you dont find a common element clear the stack and update count by +1\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        curr = head \\n        stack=[]\\n        count=0\\n        while curr:\\n            if curr.val in nums :\\n                stack.append(curr.val)\\n                curr=curr.next\\n                continue\\n            if curr.val not in nums :\\n                if stack :\\n                    stack=[]\\n                    count+=1\\n                curr=curr.next\\n                continue\\n        if stack :\\n            return count+1\\n        else :\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def numComponents(self, head: Optional[ListNode], nums: List[int]) -> int:\\n        curr = head \\n        stack=[]\\n        count=0\\n        while curr:\\n            if curr.val in nums :\\n                stack.append(curr.val)\\n                curr=curr.next\\n                continue\\n            if curr.val not in nums :\\n                if stack :\\n                    stack=[]\\n                    count+=1\\n                curr=curr.next\\n                continue\\n        if stack :\\n            return count+1\\n        else :\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4045418,
                "title": "beats-96-efficient-solution-self-explanatory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* temp=head;\\n        unordered_set<int> uSet;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) uSet.insert(nums[i]);\\n        bool flag=false;\\n        int count=0;\\n        while(temp){\\n            if(!flag && uSet.find(temp->val)!=uSet.end()){\\n                flag=true;\\n                count++;\\n            }\\n            else if(flag && uSet.find(temp->val)==uSet.end())\\n                flag=false;\\n            temp=temp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Linked List",
                    "Ordered Set"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int numComponents(ListNode* head, vector<int>& nums) {\\n        ListNode* temp=head;\\n        unordered_set<int> uSet;\\n        int n=nums.size();\\n        for(int i=0;i<n;i++) uSet.insert(nums[i]);\\n        bool flag=false;\\n        int count=0;\\n        while(temp){\\n            if(!flag && uSet.find(temp->val)!=uSet.end()){\\n                flag=true;\\n                count++;\\n            }\\n            else if(flag && uSet.find(temp->val)==uSet.end())\\n                flag=false;\\n            temp=temp->next;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1565358,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1566275,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1898825,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1570334,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1575123,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1567375,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1994891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1749328,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1571914,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1564891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1565358,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1566275,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1898825,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1570334,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1575123,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1567375,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1994891,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1749328,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1571914,
                "content": [
                    {
                        "username": "abhishes",
                        "content": "In this problem https://leetcode.com/problems/linked-list-components/description/\\n\\nThe explanation says\\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "ceriottidenise",
                        "content": "so, when there's a orphan component, it counts as if he is connected by itself. Therefore,  Math.round(nums.length/2) <= result.length <= nums.length"
                    },
                    {
                        "username": "kushalmahajan",
                        "content": "head: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\n"
                    },
                    {
                        "username": "shounakg",
                        "content": "[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\'t the expected asnwer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "0 isnt connected to 2\n5 years late ...lol\n"
                    },
                    {
                        "username": "dmitryartux",
                        "content": "Poor description"
                    },
                    {
                        "username": "gouravscode",
                        "content": "[0,1,2,3]\\n[0,1,3]\\nExpected Output - 2\\n\\nI don\\'t understand how it\\'s 2. One connection is 0 -> 1. What\\'s the other one?\\n\\nAfter putting alot of thought into it. I guess if the last node isn\\'t forming a connection with its previous node, then we can consider it as a connection (individually).\\nI still don\\'t get the point tho.\\n\\nPlease lemme know if you\\'ve got a better explanation."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "If element is present in nums array and also in linked-list, and not connected to any other nodes, then also it will be termed as a connected component with size as 1. Eg. 3 is not connected to any numbers that are present in nums array but still it will termed as a connected component of size 1. [0,1] is the second connected component"
                    },
                    {
                        "username": "itisabhishek",
                        "content": "Can Some one explain what is the question?"
                    },
                    {
                        "username": "nn1874",
                        "content": "basically you need to check how many groups of numbers that contains in the nums. \\nInput: head = [0,1,2,3], nums = [0,1,3]\\n\\n\\n0 and 1 should be in same group, its connected and both in nums[]\\n2 is not in nums[].\\n3 is another group\\nso there are 2 group \\n"
                    },
                    {
                        "username": "abejacobs",
                        "content": "In the description example 1 \\n\\nInput: \\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation: \\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow is [3] a connected component? I can understand [0,1]... But why [3] ?\\n\\nLooks like I am missing something.\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "How to sign a petition to get this question removed from leetcode ?"
                    },
                    {
                        "username": "pushpendra_20",
                        "content": "THE QUESTION IS UNDERSTOOD \\uD83E\\uDD73\\uD83E\\uDD73\\uD83E\\uDD73\\nQues is asking for connected component so explanation is as following\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nIts connected component\\'s concept is similar to graph. In the graph if there is only one node separate from every other node then it is counted 1. if there are n number of nodes connected with each-other then it is also counted as 1.\\nOnly difference is that in our ques connection of elements is linear while in the graph connection of nodes is multi-dimensional and we are looking for elements in list which are present in array.\\nI hope it will help you."
                    },
                    {
                        "username": "shounakg",
                        "content": "I might be missing something really simple but I don\\'t get this test case,\\n[0,1,2]\\n[0,2]\\n\\nexpected answer: 2\\n\\nShouldn\\u2019t the expected answer be 1?"
                    },
                    {
                        "username": "MayuD",
                        "content": "Nah. 0 and 2 arent connected\\n"
                    }
                ]
            },
            {
                "id": 1572098,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1821404,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1643292,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1627810,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1575080,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2052109,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2043669,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2014648,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 2005726,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            },
            {
                "id": 1967090,
                "content": [
                    {
                        "username": "mongolia",
                        "content": "why the test case:\\n[1,2,0,4,3]\\n[3,4,0,2,1]\\n\\nthe result is 1.\\n\\ni think it is 3."
                    },
                    {
                        "username": "nirbhay0299",
                        "content": "nums array ie [3,4,0,2,1] contains all the elements of inked-list [1,2,0,4,3]. Hence the result is 1. (The order in the nums array doesn\\'t matter. As long as num[i] can be accessed by as node (nums[j]) with node.next.val, it is connected)"
                    },
                    {
                        "username": "15o1",
                        "content": "i have the same doubt "
                    },
                    {
                        "username": "yashagg15",
                        "content": "useless question, remove this from question bank or give more details."
                    },
                    {
                        "username": "bingabid",
                        "content": "Input: head = [0,1,2,3], nums = [0,1,3]\\nOutput: 2\\nExplanation: 0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nHow on earth [3] is a connected component? \\nare you high when you were typing the problem description? "
                    },
                    {
                        "username": "c4tdog",
                        "content": "3 is connected to itself. every number is a component, even if it\\'s not connected to anything else"
                    },
                    {
                        "username": "harsh7236",
                        "content": "The explanation says\\n\\nInput:\\nhead: 0->1->2->3\\nG = [0, 1, 3]\\nOutput: 2\\nExplanation:\\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\\n\\nBut how is 3 a connected component?? there is no link between 0 -> 3 or 1 -> 3. So the right answer is 1 because 3 is not connected to anything inside G."
                    },
                    {
                        "username": "danielkua",
                        "content": "Leetcode please fix this!\\n#python #easy #python3"
                    },
                    {
                        "username": "abhay_mnit22",
                        "content": "just little trick ,it is easy \\nhttps://leetcode.com/problems/linked-list-components/solutions/4027246/java-set-flag-whileloop-easy/"
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the examples given, the linked list is generally unsorted."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Convert nums to a HashSet for constant lookup times of values. The starting number of consecutive elements is equal to nums.Length (representing that no nums are consecutive to each other). Now use a while loop that runs while head is not null  and head.next is not null. In this while-loop, if the numset contains head.val AND numset contains head.next.val, decrement consecutive elements by 1. Advance head to head.next. The ending value of your consecutive elements variable will be the answer."
                    },
                    {
                        "username": "shaamray",
                        "content": "Is the linked list is sorted for all test cases?"
                    },
                    {
                        "username": "itsgosho",
                        "content": "What connected component means:\\n\\nInput: head = [0,1,2,3,4], nums = [0,3,1,4]\\n\\n0 and 1 are connected, because 0 and 1 exist in the nums and are side by side.\\n3 and 4 are connected, because 3 and 4 exist in the nums and are side by side.\\n\\nLook it that way. The next one of the current element and current one if both exist in the nums, then the count is - 1. It is simple to code."
                    }
                ]
            }
        ]
    },
    {
        "title": "Remove Zero Sum Consecutive Nodes from Linked List",
        "question_content": "<p>Given the <code>head</code> of a linked list, we repeatedly delete consecutive sequences of nodes that sum to <code>0</code> until there are no such sequences.</p>\r\n\r\n<p>After doing so, return the head of the final linked list.&nbsp; You may return any such answer.</p>\r\n\n<p>&nbsp;</p>\n<p>(Note that in the examples below, all sequences are serializations of <code>ListNode</code> objects.)</p>\n\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2,-3,3,1]\n<strong>Output:</strong> [3,1]\n<strong>Note:</strong> The answer [1,2,1] would also be accepted.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2,3,-3,4]\n<strong>Output:</strong> [1,2,4]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> head = [1,2,3,-3,-2]\n<strong>Output:</strong> [1]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The given linked list will contain between <code>1</code> and <code>1000</code> nodes.</li>\n\t<li>Each node in the linked list has <code>-1000 &lt;= node.val &lt;= 1000</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 366319,
                "title": "java-c-python-greedily-skip-with-hashmap",
                "content": "# **Intuition**\\nAssume the input is an array.\\nDo you know how to solve it?\\nScan from the left, and calculate the prefix sum.\\nWhenever meet the seen prefix,\\nremove all elements of the subarray between them.\\n<br>\\n\\n# **Solution 1**\\nBecause the head ListNode can be removed in the end,\\nI create a `dummy` ListNode and set it as a previous node of `head`.\\n`prefix` calculates the prefix sum from the first node to the current `cur` node.\\n\\nNext step, we need an important hashmap `m` (no good name for it),\\nIt takes a prefix sum as key, and the related node as the value.\\n\\nThen we scan the linked list, accumulate the node\\'s value as `prefix` sum.\\n1. If it\\'s a prefix that we\\'ve never seen, we set `m[prefix] = cur`.\\n2. If we have seen this prefix, `m[prefix]` is the node we achieve this prefix sum.\\nWe want to skip all nodes between `m[prefix]` and `cur.next` (exclusive).\\nSo we simplely do `m[prefix].next = cur.next`.\\n\\nWe keep doing these and it\\'s done.\\n<br>\\n\\n**Complexity**\\nTime `O(N)`, one pass\\nSpace`O(N)`, for hashmap\\n<br>\\n\\n**Java:**\\n```java\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        dummy.next = head;\\n        int prefix = 0;\\n        Map<Integer, ListNode> m = new HashMap<>();\\n        while (cur != null) {\\n            prefix += cur.val;\\n            if (m.containsKey(prefix)) {\\n                cur =  m.get(prefix).next;\\n                int p = prefix + cur.val;\\n                while (p != prefix) {\\n                    m.remove(p);\\n                    cur = cur.next;\\n                    p += cur.val;\\n                }\\n                m.get(prefix).next = cur.next;\\n            } else {\\n                m.put(prefix, cur);\\n            }\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n```\\n\\n**C++:**\\n```cpp\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0), *cur = dummy;\\n        dummy->next = head;\\n        int prefix = 0;\\n        map<int, ListNode*> m;\\n        while (cur) {\\n            prefix += cur->val;\\n            if (m.count(prefix)) {\\n                cur =  m[prefix]->next;\\n                int p = prefix + cur->val;\\n                while (p != prefix) {\\n                    m.erase(p);\\n                    cur = cur->next;\\n                    p += cur->val;\\n                }\\n                m[prefix]->next = cur->next;\\n            } else {\\n                m[prefix] = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return dummy->next;\\n    }\\n```\\n\\n**Python:**\\n```python\\n    def removeZeroSumSublists(self, head):\\n        cur = dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = collections.OrderedDict()\\n        while cur:\\n            prefix += cur.val\\n            node = seen.get(prefix, cur)\\n            while prefix in seen:\\n                seen.popitem()\\n            seen[prefix] = node\\n            node.next = cur = cur.next\\n        return dummy.next\\n```\\n<br>\\n\\n# Improvement\\nI think that\\'s the best part of my post.\\nIt\\'s a great discuss in the leetcode\\'s discuss.\\n\\nPeople are willing to read my article and help me improve it.\\nTo be honest, I think I take good responsiblilty to maintain my solution.\\n(Though the case I don\\'t have prime membership and canot even read my own post in locked problem)\\n\\nThanks to @alexjst inspired me the follwing solution.\\n<br>\\n\\n# Soluiton 2: Two Passes\\n\\nThe story is that,\\nI wrote the really concise solution,\\nit got accepted but actully it\\'s wrong.\\nI fixed it by adding another while loop.\\nThat is the Solution 1.\\n\\nIf we don\\'t insist on one pass,\\nwe can find the two passes is actually really neat.\\n\\nThat turned back to the intuition that I mentioned:\\nAssume the input is an array.\\nHow will you solve the problem?\\n\\nIterate for the first time,\\ncalculate the `prefix` sum,\\nand save the it to `seen[prefix]`\\n\\nIterate for the second time,\\ncalculate the `prefix` sum,\\nand directly skip to last occurrence of this `prefix`\\n\\n**Java**\\n```java\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int prefix = 0;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> seen = new HashMap<>();\\n        seen.put(0, dummy);\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefix += i.val;\\n            seen.put(prefix, i);\\n        }\\n        prefix = 0;\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefix += i.val;\\n            i.next = seen.get(prefix).next;\\n        }\\n        return dummy.next;\\n    }\\n```\\n\\n**C++**\\n```\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        int prefix = 0;\\n        unordered_map<int, ListNode*> seen;\\n        for (ListNode* i = dummy; i; i = i->next) {\\n            seen[prefix += i->val] = i;\\n        }\\n        prefix = 0;\\n        for (ListNode* i = dummy; i; i = i->next) {\\n            i->next = seen[prefix += i->val]->next;\\n        }\\n        return dummy->next;\\n    }\\n```\\n\\n**Python**\\n```py\\n    def removeZeroSumSublists(self, head):\\n        prefix = 0\\n        seen = {}\\n        seen[0] = dummy = ListNode(0)\\n        dummy.next = head\\n        while head:\\n            prefix += head.val\\n            seen[prefix] = head\\n            head = head.next\\n        head = dummy\\n        prefix = 0\\n        while head:\\n            prefix += head.val\\n            head.next = seen[prefix].next\\n            head = head.next\\n        return dummy.next\\n```\\n<br>\\n\\n# **Update 2019-08-25**\\nThe OJ solution was wrong.\\nIt didn\\'t block the right submit,\\nbut wrong submit can also get accepted.\\n\\nFollowing the test case given by @kay_deep:\\n`[1, 3, 2, -3, -2, 5, 100, -100, 1]`\\nThe expected result should be `[1,5,1]` or `[1,3,2,1]`.\\n\\nSome solution in the discuss part are still wrong.",
                "solutionTags": [],
                "code": "```java\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        dummy.next = head;\\n        int prefix = 0;\\n        Map<Integer, ListNode> m = new HashMap<>();\\n        while (cur != null) {\\n            prefix += cur.val;\\n            if (m.containsKey(prefix)) {\\n                cur =  m.get(prefix).next;\\n                int p = prefix + cur.val;\\n                while (p != prefix) {\\n                    m.remove(p);\\n                    cur = cur.next;\\n                    p += cur.val;\\n                }\\n                m.get(prefix).next = cur.next;\\n            } else {\\n                m.put(prefix, cur);\\n            }\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```cpp\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0), *cur = dummy;\\n        dummy->next = head;\\n        int prefix = 0;\\n        map<int, ListNode*> m;\\n        while (cur) {\\n            prefix += cur->val;\\n            if (m.count(prefix)) {\\n                cur =  m[prefix]->next;\\n                int p = prefix + cur->val;\\n                while (p != prefix) {\\n                    m.erase(p);\\n                    cur = cur->next;\\n                    p += cur->val;\\n                }\\n                m[prefix]->next = cur->next;\\n            } else {\\n                m[prefix] = cur;\\n            }\\n            cur = cur->next;\\n        }\\n        return dummy->next;\\n    }\\n```\n```python\\n    def removeZeroSumSublists(self, head):\\n        cur = dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = collections.OrderedDict()\\n        while cur:\\n            prefix += cur.val\\n            node = seen.get(prefix, cur)\\n            while prefix in seen:\\n                seen.popitem()\\n            seen[prefix] = node\\n            node.next = cur = cur.next\\n        return dummy.next\\n```\n```java\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int prefix = 0;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> seen = new HashMap<>();\\n        seen.put(0, dummy);\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefix += i.val;\\n            seen.put(prefix, i);\\n        }\\n        prefix = 0;\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefix += i.val;\\n            i.next = seen.get(prefix).next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        int prefix = 0;\\n        unordered_map<int, ListNode*> seen;\\n        for (ListNode* i = dummy; i; i = i->next) {\\n            seen[prefix += i->val] = i;\\n        }\\n        prefix = 0;\\n        for (ListNode* i = dummy; i; i = i->next) {\\n            i->next = seen[prefix += i->val]->next;\\n        }\\n        return dummy->next;\\n    }\\n```\n```py\\n    def removeZeroSumSublists(self, head):\\n        prefix = 0\\n        seen = {}\\n        seen[0] = dummy = ListNode(0)\\n        dummy.next = head\\n        while head:\\n            prefix += head.val\\n            seen[prefix] = head\\n            head = head.next\\n        head = dummy\\n        prefix = 0\\n        while head:\\n            prefix += head.val\\n            head.next = seen[prefix].next\\n            head = head.next\\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 366350,
                "title": "c-o-n-explained-with-pictures",
                "content": "**Intuition and Algorithm**\\nImagine that you have this Linked list:\\nhead:      [3,4,2,-6, 1,1,5, -6] \\n\\n**What elements should I remove?**\\nWe will accumulate the values.\\nhead\\u2019 :   [3, 7,9,3,4,5,10,4]\\n(Like an array), head\\'[i] = head[i] + head\\' [i-1]\\nIf we see repeated elements then we have to deleted as follows.\\n\\n![image](https://assets.leetcode.com/users/hamlet_fiis/image_1566705933.png)\\n\\nAfter delete:\\n\\n![image](https://assets.leetcode.com/users/hamlet_fiis/image_1566705946.png)\\n\\n**Answer:**\\nhead: [3,1]\\n\\n**Algorithm**\\n* Iterate LinkedList from left to right\\n* Process each accumulative value in this datastructure. (unordered_map<int,ListNode*>um) um[ac] = currentNode;\\n* Given a current accumulative value check if exists in our map (get previous element).\\n* If they exist  um[ac]->next = currentNode->next, then delete intermediate nodes in our map between  um[ac] and currentNode\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* root =new ListNode(0);\\n        root->next=head;\\n        unordered_map<int,ListNode*>um;\\n        um[0]=root;\\n        int ac=0;\\n        \\n        while(head!=NULL){\\n            ac+=head->val;\\n            \\n            //found value\\n            if(um.find(ac)!=um.end()){\\n                ListNode* prev= um[ac];\\n                ListNode* start= prev;\\n                \\n                //delete bad references\\n                int aux = ac;\\n                while(prev!=head){\\n                    prev=prev->next;\\n                    aux+=prev->val;\\n                    if(prev!=head)um.erase(aux);\\n                }\\n                \\n                start->next = head->next;\\n            }else{\\n                um[ac]= head;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return root->next;\\n    }\\n};\\n```\\n\\n<b>Complexity Analysis </b>\\n* Time Complexity: O(n) where n is the length of head\\n* Space Complexity: O(n) where n is the length of head",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* root =new ListNode(0);\\n        root->next=head;\\n        unordered_map<int,ListNode*>um;\\n        um[0]=root;\\n        int ac=0;\\n        \\n        while(head!=NULL){\\n            ac+=head->val;\\n            \\n            //found value\\n            if(um.find(ac)!=um.end()){\\n                ListNode* prev= um[ac];\\n                ListNode* start= prev;\\n                \\n                //delete bad references\\n                int aux = ac;\\n                while(prev!=head){\\n                    prev=prev->next;\\n                    aux+=prev->val;\\n                    if(prev!=head)um.erase(aux);\\n                }\\n                \\n                start->next = head->next;\\n            }else{\\n                um[ac]= head;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return root->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 413134,
                "title": "java-o-n-with-detail-explanation",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        // The observation here is that the sum from index 0 to index M will be \\n        // equal to sum from index 0 to index N if sum from index (M+1) to index N is 0.\\n        // Thus, here we track the sum from index 0 to each index, using a Map to indicate\\n        // the farthest index N that we can remove from index M, then we shall be able to\\n        // remove M+1 -> N and continue from N+1. This works since we don\\'t have to optimize\\n        // for the number of sequences to be removed\\n        \\n        // Map from sum from index 0 to the farthest value that the sum stays unchanged.\\n        Map<Integer, ListNode> sumToFarthestNodeMap = new HashMap<>();\\n        \\n        // Need the dummy node to track the new head if changed.\\n        ListNode preHead = new ListNode(0);\\n        preHead.next = head;\\n        \\n        // First iteration to compute the map.\\n        int sum = 0;\\n        for (ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            sumToFarthestNodeMap.put(sum, p);\\n        }\\n        \\n        // Second iteration to re-connect the nodes to the farthest node where the sum stays unchanged\\n        sum = 0;\\n        for (ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            p.next = sumToFarthestNodeMap.get(sum).next;\\n        }\\n        \\n        // Done, return the head from preHead\\n        return preHead.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        // The observation here is that the sum from index 0 to index M will be \\n        // equal to sum from index 0 to index N if sum from index (M+1) to index N is 0.\\n        // Thus, here we track the sum from index 0 to each index, using a Map to indicate\\n        // the farthest index N that we can remove from index M, then we shall be able to\\n        // remove M+1 -> N and continue from N+1. This works since we don\\'t have to optimize\\n        // for the number of sequences to be removed\\n        \\n        // Map from sum from index 0 to the farthest value that the sum stays unchanged.\\n        Map<Integer, ListNode> sumToFarthestNodeMap = new HashMap<>();\\n        \\n        // Need the dummy node to track the new head if changed.\\n        ListNode preHead = new ListNode(0);\\n        preHead.next = head;\\n        \\n        // First iteration to compute the map.\\n        int sum = 0;\\n        for (ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            sumToFarthestNodeMap.put(sum, p);\\n        }\\n        \\n        // Second iteration to re-connect the nodes to the farthest node where the sum stays unchanged\\n        sum = 0;\\n        for (ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            p.next = sumToFarthestNodeMap.get(sum).next;\\n        }\\n        \\n        // Done, return the head from preHead\\n        return preHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 414285,
                "title": "python-easy-to-understand-solution-with-explanations",
                "content": "```python\\ndef removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        # can be solved by finding prefix sum;\\n        # if l1+l2 = l1+l2+...+l5, meaning that l3 + ... + l5 = 0, \\n\\t\\t# then l3 + ... + l5 is the consecutive sequence of nodes we want to delete. \\n\\t\\t# If it\\'s a array we could just remove numbers from index of l3 to l5. \\n\\t\\t# If it\\'s a linked list, we could let l2.next = l5.next, we then need to have two pointers,\\n\\t\\t# one point to l2 and the other point to l5;\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        d = {0:dummy} # key is the prefix sum, value is the last node of getting this sum value, which is l5\\n        while head:\\n            prefix += head.val\\n            d[prefix] = head\\n            head = head.next\\n\\t\\t# Go from the dummy node again to set the next node to be the last node for a prefix sum \\n        head = dummy\\n        prefix = 0\\n        while head:\\n            prefix += head.val\\n            head.next = d[prefix].next\\n            head = head.next\\n        \\n        return dummy.next\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\ndef removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        # can be solved by finding prefix sum;\\n        # if l1+l2 = l1+l2+...+l5, meaning that l3 + ... + l5 = 0, \\n\\t\\t# then l3 + ... + l5 is the consecutive sequence of nodes we want to delete. \\n\\t\\t# If it\\'s a array we could just remove numbers from index of l3 to l5. \\n\\t\\t# If it\\'s a linked list, we could let l2.next = l5.next, we then need to have two pointers,\\n\\t\\t# one point to l2 and the other point to l5;\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        d = {0:dummy} # key is the prefix sum, value is the last node of getting this sum value, which is l5\\n        while head:\\n            prefix += head.val\\n            d[prefix] = head\\n            head = head.next\\n\\t\\t# Go from the dummy node again to set the next node to be the last node for a prefix sum \\n        head = dummy\\n        prefix = 0\\n        while head:\\n            prefix += head.val\\n            head.next = d[prefix].next\\n            head = head.next\\n        \\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 507108,
                "title": "java-simple-o-n-solution-with-explanation",
                "content": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        /*\\n        Approach: The idea is, if we calculate sum of values from start and if A and B nodes are having few zero sum nodes\\n                  between them, they will have the same sum. Eg: In [2,4,2,-6,7], node 2 and node -6 both are having sum as\\n                  2, so we can connect node 2 to node 7, essentially removing zero-sum nodes [4,2,-6] from the list.\\n                  Have a HashMap (sumNodeMap) of node and sum till that node (sum --> node).\\n                  Need to have a dummy head node, to handle in case the head should be deleted as it is zero sum,\\n                  eg in [1,-1,4,3].\\n                  Traverse the Linked List. In each node, calculate the sum. If the sum exists in sumNodeMap, that means\\n                  the nodes between when we found the same sum and current node are zero sum. So get that old node and point\\n                  to next node of current node (essentially remving in-between zero-sum nodes). Also, remove those in-between\\n                  nodes from sumNodeMap, to make sure that we don\\'t use the old removed node again in future. Note that\\n                  this removing process can run for max n (number of nodes) times in total. Thus doesn\\'t affect the\\n                  O(n) time complexity of the whole program.\\n                  \\n        Complexity analysis: Time: O(n), Space: O(n)\\n        */\\n        \\n        HashMap<Integer, ListNode> sumNodeMap = new HashMap<>();\\n        \\n        ListNode dummyPreHead = new ListNode(0);\\n        dummyPreHead.next = head;\\n        \\n        sumNodeMap.put(0, dummyPreHead);                                    //Init the stack with prehead.\\n        \\n        ListNode currNode = head;\\n\\n        int sum = 0;\\n        \\n        while(currNode!=null){\\n            \\n            sum += currNode.val;\\n            \\n            if(sumNodeMap.containsKey(sum)){\\n                \\n                ListNode oldNodeWithSameSum = sumNodeMap.get(sum);          //Old node with same sum\\n                \\n                ListNode toBeRemovedNode = oldNodeWithSameSum.next;         //Remove zero-sum in-between nodes from sumNodeMap\\n                int toBeRemovedSum = sum;\\n                while(toBeRemovedNode != currNode){\\n                    toBeRemovedSum = toBeRemovedSum + toBeRemovedNode.val;\\n                    sumNodeMap.remove(toBeRemovedSum);\\n                    toBeRemovedNode = toBeRemovedNode.next;\\n                }\\n                oldNodeWithSameSum.next = currNode.next;                    //Point old node to current next node\\n            }\\n            else{\\n                sumNodeMap.put(sum, currNode);\\n            }\\n            \\n            currNode = currNode.next;\\n        }\\n        \\n        return dummyPreHead.next;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        /*\\n        Approach: The idea is, if we calculate sum of values from start and if A and B nodes are having few zero sum nodes\\n                  between them, they will have the same sum. Eg: In [2,4,2,-6,7], node 2 and node -6 both are having sum as\\n                  2, so we can connect node 2 to node 7, essentially removing zero-sum nodes [4,2,-6] from the list.\\n                  Have a HashMap (sumNodeMap) of node and sum till that node (sum --> node).\\n                  Need to have a dummy head node, to handle in case the head should be deleted as it is zero sum,\\n                  eg in [1,-1,4,3].\\n                  Traverse the Linked List. In each node, calculate the sum. If the sum exists in sumNodeMap, that means\\n                  the nodes between when we found the same sum and current node are zero sum. So get that old node and point\\n                  to next node of current node (essentially remving in-between zero-sum nodes). Also, remove those in-between\\n                  nodes from sumNodeMap, to make sure that we don\\'t use the old removed node again in future. Note that\\n                  this removing process can run for max n (number of nodes) times in total. Thus doesn\\'t affect the\\n                  O(n) time complexity of the whole program.\\n                  \\n        Complexity analysis: Time: O(n), Space: O(n)\\n        */\\n        \\n        HashMap<Integer, ListNode> sumNodeMap = new HashMap<>();\\n        \\n        ListNode dummyPreHead = new ListNode(0);\\n        dummyPreHead.next = head;\\n        \\n        sumNodeMap.put(0, dummyPreHead);                                    //Init the stack with prehead.\\n        \\n        ListNode currNode = head;\\n\\n        int sum = 0;\\n        \\n        while(currNode!=null){\\n            \\n            sum += currNode.val;\\n            \\n            if(sumNodeMap.containsKey(sum)){\\n                \\n                ListNode oldNodeWithSameSum = sumNodeMap.get(sum);          //Old node with same sum\\n                \\n                ListNode toBeRemovedNode = oldNodeWithSameSum.next;         //Remove zero-sum in-between nodes from sumNodeMap\\n                int toBeRemovedSum = sum;\\n                while(toBeRemovedNode != currNode){\\n                    toBeRemovedSum = toBeRemovedSum + toBeRemovedNode.val;\\n                    sumNodeMap.remove(toBeRemovedSum);\\n                    toBeRemovedNode = toBeRemovedNode.next;\\n                }\\n                oldNodeWithSameSum.next = currNode.next;                    //Point old node to current next node\\n            }\\n            else{\\n                sumNodeMap.put(sum, currNode);\\n            }\\n            \\n            currNode = currNode.next;\\n        }\\n        \\n        return dummyPreHead.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366337,
                "title": "java-iterative-recursive-solution",
                "content": "**Method 1: Iterative:**\\n1. Use a hashmap to keep track the prefix sum.\\n2. If current sum is zero, it means the sum from first node to current node is zero. So the new head is the next node.\\n3. If the current sum already exists the hashmap (say node-```i```), it means the sum from node-```(i+1)``` to current node is zero. So, we remove those nodes.\\n    For example,\\n```\\ninput = [1,2,3,-3,1]\\ni = 0, prefixSum = 1\\ni = 1, prefixSum = 3\\ni = 2, prefixSum = 6\\ni = 3, prefixSum = 3  // prefixsum = 3 is already in the hashmap. It means the sum of subarray [2,3] is zero.\\ni = 4, prefixSum = 4\\n```\\n4. Use a dummy head to simplify code.\\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        dummy.next = head;\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        while(cur != null) {\\n            sum += cur.val;\\n            if(map.containsKey(sum)) {\\n                cur = map.get(sum).next;\\n                int key = sum + cur.val;\\n                while(key != sum) {\\n                    map.remove(key);\\n                    cur = cur.next;\\n                    key += cur.val;\\n                }\\n                map.get(sum).next = cur.next;\\n            }\\n            else {\\n                map.put(sum, cur);   \\n            }\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\\nTime: O(N)\\nSpace: O(N)\\n\\n**Method 2: Recursive:**\\n\\n1. Remove all the nodes have zero sum starting from head.\\n2. Make sure the next node already has a non-zero-sum linked list. \\n    ```head.next = removeZeroSumSublists(head.next);```\\n3. Use a dummy head to simplify code.\\n\\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode cur = head;\\n        int sum = 0;\\n        while(cur != null) {\\n            if(cur.val + sum == 0) dummy.next = cur.next;\\n            sum += cur.val;\\n            cur = cur.next;\\n        }\\n        if(dummy.next != null) dummy.next.next = removeZeroSumSublists(dummy.next.next);   \\n        return dummy.next;\\n    }\\n}\\n```\\nTime: O(N^2)\\nSpace: O(N)",
                "solutionTags": [],
                "code": "```i```\n```(i+1)```\n```\\ninput = [1,2,3,-3,1]\\ni = 0, prefixSum = 1\\ni = 1, prefixSum = 3\\ni = 2, prefixSum = 6\\ni = 3, prefixSum = 3  // prefixsum = 3 is already in the hashmap. It means the sum of subarray [2,3] is zero.\\ni = 4, prefixSum = 4\\n```\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0), cur = dummy;\\n        dummy.next = head;\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        while(cur != null) {\\n            sum += cur.val;\\n            if(map.containsKey(sum)) {\\n                cur = map.get(sum).next;\\n                int key = sum + cur.val;\\n                while(key != sum) {\\n                    map.remove(key);\\n                    cur = cur.next;\\n                    key += cur.val;\\n                }\\n                map.get(sum).next = cur.next;\\n            }\\n            else {\\n                map.put(sum, cur);   \\n            }\\n            cur = cur.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```\n```head.next = removeZeroSumSublists(head.next);```\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode cur = head;\\n        int sum = 0;\\n        while(cur != null) {\\n            if(cur.val + sum == 0) dummy.next = cur.next;\\n            sum += cur.val;\\n            cur = cur.next;\\n        }\\n        if(dummy.next != null) dummy.next.next = removeZeroSumSublists(dummy.next.next);   \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366382,
                "title": "intuitive-java-solution-with-explanation",
                "content": "**Idea**\\nSimilar to finding subarray sum = 0. `sums` keep track of prefix sums seen so far. If we find the current sum `sum` in the prefix sums map, then we found a subarray sum = 0 from the matching entry till the current element. So remove that portion and move on exporing other nodes.\\n\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        Map<Integer, ListNode> sums = new HashMap<>();\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            sum += curr.val;\\n            if(sum == 0)\\n                head = curr.next;\\n            if(sums.containsKey(sum)){\\n                int tmp = sum;\\n                ListNode n = sums.get(sum).next;\\n                while(n != curr){\\n                    tmp += n.val;\\n                    sums.remove(tmp);\\n                    n = n.next;\\n                }\\n                sums.get(sum).next = curr.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            sums.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n```\\n**Update-1 (8/25)** Fixed the below bug. But I think which solution is efficient depends on the length of the chain which is being removed (subarray sum=0 portion) or the chain that is kept (from `head` upto the start of the removing portion).\\n\\n**Update-0 (8/24)** The above solution has a bug for cases such as `[3,4,2,-6,1,5,-2,2]`\\nMy original solution is below which goes back to `head` and repeat the process.\\n\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        Map<Integer, ListNode> sums = new HashMap<>();\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            sum += curr.val;\\n            if(sum == 0)\\n                head = curr.next;\\n            if(sums.containsKey(sum)){\\n                sums.get(sum).next = curr.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            sums.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        Map<Integer, ListNode> sums = new HashMap<>();\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            sum += curr.val;\\n            if(sum == 0)\\n                head = curr.next;\\n            if(sums.containsKey(sum)){\\n                int tmp = sum;\\n                ListNode n = sums.get(sum).next;\\n                while(n != curr){\\n                    tmp += n.val;\\n                    sums.remove(tmp);\\n                    n = n.next;\\n                }\\n                sums.get(sum).next = curr.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            sums.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n```\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        Map<Integer, ListNode> sums = new HashMap<>();\\n        int sum = 0;\\n        ListNode curr = head;\\n        while(curr != null){\\n            sum += curr.val;\\n            if(sum == 0)\\n                head = curr.next;\\n            if(sums.containsKey(sum)){\\n                sums.get(sum).next = curr.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            sums.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1701518,
                "title": "easiest-approach-clean-concise-well-explained",
                "content": "## IDEA :\\n*If we see with little focus we will come to know that we are removing the nodes with sum value 0.*\\nBut here the question is how we will come to know that sum of  subset nodes is 0. For this we can use **prefix sum**. If we are having sum which has already appeared once before it means that we are having sum of nodes between them = 0.\\n\\n**Algorithm :**\\n* Firstly make a dummy Node of value 0 to connect in front of the LinkedList.\\n* Using `pre` we will store node with sum value upto that node.\\n\\n* After storing we will again go through full linked list and if we get sum which already has stored in `dic` then we will move next pointer to that `dic` node\\'s next node.\\n\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tdummy = ListNode(0,head)\\n\\t\\t\\tpre = 0\\n\\t\\t\\tdic = {0: dummy}\\n\\n\\t\\t\\twhile head:\\n\\t\\t\\t\\tpre+=head.val\\n\\t\\t\\t\\tdic[pre] = head\\n\\t\\t\\t\\thead = head.next\\n\\n\\t\\t\\thead = dummy\\n\\t\\t\\tpre = 0\\n\\t\\t\\twhile head:\\n\\t\\t\\t\\tpre+=head.val\\n\\t\\t\\t\\thead.next = dic[pre].next\\n\\t\\t\\t\\thead = head.next\\n\\n\\t\\t\\treturn dummy.next\\n\\t\\n**Feel free to ask if you have any doubt or want example as Explaination.** \\uD83E\\uDD17\\n### Thanks and Upvote If you got any help or like the Idea !!\\uD83E\\uDD1E",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\t\\tdef removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n\\n\\t\\t\\tdummy = ListNode(0,head)\\n\\t\\t\\tpre = 0\\n\\t\\t\\tdic = {0: dummy}",
                "codeTag": "Java"
            },
            {
                "id": 477112,
                "title": "very-easy-java-solution-with-explanation",
                "content": "This problem can easily be solved with **pointer to the last sum and Greedy approach.**\\nIt is very similar to this problem: https://leetcode.com/problems/contiguous-array/\\n\\nThe point is - any number of items , whose sum is 0 , will have the same sum with previous items and these items. \\nExample explains everything:\\n[3 ,5, 7, -3,-2,-2, 6]\\n\\nWe can deduct that 7,-3,-2,-2 gives us 0.  So the sum of all previous numbers should be equal to all previous + these numbers which give us 0.\\nLet\\'s calculate sum of all elements\\narr  = [3, 5,  7,  -3, -2, -2,  6]\\ncnt = [3, **8**,15, 12,10,  **8**, 14]\\nAs we can see , we have 2 **8** sums. So we\\'re sure that items between 8\\'s are giving 0. \\n\\nBut what if we find another 8 later? The same thing  - the sum between the first 8 and the last will be equal to 0, so all of these items can be removed. \\n\\narr  = [3, 5,  7,  -3, -2, -2,  6,  -6]\\ncnt = [3, **8**,15, 12,10,  **8**, 14, **8**]\\nAll of these items from first till last together will give the sum of 0.\\n\\nAs the result, we need to know where the last 8 (or any other number) is located. \\nTo keep track of the latest item with any sum , we\\'ll use ```HashMap```.\\nBy going through an array, the latest sum will just override previous item. \\n```\\n    HashMap<Integer, ListNode> map = new HashMap(); \\n\\tint sum = 0;\\n\\t\\n\\tfor(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n\\t\\tsum+= pointer.val;\\n\\t\\tmap.put(sum, pointer);\\n\\t}\\n```\\n\\n!! If we see 0 as the sum, we need to delete all items between this last 0 , and first one. The point is that the place where we saw 0 first time was before any sum operations, which means that we have to delete all items before this item. \\nIn our case - just set ```head``` to item with 0 sum. \\n\\nAfter that, we iterate through the same nodes again, but this time we\\'ll be looking for the same sums in the hashmap, and rellocating our pointer there. \\nIf we find 0 sum, we\\'ll rellocate the head to this item as well ( because everything before will give us 0)\\n\\n**Try to play with this solution on paper and try to create your own algorithm similar to this - this is how you learn things! Just reading and copy-pasting will not be enough!**\\n\\nHere\\'s the full solution:\\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap();\\n        \\n        int sum = 0;\\n        for(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n            sum+= pointer.val;\\n            map.put(sum, pointer);\\n        }\\n        \\n        sum = 0;\\n        for(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n            sum+= pointer.val;\\n            ListNode node = map.get(sum);\\n            if(sum == 0) head = node.next;\\n            if(node != pointer) pointer.next = node.next ;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```HashMap```\n```\\n    HashMap<Integer, ListNode> map = new HashMap(); \\n\\tint sum = 0;\\n\\t\\n\\tfor(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n\\t\\tsum+= pointer.val;\\n\\t\\tmap.put(sum, pointer);\\n\\t}\\n```\n```head```\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap();\\n        \\n        int sum = 0;\\n        for(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n            sum+= pointer.val;\\n            map.put(sum, pointer);\\n        }\\n        \\n        sum = 0;\\n        for(ListNode pointer = head; pointer != null;  pointer = pointer.next){\\n            sum+= pointer.val;\\n            ListNode node = map.get(sum);\\n            if(sum == 0) head = node.next;\\n            if(node != pointer) pointer.next = node.next ;\\n        }\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367021,
                "title": "python-beats-100-tc-sc-without-a-dummy-node",
                "content": "```\\n\\n\\t    hashMap, runningSum = {}, 0\\n        cur = head \\n        while cur:\\n            runningSum += cur.val\\n            if runningSum == 0:\\n                head = cur.next\\n            else:\\n                if runningSum not in hashMap:\\n                    hashMap[runningSum] = cur \\n                else:\\n                    hashMap[runningSum].next = cur.next\\n            cur = cur.next\\n        return head\\n\\n```\\n\\nLet\\'s go over the explanation:\\n\\n\\t1. Initialize a hashMap to maintain a runningSum \\n\\n\\t2.\\n\\t\\trunningSum = 0\\n\\t\\t[1,2,3,-3,4] <- Example\\n\\n\\t\\trunningSums = [1,3,6,3,7] # we see that 3 has appeared again that means there had been a negtive number which dropped the runninSum \\n\\n\\t\\trunningSums = [1,3,7] # Here we can set the last seen runningSum node.next to cur node.next\\n\\n\\t\\tlastSeen 3.next = currentSeen 3.next\\n\\n\\t3. Corner cases [1,-1]\\n\\t\\tHere just set the head to cur.next as soon as we see a 0\\n",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\n\\n\\t    hashMap, runningSum = {}, 0\\n        cur = head \\n        while cur:\\n            runningSum += cur.val\\n            if runningSum == 0:\\n                head = cur.next\\n            else:\\n                if runningSum not in hashMap:\\n                    hashMap[runningSum] = cur \\n                else:\\n                    hashMap[runningSum].next = cur.next\\n            cur = cur.next\\n        return head\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 366426,
                "title": "clean-n-2-ac-solution",
                "content": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        for(ListNode i = dummy; i != null; i = i.next){\\n            int sum = 0;\\n            for(ListNode j = i.next; j != null ;){\\n                sum += j.val;\\n                if(sum == 0){\\n                    i.next = j.next;\\n                }\\n                j = j.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        for(ListNode i = dummy; i != null; i = i.next){\\n            int sum = 0;\\n            for(ListNode j = i.next; j != null ;){\\n                sum += j.val;\\n                if(sum == 0){\\n                    i.next = j.next;\\n                }\\n                j = j.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 795180,
                "title": "java-hashmap-prefix-sum",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        Map<Integer,ListNode> m = new HashMap<>();\\n        int prefixsum=0;\\n        ListNode cur = fake;\\n        while(cur!=null)\\n        {\\n            //System.out.println(cur.val);\\n            prefixsum+=cur.val;\\n            if(m.containsKey(prefixsum))\\n            {\\n                m.get(prefixsum).next=cur.next;\\n                m.clear();\\n                prefixsum=0;\\n                cur = fake;\\n            }\\n            else{\\n                m.put(prefixsum,cur);\\n                cur=cur.next;\\n            }\\n        }\\n        return fake.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode fake = new ListNode(0);\\n        fake.next = head;\\n        Map<Integer,ListNode> m = new HashMap<>();\\n        int prefixsum=0;\\n        ListNode cur = fake;\\n        while(cur!=null)\\n        {\\n            //System.out.println(cur.val);\\n            prefixsum+=cur.val;\\n            if(m.containsKey(prefixsum))\\n            {\\n                m.get(prefixsum).next=cur.next;\\n                m.clear();\\n                prefixsum=0;\\n                cur = fake;\\n            }\\n            else{\\n                m.put(prefixsum,cur);\\n                cur=cur.next;\\n            }\\n        }\\n        return fake.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 685304,
                "title": "c-o-n-solution-using-hashing-detailed-explanation",
                "content": "```\\n/*\\n    https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/\\n    \\n    Idea is that whenever consecutive 0-sum zublist appears, the cumulative sum becomes the same as\\n    it was just before the start of that sublist.\\n    We use a hash table to update the latest position of each cumulative sum.\\n    Then we again start the traversal computing cumulative sum and checking what is the\\n    latest position where it occurs and delete the sublist in between.\\n*/\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Deletes a linked list\\n    void deleteList(ListNode* head) {\\n        ListNode *nextptr= nullptr;\\n        while(head) {\\n            nextptr = head->next;\\n            //delete head;\\n            head = nextptr;\\n        }\\n    }\\n    \\n    // TC: O(N)\\n    // SC: O(N)\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        // (sum: pos): cumulative sum till a given node\\n        unordered_map<int, ListNode*> sum_pos;\\n        ListNode *start = nullptr, *end = nullptr, \\n                *after_start = nullptr, *after_end = nullptr;\\n        long long sum = 0;\\n        \\n        // dummy head for easier head ops\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        // initial sum 0 for position before head\\n        sum_pos[0] = dummy;\\n        \\n        // Store the cumulative sum till each node,\\n        // for the same cumulative sum we store the latest position\\n        ListNode *curr = head;\\n        while(curr) {\\n            sum += curr->val;\\n            sum_pos[sum] = curr;\\n            curr = curr->next;\\n        }\\n        \\n        // We compute the cumulative sum again, this time\\n        // for each sum we check that farthest position where it is \\n        // found again and delete the list till that position\\n        sum = 0;\\n        curr = dummy;\\n        while(curr) {\\n            sum += curr->val;\\n            // check the position this sum is last seen\\n            ListNode *last_seen_pos = sum_pos[sum];\\n            // delete the sublist to avoid memory leaks\\n            after_start = curr->next;\\n            after_end = last_seen_pos->next;\\n            // when it is not the same node\\n            // and trhere is somethign to delete\\n            if(last_seen_pos != curr) {\\n                last_seen_pos->next = nullptr;\\n                deleteList(after_start);\\n            }\\n            \\n            curr->next = after_end;\\n            curr = curr->next;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\n/*\\n    https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/submissions/\\n    \\n    Idea is that whenever consecutive 0-sum zublist appears, the cumulative sum becomes the same as\\n    it was just before the start of that sublist.\\n    We use a hash table to update the latest position of each cumulative sum.\\n    Then we again start the traversal computing cumulative sum and checking what is the\\n    latest position where it occurs and delete the sublist in between.\\n*/\\n\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    // Deletes a linked list\\n    void deleteList(ListNode* head) {\\n        ListNode *nextptr= nullptr;\\n        while(head) {\\n            nextptr = head->next;\\n            //delete head;\\n            head = nextptr;\\n        }\\n    }\\n    \\n    // TC: O(N)\\n    // SC: O(N)\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        // (sum: pos): cumulative sum till a given node\\n        unordered_map<int, ListNode*> sum_pos;\\n        ListNode *start = nullptr, *end = nullptr, \\n                *after_start = nullptr, *after_end = nullptr;\\n        long long sum = 0;\\n        \\n        // dummy head for easier head ops\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        // initial sum 0 for position before head\\n        sum_pos[0] = dummy;\\n        \\n        // Store the cumulative sum till each node,\\n        // for the same cumulative sum we store the latest position\\n        ListNode *curr = head;\\n        while(curr) {\\n            sum += curr->val;\\n            sum_pos[sum] = curr;\\n            curr = curr->next;\\n        }\\n        \\n        // We compute the cumulative sum again, this time\\n        // for each sum we check that farthest position where it is \\n        // found again and delete the list till that position\\n        sum = 0;\\n        curr = dummy;\\n        while(curr) {\\n            sum += curr->val;\\n            // check the position this sum is last seen\\n            ListNode *last_seen_pos = sum_pos[sum];\\n            // delete the sublist to avoid memory leaks\\n            after_start = curr->next;\\n            after_end = last_seen_pos->next;\\n            // when it is not the same node\\n            // and trhere is somethign to delete\\n            if(last_seen_pos != curr) {\\n                last_seen_pos->next = nullptr;\\n                deleteList(after_start);\\n            }\\n            \\n            curr->next = after_end;\\n            curr = curr->next;\\n        }\\n        \\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902549,
                "title": "c-hashmap-prefixsum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head)\\n    {\\n        ListNode *dummynode=new ListNode(0),*curr=dummynode;\\n        dummynode->next=head;\\n        map<int,ListNode*> mp;\\n        int sum=0;\\n        while(curr)\\n        {\\n            sum+=curr->val;\\n            if(mp.count(sum))\\n            {\\n                curr=mp[sum]->next;\\n                int p=sum+curr->val;\\n                while(p!=sum)\\n                {\\n                    mp.erase(p);\\n                    curr=curr->next;\\n                    p+=curr->val;\\n                }\\n                mp[sum]->next=curr->next;\\n            }\\n            else\\n            {\\n                mp[sum]=curr;\\n            }\\n            curr=curr->next;\\n        }\\n        return dummynode->next;\\n    }\\n};\\n//If you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head)\\n    {\\n        ListNode *dummynode=new ListNode(0),*curr=dummynode;\\n        dummynode->next=head;\\n        map<int,ListNode*> mp;\\n        int sum=0;\\n        while(curr)\\n        {\\n            sum+=curr->val;\\n            if(mp.count(sum))\\n            {\\n                curr=mp[sum]->next;\\n                int p=sum+curr->val;\\n                while(p!=sum)\\n                {\\n                    mp.erase(p);\\n                    curr=curr->next;\\n                    p+=curr->val;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 995902,
                "title": "java-two-pass-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        int prefix = 0;\\n        ListNode curr = dummy;\\n        Map<Integer, ListNode> seen = new HashMap<>();\\n        seen.put(prefix, dummy);\\n        \\n        while (curr != null) {\\n            prefix += curr.val;\\n            seen.put(prefix, curr);\\n            curr = curr.next;\\n        }\\n        \\n        prefix = 0;\\n        curr = dummy;\\n        while (curr != null) {\\n            prefix += curr.val;\\n            curr.next = seen.get(prefix).next;\\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        \\n        int prefix = 0;\\n        ListNode curr = dummy;\\n        Map<Integer, ListNode> seen = new HashMap<>();\\n        seen.put(prefix, dummy);\\n        \\n        while (curr != null) {\\n            prefix += curr.val;\\n            seen.put(prefix, curr);\\n            curr = curr.next;\\n        }\\n        \\n        prefix = 0;\\n        curr = dummy;\\n        while (curr != null) {\\n            prefix += curr.val;\\n            curr.next = seen.get(prefix).next;\\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366510,
                "title": "python-solution-with-dict",
                "content": "```python\\ndef removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n    p = dummy = ListNode(0)\\n    dummy.next = head\\n    s = 0\\n    s_sum = [s]\\n    vals = {}\\n    while p:\\n        s += p.val\\n        s_sum.append(s)\\n        if s not in vals:\\n            vals[s] = p\\n        else:\\n            vals[s].next = p.next\\n            s_sum.pop() # remove cur, keep the last\\n            while s_sum[-1] != s:\\n                vals.pop(s_sum.pop())\\n        p = p.next\\n    return dummy.next\\n```",
                "solutionTags": [],
                "code": "```python\\ndef removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n    p = dummy = ListNode(0)\\n    dummy.next = head\\n    s = 0\\n    s_sum = [s]\\n    vals = {}\\n    while p:\\n        s += p.val\\n        s_sum.append(s)\\n        if s not in vals:\\n            vals[s] = p\\n        else:\\n            vals[s].next = p.next\\n            s_sum.pop() # remove cur, keep the last\\n            while s_sum[-1] != s:\\n                vals.pop(s_sum.pop())\\n        p = p.next\\n    return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2079419,
                "title": "java-two-pass-solution-using-prefix-sum",
                "content": "\\tpublic static ListNode removeZeroSumSublists(ListNode head) {\\n        int prefixSum = 0;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        Map<Integer, ListNode> hashMap = new HashMap<>();\\n        hashMap.put(0, dummy);\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefixSum += i.val;\\n            hashMap.put(prefixSum, i);\\n        }\\n        prefixSum = 0;\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefixSum += i.val;\\n            i.next = hashMap.get(prefixSum).next;\\n        }\\n        return dummy.next;\\n    }",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "\\tpublic static ListNode removeZeroSumSublists(ListNode head) {\\n        int prefixSum = 0;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n\\n        Map<Integer, ListNode> hashMap = new HashMap<>();\\n        hashMap.put(0, dummy);\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefixSum += i.val;\\n            hashMap.put(prefixSum, i);\\n        }\\n        prefixSum = 0;\\n        for (ListNode i = dummy; i != null; i = i.next) {\\n            prefixSum += i.val;\\n            i.next = hashMap.get(prefixSum).next;\\n        }\\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 580406,
                "title": "java-92-78-time-100-00-space",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer,ListNode> map = new HashMap<Integer,ListNode>();\\n        ListNode dummy = new ListNode(0),p;\\n        dummy.next = head;\\n        p = dummy;\\n        int sum = 0;\\n        while(p!=null){\\n            sum+=p.val;\\n            map.put(sum,p);\\n            p = p.next;\\n        }\\n        sum = 0;\\n        p = dummy;\\n        while(p!=null){\\n            sum+=p.val;\\n            if(map.containsKey(sum)){\\n                ListNode tmp = map.get(sum);\\n                if(tmp!=p){\\n                    p.next = tmp.next;\\n                }\\n            }\\n            p = p.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer,ListNode> map = new HashMap<Integer,ListNode>();\\n        ListNode dummy = new ListNode(0),p;\\n        dummy.next = head;\\n        p = dummy;\\n        int sum = 0;\\n        while(p!=null){\\n            sum+=p.val;\\n            map.put(sum,p);\\n            p = p.next;\\n        }\\n        sum = 0;\\n        p = dummy;\\n        while(p!=null){\\n            sum+=p.val;\\n            if(map.containsKey(sum)){\\n                ListNode tmp = map.get(sum);\\n                if(tmp!=p){\\n                    p.next = tmp.next;\\n                }\\n            }\\n            p = p.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367211,
                "title": "super-simple-python-solution-commented",
                "content": "```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \\n        d = dict()          # dictionary of {cumsum : ListNode}\\n        cumsum = 0          # cumulative sum of visited nodes\\n        walk = head         # walks across Linked List\\n        \\n        while walk is not None:\\n            cumsum += walk.val\\n\\n            if cumsum == 0:\\n                # Delete all nodes before and including the\\n                # node marked with cumsum = 0\\n                walk = walk.next\\n                while head != walk:\\n                    delNode = head\\n                    head = head.next\\n                    del delNode\\n                # reset zero sum indicators and ListNode walker\\n                d = dict()\\n                walk = head\\n                cumsum = 0\\n                \\n            elif cumsum in d:\\n                # Delete all nodes after and including the\\n                # node marked with the same cumsum already\\n                # in the dictionary (they sum up to 0)\\n                ptr = d[cumsum]\\n                walk = walk.next\\n                while ptr.next != walk:\\n                    delNode = ptr.next\\n                    ptr.next = delNode.next\\n                    del delNode\\n                # reset zero sum indicators and ListNode walker\\n                d = dict()\\n                walk = head\\n                cumsum = 0\\n                \\n            else:\\n                # add cumsum and current node to dictionary\\n                d[cumsum] = walk\\n                walk = walk.next\\n                \\n        return head\\n```",
                "solutionTags": [
                    "Python",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \\n        d = dict()          # dictionary of {cumsum : ListNode}\\n        cumsum = 0          # cumulative sum of visited nodes\\n        walk = head         # walks across Linked List\\n        \\n        while walk is not None:\\n            cumsum += walk.val\\n\\n            if cumsum == 0:\\n                # Delete all nodes before and including the\\n                # node marked with cumsum = 0\\n                walk = walk.next\\n                while head != walk:\\n                    delNode = head\\n                    head = head.next\\n                    del delNode\\n                # reset zero sum indicators and ListNode walker\\n                d = dict()\\n                walk = head\\n                cumsum = 0\\n                \\n            elif cumsum in d:\\n                # Delete all nodes after and including the\\n                # node marked with the same cumsum already\\n                # in the dictionary (they sum up to 0)\\n                ptr = d[cumsum]\\n                walk = walk.next\\n                while ptr.next != walk:\\n                    delNode = ptr.next\\n                    ptr.next = delNode.next\\n                    del delNode\\n                # reset zero sum indicators and ListNode walker\\n                d = dict()\\n                walk = head\\n                cumsum = 0\\n                \\n            else:\\n                # add cumsum and current node to dictionary\\n                d[cumsum] = walk\\n                walk = walk.next\\n                \\n        return head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290238,
                "title": "easy-and-simple-detailed-c-solution-using-vector-and-sliding-window-approach",
                "content": "# Intuition\\nAs we can see from the problem statement, we need to check for subsequences in the linked list whose sum is zero, which reminds us of the subarray sum problem. Therefore, it is advisable to use a vector as a supporting data structure, as it is easier to handle and familiar to most of us.\\n\\n# Approach\\n\"Since the problem requires finding sub-sequences with a sum of zero, we will start by using a vector to store the values of the linked list. Then, we will find the indices of the sub-sequences whose sum is zero. To avoid any repetition, we will convert all the values whose sum is zero to zero, so that they don\\'t interfere with the computation of other sub-sequences. Next, we will create a new linked list and add nodes to it from the non-zero values of the vector. Finally, we will end the linked list by setting its last node to point to nullptr. We will return the next of the head of the new linked list as the actual head, as the initial head was created with a dummy value which we don\\'t need\\n\\n# Complexity\\n- Time complexity:\\n**O(N^2)**:- You all will be thinking seeing the loop that is has a time complexity of N^3 but it is not. we are using the same concept of subarray sum to k problem. Hence using sliding window and taking worst time of O(N) for the subarray calculation and N more for the conversion of the all the values to zero.\\noverall complexity. **( O(N+N^2+N)==O(N^2))**\\n\\n- Space complexity:\\n**O(N)**:- As we are using a vector of size the number of nodes are.(Here N is the total number of node in the problem. )\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        vector<int> vec;\\n        ListNode* temp = head;\\n        while (temp) {\\n            vec.push_back(temp->val); // copying the whole linked list to the vector \\n            temp = temp->next;\\n        }\\n        \\n        for (int start = 0; start < vec.size(); start++) {\\n            int sum = 0;\\n            for (int end = start; end < vec.size(); end++) {\\n                sum += vec[end]; // using sliding window to find the subarray with sum as zero\\n                if (sum == 0) {\\n                    for (int i = start; i <= end; i++) {\\n                        vec[i] = 0; // making all the values in the range (start,end) to zero \\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        ListNode alt(0); // dummy node is created so that we can make a linked list with values from the vector\\n        ListNode* a = &alt;\\n        for (int p = 0; p < vec.size(); p++) {\\n            if (vec[p] != 0) { // we take the non-zero values only\\n                a->next = new ListNode(vec[p]);\\n                a = a->next;\\n            }\\n        }\\n        a->next = nullptr;\\n        return alt.next; // as the head has a dummy value and all the required value is in the next of head \\n        // we return the next of the head i.e alt.next\\n    }\\n};\\n```\\n\\n**DO UPVOTE IF THIS WAS HELPFUL, AND FEEDBACK IS ALWAYS WELCOME :)**",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Two Pointers",
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        vector<int> vec;\\n        ListNode* temp = head;\\n        while (temp) {\\n            vec.push_back(temp->val); // copying the whole linked list to the vector \\n            temp = temp->next;\\n        }\\n        \\n        for (int start = 0; start < vec.size(); start++) {\\n            int sum = 0;\\n            for (int end = start; end < vec.size(); end++) {\\n                sum += vec[end]; // using sliding window to find the subarray with sum as zero\\n                if (sum == 0) {\\n                    for (int i = start; i <= end; i++) {\\n                        vec[i] = 0; // making all the values in the range (start,end) to zero \\n                    }\\n                    break;\\n                }\\n            }\\n        }\\n        \\n        ListNode alt(0); // dummy node is created so that we can make a linked list with values from the vector\\n        ListNode* a = &alt;\\n        for (int p = 0; p < vec.size(); p++) {\\n            if (vec[p] != 0) { // we take the non-zero values only\\n                a->next = new ListNode(vec[p]);\\n                a = a->next;\\n            }\\n        }\\n        a->next = nullptr;\\n        return alt.next; // as the head has a dummy value and all the required value is in the next of head \\n        // we return the next of the head i.e alt.next\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1028162,
                "title": "javascript-hashmap-prefix-sum-two-pass-easy-to-read",
                "content": "*Key point*: \\n* When seeing the word **consecutive sequence**, think about using **Prefix Sum** strategy.\\n* The goal is to remove the consequence sequence. We don\\'t really care about the nodes within this sequence.\\n\\n\\n\\n\\n*Algorithm*: \\n\\nStep 1: \\nWe buld the the map to store the accumlative sum with the **last node which holds the same accumlative value**. \\nWe care the last node because **the next of the last node** is where we want to build and connect the output. \\n\\nStep 2: \\nUse the node from our map to build the output.\\n\\n\\n```\\nvar removeZeroSumSublists = function(head) {\\n    if (!head) {\\n        return head;\\n    }\\n    \\n\\t// Initialize\\n    let dummy = new ListNode(0);\\n    dummy.next = head;\\n    \\n    // Step1: build the prefix sum map\\n    let curr = dummy \\n    let prefixSumMap = new Map(); \\n    let runningSum = 0; \\n    \\n    while (curr) {\\n        runningSum += curr.val;\\n        prefixSumMap.set(runningSum, curr);\\n        curr = curr.next;\\n    }\\n    \\n    // Step 2: build the output\\n    curr = dummy;\\n    runningSum = 0;\\n    \\n    while (curr) {\\n        runningSum += curr.val; \\n        curr.next = prefixSumMap.get(runningSum).next;\\n        curr = curr.next; \\n    }\\n    \\n    return dummy.next;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeZeroSumSublists = function(head) {\\n    if (!head) {\\n        return head;\\n    }\\n    \\n\\t// Initialize\\n    let dummy = new ListNode(0);\\n    dummy.next = head;\\n    \\n    // Step1: build the prefix sum map\\n    let curr = dummy \\n    let prefixSumMap = new Map(); \\n    let runningSum = 0; \\n    \\n    while (curr) {\\n        runningSum += curr.val;\\n        prefixSumMap.set(runningSum, curr);\\n        curr = curr.next;\\n    }\\n    \\n    // Step 2: build the output\\n    curr = dummy;\\n    runningSum = 0;\\n    \\n    while (curr) {\\n        runningSum += curr.val; \\n        curr.next = prefixSumMap.get(runningSum).next;\\n        curr = curr.next; \\n    }\\n    \\n    return dummy.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 755278,
                "title": "python-o-n-solution-100-speed",
                "content": "**Python O(n) Solution | 100% Speed**\\n\\nThe Python code below corresponds to a solution with O(n) time/space complexity.  The algorithm is based on the concept of cumulative sums, which works as follows:\\n\\n1. Define an initial cummulative sum \"s=0\", and start travelling across the nodes of the linked list (One-Pass loop). Build a stack \"S\" with each cummulative sum \"seen\", and a companion dictionary \"d\" for faster access to the location of each sum (avoid O(n) searches). To track the nodes of the Linked List chosen, define a second stack \"A\".\\n\\n2. If a cummulative sum appears twice, delete all entries that occurred after the first instance, and also remove them from our dictionary \"d\". For example, if we had [2,4,-4], the cummulative sums are [2,6,2], so deleting all nodes/entries after the first \"2\" is the correct choice.\\n\\n3. Iterate repeating the rules of Step 2 until the end of the linked list.\\n\\n4. Fix the pointers of the stack \"A\", to ensure that A[i].next = A[i+1]. Also, make sure that the last pointer is Null (A[-1].next = None)\\n\\n5. Return the Head of our new Linked List \"A[0]\" (if it exists)\\n\\nI hope the explanation was helpful. I think this is a beautiful problem.\\n\\nCheers,\\n\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head):\\n        #\\n        def yielder(n):\\n            # yielder: Access elements of Linked List (n=head initially)\\n            while n:\\n                yield n\\n                n = n.next\\n        #\\n        # A: nodes found\\n        # S: Running Sum values (always unique, since duplicates triger cleanup)\\n        # d: Companion dictionary for \"S\" (allows quick O(1) access).\\n        #    Entries are d[cumulative_sum] = index \\n        # t: Current Running sum\\n        #\\n        A, S = [], [] \\n        d    = {0:-1} \\n        t    = 0      # s: Current Sum\\n        for n in yielder(head):\\n            t += n.val\\n            if t in d:\\n                # Running Sum seen before, trigger cleanup\\n                for _ in range(d[t]+1,len(A)):\\n                    A.pop()\\n                    d.pop(S.pop())\\n                t = S[-1] if S else 0\\n            else:\\n                # Append new cumulative sum (unseen before)\\n                A.append(n)\\n                S.append(t)\\n                d[t] = len(A) - 1\\n        #\\n        # Fix Linked List Pointers\\n        A.append(None)\\n        for i,x in enumerate(A[:-1]):\\n            x.next = A[i+1]\\n        return A[0]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head):\\n        #\\n        def yielder(n):\\n            # yielder: Access elements of Linked List (n=head initially)\\n            while n:\\n                yield n\\n                n = n.next\\n        #\\n        # A: nodes found\\n        # S: Running Sum values (always unique, since duplicates triger cleanup)\\n        # d: Companion dictionary for \"S\" (allows quick O(1) access).\\n        #    Entries are d[cumulative_sum] = index \\n        # t: Current Running sum\\n        #\\n        A, S = [], [] \\n        d    = {0:-1} \\n        t    = 0      # s: Current Sum\\n        for n in yielder(head):\\n            t += n.val\\n            if t in d:\\n                # Running Sum seen before, trigger cleanup\\n                for _ in range(d[t]+1,len(A)):\\n                    A.pop()\\n                    d.pop(S.pop())\\n                t = S[-1] if S else 0\\n            else:\\n                # Append new cumulative sum (unseen before)\\n                A.append(n)\\n                S.append(t)\\n                d[t] = len(A) - 1\\n        #\\n        # Fix Linked List Pointers\\n        A.append(None)\\n        for i,x in enumerate(A[:-1]):\\n            x.next = A[i+1]\\n        return A[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366326,
                "title": "python-o-n-solution-using-cumulative-sum",
                "content": "```\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        hmap = {0: dummy}\\n\\n        node, cumsum = head, 0\\n        while node:\\n            nex = node.next\\n            cumsum += node.val\\n            if cumsum in hmap:\\n                temp = hmap[cumsum]\\n                delnode = temp.next\\n                temp.next = node.next\\n\\n                tcsum = cumsum\\n                while delnode.next != temp.next:\\n                    tcsum += delnode.val\\n                    del hmap[tcsum]\\n                    delnode = delnode.next\\n            else:\\n                hmap[cumsum] = node\\n            node = nex\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        hmap = {0: dummy}\\n\\n        node, cumsum = head, 0\\n        while node:\\n            nex = node.next\\n            cumsum += node.val\\n            if cumsum in hmap:\\n                temp = hmap[cumsum]\\n                delnode = temp.next\\n                temp.next = node.next\\n\\n                tcsum = cumsum\\n                while delnode.next != temp.next:\\n                    tcsum += delnode.val\\n                    del hmap[tcsum]\\n                    delnode = delnode.next\\n            else:\\n                hmap[cumsum] = node\\n            node = nex\\n        return dummy.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3526168,
                "title": "solution-using-hash-map-o-n-easiest-solution-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBruteForce Approach:\\n1. Traverse through the linked list using two nested loops.\\n2. For each starting node in the outer loop, calculate the sum of consecutive nodes in the inner loop.\\n3. If the sum of consecutive nodes is zero, remove those nodes from the linked list.\\n4. Repeat this process for all possible starting nodes and check all consecutive nodes for zero sum.\\n5. Return the modified linked list after removing all zero-sum consecutive nodes.\\n\\nSummary: In summary, the brute force approach involves iterating through all possible starting nodes and checking all consecutive nodes for zero sum, and removing them from the linked list when a zero sum is found. This approach has a time complexity of O(n^2), where n is the number of nodes in the linked list.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. So We Will be observing the prefix sum of the linked list. Lets Take First Testcase and on the first Node The Prefix Sum Will Be 1 and in the secong node it will be 1 + 2 = 3. and in thrd node it will be 1 + 2 + 3 = 6, and in the next of that node the prefix sum will be 1 + 2 + 3 + (-3) = 3. so we can observe that we again received the number 3 so that means fromn the first accurance of the 3 to the last occurence there are somem node whose sum is \\'0\\'.\\n2. now we will create an Hash Map unordered_map<int, ListNode*> m; and a dummy node with 0 and pointing the dummy->next = head; why we are doing so ? because head node can also be zero so it can be deleted by this approach so we will be hadling this edge case by this;\\n3. so in map we will be doing lik,e thi : m[0] = dummy; because initialy the prefix sum will be 0.\\n4. further we will initalize the variabnle with prefix sum name and now we will start traveresing the lkinked list for the prefix sum calculation.\\n5. what if we not found any dupicate element ? we sill be doing m[prefixsum] = head bcz we ae pointing the particular prefix sum to the corresponding node \\n6. what if we fond the element agaion ? we will be starting foprk the next odf that particular node so let initialize anothe rlist node with the name if start like: ListNode* start = m[prefix_sum];\\n7. then we will stroe the prefix sum in the new variable sum so that it wil be helping further to delete or erase the values.\\n8. further we will be starting form start->next and we wil check till start != NULL && start != head;\\n9. further we will check i\\n                        f(start != head)\\n                        {\\n                            m.erase(sum);\\n                        }\\nthen increranet the m[prefixsum]->next = head->next;\\nand retrun the dummy->next;\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the given code is O(n), where n is the number of nodes in the linked list.\\n\\nThe code iterates through the linked list once, performing constant time operations for each node. Within the while loop, the code checks if the prefix sum exists in the unordered map, which has an average time complexity of O(1) assuming a well-distributed hash function.\\n\\nTherefore, the overall time complexity is dominated by the loop that iterates through the linked list, resulting in O(n) time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the given code is O(n), where n is the number of nodes in the linked list.\\n\\nThe code uses an unordered map to store prefix sums and their corresponding node pointers. In the worst case, all nodes in the linked list could have distinct prefix sums, resulting in O(n) entries in the unordered map.\\n\\nAdditionally, the code creates a dummy node and maintains a reference to it throughout the execution, but the space occupied by the dummy node is constant and does not depend on the input size.\\n\\nHence, the overall space complexity is O(n), considering the space used by the unordered map and the constant space used by the dummy node.\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head == NULL) return 0;\\n        unordered_map<int, ListNode*> m;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        m[0] = dummy;\\n        int prefix_sum = 0;\\n        while(head != NULL)\\n        {\\n            prefix_sum = prefix_sum + head->val; // prefix_sum += head->val;\\n            if(m.find(prefix_sum) != m.end()){\\n                    ListNode* start = m[prefix_sum];\\n                    int sum = prefix_sum;\\n                    while(start != NULL && start != head)\\n                    {\\n                        start = start->next;\\n                        sum+=start->val;\\n                        if(start != head)\\n                        {\\n                            m.erase(sum);\\n                        }\\n                        \\n                    } \\n                    m[prefix_sum]->next = head->next;     \\n            }\\n            else{\\n                m[prefix_sum] = head; // jaha pr jo sum mila us ke head node ko map se maapp krdenge \\n            }\\n            head = head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Hash Function"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head == NULL) return 0;\\n        unordered_map<int, ListNode*> m;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        m[0] = dummy;\\n        int prefix_sum = 0;\\n        while(head != NULL)\\n        {\\n            prefix_sum = prefix_sum + head->val; // prefix_sum += head->val;\\n            if(m.find(prefix_sum) != m.end()){\\n                    ListNode* start = m[prefix_sum];\\n                    int sum = prefix_sum;\\n                    while(start != NULL && start != head)\\n                    {\\n                        start = start->next;\\n                        sum+=start->val;\\n                        if(start != head)\\n                        {\\n                            m.erase(sum);\\n                        }\\n                        \\n                    } \\n                    m[prefix_sum]->next = head->next;     \\n            }\\n            else{\\n                m[prefix_sum] = head; // jaha pr jo sum mila us ke head node ko map se maapp krdenge \\n            }\\n            head = head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2523185,
                "title": "java-solution-using-prefix-sum",
                "content": "We take each node and calculate its prefix sum. Prefix sum means the sum of node\\'s val + previous prefix sum\\n\\nInitially, prefix sum is 0 so as we iterate through our linked list, we keep adding the value to this prefix sum and keep adding the entries in map (unless there already is an entry in the map with same prefix sum).\\n\\ne.g. \\n\\n 1 -> 2 -> -3 -> 3 -> 1\\n \\n Initially, our prefix sum is 0. \\n \\nAnd if you are wondering why we used a dummy node, just think of this simple case when linked list is : 0 -> 0\\nIn this case we want to remove both nodes and return null. So that is why, we want a dummy node that sits before this linked list. In simple words, head node can also be a node with 0 value so that\\'s why we have a dummy node.\\n\\nAnyways, coming to 1 -> 2 -> -3 -> 3 -> 1\\n\\nInitially, our prefixSum is 0 and our map only has one entry which is { prefixSum  = 0 and node = dummy }\\n\\nNow, as start traversing. We get 1. prefixSum becomes 0 + 1 = 1. Since map does not have any entry with prefixSum = 1, we put this new entry in map.\\n\\nMap becomes -  {0 : dummy, 1 : 0th node}\\n\\nNext is 2. prefixSum becomes 1 + 2 => 3 Again, we put it in map.\\n\\nMap becomes -  {0 : dummy, \\n\\t\\t\\t\\t\\t\\t\\t1 : 0th node, \\n\\t\\t\\t\\t\\t\\t\\t2 : 1st node}\\n\\t\\t\\t\\t\\t\\t\\t\\nNext is -3. prefixSum becomes 3 + (-3) which is 0. Now we see that 0 already exists in the map. What does this mean? This means that between dummy node and the 2nd node (including it), the sum is 0 that is why we are again getting the same prefixSum at 2nd node.\\n\\nSo this basically means we have to delete all the nodes between dummy node and the 2nd node(including it). \\n\\nWe also need to make sure that when we delete the nodes, we also clear their references from the map i.e., delete all entries for those nodes.\\n\\nWe can do that using the prefixSum again. Since we want to start deleting from 0th node, we take its value, add to current prefixSum => 1 + 0 = 1, find the entry in map with key = 1 and remove it.\\n\\nAnd finally, as we do in linked list, to delete, all we have to do is dummy.next = 2nd node.next\\n\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        \\n       ListNode dummy = new ListNode(0,head);   \\n        \\n       //Map that has key as the prefix sum and value as the node for that respective prefix sum\\n       Map<Integer, ListNode> map = new HashMap<>();\\n        \\n       int prefixSum = 0;\\n        \\n       //Put the dummy node as the value of key 0\\n       map.put(0, dummy);\\n        \\n       while(head != null){\\n           prefixSum += head.val;\\n           \\n           if(map.containsKey(prefixSum)){\\n               //From the map, remove entries of all nodes that we want to delete\\n\\t\\t\\t   ListNode prev = map.get(prefixSum);\\n               ListNode node = prev.next;\\n               int sum = prefixSum;\\n               \\n               while(node != head){\\n                   sum += node.val;\\n                   map.remove(sum);\\n                   node = node.next;\\n               }\\n               //Delete the nodes\\n               prev.next = head.next;\\n           } else{\\n               //If prefixSum does not already exist in map we can safely put the entry in map.\\n               map.put(prefixSum, head);\\n           }\\n           \\n           head = head.next;\\n       }\\n        \\n        return dummy.next;\\n       \\n     }\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Prefix Sum"
                ],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        \\n       ListNode dummy = new ListNode(0,head);   \\n        \\n       //Map that has key as the prefix sum and value as the node for that respective prefix sum\\n       Map<Integer, ListNode> map = new HashMap<>();\\n        \\n       int prefixSum = 0;\\n        \\n       //Put the dummy node as the value of key 0\\n       map.put(0, dummy);\\n        \\n       while(head != null){\\n           prefixSum += head.val;\\n           \\n           if(map.containsKey(prefixSum)){\\n               //From the map, remove entries of all nodes that we want to delete\\n\\t\\t\\t   ListNode prev = map.get(prefixSum);\\n               ListNode node = prev.next;\\n               int sum = prefixSum;\\n               \\n               while(node != head){\\n                   sum += node.val;\\n                   map.remove(sum);\\n                   node = node.next;\\n               }\\n               //Delete the nodes\\n               prev.next = head.next;\\n           } else{\\n               //If prefixSum does not already exist in map we can safely put the entry in map.\\n               map.put(prefixSum, head);\\n           }\\n           \\n           head = head.next;\\n       }\\n        \\n        return dummy.next;\\n       \\n     }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1613971,
                "title": "python3-easy-and-clean",
                "content": "```\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(0, head)\\n        \\n        seen = {0: fake}        \\n        prev = 0\\n        \\n        while head:\\n            prev += head.val            \\n            seen[prev] = head\\n            \\n            head = head.next\\n            \\n        head = fake\\n        prev = 0\\n        \\n        while head:\\n            prev += head.val\\n            head.next = seen[prev].next\\n            \\n            head = head.next\\n            \\n        return fake.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(0, head)\\n        \\n        seen = {0: fake}        \\n        prev = 0\\n        \\n        while head:\\n            prev += head.val            \\n            seen[prev] = head\\n            \\n            head = head.next\\n            \\n        head = fake\\n        prev = 0\\n        \\n        while head:\\n            prev += head.val\\n            head.next = seen[prev].next\\n            \\n            head = head.next\\n            \\n        return fake.next\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1501120,
                "title": "python3-o-n-time-solution-with-hashmap",
                "content": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(0, head)\\n        \\n        d = {0: fake}\\n        \\n        prefix_sum = 0\\n        while head:\\n            prefix_sum += head.val\\n            d[prefix_sum] = head\\n            head = head.next\\n            \\n        head = fake\\n        prefix_sum = 0\\n        while head:\\n            prefix_sum += head.val\\n            head.next = d[prefix_sum].next\\n            head = head.next\\n            \\n        return fake.next\\n```",
                "solutionTags": [
                    "Python3",
                    "Linked List"
                ],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        fake = ListNode(0, head)\\n        \\n        d = {0: fake}\\n        \\n        prefix_sum = 0\\n        while head:\\n            prefix_sum += head.val\\n            d[prefix_sum] = head\\n            head = head.next\\n            \\n        head = fake\\n        prefix_sum = 0\\n        while head:\\n            prefix_sum += head.val\\n            head.next = d[prefix_sum].next\\n            head = head.next\\n            \\n        return fake.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1976072,
                "title": "java-explanation-using-hashmap",
                "content": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return null;\\n        HashMap < Integer , ListNode> hm = new HashMap<>();\\n        //we make a hashmap so that further we can manipulate sum and nodes.\\n        ListNode dummy = new ListNode(0), curr = head;\\n        hm.put(0 , dummy); //initiating dummy node with 0 not -1 because -1 will hinder the sum value and 0 do not\\n        dummy.next = head;\\n        int sum = 0;\\n        \\n        while(curr != null ){\\n            sum += curr.val;\\n            \\n            // if hashmap contains the sum then it means that the nodes in between the last same sum value and current values may have cancelled each other thus the sum is same again and we need to remove those nodes.\\n            if(hm.containsKey(sum)){\\n                int currSum = sum;\\n                ListNode toRemove = hm.get(sum).next;\\n                while(toRemove != curr){\\n                    \\n                    currSum += toRemove.val;\\n                    hm.remove(currSum);\\n                    toRemove = toRemove.next;\\n                }\\n                hm.get(sum).next = curr.next;\\n            }else{ \\n                // if the hashmap don\\'t contains the same sum value that means the nodes.val do not cancel each other\\n                hm.put(sum , curr);\\n            }\\n            curr = curr.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/1b861087-57c2-4514-b6ac-10f7efc91aa8_1650739122.338251.jpeg)\\n\\n<H3> If the solutions helps please upvote :)",
                "solutionTags": [],
                "code": "```\\n\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return null;\\n        HashMap < Integer , ListNode> hm = new HashMap<>();\\n        //we make a hashmap so that further we can manipulate sum and nodes.\\n        ListNode dummy = new ListNode(0), curr = head;\\n        hm.put(0 , dummy); //initiating dummy node with 0 not -1 because -1 will hinder the sum value and 0 do not\\n        dummy.next = head;\\n        int sum = 0;\\n        \\n        while(curr != null ){\\n            sum += curr.val;\\n            \\n            // if hashmap contains the sum then it means that the nodes in between the last same sum value and current values may have cancelled each other thus the sum is same again and we need to remove those nodes.\\n            if(hm.containsKey(sum)){\\n                int currSum = sum;\\n                ListNode toRemove = hm.get(sum).next;\\n                while(toRemove != curr){\\n                    \\n                    currSum += toRemove.val;\\n                    hm.remove(currSum);\\n                    toRemove = toRemove.next;\\n                }\\n                hm.get(sum).next = curr.next;\\n            }else{ \\n                // if the hashmap don\\'t contains the same sum value that means the nodes.val do not cancel each other\\n                hm.put(sum , curr);\\n            }\\n            curr = curr.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665583,
                "title": "c-o-n-using-hashing-with-help-of-unordered-map",
                "content": "**// Upvote if you like it !\\n// Time Complexity   : O(n)\\n// Space Complexity : O(n)**\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n      dummy->next = head;\\n      unordered_map <int, ListNode*> m;\\n      m[0] = dummy;\\n      int sum = 0;\\n      while(head){\\n         sum += head->val;\\n         m[sum] = head;\\n         head = head->next;\\n      }\\n      head = dummy;\\n      sum = 0;\\n      while(head){\\n         sum += head->val;\\n         ListNode* temp = m[sum];\\n         if(temp != head){\\n            head->next = temp->next;\\n         }\\n         head = head->next;\\n      }\\n      return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n    ListNode* dummy = new ListNode(0);\\n      dummy->next = head;\\n      unordered_map <int, ListNode*> m;\\n      m[0] = dummy;\\n      int sum = 0;\\n      while(head){\\n         sum += head->val;\\n         m[sum] = head;\\n         head = head->next;\\n      }\\n      head = dummy;\\n      sum = 0;\\n      while(head){\\n         sum += head->val;\\n         ListNode* temp = m[sum];\\n         if(temp != head){\\n            head->next = temp->next;\\n         }\\n         head = head->next;\\n      }\\n      return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 921144,
                "title": "most-concise-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        int sum = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            sum += cur.val;\\n            cur = cur.next;\\n            if (sum == 0) return removeZeroSumSublists(cur);\\n        }\\n        return new ListNode(head.val, removeZeroSumSublists(head.next));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        int sum = 0;\\n        ListNode cur = head;\\n        while (cur != null) {\\n            sum += cur.val;\\n            cur = cur.next;\\n            if (sum == 0) return removeZeroSumSublists(cur);\\n        }\\n        return new ListNode(head.val, removeZeroSumSublists(head.next));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740995,
                "title": "python-explanation",
                "content": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        # Create a dummy node to init the search\\n        pointer = ListNode(float(\"inf\"))\\n        # Point the dummy node to the head of the list\\n        pointer.next = head\\n        # create a reference to the given list and point the head to the dummy node\\n        curr = head\\n        head = pointer\\n\\n        # Iterate over the node\\n        while head:\\n            # Store the current sum\\n            current_sum = 0\\n\\n            # For each node compute the consecutive sum\\n            while curr:\\n                # Add the value of the node to the current sum\\n                current_sum += curr.val\\n\\n                # If the consecutive sum is 0\\n                # Delete the reference to the\\n                # nodes that sum up to 0\\n                if current_sum == 0:\\n                    head.next = curr.next\\n\\n                # Move to the next node\\n                curr = curr.next\\n\\n            # Move the head\\n            head = head.next\\n\\n            # Update the current node\\n            # to be the next element \\n            # of the head. This resets\\n            # the \"state\" as in the start\\n            if head:\\n                curr = head.next\\n\\n        # Return the next element of the \\n        # dummy pointer, which is going\\n        # to be the updated head of the list\\n        return pointer.next            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        # Create a dummy node to init the search\\n        pointer = ListNode(float(\"inf\"))\\n        # Point the dummy node to the head of the list\\n        pointer.next = head\\n        # create a reference to the given list and point the head to the dummy node\\n        curr = head\\n        head = pointer\\n\\n        # Iterate over the node\\n        while head:\\n            # Store the current sum\\n            current_sum = 0\\n\\n            # For each node compute the consecutive sum\\n            while curr:\\n                # Add the value of the node to the current sum\\n                current_sum += curr.val\\n\\n                # If the consecutive sum is 0\\n                # Delete the reference to the\\n                # nodes that sum up to 0\\n                if current_sum == 0:\\n                    head.next = curr.next\\n\\n                # Move to the next node\\n                curr = curr.next\\n\\n            # Move the head\\n            head = head.next\\n\\n            # Update the current node\\n            # to be the next element \\n            # of the head. This resets\\n            # the \"state\" as in the start\\n            if head:\\n                curr = head.next\\n\\n        # Return the next element of the \\n        # dummy pointer, which is going\\n        # to be the updated head of the list\\n        return pointer.next            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 675308,
                "title": "python3-simple-solution",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        s = 0\\n        temp = ListNode(0)\\n        temp.next = head\\n        result = temp\\n        while temp:\\n            s+=head.val\\n            t = s\\n            temp1 = temp.next\\n            flag = 0\\n            next = -1\\n            while temp1:\\n                t+=temp1.val\\n                if t==s:\\n                    next = temp1.next\\n                temp1 = temp1.next\\n            if next!=-1:\\n                temp.next = next\\n            temp = temp.next\\n        return result.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        s = 0\\n        temp = ListNode(0)\\n        temp.next = head\\n        result = temp\\n        while temp:\\n            s+=head.val\\n            t = s\\n            temp1 = temp.next\\n            flag = 0\\n            next = -1\\n            while temp1:\\n                t+=temp1.val\\n                if t==s:\\n                    next = temp1.next\\n                temp1 = temp1.next\\n            if next!=-1:\\n                temp.next = next\\n            temp = temp.next\\n        return result.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 506679,
                "title": "python-40ms-13-1-mb",
                "content": "\\nclass Solution:\\n\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(None)\\n        prev = dummy\\n        dummy.next = head\\n        hm = {}\\n        hm[0] = dummy\\n        count = 0\\n        while head:\\n            count += head.val\\n            if count in hm:\\n                #remove\\n                remove = hm[count].next\\n                dsum = count\\n                while remove!=head:\\n                    dsum += remove.val\\n                    del hm[dsum]\\n                    remove = remove.next\\n                #link\\n                hm[count].next = head.next\\n            else:\\n                hm[count] = head\\n            head = head.next\\n        return dummy.next",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(None)\\n        prev = dummy\\n        dummy.next = head\\n        hm = {}",
                "codeTag": "Java"
            },
            {
                "id": 366323,
                "title": "easy-and-short-solution-c",
                "content": "1. Calculate prefix sum and insert it into hashmap. If prefix sum is zero, we have remove nodes from begining to current the node.\\n2. If the prefix sum is already exist is hashmap, then remove all the intermediate nodes.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> hmap;\\n        int sum=0, flag=0;\\n        ListNode* new_head=head;\\n        ListNode* temp=head;\\n        while(temp){\\n            sum+=temp->val;\\n            if(sum==0){ new_head=temp->next; flag=1;}\\n            else if(hmap.find(sum)==hmap.end()) hmap[sum]=temp;\\n            else {hmap[sum]->next=temp->next; flag=1;}\\n            temp=temp->next;\\n        }\\n        if(flag) return removeZeroSumSublists(new_head);\\n        return new_head;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> hmap;\\n        int sum=0, flag=0;\\n        ListNode* new_head=head;\\n        ListNode* temp=head;\\n        while(temp){\\n            sum+=temp->val;\\n            if(sum==0){ new_head=temp->next; flag=1;}\\n            else if(hmap.find(sum)==hmap.end()) hmap[sum]=temp;\\n            else {hmap[sum]->next=temp->next; flag=1;}\\n            temp=temp->next;\\n        }\\n        if(flag) return removeZeroSumSublists(new_head);\\n        return new_head;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 366320,
                "title": "java-hashmap-sol",
                "content": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        // Remove starting zeroes.\\n        while (head != null && head.val == 0) {\\n            head = head.next;\\n        }\\n        if (head == null) {\\n            return null;\\n        }\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        ListNode temp = head;\\n        map.put(0, null);\\n        map.put(head.val, head);\\n        int val = head.val;\\n        temp = temp.next;\\n\\n        while (temp != null) {\\n            val += temp.val;\\n            if (val == 0) {\\n                head = temp.next;\\n            } else if (map.containsKey(val)) {\\n                ListNode node = map.get(val);\\n                node.next = temp.next;\\n            } else {\\n                map.put(val, temp);\\n\\n            }\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n```\\n**Update**:\\nAs discussed over [this](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/366319/OJ-is-Wrong.) thread:\\nThis solution is incorrect for this case [1,3,2,-3,-2,5,5,-5,1], it returns [1,5,5,-5,1] whereas it should be [1,5,1]\\nThe skipped values need to be cleaned in the map.\\n",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        // Remove starting zeroes.\\n        while (head != null && head.val == 0) {\\n            head = head.next;\\n        }\\n        if (head == null) {\\n            return null;\\n        }\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        ListNode temp = head;\\n        map.put(0, null);\\n        map.put(head.val, head);\\n        int val = head.val;\\n        temp = temp.next;\\n\\n        while (temp != null) {\\n            val += temp.val;\\n            if (val == 0) {\\n                head = temp.next;\\n            } else if (map.containsKey(val)) {\\n                ListNode node = map.get(val);\\n                node.next = temp.next;\\n            } else {\\n                map.put(val, temp);\\n\\n            }\\n            temp = temp.next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2400899,
                "title": "hash-map-java-with-comments",
                "content": "\\n\\n\\n\\n        ListNode dummy = new ListNode(0);\\n        ListNode cur = dummy;\\n        cur.next = head;\\n        int prefix =0;\\n        HashMap<Integer,ListNode> map = new HashMap<>();\\n        while(cur != null){\\n            prefix += cur.val;          //we are storing the prefix sum\\n            if(map.containsKey(prefix)){            //if we find a sum that is equal to the sum previously in  the map, we can say that some squence of numbers exists which reduced the sum to the zero in the past.\\n                cur = map.get(prefix).next;          //we\\'ll get point from where the sum got reduced, that it map.get(prefix), and start searching for the number that are responsible for the sum to reduced.\\n                int imposters = prefix + cur.val;     //this gives us the key values for the nodes which contains the zero sum, utill the last point where we found the same prefix.\\n                while(imposters != prefix){   //we are checking untill the point of same prefix because, we need the next pointer of that node to be connect with the node before zero sum\\n                    map.remove(imposters);\\n                    cur = cur.next;\\n                    imposters += cur.val;    \\n                }\\n                map.get(prefix).next = cur.next;        // this line, explaination above comment\\n            }\\n            else{\\n                map.put(prefix,cur);\\n            }\\n           cur = cur.next; \\n        }\\n        return dummy.next;\\n",
                "solutionTags": [],
                "code": "\\n\\n\\n\\n        ListNode dummy = new ListNode(0);\\n        ListNode cur = dummy;\\n        cur.next = head;\\n        int prefix =0;\\n        HashMap<Integer,ListNode> map = new HashMap<>();\\n        while(cur != null){\\n            prefix += cur.val;          //we are storing the prefix sum\\n            if(map.containsKey(prefix)){            //if we find a sum that is equal to the sum previously in  the map, we can say that some squence of numbers exists which reduced the sum to the zero in the past.\\n                cur = map.get(prefix).next;          //we\\'ll get point from where the sum got reduced, that it map.get(prefix), and start searching for the number that are responsible for the sum to reduced.\\n                int imposters = prefix + cur.val;     //this gives us the key values for the nodes which contains the zero sum, utill the last point where we found the same prefix.\\n                while(imposters != prefix){   //we are checking untill the point of same prefix because, we need the next pointer of that node to be connect with the node before zero sum\\n                    map.remove(imposters);\\n                    cur = cur.next;\\n                    imposters += cur.val;    \\n                }\\n                map.get(prefix).next = cur.next;        // this line, explaination above comment\\n            }\\n            else{\\n                map.put(prefix,cur);\\n            }\\n           cur = cur.next; \\n        }\\n        return dummy.next;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1262338,
                "title": "simple-c-hashmap-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> m;\\n        ListNode* ptr=head;int prep=0;\\n        ListNode *dummy=new ListNode (0,head);\\n        m[0]=dummy;\\n        while(ptr!=NULL)\\n        {prep=prep+ptr->val;\\n            if(m.find(prep)!=m.end())\\n            { auto it=m[prep]->next;\\n             int SUM=prep;\\n             while(it!=ptr)\\n             {SUM+=it->val;\\n                 m.erase(SUM);\\n              it=it->next;\\n             }\\n                m[prep]->next=ptr->next;    \\n            }\\n            else\\n              m[prep]=ptr;\\n            ptr=ptr->next;   \\n        }\\n        return dummy->next;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> m;\\n        ListNode* ptr=head;int prep=0;\\n        ListNode *dummy=new ListNode (0,head);\\n        m[0]=dummy;\\n        while(ptr!=NULL)\\n        {prep=prep+ptr->val;\\n            if(m.find(prep)!=m.end())\\n            { auto it=m[prep]->next;\\n             int SUM=prep;\\n             while(it!=ptr)\\n             {SUM+=it->val;\\n                 m.erase(SUM);\\n              it=it->next;\\n             }\\n                m[prep]->next=ptr->next;    \\n            }\\n            else\\n              m[prep]=ptr;\\n            ptr=ptr->next;   \\n        }\\n        return dummy->next;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1132693,
                "title": "1ms-java-solution-hashmap-solution",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> hm = new HashMap<>();\\n        ListNode dummy  = new ListNode(0);\\n        dummy.next = head;\\n        int sum = 0;\\n        hm.put(0,dummy);\\n        while(head != null) {\\n            sum += head.val;\\n            if(hm.containsKey(sum)) {\\n                ListNode temp = hm.get(sum).next; \\n                int tempSum = sum;\\n                while(temp != head) {\\n                    tempSum += temp.val;\\n                    hm.remove(tempSum);\\n                    temp = temp.next;\\n                }\\n                hm.get(sum).next = head.next;\\n            }else {\\n                hm.put(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> hm = new HashMap<>();\\n        ListNode dummy  = new ListNode(0);\\n        dummy.next = head;\\n        int sum = 0;\\n        hm.put(0,dummy);\\n        while(head != null) {\\n            sum += head.val;\\n            if(hm.containsKey(sum)) {\\n                ListNode temp = hm.get(sum).next; \\n                int tempSum = sum;\\n                while(temp != head) {\\n                    tempSum += temp.val;\\n                    hm.remove(tempSum);\\n                    temp = temp.next;\\n                }\\n                hm.get(sum).next = head.next;\\n            }else {\\n                hm.put(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707303,
                "title": "cpp-simple-solution",
                "content": "// Runtime: 16 ms, faster than 79.26% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\n// Memory Usage: 11.6 MB, less than 43.10% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List\\n// 1,9,-9,-1,5 --> 1,10,1,0,5\\n//if we dont save a value for zero at he begining we will save the first encounter of zero at 4th pos and the logic wont be able to erase previous values and the dummy\\'s next will have 5 as next and that will be our head\\n//we can encounter zero 1. when all value from first upto ith node is zero then head will be i+1 as explained before\\n//2. when node values will be zero 0->0->..->0 then u[0] will have lastest address of zero and we dont count node with zero so its next is our head \\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> u;\\n        ListNode* ptr,*temp;\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        ptr = dummy;\\n        int sum = 0;\\n        while(ptr){\\n            sum += ptr->val;\\n            u[sum] = ptr;\\n            ptr = ptr->next;\\n        }\\n        sum = 0;\\n        ptr = dummy;\\n        while(ptr){\\n            sum += ptr->val;\\n             temp = ptr->next;\\n            while(u[sum] != NULL && temp != u[sum]->next){\\n                temp = temp->next;\\n            }\\n            ptr->next = temp;\\n            ptr = temp;\\n        }\\n        head = dummy->next;\\n        delete dummy;\\n        return head;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*> u;\\n        ListNode* ptr,*temp;\\n        ListNode *dummy = new ListNode(0);\\n        dummy->next = head;\\n        ptr = dummy;\\n        int sum = 0;\\n        while(ptr){\\n            sum += ptr->val;\\n            u[sum] = ptr;\\n            ptr = ptr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 610648,
                "title": "c-concise-using-vector",
                "content": "\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* curr=head;\\n        vector<int> A;\\n        \\n        while(curr){\\n            A.push_back(curr->val);\\n            curr = curr->next;\\n        }\\n        \\n        int j, sum=0;\\n        for (auto i=0;i<A.size();i++){\\n            sum=0;\\n            for(j=i;j<A.size();j++){\\n                sum += A[j];\\n                if(sum==0)\\n                    break;\\n            }            \\n            if(sum==0) {\\n                A.erase(A.begin()+i,A.begin()+j+1);\\n                i--;\\n            }\\n        }\\n        \\n        if(A.size()==0)\\n            return NULL;\\n        else\\n        {\\n            ListNode* root = new ListNode(A[0]);\\n            curr = root;\\n            for (auto i=1;i<A.size();i++)\\n            {\\n                ListNode* temp = new ListNode;\\n                temp->val=A[i];\\n                root->next=temp;\\n                root=root->next;\\n            }\\n\\n            return curr;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* curr=head;\\n        vector<int> A;\\n        \\n        while(curr){\\n            A.push_back(curr->val);\\n            curr = curr->next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 461539,
                "title": "c-12s-82-85-100-memory-efficient",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        map<int, ListNode*> m;\\n        ListNode* ptr = head, *p;\\n        int consec_sum = 0, sum;\\n        \\n        p = new ListNode(0);\\n        p->next = head;\\n        head = p;\\n        m[0] = head;\\n        \\n        while (ptr) {\\n            \\n            consec_sum += ptr->val;\\n            \\n            if(m.find(consec_sum) != m.end()) {\\n            \\n                ListNode* b = m[consec_sum];\\n                \\n                p = b->next;\\n                \\n                b->next = ptr->next;\\n                \\n                sum = consec_sum;\\n                while (p!=ptr) {\\n                    sum += p->val;\\n                    m.erase(sum);\\n                    p = p->next;\\n                }\\n            } else\\n                m[consec_sum] = ptr;\\n            \\n            ptr = ptr->next;\\n        }\\n        return head->next;\\n    }\\n};\\n```\\nThis code is the same as 8ms code that I saw, but still runs in 12ms. (worse, it also took 16ms in some submissions)\\nIf anybody has an idea as to why it is happening, please let me know in the comments.\\n\\nThe 8ms solution is as follows:\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* dummyHead = new ListNode(0);\\n        \\n        dummyHead->next = head;\\n        \\n        map<int, ListNode*> mapping;\\n        \\n        mapping[0] = dummyHead;\\n        \\n        ListNode* curr = head;\\n        \\n        int cumsum = 0;\\n        \\n        while(curr != NULL){\\n            \\n            cumsum += curr->val;\\n            \\n            if(mapping.find(cumsum) != mapping.end()){\\n                ListNode* start = mapping[cumsum];\\n                ListNode* end = curr;\\n                ListNode* b = start;\\n                \\n                int aux = cumsum;\\n                while(start != end){\\n                    start = start->next;\\n                    aux += start->val;\\n                    if(start != end) mapping.erase(aux);\\n                }\\n                b->next = end->next;\\n                \\n                \\n            }\\n            else{\\n                mapping[cumsum] = curr;\\n                \\n            }\\n            \\n            curr = curr->next;\\n            \\n            \\n            \\n        }\\n        \\n        // while(dummyHead != NULL){\\n        //     cout << dummyHead->val << \" \";\\n        //     dummyHead = dummyHead ->next;\\n        // }\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        map<int, ListNode*> m;\\n        ListNode* ptr = head, *p;\\n        int consec_sum = 0, sum;\\n        \\n        p = new ListNode(0);\\n        p->next = head;\\n        head = p;\\n        m[0] = head;\\n        \\n        while (ptr) {\\n            \\n            consec_sum += ptr->val;\\n            \\n            if(m.find(consec_sum) != m.end()) {\\n            \\n                ListNode* b = m[consec_sum];\\n                \\n                p = b->next;\\n                \\n                b->next = ptr->next;\\n                \\n                sum = consec_sum;\\n                while (p!=ptr) {\\n                    sum += p->val;\\n                    m.erase(sum);\\n                    p = p->next;\\n                }\\n            } else\\n                m[consec_sum] = ptr;\\n            \\n            ptr = ptr->next;\\n        }\\n        return head->next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* dummyHead = new ListNode(0);\\n        \\n        dummyHead->next = head;\\n        \\n        map<int, ListNode*> mapping;\\n        \\n        mapping[0] = dummyHead;\\n        \\n        ListNode* curr = head;\\n        \\n        int cumsum = 0;\\n        \\n        while(curr != NULL){\\n            \\n            cumsum += curr->val;\\n            \\n            if(mapping.find(cumsum) != mapping.end()){\\n                ListNode* start = mapping[cumsum];\\n                ListNode* end = curr;\\n                ListNode* b = start;\\n                \\n                int aux = cumsum;\\n                while(start != end){\\n                    start = start->next;\\n                    aux += start->val;\\n                    if(start != end) mapping.erase(aux);\\n                }\\n                b->next = end->next;\\n                \\n                \\n            }\\n            else{\\n                mapping[cumsum] = curr;\\n                \\n            }\\n            \\n            curr = curr->next;\\n            \\n            \\n            \\n        }\\n        \\n        // while(dummyHead != NULL){\\n        //     cout << dummyHead->val << \" \";\\n        //     dummyHead = dummyHead ->next;\\n        // }\\n        \\n        return dummyHead->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 376823,
                "title": "java-o-n",
                "content": "One pass to find the last occurrences of different prefix sum, second pass to remove.\\n\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        for(ListNode node = dummy; node != null; node = node.next) {\\n            sum += node.val;\\n            map.put(sum, node);\\n        }\\n        sum = 0;\\n        for(ListNode node = dummy; node != null; node = node.next) {\\n            sum += node.val;\\n            node.next = map.get(sum).next;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        for(ListNode node = dummy; node != null; node = node.next) {\\n            sum += node.val;\\n            map.put(sum, node);\\n        }\\n        sum = 0;\\n        for(ListNode node = dummy; node != null; node = node.next) {\\n            sum += node.val;\\n            node.next = map.get(sum).next;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3793776,
                "title": "c-explained-simple-and-easy-recursive-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKED \\u2764\\uFE0F**\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\n        //base case\\n\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        //recursive call\\n\\n        ListNode* smallAns=removeZeroSumSublists(head->next);\\n\\n        //our part and small calculation after\\n        //recursion returns it\\'s answer\\n\\n        if(head->val==0) return smallAns;\\n        int sum=head->val;\\n        bool check=false;\\n        ListNode* temp=smallAns;\\n        while(temp!=NULL){\\n            sum+=temp->val;\\n            if(sum==0){\\n                check=true;\\n                break;\\n            }\\n            temp=temp->next;\\n        }\\n        if(check){\\n            return temp->next;\\n        }\\n        head->next=smallAns;\\n        return head;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\n        //base case\\n\\n        if(head==NULL){\\n            return NULL;\\n        }\\n\\n        //recursive call\\n\\n        ListNode* smallAns=removeZeroSumSublists(head->next);\\n\\n        //our part and small calculation after\\n        //recursion returns it\\'s answer\\n\\n        if(head->val==0) return smallAns;\\n        int sum=head->val;\\n        bool check=false;\\n        ListNode* temp=smallAns;\\n        while(temp!=NULL){\\n            sum+=temp->val;\\n            if(sum==0){\\n                check=true;\\n                break;\\n            }\\n            temp=temp->next;\\n        }\\n        if(check){\\n            return temp->next;\\n        }\\n        head->next=smallAns;\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3700075,
                "title": "java-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)return head;\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        int  running_sum=0;\\n        while(cur!=null)\\n        {\\n            running_sum += cur.val;\\n            if(running_sum==0)\\n            {\\n                if(prev == null)\\n                head = cur.next;\\n                else\\n                prev.next = cur.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            cur = cur.next;\\n        }\\n        head.next = removeZeroSumSublists(head.next);\\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)return head;\\n        ListNode prev = null;\\n        ListNode cur = head;\\n        int  running_sum=0;\\n        while(cur!=null)\\n        {\\n            running_sum += cur.val;\\n            if(running_sum==0)\\n            {\\n                if(prev == null)\\n                head = cur.next;\\n                else\\n                prev.next = cur.next;\\n                return removeZeroSumSublists(head);\\n            }\\n            cur = cur.next;\\n        }\\n        head.next = removeZeroSumSublists(head.next);\\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535522,
                "title": "simplest-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int sum = 0;\\n    ListNode dm = new ListNode(0);\\n    dm.next = head;\\n\\n    Map<Integer, ListNode> mp = new HashMap<>();\\n    mp.put(0, dm);\\n\\n\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        mp.put(sum, i);\\n    }\\n\\n\\n    sum = 0;\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        i.next = mp.get( sum ).next;\\n    }\\n    \\n    return dm.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int sum = 0;\\n    ListNode dm = new ListNode(0);\\n    dm.next = head;\\n\\n    Map<Integer, ListNode> mp = new HashMap<>();\\n    mp.put(0, dm);\\n\\n\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        mp.put(sum, i);\\n    }\\n\\n\\n    sum = 0;\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        i.next = mp.get( sum ).next;\\n    }\\n    \\n    return dm.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2757748,
                "title": "faster-than-100-js",
                "content": "```\\nvar removeZeroSumSublists = function(head) {\\n  const newNode = {\\n    val : 0,\\n    next: head\\n  };\\n\\n\\n  if (head !== null) {\\n    let cur = head;\\n    let sum = 0;\\n\\n    const sumNodeMap = {};\\n\\n    while (cur !== null) {\\n        sum += cur.val;\\n        sumNodeMap[sum] = cur;\\n\\n        cur = cur.next;\\n    }\\n\\n    cur = newNode;\\n    sum = 0;\\n\\n    while (cur !== null) {\\n        sum += cur.val;\\n\\n        if (sumNodeMap[sum]) {\\n            cur.next = sumNodeMap[sum].next;\\n        }\\n\\n        cur = cur.next;\\n    }\\n  }\\n\\n  return newNode.next;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeZeroSumSublists = function(head) {\\n  const newNode = {\\n    val : 0,\\n    next: head\\n  };\\n\\n\\n  if (head !== null) {\\n    let cur = head;\\n    let sum = 0;\\n\\n    const sumNodeMap = {};\\n\\n    while (cur !== null) {\\n        sum += cur.val;\\n        sumNodeMap[sum] = cur;\\n\\n        cur = cur.next;\\n    }\\n\\n    cur = newNode;\\n    sum = 0;\\n\\n    while (cur !== null) {\\n        sum += cur.val;\\n\\n        if (sumNodeMap[sum]) {\\n            cur.next = sumNodeMap[sum].next;\\n        }\\n\\n        cur = cur.next;\\n    }\\n  }\\n\\n  return newNode.next;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2711822,
                "title": "c-easy-short",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* root =new ListNode(0);\\n        root->next=head;\\n        unordered_map<int,ListNode*>um;\\n        um[0]=root;\\n        int ac=0;\\n        \\n        while(head!=NULL){\\n            ac+=head->val;\\n            \\n            if(um.find(ac)!=um.end()){\\n                ListNode* prev= um[ac];\\n                ListNode* start= prev;\\n               \\n                int aux = ac;\\n                while(prev!=head){\\n                    prev=prev->next;\\n                    aux+=prev->val;\\n                    if(prev!=head)um.erase(aux);\\n                }\\n                \\n                start->next = head->next;\\n            }else{\\n                um[ac]= head;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return root->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* root =new ListNode(0);\\n        root->next=head;\\n        unordered_map<int,ListNode*>um;\\n        um[0]=root;\\n        int ac=0;\\n        \\n        while(head!=NULL){\\n            ac+=head->val;\\n            \\n            if(um.find(ac)!=um.end()){\\n                ListNode* prev= um[ac];\\n                ListNode* start= prev;\\n               \\n                int aux = ac;\\n                while(prev!=head){\\n                    prev=prev->next;\\n                    aux+=prev->val;\\n                    if(prev!=head)um.erase(aux);\\n                }\\n                \\n                start->next = head->next;\\n            }else{\\n                um[ac]= head;\\n            }\\n            \\n            head=head->next;\\n        }\\n        \\n        return root->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336374,
                "title": "simple-c-solution-using-iterative-method",
                "content": "### O(n^2) time complexity\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        // take a dummy node with val \\'0\\' and at next store head\\n        ListNode* root = new ListNode(0);\\n        root->next = head;\\n        \\n        // in for loop check for each node that the sum is zero or not\\n        for(ListNode* i = root; i!=NULL; i=i->next){\\n            int sum = 0;\\n            for(ListNode* j=i->next;j!=NULL;j=j->next){\\n                sum+=j->val;\\n                // if sum is zero \\n                if(sum==0){\\n                    i->next = j->next;\\n                }\\n            }\\n        }\\n        return root->next;\\n        \\n    }\\n",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "### O(n^2) time complexity\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        // take a dummy node with val \\'0\\' and at next store head\\n        ListNode* root = new ListNode(0);\\n        root->next = head;\\n        \\n        // in for loop check for each node that the sum is zero or not\\n        for(ListNode* i = root; i!=NULL; i=i->next){\\n            int sum = 0;\\n            for(ListNode* j=i->next;j!=NULL;j=j->next){\\n                sum+=j->val;\\n                // if sum is zero \\n                if(sum==0){\\n                    i->next = j->next;\\n                }\\n            }\\n        }\\n        return root->next;\\n        \\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2317436,
                "title": "beats-100-other-solutions",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        cur = dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = collections.OrderedDict()\\n        while cur:\\n            prefix += cur.val\\n            node = seen.get(prefix, cur)\\n            while prefix in seen:\\n                seen.popitem()\\n            seen[prefix] = node\\n            node.next = cur = cur.next\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\n\\n\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        cur = dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = collections.OrderedDict()\\n        while cur:\\n            prefix += cur.val\\n            node = seen.get(prefix, cur)\\n            while prefix in seen:\\n                seen.popitem()\\n            seen[prefix] = node\\n            node.next = cur = cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842399,
                "title": "c-goto-iterative-prefix-sum-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next=head;\\n\\t\\t//goto statement will lead the program here at point\\n        point:\\n        int sum = 0;\\n\\t\\t//map to store prefix sum and respective node value\\n        unordered_map<int, ListNode*> mp;\\n        mp[0]=dummy;\\n        head=dummy->next;\\n        while(head!=NULL){\\n            sum+=head->val;\\n            if(mp.find(sum)!=mp.end()){\\n                ListNode* temp = mp[sum];\\n                temp->next=head->next;\\n\\t\\t\\t\\t//everytime we delete a part of linked list we start again from the begnning\\n                goto point; \\n            }\\n            else mp[sum]=head;\\n            head=head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next=head;\\n\\t\\t//goto statement will lead the program here at point\\n        point:\\n        int sum = 0;\\n\\t\\t//map to store prefix sum and respective node value\\n        unordered_map<int, ListNode*> mp;\\n        mp[0]=dummy;\\n        head=dummy->next;\\n        while(head!=NULL){\\n            sum+=head->val;\\n            if(mp.find(sum)!=mp.end()){\\n                ListNode* temp = mp[sum];\\n                temp->next=head->next;\\n\\t\\t\\t\\t//everytime we delete a part of linked list we start again from the begnning\\n                goto point; \\n            }\\n            else mp[sum]=head;\\n            head=head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1822860,
                "title": "java-recursion-easy-to-understand",
                "content": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        // Base Case\\n        if(head == null) return null;\\n        // Current Case: to find zero sum consecutive nodes from HEAD\\n        ListNode cur = head;\\n        int sum = 0;\\n        while(cur != null) {\\n            sum += cur.val;\\n            // found\\n            if(sum == 0) break;\\n            cur = cur.next;\\n        }\\n        // found such consecutive nodes, delete them by recursing to cur.next\\n        if(cur != null) return removeZeroSumSublists(cur.next);\\n        // such consecutive nodes don\\'t exist, move on to head.next;\\n        head.next = removeZeroSumSublists(head.next);\\n        return head;\\n    }",
                "solutionTags": [],
                "code": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        // Base Case\\n        if(head == null) return null;\\n        // Current Case: to find zero sum consecutive nodes from HEAD\\n        ListNode cur = head;\\n        int sum = 0;\\n        while(cur != null) {\\n            sum += cur.val;\\n            // found\\n            if(sum == 0) break;\\n            cur = cur.next;\\n        }\\n        // found such consecutive nodes, delete them by recursing to cur.next\\n        if(cur != null) return removeZeroSumSublists(cur.next);\\n        // such consecutive nodes don\\'t exist, move on to head.next;\\n        head.next = removeZeroSumSublists(head.next);\\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1814290,
                "title": "simplest-solution-easiest-to-understand-faster-than-100",
                "content": "Logic:\\nExample:\\n[3 ,5, 7, -3,-2,-2, 6]\\n\\nWe can observe that sum of **7,-3,-2,-2** gives us 0.\\n\\nLet\\'s calculate sum of all elements\\narr = [3, 5, 7, -3, -2, -2, 6]\\ncnt = [3, **8**,15, 12,10, **8**, 14]\\nAs we can see , we have 2 times **8** sums. ***So we\\'re sure that items between 8\\'s are summing to 0.***\\n\\nBut what if we find another 8 later? The sum between the **first 8 and the last 8** will be equal to 0, so all of the items in between can be removed.\\n\\narr = [3, 5, 7, -3, -2, -2, 6, -6]\\ncnt = [3, **8**,15, 12,10, 8, 14, **8**]\\nSum of the items from **first 8 till last 8** will equal 0.\\n\\nHence, **we need to know where the last 8 (or any other number)** is located.\\n\\nIf we see 0 as the sum, we need to delete all items first 0 and last 0.\\n\\nThen, we iterate through the same nodes again, but this time we\\'ll be looking for the same sum in the hashmap, and rellocating our pointer there.\\nIf we find sum=0, we\\'ll rellocate the head to this item as well ( because everything before will give us 0)\\n\\nCheck the below code, you will understand better!\\n\\n```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        \\n        Map<Integer,ListNode> map= new HashMap<>();\\n        \\n        ListNode fake= new ListNode(0);\\n        fake.next=head;\\n        \\n        int sum=0;\\n        \\n        for(ListNode cur=fake; cur!=null; cur=cur.next)\\n        {\\n            sum= sum+cur.val;\\n            map.put(sum,cur);\\n        }\\n        \\n        sum=0;\\n        \\n        for(ListNode cur=fake; cur!=null; cur=cur.next)\\n        {\\n            sum= sum+cur.val;\\n            cur.next= map.get(sum).next;\\n        }\\n        \\n        return fake.next;\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        \\n        Map<Integer,ListNode> map= new HashMap<>();\\n        \\n        ListNode fake= new ListNode(0);\\n        fake.next=head;\\n        \\n        int sum=0;\\n        \\n        for(ListNode cur=fake; cur!=null; cur=cur.next)\\n        {\\n            sum= sum+cur.val;\\n            map.put(sum,cur);\\n        }\\n        \\n        sum=0;\\n        \\n        for(ListNode cur=fake; cur!=null; cur=cur.next)\\n        {\\n            sum= sum+cur.val;\\n            cur.next= map.get(sum).next;\\n        }\\n        \\n        return fake.next;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767467,
                "title": "c-hashmap-easy-to-understand",
                "content": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0), *curr = dummy;\\n        dummy->next = head;\\n        int prefix = 0;\\n        map<int, ListNode*> m;\\n        while(curr)\\n        {\\n            prefix+=curr->val;\\n            if(m[prefix])\\n            {\\n                ListNode* temp=m[prefix];\\n                int x=prefix;\\n                while(temp->next!=curr)\\n                {\\n                    m.erase(x+temp->next->val);\\n                    x+=temp->next->val;\\n                    temp=temp->next;\\n                }\\n                m[prefix]->next=curr->next;\\n            }\\n            else\\n            {\\n                m[prefix]=curr;\\n            }\\n            curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* dummy = new ListNode(0), *curr = dummy;\\n        dummy->next = head;\\n        int prefix = 0;\\n        map<int, ListNode*> m;\\n        while(curr)\\n        {\\n            prefix+=curr->val;\\n            if(m[prefix])\\n            {\\n                ListNode* temp=m[prefix];\\n                int x=prefix;\\n                while(temp->next!=curr)\\n                {\\n                    m.erase(x+temp->next->val);\\n                    x+=temp->next->val;\\n                    temp=temp->next;\\n                }\\n                m[prefix]->next=curr->next;\\n            }\\n            else\\n            {\\n                m[prefix]=curr;\\n            }\\n            curr=curr->next;\\n        }\\n        return dummy->next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1713682,
                "title": "c-o-n-time-complexity-recursive-approach",
                "content": "**Approach:**\\n1. Take a pointer **ptr** pointing towards **head**;\\n2. Take integer variable **sum** initialize it as 0.\\n3. now iterate the linked list through pointer **ptr** and on each iteration add value of node in **sum**. \\n4. check if **sum** becomes zero or not, if it become zero then make **head** next to **ptr** pointer and again make **sum** to zero and continue the interation.\\n5. After this call the **removeZeroSumSublists** function and give next node of **head** as parameter.\\n6. the return value from the recursive call will store in next node of **head**.\\n7. The recursive call will be continue until the **head** become NULL.\\n\\n![image](https://assets.leetcode.com/users/images/51b27929-eb66-4587-af72-7bc92c7094c7_1642960320.7705717.jpeg)\\n\\n![image](https://assets.leetcode.com/users/images/e64cbf23-c2a9-4fa8-9fa7-21c0053bec05_1642960349.1322982.jpeg)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n          \\n        if(head==NULL){\\n            return head;\\n        }\\n        struct ListNode* ptr=head;\\n        int sum=0;\\n        while(ptr!=NULL){\\n            sum+=(ptr->val);\\n            if(sum==0){\\n                head=ptr->next;\\n                sum=0;\\n            }\\n            ptr=ptr->next;\\n        }\\n         if(head!=NULL)\\n        head->next=removeZeroSumSublists(head->next);\\n        return head;\\n    }\\n};\\n```\\n***If you like the Solution then please vote up and comment.***",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n          \\n        if(head==NULL){\\n            return head;\\n        }\\n        struct ListNode* ptr=head;\\n        int sum=0;\\n        while(ptr!=NULL){\\n            sum+=(ptr->val);\\n            if(sum==0){\\n                head=ptr->next;\\n                sum=0;\\n            }\\n            ptr=ptr->next;\\n        }\\n         if(head!=NULL)\\n        head->next=removeZeroSumSublists(head->next);\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701585,
                "title": "c-o-n-time-commented-solution-code-with-explanation",
                "content": "Please UPVOTE if you find it usefull\\n```\\n ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        // base condition\\n        if(head->next == NULL)\\n        {\\n            if(head->val == 0)\\n                return NULL;\\n            return head;\\n        }\\n        \\n        \\n        // removing zeros form the initial linklist\\n        ListNode* temp;\\n        temp = head->next;\\n        ListNode* prev = head;\\n        while(temp != NULL)\\n        {\\n            if(temp->val == 0)\\n            {\\n                prev->next = temp->next;\\n                temp = temp->next;\\n            }\\n            else\\n            {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        if(head->val == 0)\\n        {\\n            head = head->next;\\n        }\\n        \\n        \\n        /* using hash table to find zero sum\\n            condition 1 - if we found the same sum again \\n            contition 2 - if we find zero\\n            else we fill the map with sum and node\\n        */\\n        temp = head;\\n        int sum = 0;\\n        unordered_map<int,ListNode*> freq;\\n        stack<int> rem;\\n        \\n        while(temp != NULL)\\n        {\\n            sum += temp->val;\\n            if(sum == 0)\\n            {\\n                head = temp->next;\\n                freq.clear();\\n            }\\n            else if(freq.count(sum) > 0)\\n            {\\n                ListNode* prev = freq[sum];\\n                \\n                prev->next = temp->next;\\n                while(rem.top() != sum)\\n                {\\n                    int top = rem.top();\\n                    rem.pop();\\n                    freq.erase(top);\\n                }\\n            }\\n            else\\n            {   \\n                rem.push(sum);\\n                freq[sum] = temp;\\n            }\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Please UPVOTE if you find it usefull\\n```\\n ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        // base condition\\n        if(head->next == NULL)\\n        {\\n            if(head->val == 0)\\n                return NULL;\\n            return head;\\n        }\\n        \\n        \\n        // removing zeros form the initial linklist\\n        ListNode* temp;\\n        temp = head->next;\\n        ListNode* prev = head;\\n        while(temp != NULL)\\n        {\\n            if(temp->val == 0)\\n            {\\n                prev->next = temp->next;\\n                temp = temp->next;\\n            }\\n            else\\n            {\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        if(head->val == 0)\\n        {\\n            head = head->next;\\n        }\\n        \\n        \\n        /* using hash table to find zero sum\\n            condition 1 - if we found the same sum again \\n            contition 2 - if we find zero\\n            else we fill the map with sum and node\\n        */\\n        temp = head;\\n        int sum = 0;\\n        unordered_map<int,ListNode*> freq;\\n        stack<int> rem;\\n        \\n        while(temp != NULL)\\n        {\\n            sum += temp->val;\\n            if(sum == 0)\\n            {\\n                head = temp->next;\\n                freq.clear();\\n            }\\n            else if(freq.count(sum) > 0)\\n            {\\n                ListNode* prev = freq[sum];\\n                \\n                prev->next = temp->next;\\n                while(rem.top() != sum)\\n                {\\n                    int top = rem.top();\\n                    rem.pop();\\n                    freq.erase(top);\\n                }\\n            }\\n            else\\n            {   \\n                rem.push(sum);\\n                freq[sum] = temp;\\n            }\\n            temp = temp->next;\\n        }\\n        \\n        return head;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1648921,
                "title": "c-o-n-using-stack-map",
                "content": "Using Stack and Map in O(N)\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp = head;\\n        stack<ListNode*> st;\\n        int sum = 0;\\n        ListNode* ans = NULL;\\n        unordered_map<int, int> m; //storing possible sum\\n        m[0] = 1;\\n        while(temp){\\n            if(temp->val==0){ //ignorimg 0 values\\n                temp = temp->next;\\n                continue;\\n            }\\n            if(!st.empty()){\\n                int tempsum = sum+temp->val;\\n                if(m[tempsum]==1){ //if already found in map\\n                    while(sum!=tempsum && !st.empty()){ //keep popping and checking\\n                        m[sum] = 0; //removing not useful value\\n                        sum-=(st.top()->val);\\n                        st.pop();\\n                    }\\n                }else{\\n                    sum = tempsum; //update sum\\n                    m[sum] = 1; //enter into map\\n                    st.top()->next = temp; \\n                    st.push(temp); //store in stack\\n                }\\n            }else{\\n                st.push(temp); //store it\\n                sum+=temp->val; //update sum\\n                m[sum] = 1; //add in map\\n                ans = temp;\\n            }\\n            temp = temp->next;\\n        }\\n        if(!st.empty()) st.top()->next = NULL; \\n        else ans = NULL;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp = head;\\n        stack<ListNode*> st;\\n        int sum = 0;\\n        ListNode* ans = NULL;\\n        unordered_map<int, int> m; //storing possible sum\\n        m[0] = 1;\\n        while(temp){\\n            if(temp->val==0){ //ignorimg 0 values\\n                temp = temp->next;\\n                continue;\\n            }\\n            if(!st.empty()){\\n                int tempsum = sum+temp->val;\\n                if(m[tempsum]==1){ //if already found in map\\n                    while(sum!=tempsum && !st.empty()){ //keep popping and checking\\n                        m[sum] = 0; //removing not useful value\\n                        sum-=(st.top()->val);\\n                        st.pop();\\n                    }\\n                }else{\\n                    sum = tempsum; //update sum\\n                    m[sum] = 1; //enter into map\\n                    st.top()->next = temp; \\n                    st.push(temp); //store in stack\\n                }\\n            }else{\\n                st.push(temp); //store it\\n                sum+=temp->val; //update sum\\n                m[sum] = 1; //add in map\\n                ans = temp;\\n            }\\n            temp = temp->next;\\n        }\\n        if(!st.empty()) st.top()->next = NULL; \\n        else ans = NULL;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582644,
                "title": "c-using-map-easy-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        int sum=0;\\n        unordered_map<int,ListNode*> m;\\n       \\n        ListNode* root=new ListNode(0);\\n        root->next=head;\\n         m[0]=root;\\n        while(head!=NULL){\\n            sum=sum+head->val;\\n            if(m.find(sum)==m.end())\\n                m[sum]=head;\\n            else{\\n                ListNode* temp=m[sum];\\n                int csum=sum;\\n                temp=temp->next;\\n                while(temp!=head){\\n                    csum+=temp->val;\\n                    m.erase(csum);\\n                    temp=temp->next;\\n                }\\n                m[sum]->next=head->next;\\n            }\\n            head=head->next;\\n        }\\n        return root->next;\\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        int sum=0;\\n        unordered_map<int,ListNode*> m;\\n       \\n        ListNode* root=new ListNode(0);\\n        root->next=head;\\n         m[0]=root;\\n        while(head!=NULL){\\n            sum=sum+head->val;\\n            if(m.find(sum)==m.end())\\n                m[sum]=head;\\n            else{\\n                ListNode* temp=m[sum];\\n                int csum=sum;\\n                temp=temp->next;\\n                while(temp!=head){\\n                    csum+=temp->val;\\n                    m.erase(csum);\\n                    temp=temp->next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1430485,
                "title": "java-straight-forward-traverse-2ms-78",
                "content": "traverse the whole list. From each node to detect if exists 0 sum over there.If yes,skip to the next node of \"0 sum\" nodes.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode head1 = new ListNode();\\n        head1.next = head;\\n        ListNode pre = head1; \\n        while(head!=null){\\n            ListNode node = SkipZeroSum(head);\\n            if(node!= head){\\n                pre.next = node;\\n                head = node;\\n            }else{\\n                pre = head;\\n                head = head.next;\\n            }\\n        }\\n        return head1.next;\\n    }\\n    \\n    public ListNode SkipZeroSum(ListNode node){\\n        int sum = 0;\\n        ListNode cur = node;\\n        while(cur != null){\\n            sum += cur.val;\\n            if(sum == 0){\\n                return cur.next;\\n            }\\n            cur = cur.next;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode head1 = new ListNode();\\n        head1.next = head;\\n        ListNode pre = head1; \\n        while(head!=null){\\n            ListNode node = SkipZeroSum(head);\\n            if(node!= head){\\n                pre.next = node;\\n                head = node;\\n            }else{\\n                pre = head;\\n                head = head.next;\\n            }\\n        }\\n        return head1.next;\\n    }\\n    \\n    public ListNode SkipZeroSum(ListNode node){\\n        int sum = 0;\\n        ListNode cur = node;\\n        while(cur != null){\\n            sum += cur.val;\\n            if(sum == 0){\\n                return cur.next;\\n            }\\n            cur = cur.next;\\n        }\\n        return node;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430041,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* t=new ListNode(0);\\n        t->next=head;\\n        unordered_map<int,ListNode*> mp;\\n        head=t;\\n        int sum=0;\\n        while(t!=NULL){\\n            sum+=t->val;\\n            \\n            if(mp.count(sum)){\\n                ListNode* it=mp[sum];\\n                int ss=sum;\\n                while(it->next!=t){\\n                    ss+=it->next->val;\\n                    mp.erase(ss);\\n                    it->next=it->next->next;\\n                }\\n                it->next=it->next->next;\\n                t=it->next;\\n            }\\n            else\\n            {\\n                mp[sum]=t;\\n                t=t->next;\\n            }\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* t=new ListNode(0);\\n        t->next=head;\\n        unordered_map<int,ListNode*> mp;\\n        head=t;\\n        int sum=0;\\n        while(t!=NULL){\\n            sum+=t->val;\\n            \\n            if(mp.count(sum)){\\n                ListNode* it=mp[sum];\\n                int ss=sum;\\n                while(it->next!=t){\\n                    ss+=it->next->val;\\n                    mp.erase(ss);\\n                    it->next=it->next->next;\\n                }\\n                it->next=it->next->next;\\n                t=it->next;\\n            }\\n            else\\n            {\\n                mp[sum]=t;\\n                t=t->next;\\n            }\\n        }\\n        return head->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346035,
                "title": "difference-between-o-n-o-n-solution",
                "content": "-> O(n\\xB2) Brute-Force Solution :-\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *ptr = new ListNode();\\n        ptr -> next = head;\\n        for (ListNode *i = ptr; i != NULL; i = i -> next) {\\n            int sum = 0;\\n            for (ListNode *j = i -> next; j != NULL; j = j -> next) {\\n                sum += j -> val;\\n                if (sum == 0) {\\n                    if(j -> next != NULL)\\n                        i -> next = j -> next;\\n                    else {\\n                        i -> next = NULL; \\n                        break; \\n                    }\\n                }\\n            }\\n        }        \\n        return ptr -> next;\\n    }\\n};\\n```\\n\\n\\n-> O(n) Solution using HashMap :-\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *ptr = new ListNode(0);\\n        ptr -> next = head;\\n        unordered_map<int, ListNode*> map;\\n        map[0] = ptr;\\n        int totalSum = 0;\\n        while (head != NULL) {\\n            totalSum += head -> val;\\n            if (map.find(totalSum) != map.end()) {\\n                ListNode *pre = map[totalSum];\\n                ListNode *cur = pre;\\n                int temp = totalSum;\\n                while (pre != head) {\\n                    pre = pre -> next;\\n                    temp += pre -> val;\\n                    if (pre != head)\\n                        map.erase(temp);\\n                }\\n                cur -> next = head -> next;\\n            }\\n            else \\n                map[totalSum] = head;\\n            head = head -> next;\\n        }\\n        return ptr -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *ptr = new ListNode();\\n        ptr -> next = head;\\n        for (ListNode *i = ptr; i != NULL; i = i -> next) {\\n            int sum = 0;\\n            for (ListNode *j = i -> next; j != NULL; j = j -> next) {\\n                sum += j -> val;\\n                if (sum == 0) {\\n                    if(j -> next != NULL)\\n                        i -> next = j -> next;\\n                    else {\\n                        i -> next = NULL; \\n                        break; \\n                    }\\n                }\\n            }\\n        }        \\n        return ptr -> next;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *ptr = new ListNode(0);\\n        ptr -> next = head;\\n        unordered_map<int, ListNode*> map;\\n        map[0] = ptr;\\n        int totalSum = 0;\\n        while (head != NULL) {\\n            totalSum += head -> val;\\n            if (map.find(totalSum) != map.end()) {\\n                ListNode *pre = map[totalSum];\\n                ListNode *cur = pre;\\n                int temp = totalSum;\\n                while (pre != head) {\\n                    pre = pre -> next;\\n                    temp += pre -> val;\\n                    if (pre != head)\\n                        map.erase(temp);\\n                }\\n                cur -> next = head -> next;\\n            }\\n            else \\n                map[totalSum] = head;\\n            head = head -> next;\\n        }\\n        return ptr -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224374,
                "title": "java-one-pass-solution-with-hashmap",
                "content": "We maintain a hashmap to store all the nodes that have the same cummulative sum. The cummulative sum is the key, and the list of all nodes that has this cummulative sum is the value.\\nWe travserse the linked list. For each node, we iterate through all the previous nodes that have the current cummulative sum and remove all nodes between. Then we update the list of nodes that has the same cummulative sum and put the list into map.\\n```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, List<ListNode>> map = new HashMap<>();\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        int sum = 0;\\n        List<ListNode> first = new ArrayList<>(0);\\n        first.add(dummy);\\n        map.put(sum, first);\\n        ListNode curr = head;\\n        while (curr != null){\\n            sum += curr.val;\\n            List<ListNode> prevs = map.getOrDefault(sum, new ArrayList<>());\\n            for(ListNode prev : prevs) {\\n                prev.next = curr.next;    \\n            }\\n            prevs.add(curr);\\n            map.put(sum, prevs);\\n            curr = curr.next;\\n        }\\n        return dummy.next;\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, List<ListNode>> map = new HashMap<>();\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        int sum = 0;\\n        List<ListNode> first = new ArrayList<>(0);\\n        first.add(dummy);\\n        map.put(sum, first);\\n        ListNode curr = head;\\n        while (curr != null){\\n            sum += curr.val;\\n            List<ListNode> prevs = map.getOrDefault(sum, new ArrayList<>());\\n            for(ListNode prev : prevs) {\\n                prev.next = curr.next;    \\n            }\\n            prevs.add(curr);\\n            map.put(sum, prevs);\\n            curr = curr.next;\\n        }\\n        return dummy.next;\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1078468,
                "title": "java-2ms",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode ans = new ListNode(0);;\\n        ListNode prev = ans;\\n        prev.next = head;\\n        \\n        outer:\\n        while(head !=  null){\\n            ListNode curr = head;\\n            int sum = 0;\\n            while(curr != null){\\n                sum += curr.val;\\n                curr = curr.next;\\n                if(sum == 0)\\n                {\\n                    prev.next = curr;\\n                    head = curr;\\n                    continue outer;\\n                }\\n            }\\n            \\n            prev = head;\\n            head = head.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode ans = new ListNode(0);;\\n        ListNode prev = ans;\\n        prev.next = head;\\n        \\n        outer:\\n        while(head !=  null){\\n            ListNode curr = head;\\n            int sum = 0;\\n            while(curr != null){\\n                sum += curr.val;\\n                curr = curr.next;\\n                if(sum == 0)\\n                {\\n                    prev.next = curr;\\n                    head = curr;\\n                    continue outer;\\n                }\\n            }\\n            \\n            prev = head;\\n            head = head.next;\\n        }\\n        return ans.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037914,
                "title": "c-100-faster-fully-commented-easy-to-understand",
                "content": "****ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        \\n        ListNode* dummy=new ListNode(0);//considering a dummy variable poitning to head\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        \\n        while(head)\\n        {\\n            ListNode* curr=head;\\n            int sum=0;int flag=0;\\n            \\n            while(curr)\\n            {\\n                sum+=curr->val;\\n                curr=curr->next;\\n                \\n                if(sum==0)//checking if any consecutive sum is equal to zero \\n                {\\n                    flag=1;break;//if yes then breakout from the loop\\n                }\\n            }\\n            if(flag)\\n            {\\n                prev->next=curr;head=curr;continue;//chaning the value of head after elimination\\n            }\\n            prev=head;\\n            head=head->next;//traversing the loop if no loop is found\\n        }\\n        return dummy->next;//returning the new list\\n    }****",
                "solutionTags": [],
                "code": "****ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head==NULL)\\n            return head;\\n        \\n        ListNode* dummy=new ListNode(0);//considering a dummy variable poitning to head\\n        dummy->next=head;\\n        ListNode* prev=dummy;\\n        \\n        while(head)\\n        {\\n            ListNode* curr=head;\\n            int sum=0;int flag=0;\\n            \\n            while(curr)\\n            {\\n                sum+=curr->val;\\n                curr=curr->next;\\n                \\n                if(sum==0)//checking if any consecutive sum is equal to zero \\n                {\\n                    flag=1;break;//if yes then breakout from the loop\\n                }\\n            }\\n            if(flag)\\n            {\\n                prev->next=curr;head=curr;continue;//chaning the value of head after elimination\\n            }\\n            prev=head;\\n            head=head->next;//traversing the loop if no loop is found\\n        }\\n        return dummy->next;//returning the new list\\n    }****",
                "codeTag": "Unknown"
            },
            {
                "id": 1007175,
                "title": "simple-c-o-n",
                "content": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n\\tListNode *dummy=new ListNode(0);\\n\\tdummy->next=head;\\n\\tListNode *curr=dummy;\\n\\tunordered_map<int,ListNode*> hashmap;\\n\\tint sum=0;\\n\\twhile(curr!=NULL)\\n\\t{\\n\\t\\tsum=sum+curr->val;\\n\\t\\tif(hashmap.find(sum)!=hashmap.end())\\n\\t\\t{\\n\\t\\t\\tListNode *temp=hashmap[sum]->next;\\n\\t\\t\\tint t=sum;\\n\\t\\t\\twhile(temp!=curr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tt=t+temp->val;\\n\\t\\t\\t\\thashmap.erase(t);\\n\\t\\t\\t\\ttemp=temp->next;\\n\\t\\t\\t}\\n\\t\\t\\thashmap[sum]->next=curr->next;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\thashmap[sum]=curr;\\n\\t\\tcurr=curr->next;\\n\\t}\\n\\treturn dummy->next;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n\\tListNode *dummy=new ListNode(0);\\n\\tdummy->next=head;\\n\\tListNode *curr=dummy;\\n\\tunordered_map<int,ListNode*> hashmap;\\n\\tint sum=0;\\n\\twhile(curr!=NULL)\\n\\t{\\n\\t\\tsum=sum+curr->val;\\n\\t\\tif(hashmap.find(sum)!=hashmap.end())\\n\\t\\t{\\n\\t\\t\\tListNode *temp=hashmap[sum]->next;\\n\\t\\t\\tint t=sum;\\n\\t\\t\\twhile(temp!=curr)\\n\\t\\t\\t{\\n\\t\\t\\t\\tt=t+temp->val;\\n\\t\\t\\t\\thashmap.erase(t);\\n\\t\\t\\t\\ttemp=temp->next;\\n\\t\\t\\t}\\n\\t\\t\\thashmap[sum]->next=curr->next;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t\\thashmap[sum]=curr;\\n\\t\\tcurr=curr->next;\\n\\t}\\n\\treturn dummy->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 998539,
                "title": "32ms-c-solution-rac101ran-rachit-ranjan",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode*node=head;\\n        vector<int> a;\\n        while(node!=nullptr) {\\n           a.push_back(node->val);\\n           node=node->next; \\n        }\\n        for(int i=0; i<a.size(); i++) {\\n            int s=0;\\n            for(int j=i; j<a.size(); j++) {\\n                 s+=a[j];\\n                 if(s==0) {\\n                    a.erase(a.begin()+i,a.begin()+j+1);\\n                    i=-1; \\n                    break; \\n                 }\\n            }\\n        }\\n        node=nullptr;\\n        for(int i=a.size()-1; i>=0; i--) {\\n             node=insert(node,a[i]);\\n        }\\n        return node;\\n    }\\n    ListNode* insert(ListNode* head,int x) {\\n         ListNode*newnode=new ListNode();\\n         newnode->val=x;\\n         newnode->next=head;\\n         head=newnode;\\n         return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode*node=head;\\n        vector<int> a;\\n        while(node!=nullptr) {\\n           a.push_back(node->val);\\n           node=node->next; \\n        }\\n        for(int i=0; i<a.size(); i++) {\\n            int s=0;\\n            for(int j=i; j<a.size(); j++) {\\n                 s+=a[j];\\n                 if(s==0) {\\n                    a.erase(a.begin()+i,a.begin()+j+1);\\n                    i=-1; \\n                    break; \\n                 }\\n            }\\n        }\\n        node=nullptr;\\n        for(int i=a.size()-1; i>=0; i--) {\\n             node=insert(node,a[i]);\\n        }\\n        return node;\\n    }\\n    ListNode* insert(ListNode* head,int x) {\\n         ListNode*newnode=new ListNode();\\n         newnode->val=x;\\n         newnode->next=head;\\n         head=newnode;\\n         return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 796112,
                "title": "c-prefixsum-solution-without-hashmap",
                "content": "```c\\n#define MAX_NODES 1000\\n\\n// Using prefix sum\\nstruct ListNode *\\nremoveZeroSumSublists(struct ListNode *head)\\n{\\n    struct node {\\n        struct ListNode *curr;\\n        int sum;\\n    };\\n    struct ListNode dummy = {\\n        .val  = 0,\\n        .next = head,\\n    };\\n    struct node prefixSum[MAX_NODES + 1] = {{0}};\\n    int sum                              = 0;\\n    int size                             = 0;\\n    struct ListNode *curr                = &dummy;\\n    while (curr) {\\n        sum                 += curr->val;\\n        prefixSum[size].sum  = sum;\\n        prefixSum[size].curr = curr;\\n        size++;\\n        curr = curr->next;\\n    }\\n    for (int i = 0; i < size; i++) {\\n        for (int j = size - 1; j > i; j--) {\\n            if (prefixSum[i].sum == prefixSum[j].sum) {\\n                prefixSum[i].curr->next = prefixSum[j].curr->next;\\n                i                       = j;\\n                break;\\n            }\\n        }\\n    }\\n    return dummy.next;\\n}\\n```",
                "solutionTags": [],
                "code": "```c\\n#define MAX_NODES 1000\\n\\n// Using prefix sum\\nstruct ListNode *\\nremoveZeroSumSublists(struct ListNode *head)\\n{\\n    struct node {\\n        struct ListNode *curr;\\n        int sum;\\n    };\\n    struct ListNode dummy = {\\n        .val  = 0,\\n        .next = head,\\n    };\\n    struct node prefixSum[MAX_NODES + 1] = {{0}};\\n    int sum                              = 0;\\n    int size                             = 0;\\n    struct ListNode *curr                = &dummy;\\n    while (curr) {\\n        sum                 += curr->val;\\n        prefixSum[size].sum  = sum;\\n        prefixSum[size].curr = curr;\\n        size++;\\n        curr = curr->next;\\n    }\\n    for (int i = 0; i < size; i++) {\\n        for (int j = size - 1; j > i; j--) {\\n            if (prefixSum[i].sum == prefixSum[j].sum) {\\n                prefixSum[i].curr->next = prefixSum[j].curr->next;\\n                i                       = j;\\n                break;\\n            }\\n        }\\n    }\\n    return dummy.next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 743470,
                "title": "java-hashmap-storing-listnode-with-recursion",
                "content": "We can use recursion to delete consecutive sequences of nodes that sum to 0 until the list size no longer decreases\\n\\n```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null)\\n            return head;\\n    \\n        return remove(head, Integer.MAX_VALUE);\\n    } \\n    \\n    public ListNode remove(ListNode head, int prevSize) {    \\n        Map<Integer, ListNode> map = new HashMap<>(); \\n        \\n        int sum = 0, size = 0;\\n        ListNode node = head;\\n        map.put(0, null);\\n        \\n        while (node != null) {            \\n            sum += node.val;\\n            \\n            //if sum == 0, remove all prev visited nodes, start head from here\\n            if (sum == 0) {\\n                head = node.next;\\n            } else if (map.containsKey(sum)) {\\n                //skip over these nodes that add up to sum \\n                ListNode prev = map.get(sum);\\n                prev.next = node.next;\\n            } else {\\n                map.put(sum, node);\\n            }            \\n            node = node.next;\\n            size++;\\n        }\\n        \\n        if (prevSize == size)\\n            return head;    \\n        \\n        return remove(head, size);\\n    }\\n```\\n\\nPlease upvote if this made sense thanks\\n",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null)\\n            return head;\\n    \\n        return remove(head, Integer.MAX_VALUE);\\n    } \\n    \\n    public ListNode remove(ListNode head, int prevSize) {    \\n        Map<Integer, ListNode> map = new HashMap<>(); \\n        \\n        int sum = 0, size = 0;\\n        ListNode node = head;\\n        map.put(0, null);\\n        \\n        while (node != null) {            \\n            sum += node.val;\\n            \\n            //if sum == 0, remove all prev visited nodes, start head from here\\n            if (sum == 0) {\\n                head = node.next;\\n            } else if (map.containsKey(sum)) {\\n                //skip over these nodes that add up to sum \\n                ListNode prev = map.get(sum);\\n                prev.next = node.next;\\n            } else {\\n                map.put(sum, node);\\n            }            \\n            node = node.next;\\n            size++;\\n        }\\n        \\n        if (prevSize == size)\\n            return head;    \\n        \\n        return remove(head, size);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 701426,
                "title": "c-solution-with-recursive-way",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* getSum(struct ListNode* head){\\n    struct ListNode *node = head;\\n    int sum = 0;\\n    while(node){\\n        sum+=node->val;\\n        if(sum == 0) return node;\\n        node = node->next;\\n    }\\n    return node;\\n}\\n\\n\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    struct ListNode *tmpHead, *node,*prev, *ret;\\n    tmpHead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    tmpHead->val = -2000;\\n    tmpHead->next = head;\\n    while(1){\\n        prev = tmpHead;\\n        node = tmpHead->next;\\n        int f = 0;\\n        while(node){\\n            ret = getSum(node);\\n            if(ret){\\n                prev->next = ret->next;\\n                f = 1;\\n                break;\\n            } else{\\n                prev = node;\\n                node = node->next;\\n            }\\n        }\\n        if(f ==  0) break;\\n    }\\n    \\n    return tmpHead->next;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     struct ListNode *next;\\n * };\\n */\\n\\n\\nstruct ListNode* getSum(struct ListNode* head){\\n    struct ListNode *node = head;\\n    int sum = 0;\\n    while(node){\\n        sum+=node->val;\\n        if(sum == 0) return node;\\n        node = node->next;\\n    }\\n    return node;\\n}\\n\\n\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    struct ListNode *tmpHead, *node,*prev, *ret;\\n    tmpHead = (struct ListNode*)malloc(sizeof(struct ListNode));\\n    tmpHead->val = -2000;\\n    tmpHead->next = head;\\n    while(1){\\n        prev = tmpHead;\\n        node = tmpHead->next;\\n        int f = 0;\\n        while(node){\\n            ret = getSum(node);\\n            if(ret){\\n                prev->next = ret->next;\\n                f = 1;\\n                break;\\n            } else{\\n                prev = node;\\n                node = node->next;\\n            }\\n        }\\n        if(f ==  0) break;\\n    }\\n    \\n    return tmpHead->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 698068,
                "title": "java-no-hashmaps-used-easy-solution-o-n-2-beats-81-time-82-space",
                "content": "\\tpublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummyH = new ListNode(0, head);\\n        ListNode curr = dummyH;\\n        while(curr != null) {\\n            int sum = 0;\\n            while(head != null) {\\n                sum += head.val;\\n                if(sum == 0)    curr.next = head.next;\\n                head = head.next;\\n            }\\n            curr = curr.next;\\n            if(curr != null)    head = curr.next;\\n        }\\n        return dummyH.next;\\n    }",
                "solutionTags": [
                    "Linked List"
                ],
                "code": "\\tpublic ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummyH = new ListNode(0, head);\\n        ListNode curr = dummyH;\\n        while(curr != null) {\\n            int sum = 0;\\n            while(head != null) {\\n                sum += head.val;\\n                if(sum == 0)    curr.next = head.next;\\n                head = head.next;\\n            }\\n            curr = curr.next;\\n            if(curr != null)    head = curr.next;\\n        }\\n        return dummyH.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 643211,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head==NULL)\\n            return 0;\\n        unordered_map<int,ListNode*> um;\\n        int presum=0;\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        um[0]=dummy;\\n        while(head!=NULL)\\n        {\\n            presum+=head->val;\\n            if(um.find(presum)!=um.end())\\n            {\\n                ListNode*prev=um[presum];\\n                // ListNode* start=prev;\\n                int sum=presum;\\n                while(prev!=NULL&&prev!=head)\\n                {\\n                    prev=prev->next;\\n                    sum+=prev->val;\\n                    if(prev!=head)\\n                        um.erase(sum);\\n                }\\n                um[presum]->next=head->next;\\n            }\\n            else\\n                um[presum]=head;\\n            // if(head)\\n            head=head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```\\nSuggestions are welcome.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if(head==NULL)\\n            return 0;\\n        unordered_map<int,ListNode*> um;\\n        int presum=0;\\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        um[0]=dummy;\\n        while(head!=NULL)\\n        {\\n            presum+=head->val;\\n            if(um.find(presum)!=um.end())\\n            {\\n                ListNode*prev=um[presum];\\n                // ListNode* start=prev;\\n                int sum=presum;\\n                while(prev!=NULL&&prev!=head)\\n                {\\n                    prev=prev->next;\\n                    sum+=prev->val;\\n                    if(prev!=head)\\n                        um.erase(sum);\\n                }\\n                um[presum]->next=head->next;\\n            }\\n            else\\n                um[presum]=head;\\n            // if(head)\\n            head=head->next;\\n        }\\n        return dummy->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549912,
                "title": "c-8ms",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n      \\n        ListNode *prev,*cur,*start,*next;\\n        \\n        start=new ListNode(0);\\n        start->next=head;\\n        prev=start;\\n        cur=head;\\n        \\n        int sum=0;\\n        while(cur)\\n        {\\n            \\n            sum=sum+cur->val;\\n            \\n            if(sum==0)\\n            {\\n                prev->next=cur->next;\\n               \\n            }\\n             cur=cur->next;\\n            if(cur==NULL)\\n            {\\n                prev=prev->next;\\n                if(prev==NULL) break;\\n                cur=prev->next;\\n                sum=0;\\n            }\\n           \\n        }\\n        \\n        \\n        \\n        \\n        return start->next;\\n        \\n        \\n    }\\n};\\n\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n      \\n        ListNode *prev,*cur,*start,*next;\\n        \\n        start=new ListNode(0);\\n        start->next=head;\\n        prev=start;\\n        cur=head;\\n        \\n        int sum=0;\\n        while(cur)\\n        {\\n            \\n            sum=sum+cur->val;\\n            \\n            if(sum==0)\\n            {\\n                prev->next=cur->next;\\n               \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 489912,
                "title": "swift-o-n-solution",
                "content": "```\\nclass Solution {\\n    func removeZeroSumSublists(_ head: ListNode?) -> ListNode? {\\n        var map:[Int:ListNode] = [:]\\n        let dummy = ListNode(0)\\n        dummy.next = head\\n        var node:ListNode? = dummy\\n        var total = 0\\n        while node != nil {\\n            total += node!.val\\n            map[total] = node\\n            node = node?.next\\n        }\\n        \\n        total = 0\\n        node = dummy\\n        while node != nil {\\n            total += node!.val\\n            node!.next = map[total]?.next\\n            node = node?.next\\n        }\\n        return dummy.next\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func removeZeroSumSublists(_ head: ListNode?) -> ListNode? {\\n        var map:[Int:ListNode] = [:]\\n        let dummy = ListNode(0)\\n        dummy.next = head\\n        var node:ListNode? = dummy\\n        var total = 0\\n        while node != nil {\\n            total += node!.val\\n            map[total] = node\\n            node = node?.next\\n        }\\n        \\n        total = 0\\n        node = dummy\\n        while node != nil {\\n            total += node!.val\\n            node!.next = map[total]?.next\\n            node = node?.next\\n        }\\n        return dummy.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389737,
                "title": "c-solution-beat-100-using-array-and-running-sum",
                "content": "1. Convert linked list to array, **arr**, and get the running sum of the array, store in **sum**.\\n2. Use 2 pointer, **i** and **j**.\\n\\t**i** from front to back, and **j** from back to front, checking if there is a **j** that **sum[i] == sum[j]**.\\n\\tif **i == j**, which means there is no subarray with 0 sum starting from i, put i to the linked list to return.\\n\\tif **i != j**, all the numbers [i..j - 1] can be removed. Let **i = j**.\\n\\n```/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        vector<int> arr, sum = {0};\\n        ListNode* ptr = head;\\n        while(ptr) \\n        {\\n            arr.push_back(ptr->val);\\n            sum.push_back(sum.back() + ptr->val);\\n            ptr = ptr->next;\\n        }\\n        \\n        ListNode* ret = new ListNode(0);   \\n        ptr = ret;\\n        int i = 0;\\n        int n = sum.size();\\n        while(i < n - 1)\\n        {\\n            int j = n - 1;\\n            for(; j > i; --j)\\n            {\\n                if(sum[i] == sum[j]) break;\\n            }\\n            if(j == i)\\n            {\\n                ptr->next = new ListNode(arr[i]);\\n                ptr = ptr->next;\\n                i++;\\n            }\\n            else i = j;\\n        }\\n        return ret->next;\\n    }\\n};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n{\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        vector<int> arr, sum = {0}",
                "codeTag": "Java"
            },
            {
                "id": 367374,
                "title": "cpp-violent-solution",
                "content": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\t\\n        auto dummy = new ListNode(-1);\\n        dummy->next = head;\\n        auto p = dummy;\\n        while(p)\\n        {\\n            int sum = 0;\\n            bool flag = false;\\n            auto q = p->next;\\n            \\n            while(q)\\n            {\\n                sum += q->val;\\n                if(sum == 0)\\n                {\\n                    p->next = q->next;\\n                    flag = true;\\n                    break;\\n                }\\n                q = q->next;\\n            }\\n            if(!flag)\\n                p = p->next;\\n        }\\n        \\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\t\\n        auto dummy = new ListNode(-1);\\n        dummy->next = head;\\n        auto p = dummy;\\n        while(p)\\n        {\\n            int sum = 0;\\n            bool flag = false;\\n            auto q = p->next;\\n            \\n            while(q)\\n            {\\n                sum += q->val;\\n                if(sum == 0)\\n                {\\n                    p->next = q->next;\\n                    flag = true;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 366711,
                "title": "python-o-n-amazing-d",
                "content": "Short and elegant skip problem with hash map:\\n\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        s = 0\\n        cur = head\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        d = {0: dummy}\\n        \\n        while cur:\\n            s += cur.val\\n            if s not in d:\\n                d[s] = cur\\n            else:\\n                d[s].next = cur.next\\n            cur = cur.next\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        s = 0\\n        cur = head\\n        \\n        dummy = ListNode(0)\\n        dummy.next = head\\n        d = {0: dummy}\\n        \\n        while cur:\\n            s += cur.val\\n            if s not in d:\\n                d[s] = cur\\n            else:\\n                d[s].next = cur.next\\n            cur = cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4054419,
                "title": "best-java-solution-beats-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    // taken help\\n    \\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int sum = 0;\\n    ListNode dm = new ListNode(0);\\n    dm.next = head;\\n\\n    Map<Integer, ListNode> mp = new HashMap<>();\\n    mp.put(0, dm);\\n\\n\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        mp.put(sum, i);\\n    }\\n\\n\\n    sum = 0;\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        i.next = mp.get( sum ).next;\\n    }\\n    \\n    return dm.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n\\n    // taken help\\n    \\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        int sum = 0;\\n    ListNode dm = new ListNode(0);\\n    dm.next = head;\\n\\n    Map<Integer, ListNode> mp = new HashMap<>();\\n    mp.put(0, dm);\\n\\n\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        mp.put(sum, i);\\n    }\\n\\n\\n    sum = 0;\\n    for (ListNode i = dm; i != null; i = i.next) {\\n        sum += i.val;\\n        i.next = mp.get( sum ).next;\\n    }\\n    \\n    return dm.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3043979,
                "title": "c-using-map",
                "content": "\\n### Code\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *curr = head;\\n\\n        map<int, ListNode*> m;\\n        m[0] = dummy;\\n\\n        int prefix = 0;\\n        while(curr) {\\n            prefix += curr -> val;\\n\\n            if(m.count(prefix)) {\\n                ListNode *p = m[prefix] -> next;\\n                int val = prefix;\\n                while(p != curr) {\\n                    val += p -> val;\\n                    m.erase(val);\\n                    p = p -> next;\\n                }\\n                m[prefix] -> next = curr -> next;\\n                \\n            }else {\\n                m[prefix] = curr;\\n            }\\n            curr = curr -> next;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *dummy = new ListNode(0);\\n        dummy -> next = head;\\n        ListNode *curr = head;\\n\\n        map<int, ListNode*> m;\\n        m[0] = dummy;\\n\\n        int prefix = 0;\\n        while(curr) {\\n            prefix += curr -> val;\\n\\n            if(m.count(prefix)) {\\n                ListNode *p = m[prefix] -> next;\\n                int val = prefix;\\n                while(p != curr) {\\n                    val += p -> val;\\n                    m.erase(val);\\n                    p = p -> next;\\n                }\\n                m[prefix] -> next = curr -> next;\\n                \\n            }else {\\n                m[prefix] = curr;\\n            }\\n            curr = curr -> next;\\n        }\\n        \\n        return dummy -> next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617727,
                "title": "c-easy-solution-using-recursion-easy-understanding",
                "content": "**pls upvote if it helps**\\n\\n```\\nListNode* solve(ListNode* head , bool & anychange){\\n        \\n        if(head == NULL){\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        int sum = 0;\\n        \\n        while(temp != NULL){\\n            sum+=temp->val;\\n            if(sum == 0)\\n                break;\\n            temp = temp->next;\\n        }\\n        if(sum == 0){\\n            anychange = true;\\n            return temp->next;\\n        }\\n        head->next = solve(head->next,anychange);\\n        return head;\\n    }\\n    \\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        while(true){\\n            bool anychange = false;\\n            head = solve(head , anychange);\\n            \\n            if(head == NULL || anychange == false)\\n                break;\\n        }\\n            \\n            return head;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\nListNode* solve(ListNode* head , bool & anychange){\\n        \\n        if(head == NULL){\\n            return head;\\n        }\\n        ListNode* temp = head;\\n        int sum = 0;\\n        \\n        while(temp != NULL){\\n            sum+=temp->val;\\n            if(sum == 0)\\n                break;\\n            temp = temp->next;\\n        }\\n        if(sum == 0){\\n            anychange = true;\\n            return temp->next;\\n        }\\n        head->next = solve(head->next,anychange);\\n        return head;\\n    }\\n    \\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        while(true){\\n            bool anychange = false;\\n            head = solve(head , anychange);\\n            \\n            if(head == NULL || anychange == false)\\n                break;\\n        }\\n            \\n            return head;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2574319,
                "title": "c-hashmap-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void deleteNodes(int sum,ListNode* start,ListNode* end,unordered_map<int,ListNode*>&mp)\\n    {\\n        ListNode* cur = start;\\n        while(cur != end)\\n        {\\n            sum += cur->val;\\n            mp.erase(sum);\\n            cur = cur->next;\\n        }\\n    }\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        unordered_map<int,ListNode*>mp; \\n        mp[0] = NULL;\\n        ListNode* cur = head;\\n        int sum = 0;\\n        while(cur)\\n        {\\n            sum += cur->val;\\n            if(mp.find(sum) == mp.end())\\n                mp[sum] = cur;\\n            else\\n            {\\n                if(sum == 0)\\n                {\\n                    deleteNodes(0,head,cur,mp);\\n                    head = cur->next;\\n                }\\n                else\\n                {\\n                    deleteNodes(sum,mp[sum]->next,cur,mp);\\n                    mp[sum]->next = cur->next;\\n                }\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void deleteNodes(int sum,ListNode* start,ListNode* end,unordered_map<int,ListNode*>&mp)\\n    {\\n        ListNode* cur = start;\\n        while(cur != end)\\n        {\\n            sum += cur->val;\\n            mp.erase(sum);\\n            cur = cur->next;\\n        }\\n    }\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        unordered_map<int,ListNode*>mp; \\n        mp[0] = NULL;\\n        ListNode* cur = head;\\n        int sum = 0;\\n        while(cur)\\n        {\\n            sum += cur->val;\\n            if(mp.find(sum) == mp.end())\\n                mp[sum] = cur;\\n            else\\n            {\\n                if(sum == 0)\\n                {\\n                    deleteNodes(0,head,cur,mp);\\n                    head = cur->next;\\n                }\\n                else\\n                {\\n                    deleteNodes(sum,mp[sum]->next,cur,mp);\\n                    mp[sum]->next = cur->next;\\n                }\\n            }\\n            cur = cur->next;\\n        }\\n        return head;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2562923,
                "title": "beginners-approach-memory-leak-warning",
                "content": "class Solution {\\npublic:\\n     ListNode* solve(ListNode* head,bool & change)\\n     {   if(head==NULL) return head;\\n             ListNode*  temp=head;\\n             int sum=0;\\n         while(temp!=NULL)\\n         {\\n             sum=sum+temp->val;\\n             if(sum==0)\\n             {\\n             break;\\n             }\\n             temp=temp->next;\\n         }\\n         \\n         if(sum==0)\\n         {\\n             change=true;\\n             return \\n                 temp->next;\\n         }\\n         \\n         head->next=solve(head->next,change);\\n         \\n         return head;\\n     }\\n    \\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        bool change=false;\\n        \\n        while(true)\\n        {\\n            bool change=false;\\n            head=solve(head,change);\\n            if(head==NULL || change==false) break;\\n            \\n            \\n        }\\n        return head;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     ListNode* solve(ListNode* head,bool & change)\\n     {   if(head==NULL) return head;\\n             ListNode*  temp=head;\\n             int sum=0;\\n         while(temp!=NULL)\\n         {\\n             sum=sum+temp->val;\\n             if(sum==0)\\n             {\\n             break;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2544396,
                "title": "c-o-n-using-prefixsum-and-node-address",
                "content": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        map<int,ListNode*>mp;\\n        ListNode *start,*temp;\\n        int sum=0,total;\\n        start=head;\\n        while(start!=NULL)\\n        {\\n            sum=sum+start->val;\\n            if(sum==0)\\n            {\\n                head=start->next;\\n                mp.clear();\\n                \\n            }\\n            else if(mp[sum])\\n            {\\n                temp=mp[sum];\\n                temp=temp->next;\\n                total=sum;\\n                while(temp!=start)\\n                {\\n                mp.erase(total+temp->val);\\n                    total=total+temp->val;\\n                    temp=temp->next;\\n                }\\n                mp[sum]->next=start->next;   \\n            }\\n            else\\n                mp[sum]=start;\\n            start=start->next;\\n            \\n        }\\n        \\n    return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        map<int,ListNode*>mp;\\n        ListNode *start,*temp;\\n        int sum=0,total;\\n        start=head;\\n        while(start!=NULL)\\n        {\\n            sum=sum+start->val;\\n            if(sum==0)\\n            {\\n                head=start->next;\\n                mp.clear();\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2471376,
                "title": "c-o-n-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        std::unordered_map<int, ListNode*> prefix;\\n        ListNode *dummyNode = new ListNode(0, head);\\n        int sum = 0;\\n        prefix[0] = dummyNode;\\n        while(head)\\n        {\\n            sum += head->val;\\n            prefix[sum] = head;\\n            head = head->next;\\n        }\\n        sum = 0;\\n        head = dummyNode;\\n        while(head)\\n        {\\n            sum += head->val;\\n            if(prefix[sum] != head)\\n            {\\n                head->next = prefix[sum]->next;\\n            }\\n            head = head->next;\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        std::unordered_map<int, ListNode*> prefix;\\n        ListNode *dummyNode = new ListNode(0, head);\\n        int sum = 0;\\n        prefix[0] = dummyNode;\\n        while(head)\\n        {\\n            sum += head->val;\\n            prefix[sum] = head;\\n            head = head->next;\\n        }\\n        sum = 0;\\n        head = dummyNode;\\n        while(head)\\n        {\\n            sum += head->val;\\n            if(prefix[sum] != head)\\n            {\\n                head->next = prefix[sum]->next;\\n            }\\n            head = head->next;\\n        }\\n        return dummyNode->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454452,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        ListNode* dummy = new ListNode(0);\\n        \\n        dummy->next = head;\\n        \\n        int presum = 0;\\n        \\n        unordered_map<int,ListNode*> mp;\\n        \\n        mp[0] = dummy;\\n        \\n        while(head)\\n        {\\n           \\n            presum += head->val;\\n            \\n            if(mp.count(presum))\\n            {\\n              ListNode* tmp = mp[presum];\\n                \\n              int sum = presum;\\n                \\n              while(tmp && tmp != head)\\n              {\\n                  tmp = tmp->next;\\n                  \\n                  sum += tmp->val;\\n                  \\n                  if(tmp != head)\\n                  {\\n                      mp.erase(sum);\\n                  }\\n                  \\n              }\\n                \\n             mp[presum]->next = head->next;\\n            }\\n            \\n            else\\n            {\\n                mp[presum] = head;\\n            }\\n            \\n            head = head->next;\\n        }\\n        \\n        return dummy->next;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        ListNode* dummy = new ListNode(0);\\n        \\n        dummy->next = head;\\n        \\n        int presum = 0;\\n        \\n        unordered_map<int,ListNode*> mp;\\n        \\n        mp[0] = dummy;\\n        \\n        while(head)\\n        {\\n           \\n            presum += head->val;\\n            \\n            if(mp.count(presum))\\n            {\\n              ListNode* tmp = mp[presum];\\n                \\n              int sum = presum;\\n                \\n              while(tmp && tmp != head)\\n              {\\n                  tmp = tmp->next;\\n                  \\n                  sum += tmp->val;\\n                  \\n                  if(tmp != head)\\n                  {\\n                      mp.erase(sum);\\n                  }",
                "codeTag": "Java"
            },
            {
                "id": 2400384,
                "title": "cpp-beginner-friendly-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n       vector<int>nums;\\n       for(auto node = head; node; node = node->next){\\n           int value = node->val;\\n           nums.push_back(value);\\n       }\\n       int n = nums.size();\\n        \\n       vector<vector<int>>values(n,vector<int>(3,-1));\\n       for(int i=0;i<n;i++){\\n           int sum = 0;\\n           for(int j=i;j<n;j++){\\n               sum += nums[j];\\n               \\n               if(sum == 0){\\n                   values[i] = {0,i,j};\\n               }\\n           }\\n       }\\n        \\n       \\n        \\n       ListNode* actualHead = new ListNode(-1);\\n       ListNode* root = actualHead;\\n        \\n       for(int i = 0; i<n;i++){\\n           if(values[i][0] == 0){\\n               i = values[i][2];\\n               continue;\\n           }\\n           root->next = new ListNode(nums[i]);\\n           root = root->next;\\n       }\\n       return actualHead->next;\\n       // return head;\\n    }\\n};\\n\\n//  The approach here is that we are skipping those subarrays whose sum is zero\\n// Thank you : ) Please do upvote so that needy one can find over the top\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n       vector<int>nums;\\n       for(auto node = head; node; node = node->next){\\n           int value = node->val;\\n           nums.push_back(value);\\n       }\\n       int n = nums.size();\\n        \\n       vector<vector<int>>values(n,vector<int>(3,-1));\\n       for(int i=0;i<n;i++){\\n           int sum = 0;\\n           for(int j=i;j<n;j++){\\n               sum += nums[j];\\n               \\n               if(sum == 0){\\n                   values[i] = {0,i,j};\\n               }\\n           }\\n       }\\n        \\n       \\n        \\n       ListNode* actualHead = new ListNode(-1);\\n       ListNode* root = actualHead;\\n        \\n       for(int i = 0; i<n;i++){\\n           if(values[i][0] == 0){\\n               i = values[i][2];\\n               continue;\\n           }\\n           root->next = new ListNode(nums[i]);\\n           root = root->next;\\n       }\\n       return actualHead->next;\\n       // return head;\\n    }\\n};\\n\\n//  The approach here is that we are skipping those subarrays whose sum is zero\\n// Thank you : ) Please do upvote so that needy one can find over the top\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2364153,
                "title": "java-easy-approach-short-solution",
                "content": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        ListNode preHead = new ListNode(0);\\n        preHead.next = head;\\n        int sum = 0;\\n        for(ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            map.put(sum, p);\\n        }\\n        sum = 0;\\n        for(ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            p.next = map.get(sum).next;\\n        }\\n        return preHead.next;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        ListNode preHead = new ListNode(0);\\n        preHead.next = head;\\n        int sum = 0;\\n        for(ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            map.put(sum, p);\\n        }\\n        sum = 0;\\n        for(ListNode p = preHead; p != null; p = p.next) {\\n            sum += p.val;\\n            p.next = map.get(sum).next;\\n        }\\n        return preHead.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2291804,
                "title": "prefixsum-approch",
                "content": "```\\nListNode*deleteVal(ListNode*head,ListNode*curr,ListNode*last){\\n        if(curr==nullptr)\\n                return last->next;\\n        else\\n            curr->next=last->next;\\n        return head;\\n    }\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode*temp=head;\\n        unordered_map<int,ListNode*>mp;\\n        int sum=0;\\n        while(temp!=nullptr){\\n            sum+=temp->val;\\n            if(sum==0){\\n                int t=0;\\n                ListNode*tt=head;\\n                while(tt!=temp){\\n                    t+=tt->val;\\n                    mp.erase(t);\\n                    tt=tt->next;\\n                    cout<<t<<endl;\\n                }\\n               head=deleteVal(head,nullptr,temp);\\n            }\\n            if(mp.find(sum)!=mp.end()){\\n                  int t=sum;\\n                ListNode*tt=mp[sum]->next;\\n                while(tt!=temp){\\n                    t+=tt->val;\\n                    mp.erase(t);\\n                    tt=tt->next;\\n                }\\n                 // cout<<sum<<\" \"<<head->val<<\" \"<<mp[sum]->val<<endl;\\n               head=deleteVal(head,mp[sum],temp);\\n            }\\n            else{\\n                mp[sum]=temp;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "solutionTags": [
                    "Linked List",
                    "Prefix Sum"
                ],
                "code": "```\\nListNode*deleteVal(ListNode*head,ListNode*curr,ListNode*last){\\n        if(curr==nullptr)\\n                return last->next;\\n        else\\n            curr->next=last->next;\\n        return head;\\n    }\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode*temp=head;\\n        unordered_map<int,ListNode*>mp;\\n        int sum=0;\\n        while(temp!=nullptr){\\n            sum+=temp->val;\\n            if(sum==0){\\n                int t=0;\\n                ListNode*tt=head;\\n                while(tt!=temp){\\n                    t+=tt->val;\\n                    mp.erase(t);\\n                    tt=tt->next;\\n                    cout<<t<<endl;\\n                }\\n               head=deleteVal(head,nullptr,temp);\\n            }\\n            if(mp.find(sum)!=mp.end()){\\n                  int t=sum;\\n                ListNode*tt=mp[sum]->next;\\n                while(tt!=temp){\\n                    t+=tt->val;\\n                    mp.erase(t);\\n                    tt=tt->next;\\n                }\\n                 // cout<<sum<<\" \"<<head->val<<\" \"<<mp[sum]->val<<endl;\\n               head=deleteVal(head,mp[sum],temp);\\n            }\\n            else{\\n                mp[sum]=temp;\\n            }\\n            temp=temp->next;\\n        }\\n        return head;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2263816,
                "title": "python-sol-well-explained-hashmap-prefix-sum-easy-fast",
                "content": "# EXPLANATION\\n```\\n1. How do we know that any substring will have sum = 0\\n2. The idea is if any prefix sum that had occured before occurs again we know that sum of substring\\nbetween them is = 0\\nexample        [ 1,4,2,5,-7]\\nsum will be   [ 1,5,7,12,5] \\nSO 5 occurs twice i.e. sum of [2,5,-7] is 0\\nso we simply make 4.next = 7.next in linklist to remove [2,5,-7]\\nalso we remove [2,5,-7] as node if is in hashmap\\n```\\n\\n\\n\\n\\n# CODE\\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        root = ListNode(0,head)\\n        summ , d , node = 0 , {} , root\\n        while node:\\n            summ += node.val\\n            if summ in d:\\n                prev = d[summ]\\n                tmp = prev.next\\n                tmp_sum = summ\\n                while tmp != node:\\n                    tmp_sum += tmp.val\\n                    if tmp_sum in d and d[tmp_sum] == tmp :d.pop(tmp_sum)\\n                    tmp = tmp.next\\n                prev.next = node.next\\n                node = prev\\n            else:\\n                d[summ] = node\\n            node = node.next\\n        \\n        return root.next\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n1. How do we know that any substring will have sum = 0\\n2. The idea is if any prefix sum that had occured before occurs again we know that sum of substring\\nbetween them is = 0\\nexample        [ 1,4,2,5,-7]\\nsum will be   [ 1,5,7,12,5] \\nSO 5 occurs twice i.e. sum of [2,5,-7] is 0\\nso we simply make 4.next = 7.next in linklist to remove [2,5,-7]\\nalso we remove [2,5,-7] as node if is in hashmap\\n```\n```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        root = ListNode(0,head)\\n        summ , d , node = 0 , {} , root\\n        while node:\\n            summ += node.val\\n            if summ in d:\\n                prev = d[summ]\\n                tmp = prev.next\\n                tmp_sum = summ\\n                while tmp != node:\\n                    tmp_sum += tmp.val\\n                    if tmp_sum in d and d[tmp_sum] == tmp :d.pop(tmp_sum)\\n                    tmp = tmp.next\\n                prev.next = node.next\\n                node = prev\\n            else:\\n                d[summ] = node\\n            node = node.next\\n        \\n        return root.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259780,
                "title": "c-easy-to-understand-prefix-sum-with-hashmap",
                "content": "Problem similar to [560. Subarray-sum-equals-k](https://leetcode.com/problems/subarray-sum-equals-k/)\\nBut here it is Linked list instead of array.\\n\\n**Please Upvote. If It has helped you :)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode dummy(0);\\n        dummy.next = head;\\n        \\n        bool sumZeroFound = true;\\n        \\n        while(sumZeroFound){ // we need to check is new list still have zero sum\\n            sumZeroFound = false; // reset \\n            \\n            ListNode* iter = &dummy;\\n            unordered_map<int, ListNode*> prefixSumTable;\\n            prefixSumTable.insert({0, iter});\\n            iter = iter->next; // start from head node\\n            int currSum = 0;\\n\\n            while(iter){\\n                currSum += iter->val;\\n                if(prefixSumTable.find(currSum) != prefixSumTable.end()){\\n                    ListNode* start = prefixSumTable[currSum];\\n                    start->next = iter->next;\\n                    sumZeroFound = true; /// there will be changes in list\\n                }else{\\n                    prefixSumTable.insert({currSum, iter});\\n                }\\n                iter = iter->next;\\n            }\\n        }\\n        \\n        return dummy.next;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode dummy(0);\\n        dummy.next = head;\\n        \\n        bool sumZeroFound = true;\\n        \\n        while(sumZeroFound){ // we need to check is new list still have zero sum\\n            sumZeroFound = false; // reset \\n            \\n            ListNode* iter = &dummy;\\n            unordered_map<int, ListNode*> prefixSumTable;\\n            prefixSumTable.insert({0, iter}",
                "codeTag": "Java"
            },
            {
                "id": 2151121,
                "title": "c-solution-based-on-hashmap",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        unordered_map<int, ListNode*> prefix_sum_to_node;\\n        if (head == nullptr){\\n            return nullptr;\\n        }\\n        ListNode* guard = new ListNode(0);\\n        guard->next = head;\\n        head = guard;\\n   \\n        ListNode* p = head;\\n        int prefix_sum = 0;\\n        bool happen_change = false;\\n        while(p != nullptr){\\n            prefix_sum += p->val;\\n            if (prefix_sum_to_node.count(prefix_sum) == 0){\\n                prefix_sum_to_node.insert({prefix_sum, p});\\n            }\\n            else{\\n                happen_change = true;\\n                // the prefix sum has already been occured:\\n                ListNode* pre_p = prefix_sum_to_node[prefix_sum];\\n                // the nodes from pre_p->next to p can be deleted\\n                ListNode* next_p = p->next;\\n                pre_p->next = next_p;\\n                p = pre_p;\\n            }\\n            p = p->next;\\n        }\\n        while(head != nullptr){\\n            if (head->val == 0){\\n                head = head->next;    \\n            }\\n            else{\\n                break;\\n            } \\n        }        \\n        if (happen_change){\\n            return removeZeroSumSublists(head);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        unordered_map<int, ListNode*> prefix_sum_to_node;\\n        if (head == nullptr){\\n            return nullptr;\\n        }\\n        ListNode* guard = new ListNode(0);\\n        guard->next = head;\\n        head = guard;\\n   \\n        ListNode* p = head;\\n        int prefix_sum = 0;\\n        bool happen_change = false;\\n        while(p != nullptr){\\n            prefix_sum += p->val;\\n            if (prefix_sum_to_node.count(prefix_sum) == 0){\\n                prefix_sum_to_node.insert({prefix_sum, p});\\n            }\\n            else{\\n                happen_change = true;\\n                // the prefix sum has already been occured:\\n                ListNode* pre_p = prefix_sum_to_node[prefix_sum];\\n                // the nodes from pre_p->next to p can be deleted\\n                ListNode* next_p = p->next;\\n                pre_p->next = next_p;\\n                p = pre_p;\\n            }\\n            p = p->next;\\n        }\\n        while(head != nullptr){\\n            if (head->val == 0){\\n                head = head->next;    \\n            }\\n            else{\\n                break;\\n            } \\n        }        \\n        if (happen_change){\\n            return removeZeroSumSublists(head);\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2118437,
                "title": "use-dummy-variable-to-avoid-edge-cases-java-hashmap",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> hash = new HashMap<>();\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head; \\n        ListNode curr = dummy;\\n        int sum = 0; \\n        while (curr != null){\\n            sum += curr.val;\\n            hash.put(sum, curr.next);\\n            curr = curr.next; \\n        }\\n        hash.put(sum, null);\\n        curr = dummy;\\n        int tp = 0; \\n        while (curr != null){\\n            tp += curr.val;\\n            if (hash.containsKey(tp)){\\n                curr.next = hash.get(tp);\\n            }\\n            curr = curr.next; \\n        }\\n        if (tp == 0) return null;\\n        return dummy.next; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> hash = new HashMap<>();\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head; \\n        ListNode curr = dummy;\\n        int sum = 0; \\n        while (curr != null){\\n            sum += curr.val;\\n            hash.put(sum, curr.next);\\n            curr = curr.next; \\n        }\\n        hash.put(sum, null);\\n        curr = dummy;\\n        int tp = 0; \\n        while (curr != null){\\n            tp += curr.val;\\n            if (hash.containsKey(tp)){\\n                curr.next = hash.get(tp);\\n            }\\n            curr = curr.next; \\n        }\\n        if (tp == 0) return null;\\n        return dummy.next; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2071910,
                "title": "c-o-n-s-n-14ms-faster-than-66-10-8mb-less-than-88",
                "content": "Runtime: 14 ms, faster than 66.67% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\nMemory Usage: 10.8 MB, less than 87.90% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        std::vector<int> arr;\\n        buildArray(head, arr);\\n        removeZeroSumSegment(arr);\\n        \\n        ListNode* prev = nullptr;\\n        ListNode* cur = head;\\n        for (int n : arr)\\n        {\\n            cur->val = n;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        if (!prev)\\n            return nullptr;\\n        else\\n            prev->next = nullptr;\\n        \\n        return head;\\n    }\\nprivate:\\n    void buildArray(ListNode* head, std::vector<int>& arr)\\n    {\\n        while (head)\\n        {\\n            arr.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    void removeZeroSumSegment(std::vector<int>& arr)\\n    {\\n        std::vector<int> sum(arr.begin(), arr.end());\\n        for (int i = 1; i < sum.size(); i++)\\n            sum[i] += sum[i - 1];\\n        \\n        std::vector<std::pair<int, int>> zeroSegments;\\n        int is = 0;\\n        while (is < sum.size())\\n        {\\n            for (int i = sum.size() - 1; i >= is; i--)\\n            {\\n                if (sum[i] - sum[is] + arr[is] == 0)\\n                {\\n                    zeroSegments.push_back({ is, i + 1 });\\n                    is = i;\\n                    break;\\n                }\\n            }\\n            \\n            is++;\\n        }\\n        \\n        for (int i = zeroSegments.size() - 1; i >= 0; i--)\\n        {\\n            arr.erase(arr.begin() + zeroSegments[i].first, arr.begin() + zeroSegments[i].second);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution \\n{\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        std::vector<int> arr;\\n        buildArray(head, arr);\\n        removeZeroSumSegment(arr);\\n        \\n        ListNode* prev = nullptr;\\n        ListNode* cur = head;\\n        for (int n : arr)\\n        {\\n            cur->val = n;\\n            prev = cur;\\n            cur = cur->next;\\n        }\\n        if (!prev)\\n            return nullptr;\\n        else\\n            prev->next = nullptr;\\n        \\n        return head;\\n    }\\nprivate:\\n    void buildArray(ListNode* head, std::vector<int>& arr)\\n    {\\n        while (head)\\n        {\\n            arr.push_back(head->val);\\n            head = head->next;\\n        }\\n    }\\n    \\n    void removeZeroSumSegment(std::vector<int>& arr)\\n    {\\n        std::vector<int> sum(arr.begin(), arr.end());\\n        for (int i = 1; i < sum.size(); i++)\\n            sum[i] += sum[i - 1];\\n        \\n        std::vector<std::pair<int, int>> zeroSegments;\\n        int is = 0;\\n        while (is < sum.size())\\n        {\\n            for (int i = sum.size() - 1; i >= is; i--)\\n            {\\n                if (sum[i] - sum[is] + arr[is] == 0)\\n                {\\n                    zeroSegments.push_back({ is, i + 1 });\\n                    is = i;\\n                    break;\\n                }\\n            }\\n            \\n            is++;\\n        }\\n        \\n        for (int i = zeroSegments.size() - 1; i >= 0; i--)\\n        {\\n            arr.erase(arr.begin() + zeroSegments[i].first, arr.begin() + zeroSegments[i].second);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2023190,
                "title": "java-without-hashmap-o-n-2",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy=new ListNode(0,head);\\n        ListNode prev=dummy;\\n\\t\\t\\n        while(prev!=null)\\n        {\\n            int sum=0;\\n            while(head!=null)\\n            {\\n                sum+=head.val;\\n                if(sum==0)\\n                {\\n                    prev.next=head.next;\\n                }\\n                head=head.next;\\n            }\\n            prev=prev.next;\\n            if(prev!=null)\\n            {\\n               head=prev.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy=new ListNode(0,head);\\n        ListNode prev=dummy;\\n\\t\\t\\n        while(prev!=null)\\n        {\\n            int sum=0;\\n            while(head!=null)\\n            {\\n                sum+=head.val;\\n                if(sum==0)\\n                {\\n                    prev.next=head.next;\\n                }\\n                head=head.next;\\n            }\\n            prev=prev.next;\\n            if(prev!=null)\\n            {\\n               head=prev.next;\\n            }\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1846075,
                "title": "c-solution-hashmap-prefix-sum",
                "content": "\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        \\n        map<int,ListNode*> m;\\n        \\n        int prefix_sum=0;\\n        \\n        m[0]=dummy;\\n        \\n        while(head)\\n        {\\n            prefix_sum+=head->val;\\n            \\n            //if prefix_sum is already seen,then erase all prefix_sum we got thereafter.\\n            if(m.find(prefix_sum)!=m.end())\\n            {  \\n                ListNode* temp=m[prefix_sum]->next;\\n                int temp_sum=prefix_sum;\\n                \\n                while(temp!=head)\\n                {\\n                    temp_sum+=temp->val;\\n                    m.erase(temp_sum);\\n                    temp=temp->next;\\n                }\\n                \\n                m[prefix_sum]->next=head->next;\\n            }\\n            else  m[prefix_sum]=head;\\n            \\n            head=head->next;\\n        }\\n       \\n        \\n        return dummy->next;\\n        \\n    }",
                "solutionTags": [],
                "code": "\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode* dummy=new ListNode(0);\\n        dummy->next=head;\\n        \\n        map<int,ListNode*> m;\\n        \\n        int prefix_sum=0;\\n        \\n        m[0]=dummy;\\n        \\n        while(head)\\n        {\\n            prefix_sum+=head->val;\\n            \\n            //if prefix_sum is already seen,then erase all prefix_sum we got thereafter.\\n            if(m.find(prefix_sum)!=m.end())\\n            {  \\n                ListNode* temp=m[prefix_sum]->next;\\n                int temp_sum=prefix_sum;\\n                \\n                while(temp!=head)\\n                {\\n                    temp_sum+=temp->val;\\n                    m.erase(temp_sum);\\n                    temp=temp->next;\\n                }\\n                \\n                m[prefix_sum]->next=head->next;\\n            }\\n            else  m[prefix_sum]=head;\\n            \\n            head=head->next;\\n        }\\n       \\n        \\n        return dummy->next;\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1794309,
                "title": "java-simple-and-short-solution-easy-to-understand-using-hashmap",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        \\n        map.put(0, new ListNode(-1));\\n        map.get(0).next = head;\\n        \\n        ListNode temp = head;\\n        int sum = 0;\\n        while(temp != null){\\n            sum += temp.val;\\n            \\n            // Sum value is coming again, there is subarray with sum zero, remove all these nodes \\n            if(map.containsKey(sum)){\\n                ListNode node = map.get(sum);\\n                ListNode next = node.next;\\n                \\n                int auxSum = sum;\\n                while(next != temp){\\n                    auxSum += next.val;\\n                    map.remove(auxSum);\\n                    next = next.next;\\n                }\\n                node.next = temp.next;\\n            }else{  map.put(sum, temp); }\\n            \\n            temp = temp.next;\\n        }\\n        \\n        return map.get(0).next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        \\n        map.put(0, new ListNode(-1));\\n        map.get(0).next = head;\\n        \\n        ListNode temp = head;\\n        int sum = 0;\\n        while(temp != null){\\n            sum += temp.val;\\n            \\n            // Sum value is coming again, there is subarray with sum zero, remove all these nodes \\n            if(map.containsKey(sum)){\\n                ListNode node = map.get(sum);\\n                ListNode next = node.next;\\n                \\n                int auxSum = sum;\\n                while(next != temp){\\n                    auxSum += next.val;\\n                    map.remove(auxSum);\\n                    next = next.next;\\n                }\\n                node.next = temp.next;\\n            }else{  map.put(sum, temp); }\\n            \\n            temp = temp.next;\\n        }\\n        \\n        return map.get(0).next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1719144,
                "title": "1ms-solution-faster-than-100-no-hashmap-explainations-easy",
                "content": "Idea is to skip the nodes that sum upto 0.\\nSteps: \\n1. Create a pseudo head say head1,  set head1.next = head (in case head is part of the sum=0 franchise : P )\\n2. Create a prev pointer , point it to head1 ( to maintain the head being part of zero sum condition )\\n3. Create temp pointer to traverse through the list \\n4. Traverse the list\\n5. for each iteration call skipZerosum(temp) function \\n6. it iterates through temp till the end of the list\\n7. if sum is found to be zero for a node , node.next is passed back to the parent function , to let it know until when to skip to\\n8. else temp is returned as it is\\n9. if retuned node from skipZerosum(temp) is not equal to temp , skip upto the node ( prev.next = node and temp = node )\\n10. else prev = temp , temp = temp.next\\n11. Return head.next\\n```\\n\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode head1 = new ListNode();\\n        head1.next = head;\\n        ListNode prev = head1;\\n        ListNode temp = head;\\n        while(temp!=null)\\n        {\\n            ListNode node = SkipZeroSum(temp);\\n            \\n            if(node!=temp)\\n            {\\n                prev.next = node;\\n                temp = node;\\n            }\\n            else\\n            {\\n                prev= temp;\\n                temp = temp.next;\\n            }\\n        }\\n        \\n        return head1.next;\\n        \\n    }\\n    \\n    public ListNode SkipZeroSum(ListNode node){\\n        \\n        int sum =0;\\n        ListNode temp = node;\\n        \\n        while(temp!=null)\\n        {\\n            sum+=temp.val;\\n            if(sum==0)\\n            {return temp.next;}\\n            else\\n            {temp=temp.next;}\\n        }\\n        return node;\\n \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode head1 = new ListNode();\\n        head1.next = head;\\n        ListNode prev = head1;\\n        ListNode temp = head;\\n        while(temp!=null)\\n        {\\n            ListNode node = SkipZeroSum(temp);\\n            \\n            if(node!=temp)\\n            {\\n                prev.next = node;\\n                temp = node;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1667395,
                "title": "java-linear-time-and-space-using-running-sum-to-check-for-zero-sum-sublist",
                "content": "```\\n/*\\nApproach: Keep a running sum upto everynode in a map, if the sum already exist in the map, then everything from the previous map value to current map value sums to zero and can be deleted from linked list. At the same time, we will remove the deleted nodes from map as well to prevent checking a deleted node sum.\\n\\nExample:\\n               a b c d  e  f g  i j\\nInput: head = [1,3,2,-3,-2,5,5,-5,1]\\n\\nOutput: a f j\\nThe map would be constructed as:\\n\\n1 : a\\n4: b\\n6: c\\n3: d\\n1: e ----- we need to delete everything from last seen 1(a) to 1(e), otherwise 6(c) would be double counted for \"f\" below\\n6:f\\n11:g\\n6:i ------- same thing, delete from \"f\"\\n7:j\\n\\n0 == delete upto current from head and take next node as head\\nif not, \\n    check if we have seen this sum before, if we have, then that must mean everything in between must sum to zero. e.g. (b+c+d+e)\\nelse,\\n    add the running sum with the assosiated node in the map\\n    \\nAnalysis: Linear time and space\\n\\n*/\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        Map<Integer, ListNode> sumNodeMap = new HashMap<>();\\n\\n        int sum = 0;\\n        ListNode node = head;\\n        while(node != null){\\n            sum += node.val;\\n            \\n            if(sum == 0){\\n                int presum = 0;\\n                removeSumStartsWith(head, node, presum, sumNodeMap); //update map\\n                head = node.next; //update linked list\\n            }else if(sumNodeMap.containsKey(sum)){\\n                ListNode pre = sumNodeMap.get(sum);\\n                int presum = sum;\\n                \\n                removeSumStartsWith(pre.next, node, presum, sumNodeMap); //update map\\n                pre.next = node.next; //update linked list\\n            } else {\\n                sumNodeMap.put(sum, node);\\n            }\\n            \\n            node = node.next;\\n        }\\n        return head;\\n    }\\n    \\n    private void removeSumStartsWith(ListNode start, ListNode end, int presum, Map<Integer, ListNode> sumNodeMap) {\\n        while(start != end) {\\n            presum += start.val;\\n            sumNodeMap.remove(presum);\\n            start = start.next;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/*\\nApproach: Keep a running sum upto everynode in a map, if the sum already exist in the map, then everything from the previous map value to current map value sums to zero and can be deleted from linked list. At the same time, we will remove the deleted nodes from map as well to prevent checking a deleted node sum.\\n\\nExample:\\n               a b c d  e  f g  i j\\nInput: head = [1,3,2,-3,-2,5,5,-5,1]\\n\\nOutput: a f j\\nThe map would be constructed as:\\n\\n1 : a\\n4: b\\n6: c\\n3: d\\n1: e ----- we need to delete everything from last seen 1(a) to 1(e), otherwise 6(c) would be double counted for \"f\" below\\n6:f\\n11:g\\n6:i ------- same thing, delete from \"f\"\\n7:j\\n\\n0 == delete upto current from head and take next node as head\\nif not, \\n    check if we have seen this sum before, if we have, then that must mean everything in between must sum to zero. e.g. (b+c+d+e)\\nelse,\\n    add the running sum with the assosiated node in the map\\n    \\nAnalysis: Linear time and space\\n\\n*/\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null){\\n            return head;\\n        }\\n        \\n        Map<Integer, ListNode> sumNodeMap = new HashMap<>();\\n\\n        int sum = 0;\\n        ListNode node = head;\\n        while(node != null){\\n            sum += node.val;\\n            \\n            if(sum == 0){\\n                int presum = 0;\\n                removeSumStartsWith(head, node, presum, sumNodeMap); //update map\\n                head = node.next; //update linked list\\n            }else if(sumNodeMap.containsKey(sum)){\\n                ListNode pre = sumNodeMap.get(sum);\\n                int presum = sum;\\n                \\n                removeSumStartsWith(pre.next, node, presum, sumNodeMap); //update map\\n                pre.next = node.next; //update linked list\\n            } else {\\n                sumNodeMap.put(sum, node);\\n            }\\n            \\n            node = node.next;\\n        }\\n        return head;\\n    }\\n    \\n    private void removeSumStartsWith(ListNode start, ListNode end, int presum, Map<Integer, ListNode> sumNodeMap) {\\n        while(start != end) {\\n            presum += start.val;\\n            sumNodeMap.remove(presum);\\n            start = start.next;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543444,
                "title": "o-n-kotlin-solution-using-linkedhashmap-with-explanation",
                "content": "## The idea: \\nAssume you have an array like this a = [3, 1, 2, -1, -2, 4, 1]\\n\\nThe runinng sum for this array is as follows:\\n\\nsum = [3, 4, 6, 5, 3, 7, 8]\\nwhere sum[i] = a[0] + a[2] ... + a[i]\\n\\nYou can notice that we have two 3s in the sum array, the only way that we can have the number twice in summation is that this summation lost a value equivalent to its value at second occurance of the 3 number in the summation array.\\n\\nfor that we need to remove all numbers starting from the second occurrence of the 3 and stop at when we had the first occurrence.\\n\\nHowever, what if we had a summation that at somepoint became zero at sum[i], this indicate at the the summation from 0 to i is zero. which require us to remove all the numbers.\\n\\n## The Solution:\\nTo check if we have seen a summation number before sum[i] we need to insert the summation in a hash map which store as a key the summatoin and the last node associated with it. once we find that summation in the hash map we need to iterate back to all previouse nodes until we reach the other summation node. for that we need the HashMap keys to be ordered in the same order of inseration, the data structure for that is called LinkedHashMap.\\n\\nBy default the mutableMapOf() and mapOf() creates a LinkedHashMap in koltin which is an orderd hash map where keys are ordered in the order of inseration.\\n\\nOne last thing, to make the code easier and more consistant without many if statements to handle the head removal use case. we can create a dummy node with a value of 0, now if we see zero again in the summation array this is when we remove all nodes and stop at the dummay node. later when we return the answer we can return the dummyNode.next\\n\\n```kotlin\\nclass Solution {\\n    fun removeZeroSumSublists(head: ListNode?): ListNode? {\\n        var dummyNode = ListNode(0).also {\\n            it.next = head\\n        }\\n        \\n        val sumMap = mutableMapOf<Int, ListNode>()\\n        var node: ListNode? = dummyNode\\n        var sum = 0\\n        \\n        while(node != null) {\\n            sum += node!!.`val`\\n            \\n            if(sum !in sumMap) {\\n                sumMap[sum] = node\\n            } else {\\n                val prevNode = sumMap[sum]\\n                prevNode?.next = node?.next\\n                \\n                val keys = sumMap.keys.toMutableList()\\n                var index = keys.lastIndex\\n                \\n                while(index >= 0 && keys[index] != sum) {\\n                    sumMap.remove(keys[index])\\n                    index--\\n                }\\n            }\\n            \\n            node = node?.next\\n        }\\n        \\n        return dummyNode?.next\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```kotlin\\nclass Solution {\\n    fun removeZeroSumSublists(head: ListNode?): ListNode? {\\n        var dummyNode = ListNode(0).also {\\n            it.next = head\\n        }\\n        \\n        val sumMap = mutableMapOf<Int, ListNode>()\\n        var node: ListNode? = dummyNode\\n        var sum = 0\\n        \\n        while(node != null) {\\n            sum += node!!.`val`\\n            \\n            if(sum !in sumMap) {\\n                sumMap[sum] = node\\n            } else {\\n                val prevNode = sumMap[sum]\\n                prevNode?.next = node?.next\\n                \\n                val keys = sumMap.keys.toMutableList()\\n                var index = keys.lastIndex\\n                \\n                while(index >= 0 && keys[index] != sum) {\\n                    sumMap.remove(keys[index])\\n                    index--\\n                }\\n            }\\n            \\n            node = node?.next\\n        }\\n        \\n        return dummyNode?.next\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1524668,
                "title": "ugly-complicated-o-n-javascript-solution-enjoy",
                "content": "`````\\nvar removeZeroSumSublists = function(head) {\\n    const prefixSum = [];\\n    const elements = []\\n    \\n    let headCopy = head;\\n    \\n    while(headCopy){\\n        prefixSum[prefixSum.length] = (prefixSum.length-1) >= 0 ? \\n            prefixSum[prefixSum.length -1] + headCopy.val \\n        : headCopy.val;\\n        \\n        elements[elements.length] = headCopy.val;\\n        \\n        headCopy = headCopy.next;\\n    }\\n    \\n    \\n    let map = new Map();\\n    map.set(0, -1);\\n    \\n    for(let i=0; i<prefixSum.length; i++){\\n        if(!elements[i]){\\n            elements[i] = \\'-\\';\\n        } else {\\n            if(map.has(prefixSum[i])){\\n               const prevIndex = map.get(prefixSum[i]);\\n                for(let j=i; j> prevIndex; j--){\\n                    if(j!=i && prefixSum[j]!=0 && elements[j] != \\'-\\') map.delete(prefixSum[j]);\\n                    elements[j] = \\'-\\';\\n                }\\n            }else{\\n                map.set(prefixSum[i], i);   \\n            }\\n        }   \\n    }\\n    \\n    return elements.reduce((acc, val) => {\\n        if(val != \\'-\\'){\\n            if(acc[0] === null){\\n                const tmp = [];\\n                tmp[0] = new ListNode(val);\\n                tmp[1] = tmp[0];\\n                return tmp;\\n            } else {\\n                acc[1].next = new ListNode(val);\\n                acc[1] = acc[1].next;\\n            }\\n        }\\n        return acc;\\n    }, [null])[0];\\n};\\n",
                "solutionTags": [],
                "code": "`````\\nvar removeZeroSumSublists = function(head) {\\n    const prefixSum = [];\\n    const elements = []\\n    \\n    let headCopy = head;\\n    \\n    while(headCopy){\\n        prefixSum[prefixSum.length] = (prefixSum.length-1) >= 0 ? \\n            prefixSum[prefixSum.length -1] + headCopy.val \\n        : headCopy.val;\\n        \\n        elements[elements.length] = headCopy.val;\\n        \\n        headCopy = headCopy.next;\\n    }\\n    \\n    \\n    let map = new Map();\\n    map.set(0, -1);\\n    \\n    for(let i=0; i<prefixSum.length; i++){\\n        if(!elements[i]){\\n            elements[i] = \\'-\\';\\n        } else {\\n            if(map.has(prefixSum[i])){\\n               const prevIndex = map.get(prefixSum[i]);\\n                for(let j=i; j> prevIndex; j--){\\n                    if(j!=i && prefixSum[j]!=0 && elements[j] != \\'-\\') map.delete(prefixSum[j]);\\n                    elements[j] = \\'-\\';\\n                }\\n            }else{\\n                map.set(prefixSum[i], i);   \\n            }\\n        }   \\n    }\\n    \\n    return elements.reduce((acc, val) => {\\n        if(val != \\'-\\'){\\n            if(acc[0] === null){\\n                const tmp = [];\\n                tmp[0] = new ListNode(val);\\n                tmp[1] = tmp[0];\\n                return tmp;\\n            } else {\\n                acc[1].next = new ListNode(val);\\n                acc[1] = acc[1].next;\\n            }\\n        }\\n        return acc;\\n    }, [null])[0];\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1437007,
                "title": "c-8ms-91-hashmap-of-previous-prefix-sum",
                "content": "Runtime: 8 ms, faster than 91.47% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\nMemory Usage: 11.5 MB, less than 25.71% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\n```\\nclass Solution {\\npublic:\\n  \\n  ListNode* removeZeroSumSublists(ListNode* head) {\\n    ListNode *fh = new ListNode(0, head);\\n    unordered_map<int, ListNode*> mp;\\n    mp[0] = fh;\\n    int sum = 0;\\n    \\n    while( head ){\\n      sum += head->val;\\n      \\n      if(mp.count(sum)){\\n        ListNode *tmp = mp[sum]->next;\\n        for(;tmp != head; tmp = tmp->next){\\n          sum += tmp->val;\\n          mp.erase(sum);\\n        }\\n        sum += head->val;\\n        mp[sum]->next = head->next;\\n      } \\n      else mp[sum] = head; \\n      head = head->next;\\n    }\\n    \\n    return fh->next;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  ListNode* removeZeroSumSublists(ListNode* head) {\\n    ListNode *fh = new ListNode(0, head);\\n    unordered_map<int, ListNode*> mp;\\n    mp[0] = fh;\\n    int sum = 0;\\n    \\n    while( head ){\\n      sum += head->val;\\n      \\n      if(mp.count(sum)){\\n        ListNode *tmp = mp[sum]->next;\\n        for(;tmp != head; tmp = tmp->next){\\n          sum += tmp->val;\\n          mp.erase(sum);\\n        }\\n        sum += head->val;\\n        mp[sum]->next = head->next;\\n      } \\n      else mp[sum] = head; \\n      head = head->next;\\n    }\\n    \\n    return fh->next;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1430314,
                "title": "c-iteration-4ms-solution",
                "content": "```\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n   //create a dummy point prior to original head\\n    struct ListNode* first = calloc(1, sizeof(struct ListNode));\\n    first ->next = head;\\n    head = first;\\n    \\n    while (first != NULL && first->next != NULL) {\\n        int sum = 0;\\n        struct ListNode* sec = first->next;\\n        sum += sec->val;\\n        sec = sec->next;\\n\\n        while (sec != NULL && sum != 0) {\\n            sum += sec->val;\\n            sec = sec->next;\\n        }\\n\\t\\t\\n        if (sum == 0) \\n            first->next = sec;  // Do not move to next since the link is changed after reconnect\\n        else   \\n            first = first->next;\\n    }\\n   \\n    return head->next;\\n}\\n```\\nO(n^2)",
                "solutionTags": [],
                "code": "```\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n   //create a dummy point prior to original head\\n    struct ListNode* first = calloc(1, sizeof(struct ListNode));\\n    first ->next = head;\\n    head = first;\\n    \\n    while (first != NULL && first->next != NULL) {\\n        int sum = 0;\\n        struct ListNode* sec = first->next;\\n        sum += sec->val;\\n        sec = sec->next;\\n\\n        while (sec != NULL && sum != 0) {\\n            sum += sec->val;\\n            sec = sec->next;\\n        }\\n\\t\\t\\n        if (sum == 0) \\n            first->next = sec;  // Do not move to next since the link is changed after reconnect\\n        else   \\n            first = first->next;\\n    }\\n   \\n    return head->next;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1430036,
                "title": "java-o-n-two-passes-using-dummy-node-100",
                "content": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)\\n            return head;\\n        \\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        \\n        ListNode dummy = new ListNode(0, head);\\n        \\n        ListNode curr = dummy;\\n        \\n        while(curr != null) {\\n            sum += curr.val;\\n            map.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        \\n        curr = dummy;\\n        sum = 0;\\n        \\n        while(curr != null) {\\n            sum += curr.val;\\n            curr.next = map.get(sum).next;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null)\\n            return head;\\n        \\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        \\n        ListNode dummy = new ListNode(0, head);\\n        \\n        ListNode curr = dummy;\\n        \\n        while(curr != null) {\\n            sum += curr.val;\\n            map.put(sum, curr);\\n            curr = curr.next;\\n        }\\n        \\n        curr = dummy;\\n        sum = 0;\\n        \\n        while(curr != null) {\\n            sum += curr.val;\\n            curr.next = map.get(sum).next;\\n            \\n            curr = curr.next;\\n        }\\n        \\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1427316,
                "title": "c-jump-table-approach-unordered-map-2-pass",
                "content": "\\n* parse the list to look for  repeating cumulative sum to detect \"cycle\" to be *skipped*\\n\\t* update the jump table for every sum \\n\\t* if a sum is repeated, we will want to jump ahead to last occurence\\n* parse again the list, recalculating cumulative sum:\\n\\t* update  the next node reference using the jump table previously calculated\\n \\n\\n```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        unordered_map<int, ListNode*> jump;\\n\\n        int sum {0};\\n        ListNode *origine = new ListNode(0, head);\\n     \\n        for (auto cur = origine; cur != nullptr; cur = cur->next) {\\n            sum += cur->val;\\n            jump[sum] = cur; \\n        }\\n        sum = 0;\\n        for (auto cur = origine; cur != nullptr; cur = cur->next) {\\n            sum += cur->val;\\n            cur->next = jump[sum]->next;\\n        }\\n        \\n        return origine->next;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\n* parse the list to look for  repeating cumulative sum to detect \"cycle\" to be *skipped*\\n\\t* update the jump table for every sum \\n\\t* if a sum is repeated, we will want to jump ahead to last occurence\\n* parse again the list, recalculating cumulative sum:\\n\\t* update  the next node reference using the jump table previously calculated\\n \\n\\n```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        unordered_map<int, ListNode*> jump;\\n\\n        int sum {0};\\n        ListNode *origine = new ListNode(0, head);\\n     \\n        for (auto cur = origine; cur != nullptr; cur = cur->next) {\\n            sum += cur->val;\\n            jump[sum] = cur; \\n        }\\n        sum = 0;\\n        for (auto cur = origine; cur != nullptr; cur = cur->next) {\\n            sum += cur->val;\\n            cur->next = jump[sum]->next;\\n        }\\n        \\n        return origine->next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1412200,
                "title": "java-0-n-using-hashmap",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        if(head == null) {\\n            return head;\\n        }\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        ListNode tempHead = new ListNode(0);\\n        tempHead.next = head;\\n        map.put(0, tempHead);\\n        int sum = 0;\\n        while(head != null) {\\n            sum = head.val + sum;\\n            \\n            if(map.containsKey(sum)) {\\n                int prevSum = sum;\\n                ListNode itr = map.get(sum).next;\\n                \\n                while(itr != null && itr != head) {\\n                    sum += itr.val;\\n                    map.remove(sum);\\n                    itr = itr.next;\\n                }\\n                sum = prevSum;\\n                map.get(sum).next = head.next;\\n                \\n            } else {\\n                map.put(sum, head);\\n            }\\n            \\n            head = head.next;\\n        }\\n        return tempHead.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        if(head == null) {\\n            return head;\\n        }\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        ListNode tempHead = new ListNode(0);\\n        tempHead.next = head;\\n        map.put(0, tempHead);\\n        int sum = 0;\\n        while(head != null) {\\n            sum = head.val + sum;\\n            \\n            if(map.containsKey(sum)) {\\n                int prevSum = sum;\\n                ListNode itr = map.get(sum).next;\\n                \\n                while(itr != null && itr != head) {\\n                    sum += itr.val;\\n                    map.remove(sum);\\n                    itr = itr.next;\\n                }\\n                sum = prevSum;\\n                map.get(sum).next = head.next;\\n                \\n            } else {\\n                map.put(sum, head);\\n            }\\n            \\n            head = head.next;\\n        }\\n        return tempHead.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1411637,
                "title": "java-2-passes-hashmap-solution",
                "content": "2 Passes HashMap solution\\nUse HashMap to store the <prefix sum, ListNode> pair\\nIf the prefix sum exist, that means the sum bewtween previous node (not included) to the current node is 0. So we can point previous node.next to current node.next.\\nThe reason to use 2 passes is that the first pass some skipped nodes is overlapped. Consider the case [1,3,2,-3,-2,5,5,-5,1]\\n1. First pass: put <prefix sum, current node> pair into HashMap, then we can get the **last node** with such prefix sum..\\n2. Second pass: reset prefix sum to 0, point current node to dummy.  Point the current node.next to map.get(sum).next, where map.get(sum) is the **last node** with such prefix sum.\\n\\nNote 1: dummy node can process the situation where sum of the whole list is 0.\\nNote 2: We may not get th shortest list.\\n```\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        for (ListNode cur = dummy; cur != null; cur = cur.next) {\\n            sum += cur.val;\\n            map.put(sum, cur);  // get the last node with such prefix sum.\\n        }\\n        sum = 0;\\n        for (ListNode cur = dummy; cur != null; cur = cur.next) {\\n            sum += cur.val;\\n            cur.next = map.get(sum).next;  // get the last node with such prefix sum.\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Time complexity: O(N)\\n// Space complexity: O(N)\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        for (ListNode cur = dummy; cur != null; cur = cur.next) {\\n            sum += cur.val;\\n            map.put(sum, cur);  // get the last node with such prefix sum.\\n        }\\n        sum = 0;\\n        for (ListNode cur = dummy; cur != null; cur = cur.next) {\\n            sum += cur.val;\\n            cur.next = map.get(sum).next;  // get the last node with such prefix sum.\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393840,
                "title": "c-brute-force-99",
                "content": "```\\n\\n```public:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode *temp=new ListNode();\\n        temp->next=head;\\n        for(ListNode *i=temp;i!=NULL;i=i->next)\\n        {\\n            int sum=0;\\n            for(ListNode *j=i->next;j!=NULL;j=j->next)\\n            {\\n                sum=sum+j->val;\\n                if(sum==0)\\n                {\\n                    i->next=j->next;\\n                }\\n            }\\n        }\\n        return temp->next;\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1391873,
                "title": "python-one-pass-solution-with-hashmap-and-stack",
                "content": "The main idea is to keep the prefix sum in a hashmap and if the same prefix sum is observed again, remove all nodes in between. We also need to remove all prefix sum for the in-between deleted nodes from the hashmap. To do that we can keep a stack for the prefix sums and remove each prefix sum from the stack and the hashmap until we get the current prefix sum.\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:return head\\n        head = ListNode(0, head)\\n        sum_dict, stack = {0:head}, [0]\\n        cur,total = head.next, 0\\n        while cur:\\n            total += cur.val\\n            if total not in sum_dict:\\n                sum_dict[total] = cur\\n                stack.append(total)\\n            else:\\n                sum_dict[total].next = cur.next\\n                while stack[-1]!=total:\\n                    val = stack.pop()\\n                    del sum_dict[val]\\n            cur = cur.next\\n        return head.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: Optional[ListNode]) -> Optional[ListNode]:\\n        if not head:return head\\n        head = ListNode(0, head)\\n        sum_dict, stack = {0:head}, [0]\\n        cur,total = head.next, 0\\n        while cur:\\n            total += cur.val\\n            if total not in sum_dict:\\n                sum_dict[total] = cur\\n                stack.append(total)\\n            else:\\n                sum_dict[total].next = cur.next\\n                while stack[-1]!=total:\\n                    val = stack.pop()\\n                    del sum_dict[val]\\n            cur = cur.next\\n        return head.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1331542,
                "title": "c-easy-to-understand-code",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        int n = 0;\\n        vector<int> ans;\\n        ListNode* temp = head;\\n        while(temp){\\n            ans.push_back(temp->val);\\n            temp = temp->next;\\n            n++;\\n        }\\n        vector<int> isDeleted(n,0);\\n        int index = 0;\\n        while(index < n){\\n            if(!isDeleted[index]){\\n                int sum = ans[index];\\n                int j = index + 1;\\n                while(j<n){\\n                    if(sum == 0) break;\\n                    if(!isDeleted[j]) sum = sum + ans[j];\\n                    j++;\\n                }\\n                if(sum == 0){\\n                    for(int k=index; k<j; k++) isDeleted[k] = 1;\\n                }\\n            }\\n            index++;\\n        }\\n        temp = head;\\n        ListNode* root = NULL;\\n        ListNode* prev = NULL;\\n        for(int i=0; i<n; i++){\\n            if(!isDeleted[i]){\\n                temp->val = ans[i];\\n                if(!root) root = temp;\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        if(prev) prev->next = NULL;\\n        return root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        int n = 0;\\n        vector<int> ans;\\n        ListNode* temp = head;\\n        while(temp){\\n            ans.push_back(temp->val);\\n            temp = temp->next;\\n            n++;\\n        }\\n        vector<int> isDeleted(n,0);\\n        int index = 0;\\n        while(index < n){\\n            if(!isDeleted[index]){\\n                int sum = ans[index];\\n                int j = index + 1;\\n                while(j<n){\\n                    if(sum == 0) break;\\n                    if(!isDeleted[j]) sum = sum + ans[j];\\n                    j++;\\n                }\\n                if(sum == 0){\\n                    for(int k=index; k<j; k++) isDeleted[k] = 1;\\n                }\\n            }\\n            index++;\\n        }\\n        temp = head;\\n        ListNode* root = NULL;\\n        ListNode* prev = NULL;\\n        for(int i=0; i<n; i++){\\n            if(!isDeleted[i]){\\n                temp->val = ans[i];\\n                if(!root) root = temp;\\n                prev = temp;\\n                temp = temp->next;\\n            }\\n        }\\n        if(prev) prev->next = NULL;\\n        return root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1290443,
                "title": "simple-brute-force-c-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n        \\n        for(ListNode* t=temp;t!=NULL;t=t->next)\\n        {\\n           int sum=0;\\n            for(ListNode* j=t->next;j!=NULL;j=j->next)\\n            {\\n                sum+=j->val;\\n                if(sum==0)\\n                {\\n                    if(j->next!=NULL)\\n                         t->next=j->next;\\n                    else\\n                    {\\n                        t->next=NULL;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return temp->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp=new ListNode();\\n        temp->next=head;\\n        \\n        for(ListNode* t=temp;t!=NULL;t=t->next)\\n        {\\n           int sum=0;\\n            for(ListNode* j=t->next;j!=NULL;j=j->next)\\n            {\\n                sum+=j->val;\\n                if(sum==0)\\n                {\\n                    if(j->next!=NULL)\\n                         t->next=j->next;\\n                    else\\n                    {\\n                        t->next=NULL;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n        }\\n        \\n        return temp->next;\\n        \\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1148700,
                "title": "followed-the-hints-to-the-letter-but-got-only-26-speed",
                "content": "```\\nclass Solution(object):\\n    def get_data(self, head):\\n        if head is None:\\n            return []\\n        res = []\\n        current = head\\n        while current:\\n            res.append(current.val)\\n            current = current.next\\n        return res\\n\\n    def removeZeroSumSublists(self, head):\\n        lst = [v for v in self.get_data(head) if v]\\n        stack = []\\n        for v in lst:\\n            if not stack:\\n                stack.append(v)\\n            else:\\n                sum_nums = v\\n                for i in range(len(stack) - 1, -1, -1):\\n                    sum_nums += stack[i]\\n                    if not sum_nums:\\n                        stack = stack[:i]\\n                        break\\n                else:\\n                    stack.append(v)\\n        if stack:\\n            new_head = ListNode(stack[0])\\n            tmp = new_head\\n            for i in range(1, len(stack)):\\n                tmp.next = ListNode(stack[i])\\n                tmp = tmp.next\\n        else:\\n            new_head = None\\n        return new_head\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def get_data(self, head):\\n        if head is None:\\n            return []\\n        res = []\\n        current = head\\n        while current:\\n            res.append(current.val)\\n            current = current.next\\n        return res\\n\\n    def removeZeroSumSublists(self, head):\\n        lst = [v for v in self.get_data(head) if v]\\n        stack = []\\n        for v in lst:\\n            if not stack:\\n                stack.append(v)\\n            else:\\n                sum_nums = v\\n                for i in range(len(stack) - 1, -1, -1):\\n                    sum_nums += stack[i]\\n                    if not sum_nums:\\n                        stack = stack[:i]\\n                        break\\n                else:\\n                    stack.append(v)\\n        if stack:\\n            new_head = ListNode(stack[0])\\n            tmp = new_head\\n            for i in range(1, len(stack)):\\n                tmp.next = ListNode(stack[i])\\n                tmp = tmp.next\\n        else:\\n            new_head = None\\n        return new_head\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1146108,
                "title": "java-sentinel-head-with-hashmap-o-n-how-o-n-think-of-it-again",
                "content": "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        HashMap<Integer,ListNode> map=new HashMap<>();\\n        int sum=0;\\n        ListNode newHead=new ListNode(3003);\\n        map.put(0,newHead);\\n        newHead.next=head;\\n        \\n        while(head!=null)\\n        {\\n            sum+=head.val;\\n            if(map.containsKey(sum))\\n            {\\n                ListNode start=map.get(sum);\\n                ListNode temp=start.next;\\n                int tempSum=sum;\\n                while(temp!=head)\\n                {\\n                    tempSum+=temp.val;\\n                    map.remove(tempSum);\\n                    temp=temp.next;\\n                }\\n                start.next=head.next;\\n            }\\n            else\\n                map.put(sum,head);\\n            \\n            head=head.next;\\n        }\\n        return newHead.next;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n        HashMap<Integer,ListNode> map=new HashMap<>();\\n        int sum=0;\\n        ListNode newHead=new ListNode(3003);\\n        map.put(0,newHead);\\n        newHead.next=head;\\n        \\n        while(head!=null)\\n        {\\n            sum+=head.val;\\n            if(map.containsKey(sum))\\n            {\\n                ListNode start=map.get(sum);\\n                ListNode temp=start.next;\\n                int tempSum=sum;\\n                while(temp!=head)\\n                {\\n                    tempSum+=temp.val;\\n                    map.remove(tempSum);\\n                    temp=temp.next;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1091989,
                "title": "javascript-solution-brute-force-and-o-n-approach",
                "content": "```\\nvar removeZeroSumSublists = function(head) {\\n    const dummyHead = new ListNode();\\n    dummyHead.next = head;\\n    let prev = dummyHead;\\n    let start = head;\\n    \\n    while (start != null) {\\n        let sum = 0;\\n        let tail = start;\\n        \\n        while (tail != null) {\\n            sum += tail.val;\\n            if (sum === 0) break;\\n            tail = tail.next;\\n        }\\n        \\n        if (tail) {\\n            prev.next = tail.next;\\n            start = tail.next;\\n        }\\n        else {\\n            prev = start;\\n            start = start.next;\\n        }\\n    }\\n    \\n    \\n    return dummyHead.next;\\n};\\n```\\n---\\n\\n```\\nvar removeZeroSumSublists = function(head) {\\n    const map = new Map();\\n    let sum = 0;\\n    let curr = head;\\n    \\n    while (curr != null) {\\n        sum += curr.val;\\n        map.set(sum, curr);\\n        curr = curr.next;\\n    }\\n    \\n    const dummyHead = new ListNode(0);\\n    dummyHead.next = head;\\n    curr = dummyHead;\\n    sum = 0;\\n    \\n    while (curr != null) {\\n        sum += curr.val;\\n        \\n        if (map.has(sum) && map.get(sum) != curr) {\\n            curr.next = map.get(sum).next;\\n            map.delete(sum);\\n        }\\n        curr = curr.next;\\n    }\\n    \\n    return dummyHead.next;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeZeroSumSublists = function(head) {\\n    const dummyHead = new ListNode();\\n    dummyHead.next = head;\\n    let prev = dummyHead;\\n    let start = head;\\n    \\n    while (start != null) {\\n        let sum = 0;\\n        let tail = start;\\n        \\n        while (tail != null) {\\n            sum += tail.val;\\n            if (sum === 0) break;\\n            tail = tail.next;\\n        }\\n        \\n        if (tail) {\\n            prev.next = tail.next;\\n            start = tail.next;\\n        }\\n        else {\\n            prev = start;\\n            start = start.next;\\n        }\\n    }\\n    \\n    \\n    return dummyHead.next;\\n};\\n```\n```\\nvar removeZeroSumSublists = function(head) {\\n    const map = new Map();\\n    let sum = 0;\\n    let curr = head;\\n    \\n    while (curr != null) {\\n        sum += curr.val;\\n        map.set(sum, curr);\\n        curr = curr.next;\\n    }\\n    \\n    const dummyHead = new ListNode(0);\\n    dummyHead.next = head;\\n    curr = dummyHead;\\n    sum = 0;\\n    \\n    while (curr != null) {\\n        sum += curr.val;\\n        \\n        if (map.has(sum) && map.get(sum) != curr) {\\n            curr.next = map.get(sum).next;\\n            map.delete(sum);\\n        }\\n        curr = curr.next;\\n    }\\n    \\n    return dummyHead.next;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1077389,
                "title": "faster-than-98",
                "content": "```\\nListNode dummy = new ListNode(-1);\\ndummy.next = head;\\nListNode curr = dummy;\\n\\nListNode start = head;\\nint currSum = 0;\\nwhile (start != null)\\n{\\n\\tListNode end = start;\\n\\twhile (end != null)\\n\\t{\\n\\t\\tif (currSum + end.val == 0)\\n\\t\\t{\\n\\t\\t\\tcurr.next = end.next;\\n\\t\\t\\tstart = curr;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrSum += end.val;\\n\\t\\t\\tend = end.next;\\n\\t\\t}\\n\\t}\\n\\tcurr = start;\\n\\tstart = start.next;\\n\\tcurrSum = 0;\\n}\\n\\nreturn dummy.next;\\n```",
                "solutionTags": [],
                "code": "```\\nListNode dummy = new ListNode(-1);\\ndummy.next = head;\\nListNode curr = dummy;\\n\\nListNode start = head;\\nint currSum = 0;\\nwhile (start != null)\\n{\\n\\tListNode end = start;\\n\\twhile (end != null)\\n\\t{\\n\\t\\tif (currSum + end.val == 0)\\n\\t\\t{\\n\\t\\t\\tcurr.next = end.next;\\n\\t\\t\\tstart = curr;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcurrSum += end.val;\\n\\t\\t\\tend = end.next;\\n\\t\\t}\\n\\t}\\n\\tcurr = start;\\n\\tstart = start.next;\\n\\tcurrSum = 0;\\n}\\n\\nreturn dummy.next;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1040631,
                "title": "runtime-8-ms-faster-than-89-47-c-iterative-solution",
                "content": "\"\"\"\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    \\n    struct ListNode *p1;\\n    struct ListNode *p2;\\n    struct ListNode *testa;\\n    struct ListNode *prec;\\n    struct ListNode *to_free;\\n\\n    int flag;\\n    int zero;\\n\\n    testa = NULL;\\n    prec = NULL;\\n    p1 = head;\\n    \\n    while(p1 != NULL){\\n        flag = false;\\n        p2 = p1;\\n        zero = 0;\\n        \\n        while(p2!=NULL){\\n            zero += p2->val;\\n            if(zero == 0){\\n                flag = true;\\n                p2 = p2->next;\\n                while(p1 != p2){\\n                     to_free = p1;\\n                    if(p1 == testa)\\n                        testa = NULL;\\n                    \\n                    p1 = p1->next;\\n                    free(to_free);\\n                    to_free = NULL;\\n                }\\n                    \\n                if(testa == NULL){\\n                   testa = p1;\\n                    prec = testa;\\n                }else{\\n                    prec->next = p2;\\n                }\\n\\n            }else\\n                p2 = p2->next;\\n        }\\n        if(testa == NULL){\\n             testa = p1;\\n             prec = testa;\\n         }         \\n        if(flag != true){\\n            prec = p1;\\n            p1 = p1->next;   \\n        }   \\n    }  \\n    return testa;\\n}\\n\\n//this is my iterative code;\\n\\nit involves scrolling through the list with a nested while loop, to allow us to check for all cases. we start from pointer 1 and pointer 2 which are stationary in the same position (at the beginning it will naturally be the head) after which we scroll with pointer 2 and if we find the sum of zero then pointer 2 goes one position forward. obviously it follows that pointer 1 reaches it by eliminating everything it encounters. if, on the other hand, it does not find anything, the head is confirmed and pointer 1 moves forward by one position. for the head question, we have to consider more cases, in fact, in addition to the \"head\" pointer we also have prev which will be in the same position as the head only when it is confirmed, in fact if the head has value the prev pointer will have the task of making section accepted to the one after the eliminated zone.\\n\\n1112-2 8\\n\\nin this case, the head will point to 1, but it will be the task of the previous pointer to go ahead and connect zones 111 to 8.\\n\"\"\"",
                "solutionTags": [],
                "code": "\"\"\"\\nstruct ListNode* removeZeroSumSublists(struct ListNode* head){\\n    \\n    struct ListNode *p1;\\n    struct ListNode *p2;\\n    struct ListNode *testa;\\n    struct ListNode *prec;\\n    struct ListNode *to_free;\\n\\n    int flag;\\n    int zero;\\n\\n    testa = NULL;\\n    prec = NULL;\\n    p1 = head;\\n    \\n    while(p1 != NULL){\\n        flag = false;\\n        p2 = p1;\\n        zero = 0;\\n        \\n        while(p2!=NULL){\\n            zero += p2->val;\\n            if(zero == 0){\\n                flag = true;\\n                p2 = p2->next;\\n                while(p1 != p2){\\n                     to_free = p1;\\n                    if(p1 == testa)\\n                        testa = NULL;\\n                    \\n                    p1 = p1->next;\\n                    free(to_free);\\n                    to_free = NULL;\\n                }\\n                    \\n                if(testa == NULL){\\n                   testa = p1;\\n                    prec = testa;\\n                }else{\\n                    prec->next = p2;\\n                }\\n\\n            }else\\n                p2 = p2->next;\\n        }\\n        if(testa == NULL){\\n             testa = p1;\\n             prec = testa;\\n         }         \\n        if(flag != true){\\n            prec = p1;\\n            p1 = p1->next;   \\n        }   \\n    }  \\n    return testa;\\n}\\n\\n//this is my iterative code;\\n\\nit involves scrolling through the list with a nested while loop, to allow us to check for all cases. we start from pointer 1 and pointer 2 which are stationary in the same position (at the beginning it will naturally be the head) after which we scroll with pointer 2 and if we find the sum of zero then pointer 2 goes one position forward. obviously it follows that pointer 1 reaches it by eliminating everything it encounters. if, on the other hand, it does not find anything, the head is confirmed and pointer 1 moves forward by one position. for the head question, we have to consider more cases, in fact, in addition to the \"head\" pointer we also have prev which will be in the same position as the head only when it is confirmed, in fact if the head has value the prev pointer will have the task of making section accepted to the one after the eliminated zone.\\n\\n1112-2 8\\n\\nin this case, the head will point to 1, but it will be the task of the previous pointer to go ahead and connect zones 111 to 8.\\n\"\"\"",
                "codeTag": "Unknown"
            },
            {
                "id": 1003216,
                "title": "javascript-solution",
                "content": "```javascript\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeZeroSumSublists = function(head) {\\n    // let cur = head;\\n    let dummy = new ListNode();\\n    dummy.next = head;\\n    for (let i = dummy; i !== null; i= i.next) {\\n        let sum = 0;\\n        for (let j = i.next; j !== null; j = j.next) {\\n            sum += j.val;\\n            if (sum === 0) {\\n                i.next = j.next\\n            }\\n            // j = j.next\\n        }\\n    }\\n    \\n    return dummy.next\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeZeroSumSublists = function(head) {\\n    // let cur = head;\\n    let dummy = new ListNode();\\n    dummy.next = head;\\n    for (let i = dummy; i !== null; i= i.next) {\\n        let sum = 0;\\n        for (let j = i.next; j !== null; j = j.next) {\\n            sum += j.val;\\n            if (sum === 0) {\\n                i.next = j.next\\n            }\\n            // j = j.next\\n        }\\n    }\\n    \\n    return dummy.next\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002866,
                "title": "c-o-n-2-brute-force",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode ans(0);\\n        ans.next = head;\\n        \\n        ListNode* prev = &ans;\\n        \\n        while (head) {\\n            int sum = 0;\\n            \\n            ListNode* cur = head;\\n            \\n            while (cur) {\\n                sum += cur->val;\\n            \\n                if (sum == 0) {\\n                    if (prev) {\\n                        prev->next = cur->next;\\n                    }\\n                    \\n                    head = cur->next;\\n                }\\n                \\n                cur = cur->next;\\n            }\\n            \\n            prev = head;\\n            \\n            if (head) {\\n                head = head->next;\\n            }\\n        }\\n        \\n        return ans.next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        ListNode ans(0);\\n        ans.next = head;\\n        \\n        ListNode* prev = &ans;\\n        \\n        while (head) {\\n            int sum = 0;\\n            \\n            ListNode* cur = head;\\n            \\n            while (cur) {\\n                sum += cur->val;\\n            \\n                if (sum == 0) {\\n                    if (prev) {\\n                        prev->next = cur->next;\\n                    }\\n                    \\n                    head = cur->next;\\n                }\\n                \\n                cur = cur->next;\\n            }\\n            \\n            prev = head;\\n            \\n            if (head) {\\n                head = head->next;\\n            }\\n        }\\n        \\n        return ans.next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1002848,
                "title": "16-ms-faster-than-78-41-memory-usage-11-8-mb-less-than-61-85",
                "content": "```\\nclass Solution {\\n    #define ln ListNode\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* hd) {\\n        ln*it=hd,*fh=new ln(0,hd);\\n\\tint sum=0;\\n\\tunordered_map<int,ln*>ump;\\n\\tump[0]=fh;\\n\\twhile(it){\\n\\tsum+=it->val;\\n\\tif(ump.find(sum)!=ump.end()){\\n\\t\\tint tmp=sum;\\n\\t\\tln*ti=ump[sum]->next;\\n\\t\\twhile(ti!=it){\\n\\t\\ttmp+=ti->val;\\n\\t\\tump.erase(tmp);\\n\\t\\tti=ti->next;\\n\\t\\t}\\n\\t\\tump[sum]->next=it->next;\\n\\t}\\n\\telse\\n\\t\\tump[sum]=it;\\n\\tit=it->next;\\n\\t}\\n\\treturn fh->next;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    #define ln ListNode\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* hd) {\\n        ln*it=hd,*fh=new ln(0,hd);\\n\\tint sum=0;\\n\\tunordered_map<int,ln*>ump;\\n\\tump[0]=fh;\\n\\twhile(it){\\n\\tsum+=it->val;\\n\\tif(ump.find(sum)!=ump.end()){\\n\\t\\tint tmp=sum;\\n\\t\\tln*ti=ump[sum]->next;\\n\\t\\twhile(ti!=it){\\n\\t\\ttmp+=ti->val;\\n\\t\\tump.erase(tmp);\\n\\t\\tti=ti->next;\\n\\t\\t}\\n\\t\\tump[sum]->next=it->next;\\n\\t}\\n\\telse\\n\\t\\tump[sum]=it;\\n\\tit=it->next;\\n\\t}\\n\\treturn fh->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 995132,
                "title": "suggest-improvement-in-c-o-n-space-o-n-2-time",
                "content": "Could any one suggest any improvment to reduce space and time complexities??\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*>mp;\\n        \\n        ListNode* root=head;\\n        \\n        int sum=0;\\n        \\n        while(root!=NULL){\\n            sum+=root->val;  \\n              if(mp[sum]!=NULL || sum==0){\\n                \\n                  if(sum==0)\\n                      head=root->next;\\n                  else\\n                      mp[sum]->next=root->next;\\n                  \\n                mp.clear();\\n                root=head;\\n                sum=0;\\n              }\\n              else{\\n                mp[sum]=root;\\n                root=root->next;\\n              }\\n        }\\n        \\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        unordered_map<int,ListNode*>mp;\\n        \\n        ListNode* root=head;\\n        \\n        int sum=0;\\n        \\n        while(root!=NULL){\\n            sum+=root->val;  \\n              if(mp[sum]!=NULL || sum==0){\\n                \\n                  if(sum==0)\\n                      head=root->next;\\n                  else\\n                      mp[sum]->next=root->next;\\n                  \\n                mp.clear();\\n                root=head;\\n                sum=0;\\n              }",
                "codeTag": "Java"
            },
            {
                "id": 955703,
                "title": "beats-93-4-simple-c-code-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        struct ListNode *t, *p, *q; //p is the main pointer, t is a following pointer on\\n        p = t = q = head;           //p and q is the forward moving pointer to check sum\\n        int change = 0, sum = 0;\\n        \\n        if(head->val == 0 && head->next == NULL)\\n            return NULL;\\n        \\n        while(p || change>0)\\n        {\\n            if(change>0)\\n            {\\n                change--;\\n                p = head; //restart checking as a change has been made\\n            }\\n            q = p;\\n            sum = 0;\\n            while(q)\\n            {\\n                sum = sum + q->val;\\n                if(sum == 0)\\n                {\\n                    change++;\\n                    if(p==head)\\n                        head = q->next;\\n                    else\\n                        t->next = q->next;\\n                }\\n                q = q->next;\\n            }\\n            \\n            t = p; //following pointer\\n            if(p != NULL)\\n                p = p->next;    \\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        struct ListNode *t, *p, *q; //p is the main pointer, t is a following pointer on\\n        p = t = q = head;           //p and q is the forward moving pointer to check sum\\n        int change = 0, sum = 0;\\n        \\n        if(head->val == 0 && head->next == NULL)\\n            return NULL;\\n        \\n        while(p || change>0)\\n        {\\n            if(change>0)\\n            {\\n                change--;\\n                p = head; //restart checking as a change has been made\\n            }\\n            q = p;\\n            sum = 0;\\n            while(q)\\n            {\\n                sum = sum + q->val;\\n                if(sum == 0)\\n                {\\n                    change++;\\n                    if(p==head)\\n                        head = q->next;\\n                    else\\n                        t->next = q->next;\\n                }\\n                q = q->next;\\n            }\\n            \\n            t = p; //following pointer\\n            if(p != NULL)\\n                p = p->next;    \\n        }\\n        \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 950258,
                "title": "python-solution-using-hashmap-o-n",
                "content": "This problem is similar to SubArray SUm equal to K.Please solve this problem first which will help in better understanding of this solution.\\nAlgorithm:\\n1.At every node calculate the cumulative sum and store the cumulative sum with its node address in a dictionary.\\n2.When every the cumulative sum repeats it means that the sum of the values in between current node and the node  stored in the dictionary \\nshould be zero.\\n3.When scenario2 comes then we have to delete all the nodes in between these two and also clear the dictionary of these node values.\\n\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy=ListNode(0)\\n        dummy.next=head\\n        sum1=0\\n        prev=dummy\\n        curr=head\\n        values=dict()\\n        values[0]=dummy\\n        \\n        while curr!=None:\\n            \\n            sum1=sum1+curr.val\\n\\n            if sum1 not in values:\\n                values[sum1]=curr\\n            else:\\n                temp=values[sum1].next\\n                values[sum1].next=curr.next\\n                new_sum=sum1\\n                while temp!=curr:\\n                    new_sum=new_sum+temp.val\\n                    del values[new_sum]\\n                    temp=temp.next\\n\\n            prev=curr\\n            curr=curr.next\\n            \\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy=ListNode(0)\\n        dummy.next=head\\n        sum1=0\\n        prev=dummy\\n        curr=head\\n        values=dict()\\n        values[0]=dummy\\n        \\n        while curr!=None:\\n            \\n            sum1=sum1+curr.val\\n\\n            if sum1 not in values:\\n                values[sum1]=curr\\n            else:\\n                temp=values[sum1].next\\n                values[sum1].next=curr.next\\n                new_sum=sum1\\n                while temp!=curr:\\n                    new_sum=new_sum+temp.val\\n                    del values[new_sum]\\n                    temp=temp.next\\n\\n            prev=curr\\n            curr=curr.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 926931,
                "title": "easy-o-n-js-solution",
                "content": "```\\nvar removeZeroSumSublists = function(head) {\\n    let dummy = new ListNode();\\n    let cur = head;\\n    dummy.next = head;\\n    let m = new Map();\\n    m.set(0, dummy);\\n    let prefixSum = 0;\\n    while (cur !== null) {\\n        prefixSum += cur.val;\\n        if (m.has(prefixSum)) {\\n            // save pointer to next node\\n            let next = cur.next;\\n\\n            // delete the nodes in between from map\\n            let temp = m.get(prefixSum).next;\\n            let tempPrefixSum = prefixSum;\\n            while (temp !== cur && temp !== null) {\\n                tempPrefixSum += temp.val;\\n                m.delete(tempPrefixSum);\\n                temp = temp.next;\\n            }\\n\\n            // set a new cur\\n            cur = m.get(prefixSum);\\n            cur.next = next;\\n        } else {\\n            m.set(prefixSum, cur);\\n        }\\n        cur = cur.next;\\n    }\\n    \\n    return dummy.next;\\n    // Time Complexity: O(2n) = O(n);\\n    // Why O(2n)? ex) [1,2,3,4,5,-15]; we scan through the list forth and back here\\n    // Space Complexity: O(n)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar removeZeroSumSublists = function(head) {\\n    let dummy = new ListNode();\\n    let cur = head;\\n    dummy.next = head;\\n    let m = new Map();\\n    m.set(0, dummy);\\n    let prefixSum = 0;\\n    while (cur !== null) {\\n        prefixSum += cur.val;\\n        if (m.has(prefixSum)) {\\n            // save pointer to next node\\n            let next = cur.next;\\n\\n            // delete the nodes in between from map\\n            let temp = m.get(prefixSum).next;\\n            let tempPrefixSum = prefixSum;\\n            while (temp !== cur && temp !== null) {\\n                tempPrefixSum += temp.val;\\n                m.delete(tempPrefixSum);\\n                temp = temp.next;\\n            }\\n\\n            // set a new cur\\n            cur = m.get(prefixSum);\\n            cur.next = next;\\n        } else {\\n            m.set(prefixSum, cur);\\n        }\\n        cur = cur.next;\\n    }\\n    \\n    return dummy.next;\\n    // Time Complexity: O(2n) = O(n);\\n    // Why O(2n)? ex) [1,2,3,4,5,-15]; we scan through the list forth and back here\\n    // Space Complexity: O(n)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 920263,
                "title": "java-solution-stack-and-map-and-removed-the-stack",
                "content": "### map only\\n\\n```java\\n public ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        map.put(0, dummy);\\n        while (head != null) {\\n            sum += head.val;\\n            if (map.containsKey(sum)) {\\n                ListNode h = map.get(sum);\\n                ListNode t = h;\\n                int x = sum;\\n                h = h.next;\\n                while (h != head) {\\n                    x +=  h.val;\\n                    map.remove(x);\\n                    h = h.next;\\n                }\\n                t.next = head.next;\\n            } else {\\n                map.putIfAbsent(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n```\\n\\n\\n### stack and map\\n```java\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        Stack<Integer> stack = new Stack<>();\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        map.put(0, dummy);\\n        stack.push(0);\\n        int sum = 0;\\n        while (head != null) {\\n            sum += head.val;\\n            if (map.containsKey(sum)) {\\n                ListNode t = map.get(sum);\\n                t.next = head.next;\\n                while (!stack.isEmpty() && stack.peek() != sum) {\\n                    map.remove(stack.pop());\\n                }\\n            } else {\\n                map.put(sum, head);\\n                stack.push(sum);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "solutionTags": [],
                "code": "```java\\n public ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        int sum = 0;\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        map.put(0, dummy);\\n        while (head != null) {\\n            sum += head.val;\\n            if (map.containsKey(sum)) {\\n                ListNode h = map.get(sum);\\n                ListNode t = h;\\n                int x = sum;\\n                h = h.next;\\n                while (h != head) {\\n                    x +=  h.val;\\n                    map.remove(x);\\n                    h = h.next;\\n                }\\n                t.next = head.next;\\n            } else {\\n                map.putIfAbsent(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n```\n```java\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        Stack<Integer> stack = new Stack<>();\\n        ListNode dummy = new ListNode();\\n        dummy.next = head;\\n        map.put(0, dummy);\\n        stack.push(0);\\n        int sum = 0;\\n        while (head != null) {\\n            sum += head.val;\\n            if (map.containsKey(sum)) {\\n                ListNode t = map.get(sum);\\n                t.next = head.next;\\n                while (!stack.isEmpty() && stack.peek() != sum) {\\n                    map.remove(stack.pop());\\n                }\\n            } else {\\n                map.put(sum, head);\\n                stack.push(sum);\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 912564,
                "title": "javascript-hashmap",
                "content": "Whenever you see \"sum of consecutive numbers\" in the question description, you should immediately think of prefix sum.\\n\\nAnother important technique is storing references to list nodes in a hashmap.\\n\\nHere I will introduce a one-pass solution. The idea is that we want to keep track of the running prefix sum as we visit each node, storing each prefix sum as key and the corresponding node as value in a hashmap. And as soon as we see a redundant prefix sum or 0, we will know that we\\'ve seen a section that evaluates to 0. \\n\\nWhen prefix sum is 0, this means all the values from head to the curr node evaluate to 0.\\n\\nWhen prefix sum is greater than 0, and the sum already exists in the hashmap, this means the section between where that particular sum had occurred and the curr node evaluates to 0. For example, if we have a list `[1,2,-1,-1,3]`, then the prefix sums will be [1,**3,2,1**,4] as we go through the list. Notice in the prefix sum array, 1 occurs twice. That means the nodes corresponding to `3,2,1` (bolded) evaluate to 0. So in order to remove the bolded section, we need to do is look up the node where  `1` occurred first as a prefix sum (I call this `connectingNode` in the code below), and set its `next` pointer to the node where the prefix sum is `4`.\\n\\nAs part of the one-pass solution, we will be calculating the prefix sum and updating the linked list as we go. One tricky part of the logic is that the hashmap needs to be cleared as we delete nodes. We need to partially clear the map because we want the map to be an up-to-date representation of the linked list, in case a deletion allows a new consecutive sum of nums to evaluate to 0. So from the map, we should delete references to nodes that we will remove.\\n\\n```js\\nvar removeZeroSumSublists = function(head) {\\n    let map = {} // maps prefix sum to pointer to node\\n    let sum = 0\\n    let newHead = head\\n    let curr = head\\n    while(curr) {\\n        sum += curr.val\\n        if (sum === 0) {\\n\\t\\t\\t// nums from head to curr node evaluate to 0\\n            newHead = curr.next\\n            map = {} // clear map\\n        } else if (map[sum]) {\\n\\t\\t\\t// this means there is a sub-list that evaluates to 0.\\n            // we also need clear the map, but partially!\\n            // this is the trickiest part of the logic\\n            const connectingNode = map[sum]\\n            \\n            let tempSum = sum\\n            let tempPointer = map[sum].next\\n            while (tempPointer !== curr) {  \\n\\t\\t\\t\\t/* \\n\\t\\t\\t\\tImportant: the above condition is NOT tempPointer !== curr.next. \\n\\t\\t\\t\\tWe shouldn\\'t delete \"sum\" in map because:\\n\\t\\t\\t\\t\\t1) it belongs to the connecting node that is NOT getting deleted, and\\n\\t\\t\\t\\t\\t2) the current node that we\\'re processing hasn\\'t even been added to map\\n\\t\\t\\t\\t*/\\n                tempSum += tempPointer.val\\n                tempPointer = tempPointer.next\\n                \\n                delete map[tempSum]\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// we are done with cleaning up the map\\n\\t\\t\\t// so now actually update the pointer in the linked list\\n            connectingNode.next = curr.next\\n        } else { /* this else case is also super important,\\n\\t\\t\\t\\t\\ti.e., we should NOT be running \"map[sum] = curr\" outside of this else case.\\n\\t\\t\\t\\t\\tThe reason is that if we had just deleted some middle section\\n\\t\\t\\t\\t\\tof the list in the above \"else if\" case, we wouldn\\'t want to record the curr sum \\n\\t\\t\\t\\t\\t(because the curr sum belongs to a node that is now removed)*/\\n            map[sum] = curr\\n        }\\n        \\n        curr = curr.next\\n    }\\n    \\n    return newHead\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nvar removeZeroSumSublists = function(head) {\\n    let map = {} // maps prefix sum to pointer to node\\n    let sum = 0\\n    let newHead = head\\n    let curr = head\\n    while(curr) {\\n        sum += curr.val\\n        if (sum === 0) {\\n\\t\\t\\t// nums from head to curr node evaluate to 0\\n            newHead = curr.next\\n            map = {} // clear map\\n        } else if (map[sum]) {\\n\\t\\t\\t// this means there is a sub-list that evaluates to 0.\\n            // we also need clear the map, but partially!\\n            // this is the trickiest part of the logic\\n            const connectingNode = map[sum]\\n            \\n            let tempSum = sum\\n            let tempPointer = map[sum].next\\n            while (tempPointer !== curr) {  \\n\\t\\t\\t\\t/* \\n\\t\\t\\t\\tImportant: the above condition is NOT tempPointer !== curr.next. \\n\\t\\t\\t\\tWe shouldn\\'t delete \"sum\" in map because:\\n\\t\\t\\t\\t\\t1) it belongs to the connecting node that is NOT getting deleted, and\\n\\t\\t\\t\\t\\t2) the current node that we\\'re processing hasn\\'t even been added to map\\n\\t\\t\\t\\t*/\\n                tempSum += tempPointer.val\\n                tempPointer = tempPointer.next\\n                \\n                delete map[tempSum]\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// we are done with cleaning up the map\\n\\t\\t\\t// so now actually update the pointer in the linked list\\n            connectingNode.next = curr.next\\n        } else { /* this else case is also super important,\\n\\t\\t\\t\\t\\ti.e., we should NOT be running \"map[sum] = curr\" outside of this else case.\\n\\t\\t\\t\\t\\tThe reason is that if we had just deleted some middle section\\n\\t\\t\\t\\t\\tof the list in the above \"else if\" case, we wouldn\\'t want to record the curr sum \\n\\t\\t\\t\\t\\t(because the curr sum belongs to a node that is now removed)*/\\n            map[sum] = curr\\n        }\\n        \\n        curr = curr.next\\n    }\\n    \\n    return newHead\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 859773,
                "title": "c-python-solutions",
                "content": "C++ solution,\\n```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode node(0);\\n        ListNode* node_ = &node;\\n        node_->next = head;\\n        ListNode* head_ = node_;\\n        unordered_map<int,ListNode*> d;\\n        vector<int> dv;\\n        int s = 0;\\n\\n        while (node_) {\\n            s += node_->val;\\n\\n            if (d.count(s) == 0) {\\n                d[s] = node_;\\n                dv.push_back(s);\\n            }\\n            else {\\n                d[s]->next = node_->next;\\n                while (dv.back() != s) {\\n                    int t = dv.back();\\n                    dv.pop_back();\\n                    d.erase(t);\\n                }\\n            }\\n            \\n            node_ = node_->next;\\n        }\\n\\n        return head_->next;\\n    }\\n};\\n```\\n\\nPython solution,\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head):\\n        node = ListNode(0)\\n        node.next = head\\n        d, dv = {}, []\\n        s, node_ = 0, node\\n\\n        while node_:\\n            s += node_.val\\n\\n            if s not in d:\\n                d[s] = node_\\n                dv.append(s)\\n            else:\\n                d[s].next = node_.next\\n                while dv[-1] != s:\\n                    t = dv.pop()\\n                    del d[t]\\n\\n            node_ = node_.next\\n\\n        return node.next\\n```",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode node(0);\\n        ListNode* node_ = &node;\\n        node_->next = head;\\n        ListNode* head_ = node_;\\n        unordered_map<int,ListNode*> d;\\n        vector<int> dv;\\n        int s = 0;\\n\\n        while (node_) {\\n            s += node_->val;\\n\\n            if (d.count(s) == 0) {\\n                d[s] = node_;\\n                dv.push_back(s);\\n            }\\n            else {\\n                d[s]->next = node_->next;\\n                while (dv.back() != s) {\\n                    int t = dv.back();\\n                    dv.pop_back();\\n                    d.erase(t);\\n                }\\n            }\\n            \\n            node_ = node_->next;\\n        }\\n\\n        return head_->next;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head):\\n        node = ListNode(0)\\n        node.next = head\\n        d, dv = {}, []\\n        s, node_ = 0, node\\n\\n        while node_:\\n            s += node_.val\\n\\n            if s not in d:\\n                d[s] = node_\\n                dv.append(s)\\n            else:\\n                d[s].next = node_.next\\n                while dv[-1] != s:\\n                    t = dv.pop()\\n                    del d[t]\\n\\n            node_ = node_.next\\n\\n        return node.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 814712,
                "title": "simple-map-solution-c",
                "content": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\t\\t\\t\\n\\t\\t\\tmap<int,ListNode*> m;\\n\\t\\t\\tListNode* current=head;\\n\\t\\t\\tint sum=0;\\n        \\n            while(current!=NULL)\\n            {\\n                sum=sum+current->val;\\n                if(sum==0)\\n                {\\n                    ListNode* left=current->next;\\n                    current->next=NULL;\\n                    head=left;\\n                    current=left;\\n                    m.clear();\\n                }\\n                else if(m.find(sum)!=m.end())\\n                {\\n                    ListNode* left=m[sum];\\n                    \\n                    //removing sum from left->next to current\\n                    ListNode* c=left->next;\\n                    int nsum=sum;\\n                    while(c!=current)\\n                    {\\n                        nsum+=c->val;\\n                        m.erase(nsum);\\n                        c=c->next;\\n                    }\\n                    //after removing map left with prev state\\n                    \\n                    ListNode* right=current->next;\\n                    left->next=right;\\n                    current=right;\\n                }\\n                else if(m.find(sum)==m.end())\\n                {\\n                    m[sum]=current;\\n                    current=current->next;\\n                }\\n            }\\n        return head;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n\\t\\t\\t\\n\\t\\t\\tmap<int,ListNode*> m;\\n\\t\\t\\tListNode* current=head;\\n\\t\\t\\tint sum=0;\\n        \\n            while(current!=NULL)\\n            {\\n                sum=sum+current->val;\\n                if(sum==0)\\n                {\\n                    ListNode* left=current->next;\\n                    current->next=NULL;\\n                    head=left;\\n                    current=left;\\n                    m.clear();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 785062,
                "title": "c-o-n-solution-csp",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if (head == NULL) return head;\\n        \\n        ListNode* myHead = new ListNode(0, head);\\n        stack<int>sums;\\n        unordered_map<int,ListNode*>dict; //Key = Sum, Val = ListNode\\n        int sum = 0;\\n        \\n        sums.push(0);\\n        dict[0] = myHead;\\n        \\n        while(head != NULL) {\\n            \\n            sum += head->val;\\n            \\n            if (dict.find(sum) != dict.end()) {\\n                \\n                head = head->next;\\n                \\n                while(sums.top() != sum) {\\n                    \\n                    dict.erase(sums.top());\\n                    sums.pop();\\n                    \\n                }//while stack\\n                \\n                dict[sums.top()]->next = head;\\n            }//if val\\n            else {\\n                \\n                sums.push(sum);\\n                dict[sum] = head;\\n                head = head->next;\\n                \\n            }//else val\\n            \\n        }//while\\n        \\n        head = myHead->next;\\n        \\n        myHead->next = NULL;\\n        delete myHead;\\n        \\n        return head;\\n    }\\n};\\n/*\\nKK\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        if (head == NULL) return head;\\n        \\n        ListNode* myHead = new ListNode(0, head);\\n        stack<int>sums;\\n        unordered_map<int,ListNode*>dict; //Key = Sum, Val = ListNode\\n        int sum = 0;\\n        \\n        sums.push(0);\\n        dict[0] = myHead;\\n        \\n        while(head != NULL) {\\n            \\n            sum += head->val;\\n            \\n            if (dict.find(sum) != dict.end()) {\\n                \\n                head = head->next;\\n                \\n                while(sums.top() != sum) {\\n                    \\n                    dict.erase(sums.top());\\n                    sums.pop();\\n                    \\n                }//while stack\\n                \\n                dict[sums.top()]->next = head;\\n            }//if val\\n            else {\\n                \\n                sums.push(sum);\\n                dict[sum] = head;\\n                head = head->next;\\n                \\n            }//else val\\n            \\n        }//while\\n        \\n        head = myHead->next;\\n        \\n        myHead->next = NULL;\\n        delete myHead;\\n        \\n        return head;\\n    }\\n};\\n/*\\nKK\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(N)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 765186,
                "title": "c-4ms-100-speed-memory-less-than-80-77",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        ListNode *prev = new ListNode(0);\\n        prev->next = head;\\n        ListNode *temp = prev;\\n        while(temp != NULL)\\n        {\\n            int sum = 0;\\n            while(head != NULL)\\n            {\\n                sum += head->val;\\n                if(sum == 0)\\n                    temp->next = head->next;\\n                head = head->next;\\n            }\\n            temp = temp->next;\\n            if(temp != NULL)\\n                    head = temp->next;\\n        }\\n        return prev->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(NULL);\\n        ListNode *prev = new ListNode(0);\\n        prev->next = head;\\n        ListNode *temp = prev;\\n        while(temp != NULL)\\n        {\\n            int sum = 0;\\n            while(head != NULL)\\n            {\\n                sum += head->val;\\n                if(sum == 0)\\n                    temp->next = head->next;\\n                head = head->next;\\n            }\\n            temp = temp->next;\\n            if(temp != NULL)\\n                    head = temp->next;\\n        }\\n        return prev->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 744181,
                "title": "java-hashmap-storing-prev-sum-o-n",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public void cleanMap(ListNode node, int sum, ListNode head, HashMap<Integer, ListNode> map ) {\\n        if(node == head) return;\\n        sum+=node.val;\\n        map.remove(sum);\\n        cleanMap(node.next, sum, head, map);\\n    }\\n    \\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        ListNode root = new ListNode(0);\\n        root.next = head;\\n        map.put(0, root);\\n        int sum = 0;\\n        while(head!=null){\\n            sum+=head.val;\\n            if(map.containsKey(sum)){\\n                ListNode node = map.get(sum);\\n                cleanMap(node.next, sum, head, map);\\n                node.next = head.next;\\n            }\\n            else{\\n                map.put(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return root.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * public class ListNode {\\n *     int val;\\n *     ListNode next;\\n *     ListNode() {}\\n *     ListNode(int val) { this.val = val; }\\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\\n * }\\n */\\nclass Solution {\\n    \\n    public void cleanMap(ListNode node, int sum, ListNode head, HashMap<Integer, ListNode> map ) {\\n        if(node == head) return;\\n        sum+=node.val;\\n        map.remove(sum);\\n        cleanMap(node.next, sum, head, map);\\n    }\\n    \\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        HashMap<Integer, ListNode> map = new HashMap<>();\\n        ListNode root = new ListNode(0);\\n        root.next = head;\\n        map.put(0, root);\\n        int sum = 0;\\n        while(head!=null){\\n            sum+=head.val;\\n            if(map.containsKey(sum)){\\n                ListNode node = map.get(sum);\\n                cleanMap(node.next, sum, head, map);\\n                node.next = head.next;\\n            }\\n            else{\\n                map.put(sum, head);\\n            }\\n            head = head.next;\\n        }\\n        return root.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 712211,
                "title": "python-o-n-tedious-solution-though",
                "content": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        \\n        \\n        \\n        \\n        \\n        allNodes = []\\n        \\n        while head:\\n            allNodes.append(head.val)\\n            head = head.next\\n            \\n        \\n        from collections import deque\\n        \\n        \\n        \\n            \\n        \\n        dp = deque()\\n        \\n        j = 0\\n        \\n        while j < len(allNodes) and allNodes[j] == 0:\\n            j+=1\\n        \\n        \\n        if(j == len(allNodes)):\\n            return None\\n        \\n        \\n        dp.append((allNodes[j],j))\\n        \\n        prevSum = {allNodes[j]:j}\\n        \\n        for i in range(j+1,len(allNodes)):\\n            \\n            if(dp):\\n                val = dp[-1][0] + allNodes[i]\\n                \\n            else:\\n                val = allNodes[i]\\n            \\n            if(val == 0):\\n                \\n                while dp:\\n                    dp.pop()\\n                \\n                prevSum = {}\\n                continue\\n                \\n            if(val in prevSum):\\n                \\n                index = prevSum[val]\\n                \\n                while dp and (dp[-1][1] > index):\\n                    _,idx = dp.pop()\\n                    \\n                    temp_dict = prevSum.copy()\\n                    for k,v in prevSum.items():\\n                        if(v == idx):\\n                            del temp_dict[k]\\n                            \\n                    prevSum  = temp_dict.copy()\\n                    temp_dict = {}\\n        \\n            else:\\n                \\n                prevSum[val] = i\\n                dp.append((val,i))\\n                \\n           \\n        root = ListNode(-1)\\n        temp = root\\n        \\n        while dp:\\n            \\n            _,idx = dp.popleft()\\n            \\n            \\n            node = ListNode(allNodes[idx])\\n            root.next = node\\n            root = root.next\\n                \\n                \\n        return temp.next\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for singly-linked list.\\n# class ListNode:\\n#     def __init__(self, val=0, next=None):\\n#         self.val = val\\n#         self.next = next\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        \\n        \\n        \\n        \\n        \\n        allNodes = []\\n        \\n        while head:\\n            allNodes.append(head.val)\\n            head = head.next\\n            \\n        \\n        from collections import deque\\n        \\n        \\n        \\n            \\n        \\n        dp = deque()\\n        \\n        j = 0\\n        \\n        while j < len(allNodes) and allNodes[j] == 0:\\n            j+=1\\n        \\n        \\n        if(j == len(allNodes)):\\n            return None\\n        \\n        \\n        dp.append((allNodes[j],j))\\n        \\n        prevSum = {allNodes[j]:j}\\n        \\n        for i in range(j+1,len(allNodes)):\\n            \\n            if(dp):\\n                val = dp[-1][0] + allNodes[i]\\n                \\n            else:\\n                val = allNodes[i]\\n            \\n            if(val == 0):\\n                \\n                while dp:\\n                    dp.pop()\\n                \\n                prevSum = {}\\n                continue\\n                \\n            if(val in prevSum):\\n                \\n                index = prevSum[val]\\n                \\n                while dp and (dp[-1][1] > index):\\n                    _,idx = dp.pop()\\n                    \\n                    temp_dict = prevSum.copy()\\n                    for k,v in prevSum.items():\\n                        if(v == idx):\\n                            del temp_dict[k]\\n                            \\n                    prevSum  = temp_dict.copy()\\n                    temp_dict = {}\\n        \\n            else:\\n                \\n                prevSum[val] = i\\n                dp.append((val,i))\\n                \\n           \\n        root = ListNode(-1)\\n        temp = root\\n        \\n        while dp:\\n            \\n            _,idx = dp.popleft()\\n            \\n            \\n            node = ListNode(allNodes[idx])\\n            root.next = node\\n            root = root.next\\n                \\n                \\n        return temp.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 680488,
                "title": "java-accepted-hash-map-solution",
                "content": "```\\n\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\nHashMap<Integer,ListNode> map = new  HashMap<>();\\n        \\n        \\n        ListNode dummy  = new ListNode(0);\\n        dummy.next=head;\\n        int sum=0;\\n        map.put(0,dummy);\\n        while(head!=null)\\n        {\\n        sum+=head.val;\\n            if(map.containsKey(sum))\\n            {\\n                ListNode rem = map.get(sum).next;\\n                int sum2=sum;\\n                while(rem!=head)\\n                {\\n                sum2+=rem.val;\\n                    map.remove(sum2);\\n               rem=rem.next;\\n                }\\n                \\n                \\n                map.get(sum).next=head.next;\\n                \\n            }\\n        else\\n        {\\n            map.put(sum,head);\\n        }\\n        head=head.next;\\n        }\\n        \\n        return dummy.next;     \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\nHashMap<Integer,ListNode> map = new  HashMap<>();\\n        \\n        \\n        ListNode dummy  = new ListNode(0);\\n        dummy.next=head;\\n        int sum=0;\\n        map.put(0,dummy);\\n        while(head!=null)\\n        {\\n        sum+=head.val;\\n            if(map.containsKey(sum))\\n            {\\n                ListNode rem = map.get(sum).next;\\n                int sum2=sum;\\n                while(rem!=head)\\n                {\\n                sum2+=rem.val;\\n                    map.remove(sum2);\\n               rem=rem.next;\\n                }\\n                \\n                \\n                map.get(sum).next=head.next;\\n                \\n            }\\n        else\\n        {\\n            map.put(sum,head);\\n        }\\n        head=head.next;\\n        }\\n        \\n        return dummy.next;     \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 661858,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        vector<int> vals;\\n        vector<int> sum = {0};\\n        ListNode* cur = head;\\n        while (cur){\\n            vals.push_back(cur->val);\\n            cur = cur->next;\\n        }\\n        sum.push_back(vals[0]);\\n        for (int i=1; i<vals.size(); i++){\\n            sum.push_back(sum[i]+vals[i]);\\n        }\\n        ListNode* nhead = new ListNode(0);\\n        ListNode* ntail = nhead;\\n        int i = 0;\\n        while (i < vals.size()){\\n            for (int j=vals.size(); j>=i; j--){\\n                if (i==j){\\n                    ListNode* nnode = new ListNode(vals[i]);\\n                    ntail->next = nnode;\\n                    ntail = nnode;\\n                    i++; break;\\n                }else if (sum[i]==sum[j]){\\n                    i = j; break;\\n                }\\n            }\\n        }\\n        return nhead->next;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        vector<int> vals;\\n        vector<int> sum = {0};\\n        ListNode* cur = head;\\n        while (cur){\\n            vals.push_back(cur->val);\\n            cur = cur->next;\\n        }\\n        sum.push_back(vals[0]);\\n        for (int i=1; i<vals.size(); i++){\\n            sum.push_back(sum[i]+vals[i]);\\n        }\\n        ListNode* nhead = new ListNode(0);\\n        ListNode* ntail = nhead;\\n        int i = 0;\\n        while (i < vals.size()){\\n            for (int j=vals.size(); j>=i; j--){\\n                if (i==j){\\n                    ListNode* nnode = new ListNode(vals[i]);\\n                    ntail->next = nnode;\\n                    ntail = nnode;\\n                    i++; break;\\n                }else if (sum[i]==sum[j]){\\n                    i = j; break;\\n                }\\n            }\\n        }\\n        return nhead->next;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 647343,
                "title": "o-n-java-solution",
                "content": "~~~\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n      Map<Integer,ListNode> map =new HashMap<Integer,ListNode>();\\n      ListNode current =head;\\n      int sum=0;  \\n        \\n        if(head== null) return null;\\n        \\n        while(current!=null){\\n            sum+=current.val;\\n            map.put(sum,current);\\n            current=current.next;\\n        }\\n        \\n        current = head;\\n        sum=0;\\n        while(current!=null){\\n            \\n            sum+=current.val;\\n            if(sum == 0){\\n                head = current.next;\\n            }\\n            else if(map.containsKey(sum)){\\n                \\n                current.next = map.get(sum).next;\\n            }\\n            current=current.next;\\n        }\\n   return head; \\n    }\\n}\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        \\n      Map<Integer,ListNode> map =new HashMap<Integer,ListNode>();\\n      ListNode current =head;\\n      int sum=0;  \\n        \\n        if(head== null) return null;\\n        \\n        while(current!=null){\\n            sum+=current.val;\\n            map.put(sum,current);\\n            current=current.next;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 647283,
                "title": "javascript-clean-solution",
                "content": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeZeroSumSublists = function(head) {\\n  if (!head) return null;\\n  let p = head;\\n  let s = 0;\\n  while (p) {\\n    s += p.val;\\n    if (s == 0) {\\n      return removeZeroSumSublists(p.next);\\n    } else {\\n      p = p.next;\\n    }\\n  }\\n  head.next = removeZeroSumSublists(head.next);\\n  return head;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for singly-linked list.\\n * function ListNode(val, next) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.next = (next===undefined ? null : next)\\n * }\\n */\\n/**\\n * @param {ListNode} head\\n * @return {ListNode}\\n */\\nvar removeZeroSumSublists = function(head) {\\n  if (!head) return null;\\n  let p = head;\\n  let s = 0;\\n  while (p) {\\n    s += p.val;\\n    if (s == 0) {\\n      return removeZeroSumSublists(p.next);\\n    } else {\\n      p = p.next;\\n    }\\n  }\\n  head.next = removeZeroSumSublists(head.next);\\n  return head;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 640445,
                "title": "c-o-n-time-and-space-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp = head;\\n        unordered_map<int,ListNode*> MAP;\\n        int sum = 0;\\n        int temp_sum;\\n        ListNode* temp2;\\n        ListNode* parent;\\n        while(temp!=NULL){\\n            sum+=temp->val;\\n            if(sum==0){\\n                temp2 = head;\\n                temp_sum = 0;\\n                while(temp2!=temp){\\n                    temp_sum+=temp2->val;\\n                    MAP.erase(temp_sum);\\n                    temp2 = temp2->next;\\n                }\\n                head = temp->next;\\n            } else if(MAP.find(sum)!=MAP.end()){\\n                parent = MAP[sum];\\n                temp2 = parent->next;\\n                temp_sum = sum;\\n                while(temp2!=temp){\\n                    temp_sum+=temp2->val;\\n                    MAP.erase(temp_sum);\\n                    temp2 = temp2->next;\\n                }\\n                parent->next = temp->next;\\n            } else {\\n                MAP[sum] = temp;                \\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        ListNode* temp = head;\\n        unordered_map<int,ListNode*> MAP;\\n        int sum = 0;\\n        int temp_sum;\\n        ListNode* temp2;\\n        ListNode* parent;\\n        while(temp!=NULL){\\n            sum+=temp->val;\\n            if(sum==0){\\n                temp2 = head;\\n                temp_sum = 0;\\n                while(temp2!=temp){\\n                    temp_sum+=temp2->val;\\n                    MAP.erase(temp_sum);\\n                    temp2 = temp2->next;\\n                }\\n                head = temp->next;\\n            } else if(MAP.find(sum)!=MAP.end()){\\n                parent = MAP[sum];\\n                temp2 = parent->next;\\n                temp_sum = sum;\\n                while(temp2!=temp){\\n                    temp_sum+=temp2->val;\\n                    MAP.erase(temp_sum);\\n                    temp2 = temp2->next;\\n                }\\n                parent->next = temp->next;\\n            } else {\\n                MAP[sum] = temp;                \\n            }\\n            temp = temp->next;\\n        }\\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601019,
                "title": "c-hash-map-solution-linked-list-in-place",
                "content": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        if(!head || (head->val == 0 && !head->next))\\n            return NULL;\\n        \\n        ListNode* node = head;\\n        ListNode* startNode = NULL;\\n        \\n        unordered_map<int, ListNode*> hashMap;\\n        int sum = 0;\\n        hashMap[0] = NULL;\\n        bool CLEAREDUP = false;\\n       \\n        while(node)\\n        {\\n            sum += node->val;\\n\\n            if(hashMap.find(sum) == hashMap.end())\\n            {\\n                hashMap[sum] = node;\\n                node = node->next;\\n            }\\n            else\\n            {\\n                startNode = hashMap[sum];\\n                startNode ? startNode->next = node->next : head = node->next; \\n\\n                hashMap = {},   hashMap[0] = NULL;\\n                sum = 0;\\n                node = head;\\n            }\\n        }\\n            \\n        return head;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) \\n    {\\n        if(!head || (head->val == 0 && !head->next))\\n            return NULL;\\n        \\n        ListNode* node = head;\\n        ListNode* startNode = NULL;\\n        \\n        unordered_map<int, ListNode*> hashMap;\\n        int sum = 0;\\n        hashMap[0] = NULL;\\n        bool CLEAREDUP = false;\\n       \\n        while(node)\\n        {\\n            sum += node->val;\\n\\n            if(hashMap.find(sum) == hashMap.end())\\n            {\\n                hashMap[sum] = node;\\n                node = node->next;\\n            }\\n            else\\n            {\\n                startNode = hashMap[sum];\\n                startNode ? startNode->next = node->next : head = node->next; \\n\\n                hashMap = {},   hashMap[0] = NULL;\\n                sum = 0;\\n                node = head;\\n            }\\n        }\\n            \\n        return head;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 576417,
                "title": "python-98-100",
                "content": "This python code is based on @arpanbag001\\'s [explanation](https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/507108/Java-simple-O(n)-solution-with-explanation). O(n):\\n\\n```\\nclass Solution(object):\\n\\tdef removeZeroSumSublists(self, head):\\n\\t\\t\"\"\"\\n\\t\\tBased on the Java solution explained here:\\n\\t\\thttps://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/507108/Java-simple-O(n)-solution-with-explanation\\n\\n\\t\\tThe main idea is that a cumulative sum will have repeating values when there are zero sum sublists. For e.g. if the original linked list is [1,2,3,-3,-1,1], then a cumulative sum with a prehead (an artificial 0 entry before the head) will be: [0, 1, 3, 6, 3, 2, 3]. As you can see a cumulative sum of 3 occurs three times. Which implies that the sublists [3,-3] and [-1,1] add up to zero.\\n\\n\\t\\t:param head: \\n\\t\\t:return: \\n\\t\\t\"\"\"\\n\\t\\tprehead = ListNode(0)\\n\\t\\tprehead.next = head\\n\\t\\tcurrent = head\\n\\t\\tsum_map = {0: prehead} #cumulative sum map\\n\\t\\tcumsum = 0\\n\\t\\twhile current:\\n\\t\\t\\tcumsum += current.val\\n\\t\\t\\tif cumsum in sum_map: #cumulative sum in the map\\n\\t\\t\\t\\tprevmatch = sum_map[cumsum]\\n\\t\\t\\t\\twalker = prevmatch.next\\n\\t\\t\\t\\twsum = cumsum\\n\\t\\t\\t\\twhile walker != current:\\n\\t\\t\\t\\t\\twsum += walker.val\\n\\t\\t\\t\\t\\t# delete intermediate cumulative sums in zero sublist\\n\\t\\t\\t\\t\\tdel sum_map[wsum] \\n\\t\\t\\t\\t\\twalker = walker.next\\n\\t\\t\\t\\tprevmatch.next = current.next #skip zero sum sublist entries\\n\\t\\t\\telse:\\n\\t\\t\\t\\tsum_map[cumsum] = current\\n\\t\\t\\tcurrent = current.next\\n\\t\\treturn prehead.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\tdef removeZeroSumSublists(self, head):\\n\\t\\t\"\"\"\\n\\t\\tBased on the Java solution explained here:\\n\\t\\thttps://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discuss/507108/Java-simple-O(n)-solution-with-explanation\\n\\n\\t\\tThe main idea is that a cumulative sum will have repeating values when there are zero sum sublists. For e.g. if the original linked list is [1,2,3,-3,-1,1], then a cumulative sum with a prehead (an artificial 0 entry before the head) will be: [0, 1, 3, 6, 3, 2, 3]. As you can see a cumulative sum of 3 occurs three times. Which implies that the sublists [3,-3] and [-1,1] add up to zero.\\n\\n\\t\\t:param head: \\n\\t\\t:return: \\n\\t\\t\"\"\"\\n\\t\\tprehead = ListNode(0)\\n\\t\\tprehead.next = head\\n\\t\\tcurrent = head\\n\\t\\tsum_map = {0: prehead} #cumulative sum map\\n\\t\\tcumsum = 0\\n\\t\\twhile current:\\n\\t\\t\\tcumsum += current.val\\n\\t\\t\\tif cumsum in sum_map: #cumulative sum in the map\\n\\t\\t\\t\\tprevmatch = sum_map[cumsum]\\n\\t\\t\\t\\twalker = prevmatch.next\\n\\t\\t\\t\\twsum = cumsum\\n\\t\\t\\t\\twhile walker != current:\\n\\t\\t\\t\\t\\twsum += walker.val\\n\\t\\t\\t\\t\\t# delete intermediate cumulative sums in zero sublist\\n\\t\\t\\t\\t\\tdel sum_map[wsum] \\n\\t\\t\\t\\t\\twalker = walker.next\\n\\t\\t\\t\\tprevmatch.next = current.next #skip zero sum sublist entries\\n\\t\\t\\telse:\\n\\t\\t\\t\\tsum_map[cumsum] = current\\n\\t\\t\\tcurrent = current.next\\n\\t\\treturn prehead.next\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 561603,
                "title": "java-solution-with-explain",
                "content": "```java\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        while(prev.next != null){\\n\\t\\t//every time we begin from the first node, and calculate the sum of all the node from the first\\n            int sum = 0;\\n            ListNode cur = prev.next;\\n            for(; cur != null; cur = cur.next){\\n                sum += cur.val;\\n                if(sum == 0) {\\n                    prev.next = cur.next;\\n                    break; //when matches, break the loop\\n                }\\n            }\\n\\t\\t\\t// if no sum from first equals 0, then start from next node\\n            if(cur == null) prev = prev.next;\\n            \\n        }\\n        \\n        return dummy.next;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic ListNode removeZeroSumSublists(ListNode head) {\\n        if(head == null) return head;\\n        ListNode dummy = new ListNode(0);\\n        dummy.next = head;\\n        ListNode prev = dummy;\\n        while(prev.next != null){\\n\\t\\t//every time we begin from the first node, and calculate the sum of all the node from the first\\n            int sum = 0;\\n            ListNode cur = prev.next;\\n            for(; cur != null; cur = cur.next){\\n                sum += cur.val;\\n                if(sum == 0) {\\n                    prev.next = cur.next;\\n                    break; //when matches, break the loop\\n                }\\n            }\\n\\t\\t\\t// if no sum from first equals 0, then start from next node\\n            if(cur == null) prev = prev.next;\\n            \\n        }\\n        \\n        return dummy.next;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 550152,
                "title": "c-recursive",
                "content": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n\\tunordered_map<int, ListNode*> seen;\\n\\tseen[0] = nullptr;\\n\\tint sum = 0;\\n\\tfor (ListNode *curr = head; curr; curr = curr->next) {\\n\\t\\tsum += curr->val;\\n\\t\\tauto it = seen.find(sum);\\n\\t\\tif (it == seen.end()) {\\n\\t\\t\\tseen[sum] = curr;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// remove section\\n\\t\\tif (it->second) {\\n\\t\\t\\tit->second->next = curr->next;\\n\\t\\t\\treturn removeZeroSumSublists(head);\\n\\t\\t}   else {\\n\\t\\t\\treturn removeZeroSumSublists(curr->next);\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nListNode* removeZeroSumSublists(ListNode* head) {\\n\\tunordered_map<int, ListNode*> seen;\\n\\tseen[0] = nullptr;\\n\\tint sum = 0;\\n\\tfor (ListNode *curr = head; curr; curr = curr->next) {\\n\\t\\tsum += curr->val;\\n\\t\\tauto it = seen.find(sum);\\n\\t\\tif (it == seen.end()) {\\n\\t\\t\\tseen[sum] = curr;\\n\\t\\t\\tcontinue;\\n\\t\\t}\\n\\n\\t\\t// remove section\\n\\t\\tif (it->second) {\\n\\t\\t\\tit->second->next = curr->next;\\n\\t\\t\\treturn removeZeroSumSublists(head);\\n\\t\\t}   else {\\n\\t\\t\\treturn removeZeroSumSublists(curr->next);\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 548511,
                "title": "c-skipping-the-nodes-that-doesn-t-sum-effectively-adding-up-to-0",
                "content": "Here `preHead` is required for cases like [-1, 1] where prefix of array can be empty.\\n\\n```csharp\\npublic ListNode RemoveZeroSumSublists(ListNode head) \\n{\\n\\tDictionary<int, ListNode> sumToFurthestNode = new Dictionary<int, ListNode>();      \\n\\tListNode preHead = new ListNode(0);\\n\\tpreHead.next = head;\\n\\n\\tint sum = 0;\\n\\tfor(ListNode p = preHead; p != null; p = p.next)\\n\\t{\\n\\t\\tsum += p.val;\\n\\t\\tsumToFurthestNode[sum] = p;\\n\\t}\\n\\n\\tsum = 0;\\n\\tfor(ListNode p = preHead; p != null; p = p.next)\\n\\t{\\n\\t\\tsum += p.val;\\n\\t\\tp.next = sumToFurthestNode[sum].next;\\n\\t}\\n\\n\\treturn preHead.next;        \\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic ListNode RemoveZeroSumSublists(ListNode head) \\n{\\n\\tDictionary<int, ListNode> sumToFurthestNode = new Dictionary<int, ListNode>();      \\n\\tListNode preHead = new ListNode(0);\\n\\tpreHead.next = head;\\n\\n\\tint sum = 0;\\n\\tfor(ListNode p = preHead; p != null; p = p.next)\\n\\t{\\n\\t\\tsum += p.val;\\n\\t\\tsumToFurthestNode[sum] = p;\\n\\t}\\n\\n\\tsum = 0;\\n\\tfor(ListNode p = preHead; p != null; p = p.next)\\n\\t{\\n\\t\\tsum += p.val;\\n\\t\\tp.next = sumToFurthestNode[sum].next;\\n\\t}\\n\\n\\treturn preHead.next;        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 471085,
                "title": "python-brute-force-and-optimized-solutions",
                "content": "1. Brute force\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        \\n        def f(arr, target=0):\\n            if not arr:\\n                return []\\n            d = {0:-1}\\n            so_far = 0\\n            for i, num in enumerate(arr):\\n                so_far += num\\n                if so_far - target in d:\\n                    return arr[:d[so_far - target]+1] + arr[i+1:]\\n                else:\\n                    d[so_far] = i\\n            return arr\\n        \\n        def arr(head):\\n            res = []\\n            c = head\\n            while c:\\n                res.append(c.val)\\n                c = c.next\\n            return res\\n        \\n        a = arr(head)\\n        b = f(a)\\n        while a != b:\\n            a, b = b, f(b)\\n        \\n        dummy = ListNode(\"*\")\\n        current = dummy\\n        for num in b:\\n            tmp = ListNode(num)\\n            current.next = tmp\\n            current = tmp\\n        current.next = None\\n        return dummy.next\\n```\\n\\n2. Without by way of a plain list\\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = {0:dummy} # prefix:ListNode\\n        current = head\\n        while current:\\n            prefix += current.val\\n            seen[prefix] = current # seen[prefix] records the most recent seen ListNode with prefix\\n            current = current.next\\n            \\n        prefix, current = 0, dummy\\n        while current:\\n            prefix += current.val\\n            current.next = seen[prefix].next\\n            current = current.next\\n        return dummy.next\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        \\n        def f(arr, target=0):\\n            if not arr:\\n                return []\\n            d = {0:-1}\\n            so_far = 0\\n            for i, num in enumerate(arr):\\n                so_far += num\\n                if so_far - target in d:\\n                    return arr[:d[so_far - target]+1] + arr[i+1:]\\n                else:\\n                    d[so_far] = i\\n            return arr\\n        \\n        def arr(head):\\n            res = []\\n            c = head\\n            while c:\\n                res.append(c.val)\\n                c = c.next\\n            return res\\n        \\n        a = arr(head)\\n        b = f(a)\\n        while a != b:\\n            a, b = b, f(b)\\n        \\n        dummy = ListNode(\"*\")\\n        current = dummy\\n        for num in b:\\n            tmp = ListNode(num)\\n            current.next = tmp\\n            current = tmp\\n        current.next = None\\n        return dummy.next\\n```\n```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        dummy.next = head\\n        prefix = 0\\n        seen = {0:dummy} # prefix:ListNode\\n        current = head\\n        while current:\\n            prefix += current.val\\n            seen[prefix] = current # seen[prefix] records the most recent seen ListNode with prefix\\n            current = current.next\\n            \\n        prefix, current = 0, dummy\\n        while current:\\n            prefix += current.val\\n            current.next = seen[prefix].next\\n            current = current.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 466365,
                "title": "c",
                "content": "```\\npublic ListNode RemoveZeroSumSublists(ListNode head) {\\n\\tvar dict = new Dictionary<int, ListNode>();\\n\\tvar stack = new Stack<int>();\\n\\tvar sum = 0;\\n\\n\\tfor (var curr = head; curr != null; curr = curr.next) {\\n\\t\\tsum += curr.val;\\n\\n\\t\\tif (sum == 0) {\\n\\t\\t\\thead = curr.next;\\n\\t\\t\\tdict.Clear();\\n\\t\\t}\\n\\t\\telse if (dict.ContainsKey(sum)) {\\n\\t\\t\\tdict[sum].next = curr.next;\\n\\t\\t\\twhile (stack.Count > 0 && stack.Peek() != sum) \\n\\t\\t\\t\\tdict.Remove(stack.Pop());\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdict.Add(sum, curr);\\n\\t\\t\\tstack.Push(sum);\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic ListNode RemoveZeroSumSublists(ListNode head) {\\n\\tvar dict = new Dictionary<int, ListNode>();\\n\\tvar stack = new Stack<int>();\\n\\tvar sum = 0;\\n\\n\\tfor (var curr = head; curr != null; curr = curr.next) {\\n\\t\\tsum += curr.val;\\n\\n\\t\\tif (sum == 0) {\\n\\t\\t\\thead = curr.next;\\n\\t\\t\\tdict.Clear();\\n\\t\\t}\\n\\t\\telse if (dict.ContainsKey(sum)) {\\n\\t\\t\\tdict[sum].next = curr.next;\\n\\t\\t\\twhile (stack.Count > 0 && stack.Peek() != sum) \\n\\t\\t\\t\\tdict.Remove(stack.Pop());\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tdict.Add(sum, curr);\\n\\t\\t\\tstack.Push(sum);\\n\\t\\t}\\n\\t}\\n\\n\\treturn head;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 414088,
                "title": "java-recursive-solution-clean-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        if (head.next == null) return head.val == 0 ? null : head;\\n        ListNode p = removeZeroSumSublists(head.next);\\n        head.next = p;\\n        int sum = head.val;\\n        while (p != null) {\\n            if (sum == 0) return p;\\n            sum += p.val;\\n            p = p.next;\\n        }\\n        if (sum == 0) return p;\\n        \\n        return head;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        if (head == null) return null;\\n        if (head.next == null) return head.val == 0 ? null : head;\\n        ListNode p = removeZeroSumSublists(head.next);\\n        head.next = p;\\n        int sum = head.val;\\n        while (p != null) {\\n            if (sum == 0) return p;\\n            sum += p.val;\\n            p = p.next;\\n        }\\n        if (sum == 0) return p;\\n        \\n        return head;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 411097,
                "title": "easy-to-understand-c-solution-8ms-beats-98",
                "content": "Runtime: 8 ms, faster than 98.40% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\nMemory Usage: 10.4 MB, less than 100.00% of C++ online submissions for Remove Zero Sum Consecutive Nodes from Linked List.\\n\\n```\\n/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode(int x) : val(x), next(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        int prefixSum = 0;\\n        unordered_map<int, ListNode*> mp;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        mp[0] = dummy;\\n        ListNode* ptr = head;\\n        \\n        while(ptr)\\n        {\\n            prefixSum += ptr->val;\\n            \\n            if(mp.find(prefixSum) != mp.end())\\n            {\\n                ListNode* prev = mp[prefixSum];\\n                ListNode* start = prev;\\n                int auxPrefixSum = prefixSum;\\n                \\n                while(prev != ptr)\\n                {\\n                    prev = prev->next;\\n                    auxPrefixSum += prev->val;\\n                    if(prev != ptr) mp.erase(auxPrefixSum);\\n                }\\n                \\n                start->next = ptr->next;\\n            }\\n            else\\n                mp[prefixSum] = ptr;\\n            ptr = ptr->next;\\n        }\\n        return dummy->next;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    ListNode* removeZeroSumSublists(ListNode* head) {\\n        \\n        int prefixSum = 0;\\n        unordered_map<int, ListNode*> mp;\\n        ListNode* dummy = new ListNode(0);\\n        dummy->next = head;\\n        \\n        mp[0] = dummy;\\n        ListNode* ptr = head;\\n        \\n        while(ptr)\\n        {\\n            prefixSum += ptr->val;\\n            \\n            if(mp.find(prefixSum) != mp.end())\\n            {\\n                ListNode* prev = mp[prefixSum];\\n                ListNode* start = prev;\\n                int auxPrefixSum = prefixSum;\\n                \\n                while(prev != ptr)\\n                {\\n                    prev = prev->next;\\n                    auxPrefixSum += prev->val;\\n                    if(prev != ptr) mp.erase(auxPrefixSum);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 401406,
                "title": "python-92-dictionary",
                "content": "Idea: as we traverse the list from the beginning, we store all recorded partial sums in a dictionary of the form {partial_sum : last_node}. As soon as we find a node which has a partial sum we have seen before (meaning the sum of all intermediate elements is 0), we backtrack to the node where the sum was last observed, effectively remove everything in between by modifying the pointer to the next element and once again traverse the list of deleted nodes to mark them as deleted.\\n\\n```class Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        last_sum = 0\\n        data = {0:None}\\n        curr = head\\n        discarded = set()\\n        while curr:\\n            last_sum = last_sum+curr.val\\n            if last_sum in data and data[last_sum] not in discarded:\\n                res = curr.next\\n                if data[last_sum] is None:\\n                    cln = head\\n                    head = res\\n                else:\\n                    cln = data[last_sum].next\\n                    data[last_sum].next = res\\n                while cln!=res:\\n                    discarded.add(cln)\\n                    cln = cln.next\\n            else:\\n                data[last_sum] = curr\\n            curr = curr.next\\n        return head",
                "solutionTags": [],
                "code": "class Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        last_sum = 0\\n        data = {0:None}",
                "codeTag": "Java"
            },
            {
                "id": 389613,
                "title": "python-3-91-100-with-comments-fast-asf",
                "content": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        #construct hash map with initial dummy node\\n        self.nodes = {}\\n        #dummy node\\n        dummy = ListNode(-9999)\\n        self.nodes[0] = dummy\\n        #current node\\n        cur = head\\n        dummy.next = cur\\n        #current sum\\n        total = 0\\n        #keep running total and map nodes to running total\\n        while cur is not None:\\n            #add to running total\\n            total += cur.val\\n            #first check if we\\'ve seen this sum before\\n            if total in self.nodes:\\n                #to be removed (one after acc. sum)\\n                to_be_removed = self.nodes[total].next\\n                #second sum\\n                total2 = total\\n                while to_be_removed != cur:\\n                    total2 += to_be_removed.val\\n                    self.nodes.pop(total2)\\n                    to_be_removed = to_be_removed.next\\n                #draw link from sum to next of cur\\n                self.nodes[total].next = cur.next\\n            else:\\n                #map it\\n                self.nodes[total] = cur\\n            #set next\\n            cur = cur.next\\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        #construct hash map with initial dummy node\\n        self.nodes = {}\\n        #dummy node\\n        dummy = ListNode(-9999)\\n        self.nodes[0] = dummy\\n        #current node\\n        cur = head\\n        dummy.next = cur\\n        #current sum\\n        total = 0\\n        #keep running total and map nodes to running total\\n        while cur is not None:\\n            #add to running total\\n            total += cur.val\\n            #first check if we\\'ve seen this sum before\\n            if total in self.nodes:\\n                #to be removed (one after acc. sum)\\n                to_be_removed = self.nodes[total].next\\n                #second sum\\n                total2 = total\\n                while to_be_removed != cur:\\n                    total2 += to_be_removed.val\\n                    self.nodes.pop(total2)\\n                    to_be_removed = to_be_removed.next\\n                #draw link from sum to next of cur\\n                self.nodes[total].next = cur.next\\n            else:\\n                #map it\\n                self.nodes[total] = cur\\n            #set next\\n            cur = cur.next\\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 386323,
                "title": "very-easy-and-intuitive-solution-by-using-stack-and-prefix-sum-set",
                "content": "```scala\\n  def removeZeroSumSublists(head: ListNode): ListNode = {\\n\\n    import scala.collection.mutable.{Set, Stack}\\n    var set = Set[Int]()\\n    set add 0\\n    var result = new ListNode(-1)\\n    result.next = head\\n\\n    var stack = Stack[ListNode]()\\n    var runner = head\\n    var sum = 0\\n    \\n    while (runner != null) {\\n      \\n      val currVal = runner.x\\n      val curr = runner\\n      sum += currVal\\n      \\n      if (set.add(sum)) {\\n        stack push curr\\n      } else {\\n        \\n        val next = curr.next\\n        var tmpSum = sum\\n        sum -= currVal\\n        \\n        while (!stack.isEmpty && tmpSum != sum) {\\n          set remove sum\\n          sum -= (stack pop()).x\\n        }\\n        \\n        if (!stack.isEmpty) {\\n          stack.top.next = next\\n        } else {\\n          result.next = next\\n        }\\n      }\\n      runner = runner.next\\n    }\\n    result.next\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def removeZeroSumSublists(head: ListNode): ListNode = {\\n\\n    import scala.collection.mutable.{Set, Stack}\\n    var set = Set[Int]()\\n    set add 0\\n    var result = new ListNode(-1)\\n    result.next = head\\n\\n    var stack = Stack[ListNode]()\\n    var runner = head\\n    var sum = 0\\n    \\n    while (runner != null) {\\n      \\n      val currVal = runner.x\\n      val curr = runner\\n      sum += currVal\\n      \\n      if (set.add(sum)) {\\n        stack push curr\\n      } else {\\n        \\n        val next = curr.next\\n        var tmpSum = sum\\n        sum -= currVal\\n        \\n        while (!stack.isEmpty && tmpSum != sum) {\\n          set remove sum\\n          sum -= (stack pop()).x\\n        }\\n        \\n        if (!stack.isEmpty) {\\n          stack.top.next = next\\n        } else {\\n          result.next = next\\n        }\\n      }\\n      runner = runner.next\\n    }\\n    result.next\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 375895,
                "title": "python-prefix-sum-solution",
                "content": "The core of the problem is to do ```range query```, and for this purpose, as far as I know, we generally have 2 ways:\\n1. prefix sum array\\n2. Fenwick tree\\n\\nUsing a Fenwick tree would be overkilling, so the intuition that comes to my mind is prefix sum! For an array ```arr=[1, 2, -3, 4, 5]```, a prefix sum array ```pre``` would be ```[0, 1, 3, 0, 4, 9]```, the most important property of prefix sum array is:\\n\\n```pre[j] - pre[i] = sum from arr[i] to arr[j-1]```\\n\\nSo if we\\'re at position j, and find the current sum is the same as position i, then sum of range from i to j-1 must be 0.\\n\\nThere\\'s a similar problem on LeetCode: **560. Subarray Sum Equals K** (https://leetcode.com/problems/subarray-sum-equals-k/) that could give you a better understanding of how the above idea works.\\n\\nAccepted code:\\n```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        d = collections.defaultdict(ListNode)\\n        dummy = ListNode(float(\\'inf\\'))\\n        dummy.next, helper = head, head\\n        d[0] = dummy\\n        cur = 0\\n        while helper:\\n            cur += helper.val\\n            if cur in d:\\n                p = d[cur]\\n                q = p.next\\n                tmp = cur + q.val\\n                while tmp != cur:\\n                    d.pop(tmp)\\n                    q = q.next\\n                    tmp += q.val\\n                p.next = helper.next\\n            else:\\n                d[cur] = helper\\n            helper = helper.next if helper else None\\n        return dummy.next\\n```\\nNotice the tricky part is ```d[0]=dummy```, it\\'s corresponding to the first element in ```pre``` array, where ```pre[0]``` is always 0.",
                "solutionTags": [],
                "code": "```range query```\n```arr=[1, 2, -3, 4, 5]```\n```pre```\n```[0, 1, 3, 0, 4, 9]```\n```pre[j] - pre[i] = sum from arr[i] to arr[j-1]```\n```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        d = collections.defaultdict(ListNode)\\n        dummy = ListNode(float(\\'inf\\'))\\n        dummy.next, helper = head, head\\n        d[0] = dummy\\n        cur = 0\\n        while helper:\\n            cur += helper.val\\n            if cur in d:\\n                p = d[cur]\\n                q = p.next\\n                tmp = cur + q.val\\n                while tmp != cur:\\n                    d.pop(tmp)\\n                    q = q.next\\n                    tmp += q.val\\n                p.next = helper.next\\n            else:\\n                d[cur] = helper\\n            helper = helper.next if helper else None\\n        return dummy.next\\n```\n```d[0]=dummy```\n```pre```\n```pre[0]```",
                "codeTag": "Java"
            },
            {
                "id": 374273,
                "title": "python3-solution-beats-100-space-and-91-time-48ms-with-hashmap-and-dummy-node",
                "content": "```\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        prefix_sum = 0\\n        seen = {prefix_sum: dummy}\\n        \\n        while head:\\n            prefix_sum += head.val\\n\\t\\t\\t\\n\\t\\t\\t# remove elements in zero sum\\n            if prefix_sum in seen:           \\n                k, v = seen.popitem()\\n                while k != prefix_sum:\\n                    k, v = seen.popitem()\\n                seen[k] = v\\n            else:\\n\\t\\t\\t    # add non zero-sum elements\\n                seen[prefix_sum] = head\\n            \\n            head = head.next\\n        \\n\\t\\t# rebuild the linkedlist\\n        ret = dummy\\n        for i, k in enumerate(seen):\\n            if i > 0:\\n                ret.next = seen[k]\\n                ret = ret.next\\n        \\n        ret.next = None\\n        \\n        return dummy.next\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    def removeZeroSumSublists(self, head: ListNode) -> ListNode:\\n        dummy = ListNode(0)\\n        prefix_sum = 0\\n        seen = {prefix_sum: dummy}\\n        \\n        while head:\\n            prefix_sum += head.val\\n\\t\\t\\t\\n\\t\\t\\t# remove elements in zero sum\\n            if prefix_sum in seen:           \\n                k, v = seen.popitem()\\n                while k != prefix_sum:\\n                    k, v = seen.popitem()\\n                seen[k] = v\\n            else:\\n\\t\\t\\t    # add non zero-sum elements\\n                seen[prefix_sum] = head\\n            \\n            head = head.next\\n        \\n\\t\\t# rebuild the linkedlist\\n        ret = dummy\\n        for i, k in enumerate(seen):\\n            if i > 0:\\n                ret.next = seen[k]\\n                ret = ret.next\\n        \\n        ret.next = None\\n        \\n        return dummy.next\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 370857,
                "title": "python-prefix-sum-solution-with-updated-oj",
                "content": "I think OJ is updated. Now it will judge the answer correctly.\\n\\nMy solution uses a hashMap to save all the nodes based on their prefix sum. Nodes with the same prefix sum will point to the last node\\'s next.\\n\\nI have drawn a graph to futher explain it.\\n\\nTest Case: [1,3,2,-3,-2,5,5,-5,1]\\nResult: [1,5,1]\\n![image](https://assets.leetcode.com/users/hl1117/image_1567187677.png)\\n\\n\\nCodes here:\\n\"\"\"\\n\\n    def removeZeroSumSublists(self, head):\\n\\n        dummy = ListNode(-1)\\n        dummy.next= head\\n        ###### save all nodes into dictionary base on their prefix sum\\n        dic = {0: [dummy]}\\n        # current sum \\n        curSum = 0\\n        \\n        # save all the node into hashmap based on their prefix sum\\n        while head:\\n            curSum += head.val\\n            if curSum not in dic:\\n                dic[curSum] = []\\n            dic[curSum].append(head)\\n            head = head.next\\n            \\n        # update nodes with same prefix sum\\n        for nodes in dic.values():\\n            for i in range(len(nodes) - 1):\\n                nodes[i].next = nodes[-1].next\\n        return dummy.next\\n\"\"\"\\n\\n",
                "solutionTags": [],
                "code": "I think OJ is updated. Now it will judge the answer correctly.\\n\\nMy solution uses a hashMap to save all the nodes based on their prefix sum. Nodes with the same prefix sum will point to the last node\\'s next.\\n\\nI have drawn a graph to futher explain it.\\n\\nTest Case: [1,3,2,-3,-2,5,5,-5,1]\\nResult: [1,5,1]\\n![image](https://assets.leetcode.com/users/hl1117/image_1567187677.png)\\n\\n\\nCodes here:\\n\"\"\"\\n\\n    def removeZeroSumSublists(self, head):\\n\\n        dummy = ListNode(-1)\\n        dummy.next= head\\n        ###### save all nodes into dictionary base on their prefix sum\\n        dic = {0: [dummy]}\\n        # current sum \\n        curSum = 0\\n        \\n        # save all the node into hashmap based on their prefix sum\\n        while head:\\n            curSum += head.val\\n            if curSum not in dic:\\n                dic[curSum] = []\\n            dic[curSum].append(head)\\n            head = head.next\\n            \\n        # update nodes with same prefix sum\\n        for nodes in dic.values():\\n            for i in range(len(nodes) - 1):\\n                nodes[i].next = nodes[-1].next\\n        return dummy.next\\n\"\"\"\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 367739,
                "title": "python-hashtable-prefix-sum-20ms-beats-100",
                "content": "```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        d = collections.defaultdict(ListNode)\\n        dummy = ListNode(-1)\\n        d[0] = dummy\\n        dummy.next = head\\n        curr = head\\n        prefix_sum = 0\\n        while curr:\\n            prefix_sum += curr.val\\n            if prefix_sum in d:\\n                node = d[prefix_sum]\\n                node.next = curr.next\\n            else:\\n                d[prefix_sum] = curr\\n                \\n            curr = curr.next\\n            \\n        return dummy.next\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def removeZeroSumSublists(self, head):\\n        \"\"\"\\n        :type head: ListNode\\n        :rtype: ListNode\\n        \"\"\"\\n        d = collections.defaultdict(ListNode)\\n        dummy = ListNode(-1)\\n        d[0] = dummy\\n        dummy.next = head\\n        curr = head\\n        prefix_sum = 0\\n        while curr:\\n            prefix_sum += curr.val\\n            if prefix_sum in d:\\n                node = d[prefix_sum]\\n                node.next = curr.next\\n            else:\\n                d[prefix_sum] = curr\\n                \\n            curr = curr.next\\n            \\n        return dummy.next\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367016,
                "title": "java-prefix-sum-approach",
                "content": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        int sum = 0;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        map.put(0, dummy);\\n        while (head != null) {\\n            sum += head.val;\\n            map.putIfAbsent(sum, head);\\n            if (map.containsKey(sum)) {\\n                map.get(sum).next = head.next;\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public ListNode removeZeroSumSublists(ListNode head) {\\n        ListNode dummy = new ListNode(-1);\\n        dummy.next = head;\\n        int sum = 0;\\n        Map<Integer, ListNode> map = new HashMap<>();\\n        map.put(0, dummy);\\n        while (head != null) {\\n            sum += head.val;\\n            map.putIfAbsent(sum, head);\\n            if (map.containsKey(sum)) {\\n                map.get(sum).next = head.next;\\n            }\\n            head = head.next;\\n        }\\n        return dummy.next;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1569607,
                "content": [
                    {
                        "username": "abhinav_singh22",
                        "content": "When you run `[1, 2, 3, 4, -10, 1, 3, -3]` as custom test case, the expected answer shows: `[1,3,-3]` which is wrong.\\n\\nEdit: The test cases are fixed now."
                    },
                    {
                        "username": "Solo_driver07",
                        "content": "that is right"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "you can run your test case in my code ..\\n"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discussion/comments/1569607"
                    },
                    {
                        "username": "her0e1c1",
                        "content": "test returns [3,1,5,-2,2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1572956,
                "content": [
                    {
                        "username": "abhinav_singh22",
                        "content": "When you run `[1, 2, 3, 4, -10, 1, 3, -3]` as custom test case, the expected answer shows: `[1,3,-3]` which is wrong.\\n\\nEdit: The test cases are fixed now."
                    },
                    {
                        "username": "Solo_driver07",
                        "content": "that is right"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "you can run your test case in my code ..\\n"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discussion/comments/1569607"
                    },
                    {
                        "username": "her0e1c1",
                        "content": "test returns [3,1,5,-2,2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761885,
                "content": [
                    {
                        "username": "abhinav_singh22",
                        "content": "When you run `[1, 2, 3, 4, -10, 1, 3, -3]` as custom test case, the expected answer shows: `[1,3,-3]` which is wrong.\\n\\nEdit: The test cases are fixed now."
                    },
                    {
                        "username": "Solo_driver07",
                        "content": "that is right"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "you can run your test case in my code ..\\n"
                    },
                    {
                        "username": "trivedi_cs1",
                        "content": "https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/discussion/comments/1569607"
                    },
                    {
                        "username": "her0e1c1",
                        "content": "test returns [3,1,5,-2,2]"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    }
]