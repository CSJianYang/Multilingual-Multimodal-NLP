[
    {
        "title": "Subsets",
        "question_content": "Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 10\n\t-10 <= nums[i] <= 10\n\tAll the numbers of&nbsp;nums are unique.",
        "solutions": [
            {
                "id": 27281,
                "title": "a-general-approach-to-backtracking-questions-in-java-subsets-permutations-combination-sum-palindrome-partitioning",
                "content": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. \\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "This structure might apply to many other backtracking questions, but here I am just going to demonstrate Subsets, Permutations, and Combination Sum. \\n\\nSubsets : [https://leetcode.com/problems/subsets/][1]\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list , List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    }\\n\\n\\nSubsets II (contains duplicates) : [https://leetcode.com/problems/subsets-ii/][2]\\n\\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int start){\\n        list.add(new ArrayList<>(tempList));\\n        for(int i = start; i < nums.length; i++){\\n            if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n            tempList.add(nums[i]);\\n            backtrack(list, tempList, nums, i + 1);\\n            tempList.remove(tempList.size() - 1);\\n        }\\n    } \\n\\n\\n----------\\n\\nPermutations : [https://leetcode.com/problems/permutations/][3]\\n\\n    public List<List<Integer>> permute(int[] nums) {\\n       List<List<Integer>> list = new ArrayList<>();\\n       // Arrays.sort(nums); // not necessary\\n       backtrack(list, new ArrayList<>(), nums);\\n       return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\\n       if(tempList.size() == nums.length){\\n          list.add(new ArrayList<>(tempList));\\n       } else{\\n          for(int i = 0; i < nums.length; i++){ \\n             if(tempList.contains(nums[i])) continue; // element already exists, skip\\n             tempList.add(nums[i]);\\n             backtrack(list, tempList, nums);\\n             tempList.remove(tempList.size() - 1);\\n          }\\n       }\\n    } \\n\\nPermutations II (contains duplicates) : [https://leetcode.com/problems/permutations-ii/][4]\\n\\n    public List<List<Integer>> permuteUnique(int[] nums) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, new boolean[nums.length]);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, boolean [] used){\\n        if(tempList.size() == nums.length){\\n            list.add(new ArrayList<>(tempList));\\n        } else{\\n            for(int i = 0; i < nums.length; i++){\\n                if(used[i] || i > 0 && nums[i] == nums[i-1] && !used[i - 1]) continue;\\n                used[i] = true; \\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, used);\\n                used[i] = false; \\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\n\\n----------\\n\\nCombination Sum : [https://leetcode.com/problems/combination-sum/][5]\\n\\n    public List<List<Integer>> combinationSum(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{ \\n            for(int i = start; i < nums.length; i++){\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i); // not i + 1 because we can reuse same elements\\n                tempList.remove(tempList.size() - 1);\\n            }\\n        }\\n    }\\n\\nCombination Sum II (can't reuse same element) : [https://leetcode.com/problems/combination-sum-ii/][6]\\n\\n    public List<List<Integer>> combinationSum2(int[] nums, int target) {\\n        List<List<Integer>> list = new ArrayList<>();\\n        Arrays.sort(nums);\\n        backtrack(list, new ArrayList<>(), nums, target, 0);\\n        return list;\\n        \\n    }\\n    \\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums, int remain, int start){\\n        if(remain < 0) return;\\n        else if(remain == 0) list.add(new ArrayList<>(tempList));\\n        else{\\n            for(int i = start; i < nums.length; i++){\\n                if(i > start && nums[i] == nums[i-1]) continue; // skip duplicates\\n                tempList.add(nums[i]);\\n                backtrack(list, tempList, nums, remain - nums[i], i + 1);\\n                tempList.remove(tempList.size() - 1); \\n            }\\n        }\\n    } \\n\\n\\nPalindrome Partitioning : [https://leetcode.com/problems/palindrome-partitioning/][7]\\n\\n    public List<List<String>> partition(String s) {\\n       List<List<String>> list = new ArrayList<>();\\n       backtrack(list, new ArrayList<>(), s, 0);\\n       return list;\\n    }\\n    \\n    public void backtrack(List<List<String>> list, List<String> tempList, String s, int start){\\n       if(start == s.length())\\n          list.add(new ArrayList<>(tempList));\\n       else{\\n          for(int i = start; i < s.length(); i++){\\n             if(isPalindrome(s, start, i)){\\n                tempList.add(s.substring(start, i + 1));\\n                backtrack(list, tempList, s, i + 1);\\n                tempList.remove(tempList.size() - 1);\\n             }\\n          }\\n       }\\n    }\\n    \\n    public boolean isPalindrome(String s, int low, int high){\\n       while(low < high)\\n          if(s.charAt(low++) != s.charAt(high--)) return false;\\n       return true;\\n    } \\n\\n\\n\\n  [1]: https://leetcode.com/problems/subsets/\\n  [2]: https://leetcode.com/problems/subsets-ii/\\n  [3]: https://leetcode.com/problems/permutations/\\n  [4]: https://leetcode.com/problems/permutations-ii/\\n  [5]: https://leetcode.com/problems/combination-sum/\\n  [6]: https://leetcode.com/problems/combination-sum-ii/\\n  [7]: https://leetcode.com/problems/palindrome-partitioning/",
                "codeTag": "Unknown"
            },
            {
                "id": 27278,
                "title": "c-recursive-iterative-bit-manipulation",
                "content": "**Recursive (Backtracking)**\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            sub.push_back(nums[j]);\\n            subsets(nums, j + 1, sub, subs);\\n            sub.pop_back();\\n        }\\n    }\\n};\\n```\\n\\n**Iterative**\\n\\nUsing `[1, 2, 3]` as an example, the iterative process is like:\\n\\n 1. Initially, one empty subset `[[]]`\\n 2. Adding `1` to `[]`: `[[], [1]]`;\\n 3. Adding `2` to `[]` and `[1]`: `[[], [1], [2], [1, 2]]`;\\n 4. Adding `3` to `[]`, `[1]`, `[2]` and `[1, 2]`: `[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]`.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs = {{}};\\n        for (int num : nums) {\\n            int n = subs.size();\\n            for (int i = 0; i < n; i++) {\\n                subs.push_back(subs[i]); \\n                subs.back().push_back(num);\\n            }\\n        }\\n        return subs;\\n    }\\n}; \\n```\\n\\n**Bit Manipulation**\\n\\nTo give all the possible subsets, we just need to exhaust all the possible combinations of the numbers. And each number has only two possibilities: either in or not in a subset. And this can be represented using a bit.\\n\\nUsing `[1, 2, 3]` as an example, `1` appears once in every two consecutive subsets, `2` appears twice in every four consecutive subsets, and `3` appears four times in every eight subsets (initially all subsets are empty):\\n\\n```\\n[], [ ], [ ], [    ], [ ], [    ], [    ], [       ]\\n[], [1], [ ], [1   ], [ ], [1   ], [    ], [1      ]\\n[], [1], [2], [1, 2], [ ], [1   ], [2   ], [1, 2   ]\\n[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]\\n```\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size(), p = 1 << n;\\n        vector<vector<int>> subs(p);\\n        for (int i = 0; i < p; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i >> j) & 1) {\\n                    subs[i].push_back(nums[j]);\\n                }\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> sub;\\n        subsets(nums, 0, sub, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, int i, vector<int>& sub, vector<vector<int>>& subs) {\\n        subs.push_back(sub);\\n        for (int j = i; j < nums.size(); j++) {\\n            sub.push_back(nums[j]);\\n            subsets(nums, j + 1, sub, subs);\\n            sub.pop_back();\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs = {{}};\\n        for (int num : nums) {\\n            int n = subs.size();\\n            for (int i = 0; i < n; i++) {\\n                subs.push_back(subs[i]); \\n                subs.back().push_back(num);\\n            }\\n        }\\n        return subs;\\n    }\\n}; \\n```\n```\\n[], [ ], [ ], [    ], [ ], [    ], [    ], [       ]\\n[], [1], [ ], [1   ], [ ], [1   ], [    ], [1      ]\\n[], [1], [2], [1, 2], [ ], [1   ], [2   ], [1, 2   ]\\n[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size(), p = 1 << n;\\n        vector<vector<int>> subs(p);\\n        for (int i = 0; i < p; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i >> j) & 1) {\\n                    subs[i].push_back(nums[j]);\\n                }\\n            }\\n        }\\n        return subs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 122645,
                "title": "3ms-easiest-solution-no-backtracking-no-bit-manipulation-no-dfs-no-bullshit",
                "content": "While iterating through all numbers, for each new number, we can either pick it or not pick it\\n1, if pick, just add current number to every existing subset.\\n2, if not pick, just leave all existing subsets as they are.\\nWe just combine both into our result.\\n\\nFor example, {1,2,3} intially we have an emtpy set as result [ [ ] ]\\nConsidering 1, if not use it, still [ ], if use 1, add it to [ ], so we have [1] now\\nCombine them, now we have [ [ ], [1] ] as all possible subset\\n\\nNext considering 2, if not use it, we still have [ [ ], [1] ], if use 2, just add 2 to each previous subset, we have [2], [1,2]\\nCombine them, now we have [ [ ], [1], [2], [1,2] ]\\n\\nNext considering 3, if not use it, we still have  [ [ ], [1], [2], [1,2] ], if use 3, just add 3 to each previous subset, we have [ [3], [1,3], [2,3], [1,2,3] ]\\nCombine them, now we have  [ [ ], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3] ]\\n\\n```\\npublic List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        for(int n : nums){\\n            int size = result.size();\\n            for(int i=0; i<size; i++){\\n                List<Integer> subset = new ArrayList<>(result.get(i));\\n                subset.add(n);\\n                result.add(subset);\\n            }\\n        }\\n        return result;\\n    }\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>());\\n        for(int n : nums){\\n            int size = result.size();\\n            for(int i=0; i<size; i++){\\n                List<Integer> subset = new ArrayList<>(result.get(i));\\n                subset.add(n);\\n                result.add(subset);\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27301,
                "title": "python-easy-to-understand-solutions-dfs-recursively-bit-manipulation-iteratively",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        ret = []\\n        self.dfs(nums, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n       \\n    # Bit Manipulation    \\n    def subsets2(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(1<<len(nums)):\\n            tmp = []\\n            for j in xrange(len(nums)):\\n                if i & 1 << j:  # if i >> j & 1:\\n                    tmp.append(nums[j])\\n            res.append(tmp)\\n        return res\\n\\t\\t\\n    # Iteratively\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in sorted(nums):\\n            res += [item+[num] for item in res]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        ret = []\\n        self.dfs(nums, [], ret)\\n        return ret\\n    \\n    def dfs(self, nums, path, ret):\\n        ret.append(path)\\n        for i in range(len(nums)):\\n            self.dfs(nums[i+1:], path+[nums[i]], ret)\\n       \\n    # Bit Manipulation    \\n    def subsets2(self, nums):\\n        res = []\\n        nums.sort()\\n        for i in xrange(1<<len(nums)):\\n            tmp = []\\n            for j in xrange(len(nums)):\\n                if i & 1 << j:  # if i >> j & 1:\\n                    tmp.append(nums[j])\\n            res.append(tmp)\\n        return res\\n\\t\\t\\n    # Iteratively\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in sorted(nums):\\n            res += [item+[num] for item in res]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27288,
                "title": "my-solution-using-bit-manipulation",
                "content": "    class Solution {\\n    public:\\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort (S.begin(), S.end());\\n            int elem_num = S.size();\\n            int subset_num = pow (2, elem_num);\\n            vector<vector<int> > subset_set (subset_num, vector<int>());\\n            for (int i = 0; i < elem_num; i++)\\n                for (int j = 0; j < subset_num; j++)\\n                    if ((j >> i) & 1)\\n                        subset_set[j].push_back (S[i]);\\n            return subset_set;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort (S.begin(), S.end());\\n            int elem_num = S.size();\\n            int subset_num = pow (2, elem_num);\\n            vector<vector<int> > subset_set (subset_num, vector<int>());\\n            for (int i = 0; i < elem_num; i++)\\n                for (int j = 0; j < subset_num; j++)\\n                    if ((j >> i) & 1)\\n                        subset_set[j].push_back (S[i]);\\n            return subset_set;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 429534,
                "title": "general-backtracking-questions-solutions-in-python-for-reference",
                "content": "I have taken solutions of @caikehe from frequently asked backtracking questions which I found really helpful and had copied for my reference. I thought this post will be helpful for everybody as in an interview I think these basic solutions can come in handy. Please add any more questions in comments that you think might be important and I can add it in the post.\\n\\n#### Combinations :\\n```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```  \\n\\t\\n#### Permutations I\\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```        \\n\\n#### Permutations II\\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\\n\\n \\n#### Subsets 1\\n\\n\\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Subsets II  \\n\\n\\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\\n\\n\\n#### Combination Sum        \\n\\n\\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\\n\\n        \\n        \\n#### Combination Sum II        \\n\\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\ndef combine(self, n, k):\\n    res = []\\n    self.dfs(xrange(1,n+1), k, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, k, index, path, res):\\n    #if k < 0:  #backtracking\\n        #return \\n    if k == 0:\\n        res.append(path)\\n        return # backtracking \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, k-1, i+1, path+[nums[i]], res)\\n```\n```\\nclass Solution:\\n    def permute(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.dfs(nums, [], res)\\n        return res\\n\\n    def dfs(self, nums, path, res):\\n        if not nums:\\n            res.append(path)\\n            #return # backtracking\\n        for i in range(len(nums)):\\n            self.dfs(nums[:i]+nums[i+1:], path+[nums[i]], res)\\n```\n```\\ndef permuteUnique(self, nums):\\n    res, visited = [], [False]*len(nums)\\n    nums.sort()\\n    self.dfs(nums, visited, [], res)\\n    return res\\n    \\ndef dfs(self, nums, visited, path, res):\\n    if len(nums) == len(path):\\n        res.append(path)\\n        return \\n    for i in xrange(len(nums)):\\n        if not visited[i]: \\n            if i>0 and not visited[i-1] and nums[i] == nums[i-1]:  # here should pay attention\\n                continue\\n            visited[i] = True\\n            self.dfs(nums, visited, path+[nums[i]], res)\\n            visited[i] = False\\n```\n```\\ndef subsets1(self, nums):\\n    res = []\\n    self.dfs(sorted(nums), 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef subsetsWithDup(self, nums):\\n    res = []\\n    nums.sort()\\n    self.dfs(nums, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, index, path, res):\\n    res.append(path)\\n    for i in xrange(index, len(nums)):\\n        if i > index and nums[i] == nums[i-1]:\\n            continue\\n        self.dfs(nums, i+1, path+[nums[i]], res)\\n```\n```\\ndef combinationSum(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, nums, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return \\n    for i in xrange(index, len(nums)):\\n        self.dfs(nums, target-nums[i], i, path+[nums[i]], res)\\n```\n```\\ndef combinationSum2(self, candidates, target):\\n    res = []\\n    candidates.sort()\\n    self.dfs(candidates, target, 0, [], res)\\n    return res\\n    \\ndef dfs(self, candidates, target, index, path, res):\\n    if target < 0:\\n        return  # backtracking\\n    if target == 0:\\n        res.append(path)\\n        return  # backtracking \\n    for i in xrange(index, len(candidates)):\\n        if i > index and candidates[i] == candidates[i-1]:\\n            continue\\n        self.dfs(candidates, target-candidates[i], i+1, path+[candidates[i]], res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27356,
                "title": "5-lines-of-python",
                "content": "    class Solution(object):\\n        def subsets(self, nums):\\n            nums.sort()\\n            result = [[]]\\n            for num in nums:\\n                result += [i + [num] for i in result]\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def subsets(self, nums):\\n            nums.sort()\\n            result = [[]]\\n            for num in nums:\\n                result += [i + [num] for i in result]\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 731215,
                "title": "c-3-approaches-recursive-iterative-bit-manipulation-solutions",
                "content": "```\\n// Recursive Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void sub(vector<int> &nums, int i, vector<int> temp)\\n    {\\n        if(i==nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        sub(nums, i+1, temp);\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> temp;       \\n        sub(nums, 0, temp); // or sub(nums, 0, vector<int> {});\\n        return ans;\\n    }\\n};\\n```\\n```\\n// Iterative Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        \\n        ans.push_back({});\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sz = ans.size();\\n            for(int j=0; j<sz; j++)\\n            {\\n                vector<int> temp = ans[j];\\n                temp.push_back(nums[i]);\\n                ans.push_back(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n```\\n// Bit Manipulation\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion",
                    "Iterator",
                    "Bitmask"
                ],
                "code": "```\\n// Recursive Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans;\\n    \\n    void sub(vector<int> &nums, int i, vector<int> temp)\\n    {\\n        if(i==nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        sub(nums, i+1, temp);\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> temp;       \\n        sub(nums, 0, temp); // or sub(nums, 0, vector<int> {});\\n        return ans;\\n    }\\n};\\n```\n```\\n// Iterative Solution\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        \\n        ans.push_back({});\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int sz = ans.size();\\n            for(int j=0; j<sz; j++)\\n            {\\n                vector<int> temp = ans[j];\\n                temp.push_back(nums[i]);\\n                ans.push_back(temp);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n// Bit Manipulation\\n// Time complexity : O(N*(2^N))\\n// Space complexity : O(N*(2^N))\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766675,
                "title": "java-intuition-of-approach-backtracking",
                "content": "****\\nPlease upvote if the explanation helps, as it keeps up the motivation to provide such posts.\\n****\\n\\n**Intuition**\\n\\nThis falls into a set of classic problems that can be solved using \"pick\"- \"don\\'t pick\" approach. \\n\\n![image](https://assets.leetcode.com/users/images/1ca8ad88-a0dc-4995-82e0-ce6822177b98_1621218217.2663536.png)\\n\\nAs through observation, it is clear that we start with having a choice to pick or not pick from the first element and then, we propagate this choice down the tree. \\nSo, \\n1. we either pick the element and move ahead ( increment the index ) or,\\n2. we don\\'t pick the element and move ahead\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```\\n*****\\n\\n\\u2714\\uFE0F **Another related problems** : \\n* https://leetcode.com/problems/subsets-ii/\\n* https://leetcode.com/problems/permutations/\\n* https://leetcode.com/problems/permutations-ii/\\n* https://leetcode.com/problems/combination-sum/\\n* https://leetcode.com/problems/combination-sum-ii/\\n* https://leetcode.com/problems/palindrome-partitioning/\\n\\n\\n\\u2714\\uFE0F **Complexity Analysis:**\\n* TC: `O(n * 2^n)`, as every element has two options-to pick or not pick and `n` bcz we are copying the list of size `n` in base case.\\n* SC: `O(n * 2^n)`\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27279,
                "title": "simple-java-solution-with-for-each-loops",
                "content": "No  messy indexing. Avoid the ConcurrentModificationException by using a temp list.\\n\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] S) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            res.add(new ArrayList<Integer>());\\n            \\n            Arrays.sort(S);\\n            for(int i : S) {\\n                List<List<Integer>> tmp = new ArrayList<>();\\n                for(List<Integer> sub : res) {\\n                    List<Integer> a = new ArrayList<>(sub);\\n                    a.add(i);\\n                    tmp.add(a);\\n                }\\n                res.addAll(tmp);\\n            }\\n            return res;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] S) {\\n            List<List<Integer>> res = new ArrayList<>();\\n            res.add(new ArrayList<Integer>());\\n            \\n            Arrays.sort(S);\\n            for(int i : S) {\\n                List<List<Integer>> tmp = new ArrayList<>();\\n                for(List<Integer> sub : res) {\\n                    List<Integer> a = new ArrayList<>(sub);\\n                    a.add(i);\\n                    tmp.add(a);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 973667,
                "title": "backtracking-template-explanation-visual-python",
                "content": "TL;DR use standard backtracking template that can be applied to backtracking problems that involve [combinations](https://leetcode.com/problems/combinations/) or [permutations](https://leetcode.com/problems/permutations/discuss/971584/Backtracking-or-Explanation-%2B-Visual-or-Python)\\n\\n(starter list of problems that use template  below + explanation + visual) \\n\\n```python \\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t    res, path = [], []\\n        self.dfs(0, res, path, nums)\\n        return res\\n\\t\\t\\n def dfs(self, index, res, path, nums):\\n        res.append(list(path)) \\n        for i in range(index, len(nums)):\\n            path.append(nums[i])\\n            self.dfs(i+1, res, path, nums)\\n            path.pop()\\n```\\n#### Problems That Use This Template\\n1. [Combinations](https://leetcode.com/problems/combinations/)\\n2. [Combination Sum I](https://leetcode.com/problems/combination-sum/)\\n3. [Combination sum II](https://leetcode.com/problems/combination-sum-ii/)\\n4. [Combination sum III](https://leetcode.com/problems/combination-sum-iii/)\\n5. [N Queens I](https://leetcode.com/problems/n-queens/)\\n6. [N Queens II](https://leetcode.com/problems/n-queens-ii/discuss/)\\n7. [Permutations I](https://leetcode.com/problems/permutations/)\\n8. [Permutations II](https://leetcode.com/problems/permutations-ii/discuss/972627/Backtracking-%2B-Permutation-Template-or-Explanation-or-Python)\\n\\n(there are definetly more problems that use this template feel free to comment below if you know one and i will update the list) \\n\\n### Explanation + Visual \\n\\nThe goal is to generate all possible subsets given a set of ```N``` elements. \\n\\nTo put another way the goal is to find the power (the set of all subsets) set of ```S``` (the given set of elements) \\n\\nAll subsets must be generated,  meaning all options must be exaushted. This indicates that backtracking is a good approach to take to solve the problem.  \\n\\nFrom a recursive perspective, a choice is made at each step, to include an element in the subset or exclude an element from the subset. the choice is binary (yes or no) and this choice must be made for all  ```N``` elements and we make every choice. this results in a runtime of \\n```O(N*2^N)``` \\n\\nThe code uses a DFS traversal and undoes previous decisions by removing a previous choice from the current subset. ***This is the heart of backtracking***, we try all possibilities knowing that some may not lead to a solution. when path no longer can lead to a solution, the decision is reveresed. \\n\\nTo understand the code for this problem, it is essntial to understand how the recursion tree (state space tree) is generated. Thus i have provided a visual with numbers to denote the order in which nodes are generated. \\n\\nVisual is for example ```[1, 2 , 3]```\\n![image](https://assets.leetcode.com/users/images/5252e51a-8e1f-4394-af00-0c0bea61aa8b_1608066366.6589456.png)\\n\\n",
                "solutionTags": [],
                "code": "```python \\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t    res, path = [], []\\n        self.dfs(0, res, path, nums)\\n        return res\\n\\t\\t\\n def dfs(self, index, res, path, nums):\\n        res.append(list(path)) \\n        for i in range(index, len(nums)):\\n            path.append(nums[i])\\n            self.dfs(i+1, res, path, nums)\\n            path.pop()\\n```\n```N```\n```S```\n```N```\n```O(N*2^N)```\n```[1, 2 , 3]```",
                "codeTag": "Python3"
            },
            {
                "id": 27511,
                "title": "c-8ms-simple-iterative-solution",
                "content": "    class Solution {\\n    public:\\n\\tvector<vector<int> > subsets(vector<int> &S) {\\n\\t\\tvector<vector<int> > res(1, vector<int>());\\n\\t\\tsort(S.begin(), S.end());\\n\\t\\t\\n\\t\\tfor (int i = 0; i < S.size(); i++) {\\n\\t\\t\\tint n = res.size();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tres.push_back(res[j]);\\n\\t\\t\\t\\tres.back().push_back(S[i]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn res;\\n\\t  }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n\\tvector<vector<int> > subsets(vector<int> &S) {\\n\\t\\tvector<vector<int> > res(1, vector<int>());\\n\\t\\tsort(S.begin(), S.end());\\n\\t\\t\\n\\t\\tfor (int i = 0; i < S.size(); i++) {\\n\\t\\t\\tint n = res.size();\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tres.push_back(res[j]);\\n\\t\\t\\t\\tres.back().push_back(S[i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1766969,
                "title": "c-100-faster-solution-0-ms-bit-manipulation-easy-to-understand",
                "content": "**Upvote if helpful**\\n\\n**Explaination** : We can use a n-bit integer ( from 0 to 2^n-1) whose individual bits represent wether the element(present at ith index) of the string is included or not.\\nthe two options can be represented as :\\n\\n* \\'1\\' (set bit ) denotes element included\\n\\n* \\'0\\' denotes element not included\\n\\n**If the ith bit in the integer is set then, append ith element from the string for the subset.**\\n```\\nTry to understand this thing with the help of example:\\n\\nchar s[3] = [\\'1\\' , \\'2\\' , \\'3\\' ]\\nTotal number of subsets = pow(2, n) = pow(2, 3) = 8\\nValue of integer Subsets\\n\\n000                    -> Empty set\\n001                    -> 1\\n010                    -> 2\\n011                    -> 12\\n100                    -> 3\\n101                    -> 13\\n110                    -> 23\\n111                    -> 123\\n```\\n![image](https://assets.leetcode.com/users/images/a78610ac-542e-4301-8c85-0e236a43dec6_1644758596.1727226.png)\\n\\n* **Code**\\n```\\nvoid findsub( vector<vector<int>> &res , vector<int> nums , int i){\\n        int j = 0;\\n        vector<int>v;\\n        while(i>0){\\n            if((i&1)==1) v.push_back(nums[j]);\\n            j++;\\n            i = i>>1;\\n        }\\n        res.push_back(v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        for(int i = 0 ; i < (1<<n) ;i++){\\n            findsub(res,nums,i);\\n        }\\n        return res;\\n    }\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nTry to understand this thing with the help of example:\\n\\nchar s[3] = [\\'1\\' , \\'2\\' , \\'3\\' ]\\nTotal number of subsets = pow(2, n) = pow(2, 3) = 8\\nValue of integer Subsets\\n\\n000                    -> Empty set\\n001                    -> 1\\n010                    -> 2\\n011                    -> 12\\n100                    -> 3\\n101                    -> 13\\n110                    -> 23\\n111                    -> 123\\n```\n```\\nvoid findsub( vector<vector<int>> &res , vector<int> nums , int i){\\n        int j = 0;\\n        vector<int>v;\\n        while(i>0){\\n            if((i&1)==1) v.push_back(nums[j]);\\n            j++;\\n            i = i>>1;\\n        }\\n        res.push_back(v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res;\\n        int n = nums.size();\\n        for(int i = 0 ; i < (1<<n) ;i++){\\n            findsub(res,nums,i);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 940599,
                "title": "3-approaches-for-your-interview-dry-run-iterative-recursive-bitmasking",
                "content": "#### **Approach  1:** Recursive\\n* simplest insight is to follow : `\\'take it\\'`, and` \\'dont take\\' `approach\\n\\n<br>\\n\\n```\\nvar subsets = function(nums) {\\n\\tlet res=[]                    // the final arr, which we will display\\n\\tlet auxArr = [], i=0             // global vars\\n    \\n    function recur(nums,i,auxArr){\\n        if(i==nums.length) { res.push(auxArr); return } //operation of recursion will be upto i=n-1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // when it will hit, i==n, it will store the computed arr, in the final arr, and break(return)\\n        \\n\\t\\t// take it\\n        recur(nums, i+1, [...auxArr, nums[i] ] ) //or, we can use \\'aux.concat(nums[i])\\'\\n\\t\\t\\n\\t\\t// dont take\\n        recur(nums, i+1, auxArr)\\n    \\n    }\\n    \\n    recur(nums,i,auxArr) // passing the global variable declared already\\n    return res        // rerturn the final 2d arr\\n    \\n    \\n};\\n\\n\\n\\t                  1 2 3\\n \\t\\t\\t\\t  /           \\\\\\n \\t\\t    \\t1 \\t\\t\\t     []\\t\\n              /     \\\\           /.  \\\\\\n            1 2\\t     1\\t       2.    []\\n           /  \\\\\\t\\t/ \\\\       / \\\\    / \\\\\\n        123.   12. 13. 1.    23. 2. 3. [].\\n\\n```\\n\\nAll the left part are result of : `\\'Take it\\'`\\nAll the right one are :  `\\'dont take\\'`\\n<br><br><br>\\n<hr><hr>\\n<br>\\n\\n#### **Approach 2**  : Iterative \\n\\n```\\nvar subsets = function(nums) {\\n    let res = [[]], appendarr= []\\n    \\n    for(let num of nums){\\n        appendarr = []\\n        for(let entry of res){\\n            appendarr.push([...entry, num])\\n        }\\n        \\n        res.push(...appendarr)\\n    }\\n    \\n    return res\\n    \\n};\\n\\n\\n0 (Empty)             :         [] \\n1 (Adding 1 to it)    :         [] [1] \\n2 (Adding 2 to it)    :         [] [1] [2] [1,2]\\n3 (Adding 3 to it)    :         [] [1] [2] [1,2] [3] [1,3] [2,3] [1,2,3]\\n```\\n\\n<br> <br> <br> <hr> <hr>\\n#### **Approach 3** : Bit Masking \\n<br> <br>\\n```\\nvar subsets = function(nums) {\\n  const result = [];\\n  result.push([]);   // handling the first case (i=0). for that, an empty arr should be there\\n  \\n  let size = nums.length\\n  \\n  for(let i = 1; i < (1<<size) ; i++){   // generating for range upto [(2^n)-1]\\n    let subset = [];\\n    let bitmask=0\\n    \\n      while(bitmask<size){\\n          if(i & (1 << bitmask)){           // if it exists (not zero)\\n              subset.push( nums[bitmask] );\\n          }\\n          bitmask++   \\n      }\\n      result.push(subset)\\n  }\\n  return result\\n};\\n```\\n<br> <br>\\n```\\nDry Run: \\n\\nlets take nums = [1,2,3]\\nwe will be searching all elem from 0-> 2^n\\n\\nso, checking :\\n\\ni         \\n\\u2B07                                  while(bitmask<size)\\n\\n0 [000]                             [ ] \\n\\n\\n1 [001]      i=1.           \\n\\t\\t\\t\\t\\t\\t\\ti\\t\\t001      001      001\\n\\t\\t\\t  \\t          mask\\t    001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t   ----     ----     ----\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]      000      000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n2 [010]      i=2.                        \\n\\t\\t\\t\\t\\t       i        010      010      010\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3 [011]      i=3.           \\n\\t\\t\\t\\t\\t       i        011      011      011\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n4 [100]      i=4.         \\n\\t\\t\\t\\t\\t       i        100      100      100\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n5 [101]      i=5.           \\n\\t\\t\\t\\t\\t       i        101      101      101\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n6 [110]      i=6.          \\n\\t\\t\\t\\t\\t       i        110      110      110\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t    000     [010]    [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n7 [111]      i=7.          \\n\\t\\t\\t\\t\\t       i        111      111      111\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]     [010]    [100]\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nvar subsets = function(nums) {\\n\\tlet res=[]                    // the final arr, which we will display\\n\\tlet auxArr = [], i=0             // global vars\\n    \\n    function recur(nums,i,auxArr){\\n        if(i==nums.length) { res.push(auxArr); return } //operation of recursion will be upto i=n-1\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t // when it will hit, i==n, it will store the computed arr, in the final arr, and break(return)\\n        \\n\\t\\t// take it\\n        recur(nums, i+1, [...auxArr, nums[i] ] ) //or, we can use \\'aux.concat(nums[i])\\'\\n\\t\\t\\n\\t\\t// dont take\\n        recur(nums, i+1, auxArr)\\n    \\n    }\\n    \\n    recur(nums,i,auxArr) // passing the global variable declared already\\n    return res        // rerturn the final 2d arr\\n    \\n    \\n};\\n\\n\\n\\t                  1 2 3\\n \\t\\t\\t\\t  /           \\\\\\n \\t\\t    \\t1 \\t\\t\\t     []\\t\\n              /     \\\\           /.  \\\\\\n            1 2\\t     1\\t       2.    []\\n           /  \\\\\\t\\t/ \\\\       / \\\\    / \\\\\\n        123.   12. 13. 1.    23. 2. 3. [].\\n\\n```\n```\\nvar subsets = function(nums) {\\n    let res = [[]], appendarr= []\\n    \\n    for(let num of nums){\\n        appendarr = []\\n        for(let entry of res){\\n            appendarr.push([...entry, num])\\n        }\\n        \\n        res.push(...appendarr)\\n    }\\n    \\n    return res\\n    \\n};\\n\\n\\n0 (Empty)             :         [] \\n1 (Adding 1 to it)    :         [] [1] \\n2 (Adding 2 to it)    :         [] [1] [2] [1,2]\\n3 (Adding 3 to it)    :         [] [1] [2] [1,2] [3] [1,3] [2,3] [1,2,3]\\n```\n```\\nvar subsets = function(nums) {\\n  const result = [];\\n  result.push([]);   // handling the first case (i=0). for that, an empty arr should be there\\n  \\n  let size = nums.length\\n  \\n  for(let i = 1; i < (1<<size) ; i++){   // generating for range upto [(2^n)-1]\\n    let subset = [];\\n    let bitmask=0\\n    \\n      while(bitmask<size){\\n          if(i & (1 << bitmask)){           // if it exists (not zero)\\n              subset.push( nums[bitmask] );\\n          }\\n          bitmask++   \\n      }\\n      result.push(subset)\\n  }\\n  return result\\n};\\n```\n```\\nDry Run: \\n\\nlets take nums = [1,2,3]\\nwe will be searching all elem from 0-> 2^n\\n\\nso, checking :\\n\\ni         \\n\\u2B07                                  while(bitmask<size)\\n\\n0 [000]                             [ ] \\n\\n\\n1 [001]      i=1.           \\n\\t\\t\\t\\t\\t\\t\\ti\\t\\t001      001      001\\n\\t\\t\\t  \\t          mask\\t    001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t   ----     ----     ----\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]      000      000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n2 [010]      i=2.                        \\n\\t\\t\\t\\t\\t       i        010      010      010\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n3 [011]      i=3.           \\n\\t\\t\\t\\t\\t       i        011      011      011\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t  [001]     [010]     000\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n4 [100]      i=4.         \\n\\t\\t\\t\\t\\t       i        100      100      100\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t000      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n5 [101]      i=5.           \\n\\t\\t\\t\\t\\t       i        101      101      101\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]      000     [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n6 [110]      i=6.          \\n\\t\\t\\t\\t\\t       i        110      110      110\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t    000     [010]    [100]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\n7 [111]      i=7.          \\n\\t\\t\\t\\t\\t       i        111      111      111\\n\\t\\t\\t\\t\\t     mask       001      010      100\\n\\t\\t\\t\\t\\t\\t\\t\\t    ---      ---      ---\\n\\t\\t\\t\\t\\t\\t\\t\\t   [001]     [010]    [100]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27294,
                "title": "simple-iteration-no-recursion-no-twiddling-explanation",
                "content": "My idea was to start out with an empty subset and either take or don't take the next element in the input array. Here's how it goes down for input `[1,2,3]`:\\n\\nstart with\\n\\n    [] // empty set is always a subset\\n\\nthen either take or not take the next element (`1`), this doubles the result size:\\n\\n    []   // not take 1\\n    [1] //      take 1 + new\\n\\nthen take or not take the next element: `2`\\n\\n    []    // not take 1, not take 2\\n    [2]   // not take 1,     take 2 + new\\n    [1]   //     take 1, not take 2\\n    [1,2] //     take 1,     take 2 + new\\n\\nand finally take or not take `3`.\\n\\n    []      // not take 1, not take 2, not take 3\\n    [3]     // not take 1, not take 2,     take 3 + new\\n    [2]     // not take 1,     take 2, not take 3\\n    [2,3]   // not take 1,     take 2,     take 3 + new\\n    [1]     //     take 1, not take 2, not take 3\\n    [1,3]   //     take 1, not take 2,     take 3 + new\\n    [1,2]   //     take 1,     take 2, not take 3\\n    [1,2,3] //     take 1,     take 2,     take 3 + new\\n\\nAnd we're done, we have all `2^3 = 8` subsets generated.\\n\\nIt is possible to generate these with a simple loop, there's only one trick here, the variable `size`. It's usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don't want to end up with an infinite loop, we have to remember how many `results` were available in the previous iteration, which is exactly the `size()` of the `result` at the beginning of the current iteration.\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums); // make sure subsets are ordered\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>()); // start with empty set\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = 0, size = result.size(); j < size; ++j) { // remember\\n                List<Integer> subset = new ArrayList<>(result.get(j)); // copy a new one\\n                subset.add(nums[i]); // expand\\n                result.add(subset); // collect\\n            }\\n        }\\n        return result;\\n    }\\n\\nIt is also necessary to order the input to satisfy the requirement:\\n\\n> * Elements in a subset must be in non-descending order.\\n\\nBecause `i` is increasing it means that whatever we take from nums will also be in increasing order.\\n\\nThe other requirement:\\n\\n> * The solution set must not contain duplicate subsets.\\n\\nis automatically guaranteed by the input specification and the algorithm walking indices straight and once:\\n\\n> Given a set of **distinct** integers, `nums`, return all possible subsets. *[emphasis mine]*",
                "solutionTags": [
                    "Java"
                ],
                "code": "My idea was to start out with an empty subset and either take or don't take the next element in the input array. Here's how it goes down for input `[1,2,3]`:\\n\\nstart with\\n\\n    [] // empty set is always a subset\\n\\nthen either take or not take the next element (`1`), this doubles the result size:\\n\\n    []   // not take 1\\n    [1] //      take 1 + new\\n\\nthen take or not take the next element: `2`\\n\\n    []    // not take 1, not take 2\\n    [2]   // not take 1,     take 2 + new\\n    [1]   //     take 1, not take 2\\n    [1,2] //     take 1,     take 2 + new\\n\\nand finally take or not take `3`.\\n\\n    []      // not take 1, not take 2, not take 3\\n    [3]     // not take 1, not take 2,     take 3 + new\\n    [2]     // not take 1,     take 2, not take 3\\n    [2,3]   // not take 1,     take 2,     take 3 + new\\n    [1]     //     take 1, not take 2, not take 3\\n    [1,3]   //     take 1, not take 2,     take 3 + new\\n    [1,2]   //     take 1,     take 2, not take 3\\n    [1,2,3] //     take 1,     take 2,     take 3 + new\\n\\nAnd we're done, we have all `2^3 = 8` subsets generated.\\n\\nIt is possible to generate these with a simple loop, there's only one trick here, the variable `size`. It's usually a good practice to cache method call results, but now it is cached for a different reason: because it changes in every iteration. If we don't want to end up with an infinite loop, we have to remember how many `results` were available in the previous iteration, which is exactly the `size()` of the `result` at the beginning of the current iteration.\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums); // make sure subsets are ordered\\n        List<List<Integer>> result = new ArrayList<>();\\n        result.add(new ArrayList<>()); // start with empty set\\n        for (int i = 0; i < nums.length; ++i) {\\n            for (int j = 0, size = result.size(); j < size; ++j) { // remember\\n                List<Integer> subset = new ArrayList<>(result.get(j)); // copy a new one\\n                subset.add(nums[i]); // expand\\n                result.add(subset); // collect\\n            }\\n        }\\n        return result;\\n    }\\n\\nIt is also necessary to order the input to satisfy the requirement:\\n\\n> * Elements in a subset must be in non-descending order.\\n\\nBecause `i` is increasing it means that whatever we take from nums will also be in increasing order.\\n\\nThe other requirement:\\n\\n> * The solution set must not contain duplicate subsets.\\n\\nis automatically guaranteed by the input specification and the algorithm walking indices straight and once:\\n\\n> Given a set of **distinct** integers, `nums`, return all possible subsets. *[emphasis mine]*",
                "codeTag": "Unknown"
            },
            {
                "id": 729863,
                "title": "c-using-bit-masking-most-simpler-with-explain",
                "content": "Idea is ---\\nAs they said all numbers are ```distinct integers``` and We need to find out  all possible subsets\\nNo of subsets would be ```(2 power, No_of_element[from the array])```\\nAnd how We are going to Find It Out ????\\nNeed To Run A loop From 0 to 2^No_of_element and for each number Find All Set Bit Positions Element from that array\\n\\nlets take An Example For better Understanding\\n\\narray = [1,2,3]\\nNo of subsets = 2^3 = 8\\nfrom 0 to 8 for each value find setbit and put into an array\\n\\n    No     BitRepresentation       Array         Ans_Array \\n    0         [ 0 0 0 ]             []            {}                  ----->as There No Set Bit \\n\\n    1         [ 0 0 1 ]            [ 0 0 3]       {3}  \\n\\n    2         [ 0 1 0 ]            [ 0 2 0]       {2}  \\n\\n    3         [ 0 1 1 ]            [ 0 2 3]       {2,3}  \\n\\n    4         [ 1 0 0 ]            [ 1 0 0]       {1}  \\n\\n    5         [ 1 0 1 ]            [ 1 0 3]       {1,3}  \\n\\n    6         [ 1 1 0 ]            [ 1 2 0]       {1,2}  \\n\\n    7         [ 1 1 1 ]            [ 1 2 3]       {1,2,3}  \\n \\nANSWER - [{},{3},{2},{1},{1,3},{1,2},{1,2,3}]  - --->return It\\n   \\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int>FindSubSet(int no,vector<int>&nums){\\n        vector<int>re;\\n        int i = 0;\\n        while(no){\\n            if(no&1){\\n                re.push_back(nums[i]);\\n            }\\n            i++;\\n            no>>=1;\\n        }\\n        return re;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        int total = 1<<n;\\n        for(int i=0;i<total;i++){\\n            vector<int>temp = FindSubSet(i,nums);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nI hope It Help You \\nIf You Realy Like This Please UpVote\\nAny Suggesstion Comments below\\nThank You (^-^)",
                "solutionTags": [],
                "code": "```distinct integers```\n```(2 power, No_of_element[from the array])```\n```\\nclass Solution {\\npublic:\\n    vector<int>FindSubSet(int no,vector<int>&nums){\\n        vector<int>re;\\n        int i = 0;\\n        while(no){\\n            if(no&1){\\n                re.push_back(nums[i]);\\n            }\\n            i++;\\n            no>>=1;\\n        }\\n        return re;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>>ans;\\n        int total = 1<<n;\\n        for(int i=0;i<total;i++){\\n            vector<int>temp = FindSubSet(i,nums);\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140388,
                "title": "clear-and-simple-explanation-with-example-100-faster",
                "content": "**Intuition:** Since we are asked to calculate all the possible subsets, hence we will use backtracking , accepting the cases which satisfy conditions and reject the others.\\n\\n**Concept:** This problem is different than the rest of the usual backtracking ones in the sense that , in this problem, we dont have a separate base case that tells us when to stop with the recursion. We keep looping until we run out of indexes and that marks the end of our recursion. \\n\\nWe basically loop over every element in our input `nums`, and we recursively call the method to generate subsets corresponding to that element in the next line and then we remove that element since we are done with it, and we add it to our `subsets` array. \\n\\nAnd **VOILA!!!** Its done.\\nI know it sounds confusing, hence I am going to give an example to explain myself better:\\n\\n**Let\\'s take an example -> nums = [1,2,3]**\\n * first of all, we created current = [ ]\\nNow, we are going to create a copy of current and add it to our subsets Arraylist.\\nSo far, we have subsets = [[ ]]  \\n\\n* Now, we insert the nums[i] i.e., nums[0] in current. Current become -> [1]\\nNow, we make a recursion call with index = 1 and current = [1].\\n\\n* Now, we  add current in subsets. Subsets = [[ ], [1]] (created a copy of current and added it to subset)\\nAdd nums[i] to current where index = 1. Current = [1,2]\\nRecursion call -> index = 2, current = [1, 2].\\n\\n* Add current to subsets. Subsets = [[ ], [1], [1,2]]\\nAdd nums[i] to current where index = 2.\\nRecursion call -> index = 3, current = [1,2,3]\\n\\n* Add current to subset. Subsets = [[ ], [1],[1,2],[1,2,3]]\\nNow, for loop won\\'t execute because index > nums.length().\\nSo, it will return now. \\n\\n* Now, we come to statement current.remove(current.size() - 1).\\nWe now get, current = [1,2]. i = 2 here. Now, we come to next iteration of for loop, i becomes 3 but 3 < nums.length(). \\nSo, it will again return.\\n\\n* Now, we come to statement current.remove(current.size() - 1) again.\\nWe now get, current = [1], i = 1 here. Now, in next loop iteration, i = 2.\\nWe add nums[i] to current. i = 2. Current = [1,3]\\nRecursion Call -> current = [1,3], index = 3\\n\\n* Insert current to subset. Subset = [[ ], [1], [1,2], [1,2,3], [1,3]]\\nWe now try to run the loop but i = 3 and it is not less than nums.length(). \\nSo, we return.\\n\\n* Now, we come back to statement current.remove(current.size() - 1).\\nAnd in the same fashion, [1] is also removed. After 1 is removed, we get [ ] and we insert 2 in it. then we insert [2] in subsets. Then we insert [2,3]. Then we remove 3 and 2. Then we insert [3]. And we are done.\\n\\n* We finally get subset = [[ ], [1], [1,2], [1,2,3], [1,3], [2], [2,3], [3]] ------> ANSWER. Return it. \\n\\nI hope this helped ,and now to implement the logic above , here is the code:\\n\\n**Code:**\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>subset;\\n    void helper(int index, vector<int>&current,vector<int>&nums)\\n    {\\n        subset.push_back(current); // push the current subset into the resultant array\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back(); // as this has been used, pop it\\n        }\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>current;\\n        helper(0,current,nums);\\n        return subset; //return answer\\n    }\\n};\\n```\\n**For similar problems: [Backtracking Collection](https://leetcode.com/discuss/interview-question/1141947/backtracking-study-and-analysis)**\\n\\nIf you like, please **UPVOTE**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>subset;\\n    void helper(int index, vector<int>&current,vector<int>&nums)\\n    {\\n        subset.push_back(current); // push the current subset into the resultant array\\n        for(int i=index;i<nums.size();i++)\\n        {\\n            current.push_back(nums[i]); // add the current element to consider the subsets corresponding to it\\n            helper(i+1,current,nums);  //generate subsets for this array\\n            current.pop_back(); // as this has been used, pop it\\n        }\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>current;\\n        helper(0,current,nums);\\n        return subset; //return answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27332,
                "title": "java-subsets-solution",
                "content": "public class Solution {\\n    \\n    \\n    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       \\n        if(S.length == 0){\\n            return result;\\n        }\\n        \\n        Arrays.sort(S);\\n        dfs(S, 0, new ArrayList<Integer>(), result);\\n        return result;\\n    }\\n    \\n    public void dfs(int[] s, int index, List<Integer> path, List<List<Integer>> result){\\n        result.add(new ArrayList<Integer>(path));\\n        \\n        for(int i = index; i < s.length; i++){\\n            path.add(s[i]);\\n            dfs(s, i+1, path, result);\\n            path.remove(path.size()-1);\\n        }\\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    \\n    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\\n       \\n        if(S.length == 0){\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 360873,
                "title": "python-backtracking",
                "content": "This is a classic backtracking problem. Every back tracking problem can be solved by using the **\"choose\"-> \"explore\" -> \"unchoose\"** strategy.\\n\"Choosing\" is based on the decision tree specific to the problem. Look at the image attached. ![image](https://assets.leetcode.com/users/geekcoder1989/image_1566089485.png)\\n At every level, the decision is whether to include the first element from the remaining set into the chosen set. Based on the decision, further exploration follows.\\n\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def explore(chosen, remaining, res):\\n            if not remaining:\\n                res.append(chosen[:])\\n                return\\n            d = remaining.pop(0)\\n            #choose\\n            chosen.append(d)\\n            #explore\\n            explore(chosen, remaining, res)\\n            chosen.pop()\\n            explore(chosen, remaining, res)\\n            #unchoose\\n            remaining.insert(0, d)\\n        \\n        res = []\\n        chosen = []\\n        explore(chosen, nums, res)\\n        return res\\n```\\t\\t",
                "solutionTags": [
                    "Python3",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def explore(chosen, remaining, res):\\n            if not remaining:\\n                res.append(chosen[:])\\n                return\\n            d = remaining.pop(0)\\n            #choose\\n            chosen.append(d)\\n            #explore\\n            explore(chosen, remaining, res)\\n            chosen.pop()\\n            explore(chosen, remaining, res)\\n            #unchoose\\n            remaining.insert(0, d)\\n        \\n        res = []\\n        chosen = []\\n        explore(chosen, nums, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27353,
                "title": "short-and-clear-solutions",
                "content": "Straight-forward iterative solution:\\n\\n    def subsets(self, nums):\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]\\n        return subsets\\n\\nSame thing but with `reduce` instead of the loop:\\n\\n    def subsets(self, nums):\\n        return reduce(lambda subsets, n: subsets + [s+[n] for s in subsets], nums, [[]])\\n\\nUsing `combinations` from the library:\\n\\n    def subsets(self, nums):\\n        return [s for n in range(len(nums)+1)\\n                for s in itertools.combinations(nums, n)]\\n\\nUsing integers as bit mask to tell which elements to use in a subset:\\n\\n    def subsets(self, nums):\\n        return [[nums[i] for i in range(len(nums)) if mask >> i & 1]\\n                for mask in range(2 ** len(nums))]",
                "solutionTags": [
                    "Python"
                ],
                "code": "Straight-forward iterative solution:\\n\\n    def subsets(self, nums):\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]\\n        return subsets\\n\\nSame thing but with `reduce` instead of the loop:\\n\\n    def subsets(self, nums):\\n        return reduce(lambda subsets, n: subsets + [s+[n] for s in subsets], nums, [[]])\\n\\nUsing `combinations` from the library:\\n\\n    def subsets(self, nums):\\n        return [s for n in range(len(nums)+1)\\n                for s in itertools.combinations(nums, n)]\\n\\nUsing integers as bit mask to tell which elements to use in a subset:\\n\\n    def subsets(self, nums):\\n        return [[nums[i] for i in range(len(nums)) if mask >> i & 1]\\n                for mask in range(2 ** len(nums))]",
                "codeTag": "Python3"
            },
            {
                "id": 1766584,
                "title": "python3-bit-manipulation-99-55-faster-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nThe idea is to use a bitmask where every bit represents an element in the `nums` list. If a bit is set to one, that means the corresponding element is active and goes to a subset. By subtracting the mask by 1 until it turns to zero, we will be able to iterate all possible variations of unique subsets. Example: `nums=[1, 2, 3]`:\\nmask=111 | nums=[**1, 2, 3**]\\nmask=110 | nums=[**1,2,** 3]\\nmask=101 | nums=[**1,** 2, **3**]\\nmask=100 | nums=[**1,** 2, 3]\\netc.\\n\\nTime: **O(N * 2^N)** - iterations\\nSpace: **O(1)** - if not account for the answer list \\n\\nRuntime: 24 ms, faster than **99.55%** of Python3 online submissions for Subsets.\\nMemory Usage: 14.1 MB, less than **95.43%** of Python3 online submissions for Subsets.\\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\tL, ans = len(nums), list([[]])\\n\\n\\tmask = 2**L - 1\\n\\twhile mask:\\n\\t\\tcopy, i, subset = mask, L - 1, list()\\n\\t\\twhile copy:\\n\\t\\t\\tif copy & 1: subset.append(nums[i])\\n\\t\\t\\ti, copy = i - 1, copy >> 1\\n\\n\\t\\tans.append(subset)\\n\\t\\tmask -= 1\\n\\n\\treturn ans\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\tL, ans = len(nums), list([[]])\\n\\n\\tmask = 2**L - 1\\n\\twhile mask:\\n\\t\\tcopy, i, subset = mask, L - 1, list()\\n\\t\\twhile copy:\\n\\t\\t\\tif copy & 1: subset.append(nums[i])\\n\\t\\t\\ti, copy = i - 1, copy >> 1\\n\\n\\t\\tans.append(subset)\\n\\t\\tmask -= 1\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 299665,
                "title": "recursive-javascript-solution",
                "content": "```js\\nfunction subsets(nums) {\\n\\tconst powerset = [];\\n\\tgeneratePowerset([], 0);\\n\\n\\tfunction generatePowerset(path, index) {\\n\\t\\tpowerset.push(path);\\n\\t\\tfor (let i = index; i < nums.length; i++) {\\n\\t\\t\\tgeneratePowerset([...path, nums[i]], i + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn powerset;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```js\\nfunction subsets(nums) {\\n\\tconst powerset = [];\\n\\tgeneratePowerset([], 0);\\n\\n\\tfunction generatePowerset(path, index) {\\n\\t\\tpowerset.push(path);\\n\\t\\tfor (let i = index; i < nums.length; i++) {\\n\\t\\t\\tgeneratePowerset([...path, nums[i]], i + 1);\\n\\t\\t}\\n\\t}\\n\\n\\treturn powerset;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27277,
                "title": "5-line-simple-python-solution-beat-96",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i] + [n])\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i] + [n])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27485,
                "title": "share-my-12-line-simple-java-code-with-brief-explanations",
                "content": "    /*\\n        dfs. \\u6bcf\\u4e2a\\u4f4d\\u7f6e\\u90fd\\u6709\\u9009\\u4e0e\\u4e0d\\u9009\\u4e24\\u4e2a\\u9009\\u9879, \\u4e5f\\u53ef\\u4ee5\\u770b\\u6210\\u904d\\u5386\\u4e00\\u68f5\\u4e8c\\u53c9\\u6811, \\u5411\\u5de6\\u8d70\\u9009, \\u5411\\u53f3\\u8d70\\u4e0d\\u9009\\n    */\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums == null) { return ans; }\\n            Arrays.sort(nums);  // non-descending order\\n            dfs(ans, nums, new ArrayList<Integer>(), 0);\\n            return ans; \\n        }\\n        \\n        private void dfs(List<List<Integer>> ans, int[] nums, List<Integer> list, int index) {\\n            if (index == nums.length) { ans.add(new ArrayList<Integer>(list)); return; }\\n            dfs(ans, nums, list, index+1);  // not pick the number at this index\\n            list.add(nums[index]);\\n            dfs(ans, nums, list, index+1);  // pick the number at this index\\n            list.remove(list.size()-1);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> ans = new ArrayList<>();\\n            if (nums == null) { return ans; }",
                "codeTag": "Java"
            },
            {
                "id": 381670,
                "title": "c-backtracking-solution-with-comments",
                "content": "```\\n/*\\nTime complexity : O(N*(2^N))\\nSpace complexity : O(N*(2^N))\\n\\nI am not very clear, please refer to Back to Back SWE\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> cache;\\n        vector<int> temp;\\n        subsets(nums, cache, temp, 0);\\n        return cache;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, vector<vector<int>>& cache, vector<int> &temp, int start) {\\n        // goal, once we reach the end, add it to the result\\n        if(start == nums.size()) {\\n            cache.push_back(temp);\\n            return;\\n        }\\n        // for every element we have two choices : keep it or drop it\\n        // choice 1, keep it\\n        temp.push_back(nums[start]);\\n        subsets(nums, cache, temp, start + 1);\\n        // choice 2, drop it\\n        temp.pop_back();\\n        subsets(nums, cache, temp, start + 1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking"
                ],
                "code": "```\\n/*\\nTime complexity : O(N*(2^N))\\nSpace complexity : O(N*(2^N))\\n\\nI am not very clear, please refer to Back to Back SWE\\n*/\\n\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> cache;\\n        vector<int> temp;\\n        subsets(nums, cache, temp, 0);\\n        return cache;\\n    }\\nprivate:\\n    void subsets(vector<int>& nums, vector<vector<int>>& cache, vector<int> &temp, int start) {\\n        // goal, once we reach the end, add it to the result\\n        if(start == nums.size()) {\\n            cache.push_back(temp);\\n            return;\\n        }\\n        // for every element we have two choices : keep it or drop it\\n        // choice 1, keep it\\n        temp.push_back(nums[start]);\\n        subsets(nums, cache, temp, start + 1);\\n        // choice 2, drop it\\n        temp.pop_back();\\n        subsets(nums, cache, temp, start + 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184674,
                "title": "javascript",
                "content": "```\nvar subsets = function(nums) {\n    let result = [];\n    dfs([], 0);\n    \n    function dfs(current, index){\n        result.push(current);\n        for(let i = index; i < nums.length; i++) {\n            dfs(current.concat(nums[i]), i + 1);\n        }\n    }\n    \n    return result;\n};\n```",
                "solutionTags": [],
                "code": "```\nvar subsets = function(nums) {\n    let result = [];\n    dfs([], 0);\n    \n    function dfs(current, index){\n        result.push(current);\n        for(let i = index; i < nums.length; i++) {\n            dfs(current.concat(nums[i]), i + 1);\n        }\n    }\n    \n    return result;\n};\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729842,
                "title": "python-3-solutions-backtracking-2-oneliners-explained",
                "content": "In this problem we need to return all posible subsets of given set, and there are a big number of them: `2^n`. It usually means, that we need to use some backtracking approach to do it.\\nLet us have function `dfs(self, current, nums)`, with parameters:\\n1. `current` is set of indexes choosen number: we always choose indexes in increasing order. \\n2. `nums` are our original numbers (we can make it global varialbe as well).\\n\\nAlso I start with dummy variable index `-1`, and when we add subset to final answer, we remove this element. Then we recursively run `dfs` with new added number `i`.\\n\\n**Complexity**: both time ans space is `O(2^n*n)`, because we have `2^n` subsets with n/2 elements in average.\\n\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        self.out = []\\n        self.dfs([-1],nums)\\n        return self.out\\n\\n    def dfs(self, current, nums):\\n        self.out.append([nums[s] for s in current][1:])\\n        for i in range(current[-1] + 1, len(nums)):\\n            self.dfs(current + [i], nums)\\n```\\n\\n**Oneliners**\\nFirst one is to use `combinations` library from python, and we itarate over all possible number of elements. Second one uses binary masks.\\n\\n```\\nreturn chain.from_iterable(combinations(nums, i) for i in range(len(nums)+1))\\n\\nreturn [[nums[j] for j in range(len(nums)) if (i&(1<<j))] for i in range(1<<len(nums))]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        self.out = []\\n        self.dfs([-1],nums)\\n        return self.out\\n\\n    def dfs(self, current, nums):\\n        self.out.append([nums[s] for s in current][1:])\\n        for i in range(current[-1] + 1, len(nums)):\\n            self.dfs(current + [i], nums)\\n```\n```\\nreturn chain.from_iterable(combinations(nums, i) for i in range(len(nums)+1))\\n\\nreturn [[nums[j] for j in range(len(nums)) if (i&(1<<j))] for i in range(1<<len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362545,
                "title": "python3-backtracking",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    level 0: []\\n    level 1: [11]                    [22]       [33]\\n    level 2: [11,22]     [11,33]     [22,33] \\n    level 3: [11,22,33]\\n  \\n    \"\"\"\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```\\n* The length of subset:\\nwe have two choices for a given item in the nums: in the subset or not in the subset. So, if we have 2 choices for each of the \\uD835\\uDC5B elements, the total number of subsets possible is 2**n.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    level 0: []\\n    level 1: [11]                    [22]       [33]\\n    level 2: [11,22]     [11,33]     [22,33] \\n    level 3: [11,22,33]\\n  \\n    \"\"\"\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        self.backtracking(res,0,[],nums)\\n        return res\\n    def backtracking(self,res,start,subset,nums):\\n        res.append(list(subset))\\n        for i in range(start,len(nums)):\\n            subset.append(nums[i])\\n            self.backtracking(res,i+1,subset,nums)\\n            subset.pop()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766662,
                "title": "easy-to-go-solution",
                "content": ">In this question if you observe you will found out that we have given some `choices` & on that `choices` we have to make `decision`.\\n>>So, what choices we have given is whether **to include \"Yes\" or not \"No\".**\\n\\nLet\\'s say we have **input:** [1, 2, 3] to make it\\'s recursive diagram. We have choices like to include 1 or not & so on...\\n\\n```\\n       1                    2                      3\\n\\t  / \\\\                  / \\\\                    / \\\\\\n\\tYes  No              Yes  No                Yes  No\\n```\\n\\nSo, on these choices whatever decision I will take, it will make my subset!\\n\\n![image](https://assets.leetcode.com/users/images/e031f1ed-c20f-4999-ab43-bc49bb1e235d_1644719174.8762171.png)\\n\\nSo, if you see we are taking choices whether to have or not. [ 0 or 1 ] And by these choices we are making decision\\'s. And because of that. Our Input is getting smaller.\\n\\nNow let\\'s understand, how we will build our **recursion tree**\\n\\nAgain, let\\'s understand with example we have to get subset of [1, 2]\\n\\n```\\n|  [ ]  |   1 -> 0 2 -> 0\\n|  1    |   1 -> 1 2 -> 0\\n|  2    |   1 -> 0 2 -> 1\\n|  12   |   1 -> 1 2 -> 1\\n```\\n\\nSo, instead of representing in `1->0 2->0` way. We want to represent in a good way & that way is called **Recursive Tree**\\n\\nFor Recursive tree there is a method called **\"IP - OP Method\"**\\n\\n![image](https://assets.leetcode.com/users/images/f3beda30-bb5b-4f19-8642-56ce05fff151_1644719440.842423.png)\\n\\nLet\\'s understand this tree with an example as well. **Get subset of [1, 2, 3]**\\n\\n![image](https://assets.leetcode.com/users/images/219e18c6-cc00-45c5-b9c2-e1cc287123d8_1644720694.847087.png)\\n\\nSo, as you see once the **input is becoming empty** we are getting our answer:\\nWe put our base-condition `if input size becomes 0`\\n **return & get\\'s the answer**\\n\\n\\n>**2 steps to solve Recursion Problem**\\n* `Design a recursive tree`\\n* `F8ck the problem a.k.a` **Write the code**\\n\\n*I hope now, you got the idea.* **Let\\'s code it:**\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<Integer> ip = new ArrayList<>(); // ip = input\\n        for(int i = 0; i < nums.length; i++){\\n            ip.add(nums[i]);\\n        }\\n        List<Integer> op = new ArrayList<>(); // op = output\\n        List<List<Integer>> res = new ArrayList<>(); \\n        \\n        solve(ip, op, res);\\n        return res;\\n    }\\n    public void solve(List<Integer> ip, List<Integer> op, List<List<Integer>> res){\\n        if(ip.size() == 0){\\n            res.add(op);\\n            return;\\n        }\\n        \\n        List<Integer> op1 = new ArrayList<>(op); // op1 = output1\\n        List<Integer> op2 = new ArrayList<>(op); // op2 = output2\\n        \\n        op2.add(ip.get(0));\\n        \\n        //NEED TO DECALARE NEW input ARRAYLIST BECUASE JAVA IS \"PASS BY VALUE\"\\n        List<Integer> input = new ArrayList<>(ip);\\n\\n        input.remove(0);\\n        \\n        solve(input, op1, res);\\n        solve(input, op2, res);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n       1                    2                      3\\n\\t  / \\\\                  / \\\\                    / \\\\\\n\\tYes  No              Yes  No                Yes  No\\n```\n```\\n|  [ ]  |   1 -> 0 2 -> 0\\n|  1    |   1 -> 1 2 -> 0\\n|  2    |   1 -> 0 2 -> 1\\n|  12   |   1 -> 1 2 -> 1\\n```\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<Integer> ip = new ArrayList<>(); // ip = input\\n        for(int i = 0; i < nums.length; i++){\\n            ip.add(nums[i]);\\n        }\\n        List<Integer> op = new ArrayList<>(); // op = output\\n        List<List<Integer>> res = new ArrayList<>(); \\n        \\n        solve(ip, op, res);\\n        return res;\\n    }\\n    public void solve(List<Integer> ip, List<Integer> op, List<List<Integer>> res){\\n        if(ip.size() == 0){\\n            res.add(op);\\n            return;\\n        }\\n        \\n        List<Integer> op1 = new ArrayList<>(op); // op1 = output1\\n        List<Integer> op2 = new ArrayList<>(op); // op2 = output2\\n        \\n        op2.add(ip.get(0));\\n        \\n        //NEED TO DECALARE NEW input ARRAYLIST BECUASE JAVA IS \"PASS BY VALUE\"\\n        List<Integer> input = new ArrayList<>(ip);\\n\\n        input.remove(0);\\n        \\n        solve(input, op1, res);\\n        solve(input, op2, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1598122,
                "title": "python-subsets-vs-combinations-vs-permutations-visualized",
                "content": "**Idea:**\\n- To generate subsets, each node in the recrsive tree is part of the solution.\\n- The generation of **subsets** and that of **combinations** are simialr. In fact, combinations is a special case of subsets where the answers must be of a specific size k (nCk)\\n- On the other hand, subsets come in varying sizes - from 0 (aka. empty subset)all the way to size n.\\n- **Visually,** the recursive tree that we must generate to arrive at *both* **subsets** and **combinations** of a list is the same. \\n- However, only **leaf nodes that are of size k** make up the solution to the **combination problem,** whereas the solution for the **subsets** problem comprise of **all nodes** in the recursive tree without exception.\\n- See below visuals for a comparison between: \\n    - **Trimming algortihm** (used in generating subsets, combinations)\\n    - **Swapping algorithm** (used in generating permutations)\\n\\n![image](https://assets.leetcode.com/users/images/f45911f6-3d16-4ff9-b745-ea473f48b70e_1641245486.5257618.png)\\n\\n![image](https://assets.leetcode.com/users/images/73e04b91-2fac-40f8-9cc2-d696fb7c81f2_1637989748.5639527.png)\\n\\n\\n------------------------------------------------------------------------------\\n[1] Recursive\\n--------------------------------\\n------------------------------------------------------------------------------\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\tRecursive\\n\\t\\'\\'\\'\\n\\t# - helper\\n\\tdef recurse(start, subset):\\n\\n\\t\\tres.append(subset)\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\trecurse(i+1, subset+[nums[i]])\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\treturn recurse(0, []) # startIndx, subset\\n```\\n------------------------------------------------------------------------------\\n[2] Iterative\\n--------------------------------\\n------------------------------------------------------------------------------\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\titerative\\n\\t\\'\\'\\'\\n\\tstack = [(0, [])] # start, subset\\n\\tres = []\\n\\twhile stack:\\n\\t\\tstart, subset = stack.pop()\\n\\t\\tres.append(subset) # no cond to be checked (unlike combinations, perm)\\n\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\tstack.append((i+1, subset+[nums[i]]))\\n\\n\\treturn res\\n```\\n- Similar problems:\\n\\t- Combinations: https://leetcode.com/problems/combinations/discuss/1409224/Python-4-Approaches-Explained-%2B-Visualized\\n\\t- Permuations: https://leetcode.com/problems/permutations/discuss/993970/Python-4-Approaches-%3A-Visuals-%2B-Time-Complexity-Analysis",
                "solutionTags": [
                    "Recursion",
                    "Iterator",
                    "Probability and Statistics"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\tRecursive\\n\\t\\'\\'\\'\\n\\t# - helper\\n\\tdef recurse(start, subset):\\n\\n\\t\\tres.append(subset)\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\trecurse(i+1, subset+[nums[i]])\\n\\t\\treturn res\\n\\n\\t# - main\\n\\tres = []\\n\\treturn recurse(0, []) # startIndx, subset\\n```\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\'\\'\\'\\n\\titerative\\n\\t\\'\\'\\'\\n\\tstack = [(0, [])] # start, subset\\n\\tres = []\\n\\twhile stack:\\n\\t\\tstart, subset = stack.pop()\\n\\t\\tres.append(subset) # no cond to be checked (unlike combinations, perm)\\n\\n\\t\\tfor i in range(start, len(nums)):\\n\\t\\t\\tstack.append((i+1, subset+[nums[i]]))\\n\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 473975,
                "title": "learning-and-summarizing-3-solutions",
                "content": "\\n**BFS**\\n```\\nlet subsetsbfs = function (nums) {\\n  const res = [[]];\\n  for (let i = 0; i < nums.length; i++) {\\n    const size = res.length;\\n    for (let j = 0; j < size; j++) {\\n      res.push([...res[j], nums[i]]);\\n    }\\n  }\\n  return res;\\n};\\n```\\n\\n\\n**Backtracking**\\n```\\nlet subsets = function (nums) {\\n  const res = [];\\n  const backtracking = (nums, res, idx, path) => {\\n    res.push([...path]);\\n\\n    for (let i = idx; i < nums.length; i++) {\\n      path.push(nums[i]);\\n      backtracking(nums, res, i + 1, path);\\n      path.pop();\\n    }\\n  };\\n\\n  backtracking(nums, res, 0, []);\\n\\n  return res;\\n};\\n```\\n\\n\\n**Lexicographic Subsets**\\n```\\nvar subsets = function(nums) {\\n    let res = []\\n    const powSize = Math.pow(2, nums.length)\\n\\n    for (let i = 0; i < powSize; i++) {\\n        let set = []\\n        for (let j = 0; j < nums.length; j++) {\\n            if ((i & (1 << j)) > 0) {\\n                set.push(nums[j])\\n            }\\n        }\\n        res.push(set)\\n    }\\n    return res\\n}\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nlet subsetsbfs = function (nums) {\\n  const res = [[]];\\n  for (let i = 0; i < nums.length; i++) {\\n    const size = res.length;\\n    for (let j = 0; j < size; j++) {\\n      res.push([...res[j], nums[i]]);\\n    }\\n  }\\n  return res;\\n};\\n```\n```\\nlet subsets = function (nums) {\\n  const res = [];\\n  const backtracking = (nums, res, idx, path) => {\\n    res.push([...path]);\\n\\n    for (let i = idx; i < nums.length; i++) {\\n      path.push(nums[i]);\\n      backtracking(nums, res, i + 1, path);\\n      path.pop();\\n    }\\n  };\\n\\n  backtracking(nums, res, 0, []);\\n\\n  return res;\\n};\\n```\n```\\nvar subsets = function(nums) {\\n    let res = []\\n    const powSize = Math.pow(2, nums.length)\\n\\n    for (let i = 0; i < powSize; i++) {\\n        let set = []\\n        for (let j = 0; j < nums.length; j++) {\\n            if ((i & (1 << j)) > 0) {\\n                set.push(nums[j])\\n            }\\n        }\\n        res.push(set)\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1571250,
                "title": "c-solution-using-recursion-with-full-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We pass ans array, index, input array(ip), output array(op) to solve function.\\n- In every function call either we have to take the input to the array or skip that.\\n- If we skip we simply call the function and increase the index by 1.\\n- else we include that in op array\\xA0***//op.push_back(ip[i])***\\n- again we call for the next index and after we return we simply pop last element from op\\n- Base condition: When idx is equal to the size of ip we return.\\n- **Time complexity:** O().\\n\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\n    void solve(vector<vector<int>> &ans, int i, vector<int>& ip, vector<int> op){\\n        if(ip.size()==i){\\n            ans.push_back(op);\\n            return;\\n        }\\n        solve(ans, i+1, ip, op);        \\n        op.push_back(ip[i]);\\n        solve(ans, i+1, ip, op);\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& ip) {\\n        vector<vector<int>> ans;\\n        vector<int>op;\\n        solve(ans, 0, ip, op);\\n        return ans;\\n        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\n    void solve(vector<vector<int>> &ans, int i, vector<int>& ip, vector<int> op){\\n        if(ip.size()==i){\\n            ans.push_back(op);\\n            return;\\n        }\\n        solve(ans, i+1, ip, op);        \\n        op.push_back(ip[i]);\\n        solve(ans, i+1, ip, op);\\n        return;\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& ip) {\\n        vector<vector<int>> ans;\\n        vector<int>op;\\n        solve(ans, 0, ip, op);\\n        return ans;\\n        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1549657,
                "title": "java-tc-o-n-2-n-sc-o-1-constant-space-iterative-backtracking-solutions",
                "content": "**Constant Space Iterative Solution**\\n```java\\n/**\\n * Constant Space Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(1) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        result.add(new ArrayList<>());\\n        for (int n : nums) {\\n            int size = result.size();\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> temp = new ArrayList<>(result.get(i));\\n                temp.add(n);\\n                result.add(temp);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\n---\\n**Backtracking (Recursion). This solution take O(N) space for recursion depth and temp list.**\\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N) (Recursion Depth + TempList)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        subsetsHelper(nums, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsHelper(int[] nums, int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            subsetsHelper(nums, i + 1, temp, result);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other Subsets questions on LeetCode:\\n- [90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/1549662/Java-or-TC:-O(N*2N)-or-SC:-O(UniqueNums)-or-Space-Optimized-Iterative-and-Backtracking-solutions)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\n/**\\n * Constant Space Iterative Solution\\n *\\n * S(n) = (0 \\xD7 (n C 0) + 1 \\xD7 (n C 1) + 2 \\xD7 (n C 2) + \\u2026 + n \\xD7 (n C n))\\n * Note that (n C k) = (n C n-k). Therefore:\\n * S(n) = 0 \\xD7 (n C n) + 1 \\xD7 (n C n-1) + 2 \\xD7 (n C n-2) + \\u2026 + n \\xD7 (n C 0)\\n * If we add these two together, we get\\n * 2S(n) = n \\xD7 (n C 0) + n \\xD7 (n C 1) + \\u2026 + n \\xD7 (n C n)\\n *       = n \\xD7 (n C 0 + n C 1 + \\u2026 + n C n)\\n * As per binomial theorem, (n C 0 + n C 1 + \\u2026 + n C n) = 2^n, so\\n * 2*S(n) = n * 2^n => S(n) = n * 2^(n-1)\\n *\\n * Time Complexity: O(S(N) + n C 0) = O(N * 2^(N-1) + 1) = O(N * 2^N)\\n *\\n * Space Complexity: O(1) (Excluding the result space)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        result.add(new ArrayList<>());\\n        for (int n : nums) {\\n            int size = result.size();\\n            for (int i = 0; i < size; i++) {\\n                List<Integer> temp = new ArrayList<>(result.get(i));\\n                temp.add(n);\\n                result.add(temp);\\n            }\\n        }\\n\\n        return result;\\n    }\\n}\\n```\n```java\\n/**\\n * Backtracking (Recursion)\\n *\\n * Time Complexity: O(N * 2 ^ N) Refer to above explanation\\n *\\n * Space Complexity: O(N) (Recursion Depth + TempList)\\n *\\n * N = Length of input nums array\\n */\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n        if (nums == null) {\\n            return result;\\n        }\\n\\n        subsetsHelper(nums, 0, new ArrayList<>(), result);\\n        return result;\\n    }\\n\\n    private void subsetsHelper(int[] nums, int start, List<Integer> temp, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(temp));\\n\\n        for (int i = start; i < nums.length; i++) {\\n            temp.add(nums[i]);\\n            subsetsHelper(nums, i + 1, temp, result);\\n            temp.remove(temp.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 855802,
                "title": "java-backtracking-2-n-100-fast-solution-time-complexity-explained",
                "content": "```\\nclass Solution {\\n    int nums[];\\n    List<List<Integer>> result;\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.result=new ArrayList<List<Integer>>();\\n        this.nums=nums;\\n        \\n        compute(0,new ArrayList<Integer>());\\n        return result;\\n    }\\n    \\n    private void compute(int i,ArrayList<Integer> al){\\n        if(i==nums.length){\\n            result.add(new ArrayList<Integer>(al));\\n            return;\\n        }\\n        compute(i+1,al);\\n        al.add(nums[i]);\\n        compute(i+1,al);\\n        al.remove(new Integer(nums[i]));\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d2f21464-a034-4873-a490-179e24383fa5_1600613703.2150216.png)\\n\\n\\nFor set of n elements, power set will have, 2^n elements.\\n\\nso let\\'s say.. we have elements [1,2,3]\\nso for every number we have a choice, we include that number, or we exclude it..\\n\\nso above approach follows same concept..\\n\\nLook at the image above, \\n1) intially index is 0, and list is empty.. \\n2) so now, element at index 0 have two functions calls, one where 1 is not included in arrayList\\n   and other one where 1 is included..\\n3) now, for level-1\\'s dunction call, index is 1. so again element at index 2, will have those function calls..\\n4) continue same, till the last element. \\n5) when index reaches value n (i.e, processed all elements) \\n   copy the content of list into other arraylist, and insert it into new list.\\n   \\nNOTE: if you have noticed, all lists will be unique.. reason is, this approach creates, exactly 2^n paths from root to leaf nodes and every leaf node represents one list from power set.\\n\\nTime Complexity: \\n1) let\\'s ccreate recurrence relation first.. T(n) = 2*T(n-1) &  if(n=1) T(0)= 1;\\n2) so now, T(n) = 2*2*T(n-2)\\n3) T(n) = (2^2) * T(n-2)\\n4) if we generalize this expression, using k,\\n    T(n) = (2^k) * T(n-k)\\n5) when k=n,\\n    T(n) = 2^n * T(0) and T(0) = 1;\\ntherfore time complexity of above program is, T(n) = 2^n",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    int nums[];\\n    List<List<Integer>> result;\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        this.result=new ArrayList<List<Integer>>();\\n        this.nums=nums;\\n        \\n        compute(0,new ArrayList<Integer>());\\n        return result;\\n    }\\n    \\n    private void compute(int i,ArrayList<Integer> al){\\n        if(i==nums.length){\\n            result.add(new ArrayList<Integer>(al));\\n            return;\\n        }\\n        compute(i+1,al);\\n        al.add(nums[i]);\\n        compute(i+1,al);\\n        al.remove(new Integer(nums[i]));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527606,
                "title": "several-python-solution-w-explanation-demo",
                "content": "Here, we share some solution, including bit serial mapping, element adding, concise DFS, as well as built-in iteration tools in Python.\\n\\nTime Complexity: O( n * 2^n )\\nSpace Complexity: O( n * 2^n )\\n\\n---\\n**Algorithm**:\\n\\n**#1: Bit serial mapping**\\n\\nThe bit serial from 0 to 2^n - 1 can be mapped to element selction for subset generation.\\n\\nTake nums = [1,2,3] for example.\\n\\nsize of input = 3.\\nThus, we go through bit serial from 0 to 2^3 -1 = ( 1 << 3 ) - 1 =  7, then getting corresponding subset on the fly.\\n\\n0 = 0b 000 = empty set = [ ]\\n1 = 0b 00**1** = select first element = [ 1 ]\\n2 = 0b 0**1**0 = select second element = [ 2 ]\\n3 = 0b 0**11** = select first and second elements = [ 1, 2 ]\\n4 = 0b **1**00 = select third element = [ 3 ]\\n5 = 0b **1**0**1** = select first and third elements = [ 1, 3 ]\\n6 = 0b **11**0 = select second and third elements = [ 2, 3 ]\\n7 = 0b **111** = select all elements = [ 1, 2 , 3 ]\\n\\n---\\n\\n**Implementation_#1**:\\nBy bit serial mapping\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size\\n\\t\\t\\n        return [ [ nums[i]  for i in range(size) if bits_sn & (1 << i) != 0 ] for bits_sn in range(upper_bound) ]\\n```\\n\\nor\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size \\n        \\n        all_subset = [ ]\\n        for bits_sn in range(upper_bound):\\n            \\n            cur_subset = []\\n            \\n            for i in range(size):\\n                \\n                if bits_sn & (1 << i) != 0:\\n                    \\n                    cur_subset.append( nums[i] )\\n            \\n            all_subset.append( cur_subset )\\n        \\n        return all_subset\\n```\\n\\n---\\n\\n**#2: Element adding**\\n\\n**Base case** is **empty set**: [ **[ ]**  ]\\nBuild all subsets from base-case in bottom-up, add one element for each iteration.\\n\\nTake nums = [1,2,3] for example.\\n\\nInitialization of solution = [ **[ ]**  ] # empty set\\n\\n1st iteration, add [ **1** ] to current solution\\nsolution = [ [ ], [ **1** ] ]\\n\\n2nd iteration, add [ **2** ] to current solution\\nsolution = [ [ ], [ 1 ], [ **2** ], [ 1, **2** ] ]\\n\\n3rd iteration, add [ **3** ] to current solution\\nsolution = [ [ ], [ 1 ], [ 2 ], [ 1, 2 ], [ **3** ], [ 1, **3** ], [ 2, **3** ], [ 1, 2, **3** ] ]\\n\\nCompleted.\\n\\nAll subsets = [ [ ], [ 1 ], [ 2 ], [ 1, 2 ], [ 3 ], [ 1, 3 ], [ 2, 3 ], [ 1, 2, 3 ] ]\\n\\n---\\n\\n**Implementation_#2**:\\nBy element adding\\n\\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n        \\n        # Base case:\\n        solution = [ [] ]\\n        \\n        # General case:\\n        # Generate subset by element adding\\n        for element in nums:\\n            \\n            solution += ( [ current + [ element ] for current in solution ] )\\n            \\n        return solution\\n```\\n\\n---\\n\\n**#3: Concise DFS**\\n\\n---\\n\\n**Implementation_#3**:\\nBy concise DFS\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        solution = []\\n        size = len(nums)\\n        \\n        def dfs(cur, set_len, start_idx):\\n            \\n            if set_len == len(cur):\\n                solution.append( cur[::] )\\n                return\\n            \\n            for j in range(start_idx, size):\\n                \\n                cur.append( nums[j] )\\n                dfs(cur, set_len, j+1)\\n                cur.pop()\\n        #------------------------------------------\\n        \\n        for set_len in range(0, size+1):\\n            dfs(cur=[], set_len=set_len, start_idx=0)\\n        \\n        return solution\\n```\\n\\n---\\n\\n**#4: Built-in iteration tools in Python**\\n\\nLet size = *n* denote the length of input array\\n\\nAll subset \\n= subset of no element, subset of 1 element, subset of 2 element,... subset of n elements\\n= cases of C( *n*, 0) + cases of C( *n*, 1) + cases of C( *n*, 2) + ... + cases of C( *n*, *n* )\\n= 2^n cases in total\\n\\nPython have **built-in tool** to generate **Combination** of given list and *k*, *k* is from 1 to *n*. Its syntax is as following:\\n\\nitertools.combinations( *iterable* , *k* )\\n\\nExample:\\ncombinations(\\'ABCD\\', 2) --> AB AC AD BC BD CD\\n\\n---\\n\\n**Implementation_#4**:\\nBy built-in iteration tools in Python\\n\\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def subsets(self, nums):\\n        \\n        solution, size = [], len(nums)\\n        \\n        for k in range(size+1):\\n            \\n            solution += [ list(comb) for comb in combinations(nums, k) ]\\n        \\n        return solution\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #90 Subset II](https://leetcode.com/problems/subsets-ii/)\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about bitwise shift operator <<, >>](https://docs.python.org/3/reference/expressions.html#shifting-operations)\\n\\n[2] [Python official docs about list comprehension [ ... ]](https://docs.python.org/3/tutorial/datastructures.html#list-comprehensions)\\n\\n[3] [Python official docs about itertools.combination( )](https://docs.python.org/3.8/library/itertools.html#itertools.combinations)\\n\\n",
                "solutionTags": [
                    "Python",
                    "Bit Manipulation",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size\\n\\t\\t\\n        return [ [ nums[i]  for i in range(size) if bits_sn & (1 << i) != 0 ] for bits_sn in range(upper_bound) ]\\n```\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n    \\n        size = len(nums)\\n        upper_bound = 1 << size \\n        \\n        all_subset = [ ]\\n        for bits_sn in range(upper_bound):\\n            \\n            cur_subset = []\\n            \\n            for i in range(size):\\n                \\n                if bits_sn & (1 << i) != 0:\\n                    \\n                    cur_subset.append( nums[i] )\\n            \\n            all_subset.append( cur_subset )\\n        \\n        return all_subset\\n```\n```\\nclass Solution:\\n    \\n    def subsets(self, nums):\\n        \\n        # Base case:\\n        solution = [ [] ]\\n        \\n        # General case:\\n        # Generate subset by element adding\\n        for element in nums:\\n            \\n            solution += ( [ current + [ element ] for current in solution ] )\\n            \\n        return solution\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        solution = []\\n        size = len(nums)\\n        \\n        def dfs(cur, set_len, start_idx):\\n            \\n            if set_len == len(cur):\\n                solution.append( cur[::] )\\n                return\\n            \\n            for j in range(start_idx, size):\\n                \\n                cur.append( nums[j] )\\n                dfs(cur, set_len, j+1)\\n                cur.pop()\\n        #------------------------------------------\\n        \\n        for set_len in range(0, size+1):\\n            dfs(cur=[], set_len=set_len, start_idx=0)\\n        \\n        return solution\\n```\n```\\nfrom itertools import combinations\\n\\nclass Solution:\\n    def subsets(self, nums):\\n        \\n        solution, size = [], len(nums)\\n        \\n        for k in range(size+1):\\n            \\n            solution += [ list(comb) for comb in combinations(nums, k) ]\\n        \\n        return solution\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187733,
                "title": "backtrack-template-make-backtracking-easy",
                "content": "Here is my summary about Backtracking Template:\\n[Never be stuck by Backtracking Problem -- Backtracking problem Template](https://leetcode.com/problems/palindrome-partitioning/discuss/182307/Java:-Backtracking-Template-General-Approach)\\n\\n```java\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        // Backtracking\\n        // Edge case\\n        if(nums == null || nums.length == 0) return new ArrayList<>();\\n        \\n        List<Integer> step = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        helper(nums, 0, step, result);\\n        return result;\\n    }\\n    public void helper(int[] nums, int start, List<Integer> step, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(step));\\n        for(int i = start; i < nums.length; i++) {\\n            // choose\\n            step.add(nums[i]);\\n            // explore\\n            helper(nums, i + 1, step, result);\\n            // unchoose\\n            step.remove(step.size() - 1);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        // Backtracking\\n        // Edge case\\n        if(nums == null || nums.length == 0) return new ArrayList<>();\\n        \\n        List<Integer> step = new ArrayList<>();\\n        List<List<Integer>> result = new ArrayList<>();\\n        helper(nums, 0, step, result);\\n        return result;\\n    }\\n    public void helper(int[] nums, int start, List<Integer> step, List<List<Integer>> result) {\\n        result.add(new ArrayList<>(step));\\n        for(int i = start; i < nums.length; i++) {\\n            // choose\\n            step.add(nums[i]);\\n            // explore\\n            helper(nums, i + 1, step, result);\\n            // unchoose\\n            step.remove(step.size() - 1);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1768746,
                "title": "python3-o-n-2-n-3-line-solution",
                "content": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[[]]\\n        for j in nums:\\n            ans+=[i+[j] for i in ans]\\n        return ans\\n            \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[[]]\\n        for j in nums:\\n            ans+=[i+[j] for i in ans]\\n        return ans\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27550,
                "title": "very-simple-and-fast-java-solution-with-explanation",
                "content": "\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        for (int i = pos; i < n.length; i++) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe idea is use pos to keep track of the index of the array. Compare to other backracking problem like combinations, the condition that each single List adds to the List<List<Integer>> is when the index of the array is valid. Meanwhile, after adding to the List<List<Integer>> , keeping going for the for loop.\\n\\n\\n----------\\nthe following is the combinations I wrote, which is very similar to this problem.\\n\\n        public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 1, n, k);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int n, int k) {\\n        if (each.size() == k) {\\n            res.add(each);\\n            return;\\n        }\\n        for (int i = pos; i <= n; i++) {\\n            each.add(i);\\n            helper(res, new ArrayList<>(each), i + 1, n, k);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 0, nums);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int[] n) {\\n        if (pos <= n.length) {\\n            res.add(each);\\n        }\\n        for (int i = pos; i < n.length; i++) {\\n            each.add(n[i]);\\n            helper(res, new ArrayList<>(each), i + 1, n);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }\\n\\n\\n----------\\nThe idea is use pos to keep track of the index of the array. Compare to other backracking problem like combinations, the condition that each single List adds to the List<List<Integer>> is when the index of the array is valid. Meanwhile, after adding to the List<List<Integer>> , keeping going for the for loop.\\n\\n\\n----------\\nthe following is the combinations I wrote, which is very similar to this problem.\\n\\n        public List<List<Integer>> combine(int n, int k) {\\n        List<List<Integer>> res = new ArrayList<>();\\n        List<Integer> each = new ArrayList<>();\\n        helper(res, each, 1, n, k);\\n        return res;\\n    }\\n    public void helper(List<List<Integer>> res, List<Integer> each, int pos, int n, int k) {\\n        if (each.size() == k) {\\n            res.add(each);\\n            return;\\n        }\\n        for (int i = pos; i <= n; i++) {\\n            each.add(i);\\n            helper(res, new ArrayList<>(each), i + 1, n, k);\\n            each.remove(each.size() - 1);\\n        }\\n        return;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2418147,
                "title": "c-explained-beats-100-optimized-tc-o-2-n",
                "content": "**PLEASE UPVOTE IF YOU FIND MY APPROACH HELPFUL, MEANS A LOT \\uD83D\\uDE0A**\\n\\n**Time complexity: O(2^n)**\\n**Space complexity: O(n)**\\n\\n**Approach:**\\n* Subsets can be determined by trying different combinations, so we will use recursion here.\\n* Case1: exclude the element then include the element.\\n* Case2: include the element then exclude the element.\\n* Either of the cases can be used to solve this problem.\\n\\n**Case1:**\\n```\\nclass Solution {\\nprivate:\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int>>& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        \\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n**Case2:**\\n```\\nclass Solution {\\nprivate:\\n    void subset_finder(vector<int>& nums, int index, vector<int> one_subset, vector<vector<int>> &ans)\\n    {\\n        // base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(one_subset);\\n            return;\\n        }\\n        // take\\n        one_subset.push_back(nums[index]);\\n        subset_finder(nums, index+1, one_subset, ans);\\n        \\n        // not take\\n\\t\\t// backtracking\\n        one_subset.pop_back();\\n        subset_finder(nums, index+1, one_subset, ans);\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> one_subset;\\n        int index = 0;\\n        subset_finder(nums, index, one_subset, ans);\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void solve(vector<int> nums, vector<int> output, int index, vector<vector<int>>& ans) {\\n        //base case\\n        if(index >= nums.size()) {\\n            ans.push_back(output);\\n            return ;\\n        }\\n        \\n        //exclude\\n        solve(nums, output, index+1, ans);\\n        \\n        //include\\n        int element = nums[index];\\n        output.push_back(element);\\n        solve(nums, output, index+1, ans);\\n        \\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        \\n        vector<vector<int> > ans;\\n        vector<int> output;\\n        int index = 0;\\n        solve(nums, output, index, ans);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void subset_finder(vector<int>& nums, int index, vector<int> one_subset, vector<vector<int>> &ans)\\n    {\\n        // base case\\n        if(index>=nums.size())\\n        {\\n            ans.push_back(one_subset);\\n            return;\\n        }\\n        // take\\n        one_subset.push_back(nums[index]);\\n        subset_finder(nums, index+1, one_subset, ans);\\n        \\n        // not take\\n\\t\\t// backtracking\\n        one_subset.pop_back();\\n        subset_finder(nums, index+1, one_subset, ans);\\n    }\\n    \\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> one_subset;\\n        int index = 0;\\n        subset_finder(nums, index, one_subset, ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 489255,
                "title": "javascript-backtracking",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let result = [[]];\\n    \\n    function backtrack(first, current) {\\n    // we iterate over the indexes i from \\'first\\' to the length\\n    //of the entire sequence \\'nums\\'\\n    for (let i = first; i < nums.length; i++) {\\n        current.push(nums[i]);\\n\\n        // use distructure operator to clone \\'current\\' value and save to \\'result\\'\\n        result.push([...current]);\\n\\n        // generate all other subsets for the current subset.\\n        // increasing the position by one to avoid duplicates in \\'result\\'\\n        backtrack(i + 1, current);\\n\\n        // BACKTRACK.\\n        current.pop();\\n    }\\n}\\n    \\n    backtrack(0, []);\\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let result = [[]];\\n    \\n    function backtrack(first, current) {\\n    // we iterate over the indexes i from \\'first\\' to the length\\n    //of the entire sequence \\'nums\\'\\n    for (let i = first; i < nums.length; i++) {\\n        current.push(nums[i]);\\n\\n        // use distructure operator to clone \\'current\\' value and save to \\'result\\'\\n        result.push([...current]);\\n\\n        // generate all other subsets for the current subset.\\n        // increasing the position by one to avoid duplicates in \\'result\\'\\n        backtrack(i + 1, current);\\n\\n        // BACKTRACK.\\n        current.pop();\\n    }\\n}\\n    \\n    backtrack(0, []);\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 827202,
                "title": "best-java-fastest-solution-0ms-100-faster-and-98-3-less-space",
                "content": "\\nits works on concept of taking the item and ignoring the item at each step\\n\\n```\\n public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        generate(nums,0,new ArrayList<>(),ll);\\n        return ll;\\n    }\\n    public void generate(int[] nums,int i,List<Integer> ls,List<List<Integer>> ll){\\n        if(i==nums.length){\\n            ll.add(new ArrayList(ls));\\n            return;\\n        }\\n        generate(nums,i+1,ls,ll);\\n        ls.add(nums[i]);\\n        generate(nums,i+1,ls,ll);\\n        ls.remove(ls.size()-1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\n public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> ll=new ArrayList<>();\\n        generate(nums,0,new ArrayList<>(),ll);\\n        return ll;\\n    }\\n    public void generate(int[] nums,int i,List<Integer> ls,List<List<Integer>> ll){\\n        if(i==nums.length){\\n            ll.add(new ArrayList(ls));\\n            return;\\n        }\\n        generate(nums,i+1,ls,ll);\\n        ls.add(nums[i]);\\n        generate(nums,i+1,ls,ll);\\n        ls.remove(ls.size()-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 159942,
                "title": "python3-backtracking-no-loops-very-easy-to-understand",
                "content": "I\\'m a beginner, so I learned about backtracking from a Stanford lecture on youtube. Most python solutions on here used loops, which initially was hard for me to understand. \\n\\nBasically, the idea here is that you\\'re \"choosing\" an element, running the helper *including* the element (which gets all possible sublists with the \"chosen\" one), then running the helper again *not including* the chosen one.\\n\\n*sidenote*: In the helper, I appended a copy of the aux list. If you pass in the reference, your result will have all empty sublists.\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = []\\n        self.helper(nums, 0, res, [])\\n        return res\\n    \\n    def helper(self, nums, idx, res, aux):\\n        if idx == len(nums):\\n            res.append(aux.copy())\\n            return\\n        aux.append(nums[idx])\\n        self.helper(nums, idx + 1, res, aux)\\n        aux.pop()\\n        self.helper(nums, idx + 1, res, aux)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = []\\n        self.helper(nums, 0, res, [])\\n        return res\\n    \\n    def helper(self, nums, idx, res, aux):\\n        if idx == len(nums):\\n            res.append(aux.copy())\\n            return\\n        aux.append(nums[idx])\\n        self.helper(nums, idx + 1, res, aux)\\n        aux.pop()\\n        self.helper(nums, idx + 1, res, aux)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27604,
                "title": "not-sure-if-this-is-the-best-solution-using-java",
                "content": "    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        Arrays.sort(S);\\n        for(int i = S.length - 1; i >= 0; i--){\\n            int size = res.size() - 1;\\n            for(int j = size; j >= 0; j--){\\n                List<Integer> newList1 = new ArrayList<>();\\n                newList1.add(S[i]);\\n                newList1.addAll(res.get(j));\\n                res.add(newList1);\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "    public List<List<Integer>> subsets(int[] S) {\\n        List<List<Integer>> res = new ArrayList<List<Integer>>();\\n        res.add(new ArrayList<Integer>());\\n        Arrays.sort(S);\\n        for(int i = S.length - 1; i >= 0; i--){\\n            int size = res.size() - 1;\\n            for(int j = size; j >= 0; j--){\\n                List<Integer> newList1 = new ArrayList<>();\\n                newList1.add(S[i]);\\n                newList1.addAll(res.get(j));\\n                res.add(newList1);\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1333022,
                "title": "c-simple-and-short-solution-no-recursion-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 250619,
                "title": "javascript-solution",
                "content": "```\\nvar subsets = function(nums) {\\n    let res = [[]]\\n    for (let i = 0; i < nums.length; ++i) {\\n  \\t\\tlet length = res.length;\\n\\t\\tfor (let j = 0; j < length; ++j) {\\n\\t\\t\\tres.push([...res[j],nums[i]])\\n        }  \\n   }\\n   return res\\n };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar subsets = function(nums) {\\n    let res = [[]]\\n    for (let i = 0; i < nums.length; ++i) {\\n  \\t\\tlet length = res.length;\\n\\t\\tfor (let j = 0; j < length; ++j) {\\n\\t\\t\\tres.push([...res[j],nums[i]])\\n        }  \\n   }\\n   return res\\n };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27522,
                "title": "haven-t-see-dp-solution-here-it-is",
                "content": "\\nFor this question, DP or recursive or backtrack what ever, I think it's almost same thing,but let's do it in a pure DP way:\\n        \\n1 Start from only 1 dig in the list, then result is obvious, [[],[nums[0]]]\\n        \\n2 Than for each new dig, the result is the previous list + previous list append the new dig,\\n          it's easy to understand, since once the new dig come in, there is 2 options, with it or with out it.\\n          without it, is the previous result, with it, it  to add this dig in each array of the previuos result\\n    \\n\\n    def subnets(nums):\\n        nums.sort()\\n        dp={}\\n        dp[0]=[[],[nums[0]] ] \\n        \\n        for i in range(1,len(nums)):\\n            dp[i]=dp[i-1]+[x+[nums[i]] for x in dp[i-1]]\\n        return dp[len(nums)-1]",
                "solutionTags": [],
                "code": "\\nFor this question, DP or recursive or backtrack what ever, I think it's almost same thing,but let's do it in a pure DP way:\\n        \\n1 Start from only 1 dig in the list, then result is obvious, [[],[nums[0]]]\\n        \\n2 Than for each new dig, the result is the previous list + previous list append the new dig,\\n          it's easy to understand, since once the new dig come in, there is 2 options, with it or with out it.\\n          without it, is the previous result, with it, it  to add this dig in each array of the previuos result\\n    \\n\\n    def subnets(nums):\\n        nums.sort()\\n        dp={}\\n        dp[0]=[[],[nums[0]] ] \\n        \\n        for i in range(1,len(nums)):\\n            dp[i]=dp[i-1]+[x+[nums[i]] for x in dp[i-1]]\\n        return dp[len(nums)-1]",
                "codeTag": "Python3"
            },
            {
                "id": 27543,
                "title": "simple-java-solution-using-bit-operations",
                "content": "    public class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n = nums.length;\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        for (int i = 0; i < Math.pow(2, n); i++)\\n        {\\n            List<Integer> subset = new ArrayList<>();\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (((1 << j) & i) != 0)\\n                    subset.add(nums[j]);\\n            }\\n            Collections.sort(subset);\\n            subsets.add(subset);\\n        }\\n        return subsets;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n = nums.length;\\n        List<List<Integer>> subsets = new ArrayList<>();\\n        for (int i = 0; i < Math.pow(2, n); i++)\\n        {\\n            List<Integer> subset = new ArrayList<>();\\n            for (int j = 0; j < n; j++)\\n            {\\n                if (((1 << j) & i) != 0)\\n                    subset.add(nums[j]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1768235,
                "title": "python-recursion-dfs-backtractking-easy-to-understand",
                "content": "**Approach:**\\n1.  If index reaches to the end that means we have covered all the values in the set.\\n2.  We simply leave the value and move to the next position once.\\n3.  We add the value to subSet and then move to next position.\\nFinally, we get powerset with all the unique subsets.\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n, result = len(nums), []\\n        def powerSet(nums, i, subSet): \\n            if i==n:\\n                result.append(subSet) \\n                return \\n            powerSet(nums, i+1, subSet) \\n            powerSet(nums, i+1, subSet + [nums[i]]) \\n        powerSet(nums, 0, [])\\n        return result \\n```\\n**I hope that you\\'ve found this useful.**\\n**In that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**\\nComment below if you have any queries.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n, result = len(nums), []\\n        def powerSet(nums, i, subSet): \\n            if i==n:\\n                result.append(subSet) \\n                return \\n            powerSet(nums, i+1, subSet) \\n            powerSet(nums, i+1, subSet + [nums[i]]) \\n        powerSet(nums, 0, [])\\n        return result \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767500,
                "title": "c-backtracking-recursion-two-approaches",
                "content": "***Brief note about Question-***\\n* We have to return *all possible subsets (the power set).*\\n```\\nLets take an example which is not given in the question-\\nsuppose array is given arr[]: [7,4,5]\\n\\nso, the answer should be \\n[[],[7],[4],[4,7],[5],[5,7],[4,5],[4,5,7]]\\n```\\n________\\n***Solution - I (Backtracking, Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    // it is use to store answer\\n    vector<vector<int>> ans;\\n    \\n    // solve function for generating answer\\n    void solve(int i, vector<int>&arr, vector<int>&temp)\\n    {\\n        if(i == arr.size()) // if index reaches the size of the array \\n        {\\n            //if we find out a possibility, push it into the answer array\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // taking ith element\\n        temp.push_back(arr[i]);\\n        \\n        // call for the next index\\n        solve(i + 1, arr, temp);\\n        \\n        // not taking ith ele,so first pop that already pushed ele, and then call for next index and generating the next possibility\\n        temp.pop_back();\\n        \\n        // calling for next index\\n        solve(i + 1, arr, temp);\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        ans.clear(); // clear global array\\n        \\n        vector<int> temp; // temporary array for generating answer\\n        solve(0, arr, temp); // generating all possibility\\n        \\n        return ans;\\n    }\\n};\\n```\\n__________\\n***Solution - II (Accepted)-***\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // to store answer\\n    \\n    void solve(vector<int> &arr, int i, vector<int> temp)\\n    {\\n        if(i == arr.size()) // if we find out one possibility\\n        {\\n            //push into the final answer that possibility\\n            ans.push_back(temp); \\n            return;\\n        }\\n        \\n        solve(arr, i + 1, temp); // finding possibility for next index\\n        \\n        temp.push_back(arr[i]); // push into the array\\n        \\n        solve(arr, i + 1, temp); //again finding out the next possibility\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n         vector<int> temp; // vector to store temporary answer\\n        \\n        solve(arr, 0, temp); // function that will generate our final answer\\n        \\n        return ans; // return the final answer\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nLets take an example which is not given in the question-\\nsuppose array is given arr[]: [7,4,5]\\n\\nso, the answer should be \\n[[],[7],[4],[4,7],[5],[5,7],[4,5],[4,5,7]]\\n```\n```\\nclass Solution {\\npublic:\\n    // it is use to store answer\\n    vector<vector<int>> ans;\\n    \\n    // solve function for generating answer\\n    void solve(int i, vector<int>&arr, vector<int>&temp)\\n    {\\n        if(i == arr.size()) // if index reaches the size of the array \\n        {\\n            //if we find out a possibility, push it into the answer array\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // taking ith element\\n        temp.push_back(arr[i]);\\n        \\n        // call for the next index\\n        solve(i + 1, arr, temp);\\n        \\n        // not taking ith ele,so first pop that already pushed ele, and then call for next index and generating the next possibility\\n        temp.pop_back();\\n        \\n        // calling for next index\\n        solve(i + 1, arr, temp);\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        ans.clear(); // clear global array\\n        \\n        vector<int> temp; // temporary array for generating answer\\n        solve(0, arr, temp); // generating all possibility\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> ans; // to store answer\\n    \\n    void solve(vector<int> &arr, int i, vector<int> temp)\\n    {\\n        if(i == arr.size()) // if we find out one possibility\\n        {\\n            //push into the final answer that possibility\\n            ans.push_back(temp); \\n            return;\\n        }\\n        \\n        solve(arr, i + 1, temp); // finding possibility for next index\\n        \\n        temp.push_back(arr[i]); // push into the array\\n        \\n        solve(arr, i + 1, temp); //again finding out the next possibility\\n        \\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n         vector<int> temp; // vector to store temporary answer\\n        \\n        solve(arr, 0, temp); // function that will generate our final answer\\n        \\n        return ans; // return the final answer\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651200,
                "title": "c-iterative-generate-next-subset-based-on-previous-subsets",
                "content": "Start with empty subset, and for each of existing subsets, create the copy and add next num to it.\\n\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{        \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tresult.Add(new List<int>());\\n\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tint currentCount = result.Count;\\n\\t\\tfor(int i = 0; i < currentCount; i++)\\n\\t\\t{\\n\\t\\t\\tList<int> subset = result[i].ToList();\\n\\t\\t\\tsubset.Add(num);\\n\\t\\t\\tresult.Add(subset);                \\n\\t\\t}            \\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nUsing bit mask\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{\\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tint size = (int) Math.Pow(2, nums.Length);\\n\\n\\tfor(int i = 0; i < size; i++)\\n\\t{\\n\\t\\tList<int> subset = new List<int>();\\n\\t\\tfor(int j = 0; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsubset.Add(nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.Add(subset);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\\n\\nAlso, recursive solution:\\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{       \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tList<int> currentList = new List<int>();\\n\\thelper(nums, result, currentList, 0);\\n\\treturn result;\\n}\\n\\nprivate void helper(int[] nums, IList<IList<int>> result, List<int> currentList, int start)\\n{\\n\\tresult.Add(currentList.ToList());\\n\\tfor(int i = start; i < nums.Length; i++)\\n\\t{\\n\\t\\tcurrentList.Add(nums[i]); \\n\\t\\thelper(nums, result, currentList, i + 1);\\n\\t\\tcurrentList.RemoveAt(currentList.Count - 1);\\n\\t}\\n} \\n```\\n",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{        \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tresult.Add(new List<int>());\\n\\n\\tforeach(var num in nums)\\n\\t{\\n\\t\\tint currentCount = result.Count;\\n\\t\\tfor(int i = 0; i < currentCount; i++)\\n\\t\\t{\\n\\t\\t\\tList<int> subset = result[i].ToList();\\n\\t\\t\\tsubset.Add(num);\\n\\t\\t\\tresult.Add(subset);                \\n\\t\\t}            \\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{\\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tint size = (int) Math.Pow(2, nums.Length);\\n\\n\\tfor(int i = 0; i < size; i++)\\n\\t{\\n\\t\\tList<int> subset = new List<int>();\\n\\t\\tfor(int j = 0; j < nums.Length; j++)\\n\\t\\t{\\n\\t\\t\\tif((i & (1 << j)) != 0)\\n\\t\\t\\t{\\n\\t\\t\\t\\tsubset.Add(nums[j]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult.Add(subset);\\n\\t}\\n\\n\\treturn result;\\n}\\n```\n```csharp\\npublic IList<IList<int>> Subsets(int[] nums) \\n{       \\n\\tIList<IList<int>> result = new List<IList<int>>();\\n\\tList<int> currentList = new List<int>();\\n\\thelper(nums, result, currentList, 0);\\n\\treturn result;\\n}\\n\\nprivate void helper(int[] nums, IList<IList<int>> result, List<int> currentList, int start)\\n{\\n\\tresult.Add(currentList.ToList());\\n\\tfor(int i = start; i < nums.Length; i++)\\n\\t{\\n\\t\\tcurrentList.Add(nums[i]); \\n\\t\\thelper(nums, result, currentList, i + 1);\\n\\t\\tcurrentList.RemoveAt(currentList.Count - 1);\\n\\t}\\n} \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27466,
                "title": "java-concise-recursive-solution",
                "content": "        \\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(int[] nums, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        ret.add(path);\\n        for (int i = idx; i < nums.length; i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums[i]);\\n            dfs(nums, i+1, p, ret);\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "        \\n    public List<List<Integer>> subsets(int[] nums) {\\n        Arrays.sort(nums);\\n        List<List<Integer>> ret = new ArrayList<>();\\n        dfs(nums, 0, new ArrayList<>(), ret);\\n        return ret;\\n    }\\n    \\n    private void dfs(int[] nums, int idx, List<Integer> path, List<List<Integer>> ret) {\\n        ret.add(path);\\n        for (int i = idx; i < nums.length; i++) {\\n            List<Integer> p = new ArrayList<>(path);\\n            p.add(nums[i]);\\n            dfs(nums, i+1, p, ret);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2216391,
                "title": "python-most-concise-recursive-and-iterative-backtracking-with-explanations",
                "content": "I think that an iterative solution is more intuitive for beginners because you can easily debug it step by step and understand what is going on. \\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        # create list for storing subsets\\n        ans = []\\n        \\n\\t\\t# initialize stack with empty subset and next position equal to 0\\n        stack = [(0,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# retrieve last subset in a stack and its\\' corresponding next position\\n            next_pos, subset = stack.pop()\\n\\t\\t\\t\\n\\t\\t\\t# save current subset\\n            ans.append(subset)\\n            \\n\\t\\t\\t# append each available element starting from next position\\n\\t\\t\\t# to the current subset and append it to the stack increasing next \\n\\t\\t\\t# position by one\\n            for i in range(next_pos,len(nums)):\\n                stack.append((i+1,subset+[nums[i]]))\\n        \\n        return ans\\n```\\nRecursive solution is absolutely the same, but instead of using stack explicitly it uses the call stack.\\n\\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        ans = []\\n        \\n        def dfs(next_pos,subset):\\n            \\n            ans.append(subset)\\n            \\n            for i in range(next_pos,len(nums)):\\n                \\n                dfs(i+1,subset+[nums[i]])\\n        \\n        dfs(0,[])\\n        \\n        return ans\\n```\\nAnd also, to understand all these backtracking problems you should draw it: draw a corresponding tree of choices and you will understand it faster.",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Stack",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        # create list for storing subsets\\n        ans = []\\n        \\n\\t\\t# initialize stack with empty subset and next position equal to 0\\n        stack = [(0,[])]\\n        \\n        while stack:\\n            \\n\\t\\t\\t# retrieve last subset in a stack and its\\' corresponding next position\\n            next_pos, subset = stack.pop()\\n\\t\\t\\t\\n\\t\\t\\t# save current subset\\n            ans.append(subset)\\n            \\n\\t\\t\\t# append each available element starting from next position\\n\\t\\t\\t# to the current subset and append it to the stack increasing next \\n\\t\\t\\t# position by one\\n            for i in range(next_pos,len(nums)):\\n                stack.append((i+1,subset+[nums[i]]))\\n        \\n        return ans\\n```\n```\\ndef subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        ans = []\\n        \\n        def dfs(next_pos,subset):\\n            \\n            ans.append(subset)\\n            \\n            for i in range(next_pos,len(nums)):\\n                \\n                dfs(i+1,subset+[nums[i]])\\n        \\n        dfs(0,[])\\n        \\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1918862,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ max: Int, _ target: Int) {\\n            if target == 0 {\\n                res.append([])\\n                return\\n            }\\n            \\n            if path.count == target {\\n                res.append(path.map({ nums[$0] }))\\n                return\\n            }\\n            \\n            var path = path\\n            \\n            for index in max+1..<nums.count {\\n                path.append(index)\\n                backtrack(path, index, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        for i in 0...nums.count {\\n            backtrack([], -1, i)\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var res: [[Int]] = []\\n\\n\\n        func backtrack(_ path: [Int], _ max: Int, _ target: Int) {\\n            if target == 0 {\\n                res.append([])\\n                return\\n            }\\n            \\n            if path.count == target {\\n                res.append(path.map({ nums[$0] }))\\n                return\\n            }\\n            \\n            var path = path\\n            \\n            for index in max+1..<nums.count {\\n                path.append(index)\\n                backtrack(path, index, target)\\n                path.remove(at: path.count - 1)\\n            }\\n        }\\n        \\n        for i in 0...nums.count {\\n            backtrack([], -1, i)\\n        }\\n        \\n        return res\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 957648,
                "title": "python-4-lines-iterative-recursive-mapping-bits",
                "content": "Iterative\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]        \\n        return subsets\\n```\\nRecursive\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return [[]]\\n        without = self.subsets(nums[1:])\\n        return without + [s + [nums[0]] for s in without]\\n```\\nMapping bits\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = []\\n        for n in range(2**len(nums)):            \\n            subsets.append([nums[i] for i, c in enumerate(bin(n)[:1:-1]) if c == \\'1\\'])\\n        return subsets\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n        for n in nums:\\n            subsets += [s + [n] for s in subsets]        \\n        return subsets\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        if not nums:\\n            return [[]]\\n        without = self.subsets(nums[1:])\\n        return without + [s + [nums[0]] for s in without]\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = []\\n        for n in range(2**len(nums)):            \\n            subsets.append([nums[i] for i, c in enumerate(bin(n)[:1:-1]) if c == \\'1\\'])\\n        return subsets\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27337,
                "title": "simple-fast-and-short-swift-solution-beat-97-3",
                "content": "Add one integer every time. Not only add to ans array, but add a integer to ans array 's element. For example,\\ninput = [1,2,3] \\nAdd a number 1:\\nans = [ [1] ]\\nand add a number 2:\\nans = [ [1], [1,2], [2] ]\\nand add a number 3:\\nans = [ [1], [1,2], [2], [1,3], [1,2,3], [2,3], [3] ]    \\n\\n```\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var ans:[[Int]] = []\\n        for i in 0..<nums.count{\\n            for j in 0..<ans.count{\\n                var temp = ans[j]\\n                temp.append(nums[i])\\n                ans.append(temp)\\n            }\\n            ans.append([nums[i]])\\n        }\\n        ans.append([])\\n        return ans\\n    }",
                "solutionTags": [
                    "Swift"
                ],
                "code": "Add one integer every time. Not only add to ans array, but add a integer to ans array 's element. For example,\\ninput = [1,2,3] \\nAdd a number 1:\\nans = [ [1] ]\\nand add a number 2:\\nans = [ [1], [1,2], [2] ]\\nand add a number 3:\\nans = [ [1], [1,2], [2], [1,3], [1,2,3], [2,3], [3] ]    \\n\\n```\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var ans:[[Int]] = []\\n        for i in 0..<nums.count{\\n            for j in 0..<ans.count{\\n                var temp = ans[j]\\n                temp.append(nums[i])\\n                ans.append(temp)\\n            }\\n            ans.append([nums[i]])\\n        }\\n        ans.append([])\\n        return ans\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27536,
                "title": "4ms-c-solution-using-recursion",
                "content": "    class Solution {\\n    public:\\n    \\tvoid f(vector<int>& temp,vector<vector<int>>&result,int i,vector<int>& nums){\\n    \\t\\tif(i==nums.size()){\\n    \\t\\t\\tresult.push_back(temp);\\n    \\t\\t\\treturn;\\n    \\t\\t}\\n    \\t\\ttemp.push_back(nums[i]);\\n    \\t\\tf(temp,result,i+1,nums);\\n    \\t\\ttemp.pop_back();\\n    \\t\\tf(temp,result,i+1,nums);\\n    \\t\\treturn;\\n    \\t}\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            sort(nums.begin(),nums.end());\\n            vector<int> temp;\\n    \\t\\tvector<vector<int>>result;\\n    \\t\\tf(temp,result,0,nums);\\n    \\t\\treturn result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    \\tvoid f(vector<int>& temp,vector<vector<int>>&result,int i,vector<int>& nums){\\n    \\t\\tif(i==nums.size()){\\n    \\t\\t\\tresult.push_back(temp);\\n    \\t\\t\\treturn;\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 27546,
                "title": "share-my-recursive-solution",
                "content": "I am a big recursive person. And I would like to think everything in a recursive way. \\n\\nFor the case of this problem, using a loop seems definitely to be a more elegant solution. But I would still like to share my recursive solution with you guys.\\n\\nI make recursive call trying to go over the vector from left to right. For each number in vector, it has to options: show in the subset, or not show in the subset. There for each recursive call will generate two more recursive calls. And in the base case, we add the vector to result set. \\n\\nHope you liked my solution.\\n\\n    class Solution {\\n    public:\\n        void subsets_helper(vector<int> tmpVec, vector<vector<int>>& result, vector<int>& S, int level){\\n            if(level==0) result.push_back(tmpVec);\\n            else{\\n                vector<int> newVec0 = tmpVec; newVec0.push_back(S[S.size()-level]);\\n                vector<int> newVec1 = tmpVec;\\n                subsets_helper(newVec0, result, S, level-1);\\n                subsets_helper(newVec1, result, S, level-1);\\n            }\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            vector<vector<int>> result;\\n            vector<int> tmpVec;\\n            subsets_helper(tmpVec, result, S, S.size());\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void subsets_helper(vector<int> tmpVec, vector<vector<int>>& result, vector<int>& S, int level){\\n            if(level==0) result.push_back(tmpVec);\\n            else{\\n                vector<int> newVec0 = tmpVec; newVec0.push_back(S[S.size()-level]);\\n                vector<int> newVec1 = tmpVec;\\n                subsets_helper(newVec0, result, S, level-1);\\n                subsets_helper(newVec1, result, S, level-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3088930,
                "title": "simple-c-using-bitmask-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>temp;\\n           for(int j=0;j<n;j++){\\n              if(i&(1<<j))temp.push_back(arr[j]);\\n           }\\n           ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<vector<int>>ans;\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>temp;\\n           for(int j=0;j<n;j++){\\n              if(i&(1<<j))temp.push_back(arr[j]);\\n           }\\n           ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2739067,
                "title": "python-java-js-c-by-dfs-backtracking-w-demo",
                "content": "[\\u4E2D\\u6587\\u8A73\\u89E3 \\u89E3\\u8AAA\\u5F71\\u7247\\nTutorial video in Chinese](https://www.youtube.com/watch?v=ITwWVCfLgug&t=0s)\\n\\n**Hint**\\n\\nWhen it comes to **subset**, **combination**, **permutation**, **tree path sum**, think of **DFS+backtracking**.\\n\\n\\nTime Complexity: O( n * 2^n )\\nSpace Complexity: O( n * 2^n )\\n\\n\\n---\\n\\nReview of DFS + backtracking template\\n\\n```\\n\\ndef backtrack( parameter ):\\n\\n\\t# Base case handle, aka stop condition\\n\\tif stop condition:\\n\\t\\t# save valid result if needed\\n\\t\\treturn\\n\\t\\t\\n\\t\\n\\t# General cases handle:\\n\\tfor each possible next move/next selection:\\n\\t\\t\\n\\t\\tmake a next move/ select a element\\n\\t\\n\\t\\tbacktrack( updated parameter )\\n\\t\\t\\n\\t\\troll back / undo selection\\n\\t\\t\\n\\treturn\\n```\\n\\n---\\n\\n**Demo of subset generation with input = [1, 2, 3]**\\n\\n<img src=\"https://i.imgur.com/FrdBKKY.png\">\\n\\n---\\n\\n**Python**\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        \\n        all_subset = []\\n        bag = []\\n        \\n        \\n        def makeSubsetFrom( startIndex ):\\n            \\n            # Add current subset into final result\\n            # Note: python object is passing by reference, so we have to make a copy\\n            all_subset.append( bag[::] )\\n            \\n            \\n            ## Base cases aka stop condition:\\n            # No more element\\n            if startIndex == len(nums):\\n                return\\n            \\n            ## General cases\\n            # Current level, we choouse element on index i\\n            for i in range(startIndex, len(nums) ):\\n                \\n                bag.append( nums[i] )           # put this element into bag\\n                makeSubsetFrom( i+1 )           # make subset from remaining elements\\n                bag.pop()                       # undo selection\\n            \\n            return\\n        \\n        #----------------------------------------\\n        makeSubsetFrom( startIndex = 0 )\\n        \\n        return all_subset\\n```\\n\\n---\\n\\n**Java**\\n\\n```\\nclass Solution {\\n    \\n    private List< List<Integer> > allSubset = new ArrayList< List<Integer> >();\\n    private List< Integer > bag = new ArrayList<Integer>();\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        makeSubsetFrom( 0, nums );    \\n    \\n        return allSubset;\\n    }\\n    \\n    private void makeSubsetFrom( int startIndex, int[] nums){\\n        \\n        // Add current subset into final result\\n        // Java object is passing by refernce, so we have to make a copy here\\n        allSubset.add( new ArrayList<Integer>(bag) );\\n\\n\\n        //// Base cases aka stop condition:\\n        // No more element\\n        if( startIndex == nums.length ){\\n            return;\\n        }\\n\\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( int i = startIndex ; i < nums.length ; i++ ){ \\n\\n            bag.add( nums[i] );            // put this element into bag\\n            makeSubsetFrom( i+1, nums );   // make subset from remaining elements\\n            bag.remove( bag.size()-1);     // undo selection\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```\\n\\n---\\n\\n**Javascript**\\n\\n```\\nvar subsets = function(nums) {\\n    \\n    let allSubset = [];\\n    let bag = [];\\n    \\n    \\n    var makeSubsetFrom = function( startIndex ){\\n        \\n        // JS object is passing by referece, so we have to make a copy here\\n        allSubset.push( [...bag] );\\n        \\n        //// Base cases aka stop condition:\\n        // No more element\\n        if ( startIndex == nums.length ){\\n            return;\\n        }\\n        \\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( let i = startIndex ; i < nums.length ; i++){\\n            \\n            bag.push( nums[i] );    // put this element into bag\\n            makeSubsetFrom( i+1 );  // make subset from remaining elements\\n            bag.pop();              // undo selection\\n        }\\n        return;\\n    }\\n    // ---------------------------------\\n    makeSubsetFrom( startIndex = 0 );\\n    return allSubset;\\n    \\n};\\n```\\n\\n---\\n\\n**C++**\\n\\n```\\nclass Solution{\\npublic:\\n    vector< vector<int> > subsets( vector<int>& nums ){\\n    \\n        vector< vector<int> > allSubset;\\n        vector< int > bag;\\n        \\n        \\n        std::function< void(int)> makeSubsetFrom = [&](int startIndex)->void{\\n            \\n            // Add current subset into final result\\n            allSubset.emplace_back( bag );\\n            \\n            \\n            //// Base cases aka stop condition:\\n            // No more element\\n            if( startIndex == nums.size() ){\\n                return;\\n            }\\n            \\n            //// General cases\\n            // Current level, we choouse element on index i\\n            for( int i = startIndex ; i < nums.size() ; i++ ){ \\n                \\n                bag.emplace_back( nums[i] );            // put this element into bag\\n                makeSubsetFrom( i+1 );                  // make subset from remaining elements\\n                bag.pop_back();                         // undo selection\\n            }\\n            return;\\n        };\\n        \\n        //----------------------------------------\\n        makeSubsetFrom( 0 );    \\n    \\n        return allSubset;\\n    }\\n};\\n\\n```\\n\\n---\\n\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\n\\ndef backtrack( parameter ):\\n\\n\\t# Base case handle, aka stop condition\\n\\tif stop condition:\\n\\t\\t# save valid result if needed\\n\\t\\treturn\\n\\t\\t\\n\\t\\n\\t# General cases handle:\\n\\tfor each possible next move/next selection:\\n\\t\\t\\n\\t\\tmake a next move/ select a element\\n\\t\\n\\t\\tbacktrack( updated parameter )\\n\\t\\t\\n\\t\\troll back / undo selection\\n\\t\\t\\n\\treturn\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        \\n        all_subset = []\\n        bag = []\\n        \\n        \\n        def makeSubsetFrom( startIndex ):\\n            \\n            # Add current subset into final result\\n            # Note: python object is passing by reference, so we have to make a copy\\n            all_subset.append( bag[::] )\\n            \\n            \\n            ## Base cases aka stop condition:\\n            # No more element\\n            if startIndex == len(nums):\\n                return\\n            \\n            ## General cases\\n            # Current level, we choouse element on index i\\n            for i in range(startIndex, len(nums) ):\\n                \\n                bag.append( nums[i] )           # put this element into bag\\n                makeSubsetFrom( i+1 )           # make subset from remaining elements\\n                bag.pop()                       # undo selection\\n            \\n            return\\n        \\n        #----------------------------------------\\n        makeSubsetFrom( startIndex = 0 )\\n        \\n        return all_subset\\n```\n```\\nclass Solution {\\n    \\n    private List< List<Integer> > allSubset = new ArrayList< List<Integer> >();\\n    private List< Integer > bag = new ArrayList<Integer>();\\n    \\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        makeSubsetFrom( 0, nums );    \\n    \\n        return allSubset;\\n    }\\n    \\n    private void makeSubsetFrom( int startIndex, int[] nums){\\n        \\n        // Add current subset into final result\\n        // Java object is passing by refernce, so we have to make a copy here\\n        allSubset.add( new ArrayList<Integer>(bag) );\\n\\n\\n        //// Base cases aka stop condition:\\n        // No more element\\n        if( startIndex == nums.length ){\\n            return;\\n        }\\n\\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( int i = startIndex ; i < nums.length ; i++ ){ \\n\\n            bag.add( nums[i] );            // put this element into bag\\n            makeSubsetFrom( i+1, nums );   // make subset from remaining elements\\n            bag.remove( bag.size()-1);     // undo selection\\n        }\\n        return;\\n        \\n    }\\n    \\n}\\n```\n```\\nvar subsets = function(nums) {\\n    \\n    let allSubset = [];\\n    let bag = [];\\n    \\n    \\n    var makeSubsetFrom = function( startIndex ){\\n        \\n        // JS object is passing by referece, so we have to make a copy here\\n        allSubset.push( [...bag] );\\n        \\n        //// Base cases aka stop condition:\\n        // No more element\\n        if ( startIndex == nums.length ){\\n            return;\\n        }\\n        \\n        //// General cases\\n        // Current level, we choouse element on index i\\n        for( let i = startIndex ; i < nums.length ; i++){\\n            \\n            bag.push( nums[i] );    // put this element into bag\\n            makeSubsetFrom( i+1 );  // make subset from remaining elements\\n            bag.pop();              // undo selection\\n        }\\n        return;\\n    }\\n    // ---------------------------------\\n    makeSubsetFrom( startIndex = 0 );\\n    return allSubset;\\n    \\n};\\n```\n```\\nclass Solution{\\npublic:\\n    vector< vector<int> > subsets( vector<int>& nums ){\\n    \\n        vector< vector<int> > allSubset;\\n        vector< int > bag;\\n        \\n        \\n        std::function< void(int)> makeSubsetFrom = [&](int startIndex)->void{\\n            \\n            // Add current subset into final result\\n            allSubset.emplace_back( bag );\\n            \\n            \\n            //// Base cases aka stop condition:\\n            // No more element\\n            if( startIndex == nums.size() ){\\n                return;\\n            }\\n            \\n            //// General cases\\n            // Current level, we choouse element on index i\\n            for( int i = startIndex ; i < nums.size() ; i++ ){ \\n                \\n                bag.emplace_back( nums[i] );            // put this element into bag\\n                makeSubsetFrom( i+1 );                  // make subset from remaining elements\\n                bag.pop_back();                         // undo selection\\n            }\\n            return;\\n        };\\n        \\n        //----------------------------------------\\n        makeSubsetFrom( 0 );    \\n    \\n        return allSubset;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095689,
                "title": "cpp-using-aditya-verma-subset-video-12-recursion-playlist",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >m;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            m.push_back(op);\\n            return;\\n        }\\n        vector<int>op1=op,op2=op;\\n        op1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,op1);\\n        solve(nums,op2);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>op;\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> >m;\\n    void solve(vector<int>nums,vector<int>op)\\n    {\\n        if(nums.size()==0)\\n        {\\n            m.push_back(op);\\n            return;\\n        }\\n        vector<int>op1=op,op2=op;\\n        op1.push_back(nums[0]);\\n        nums.erase(nums.begin()+0);\\n        solve(nums,op1);\\n        solve(nums,op2);\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int>op;\\n        solve(nums,op);\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 803124,
                "title": "simple-python-recursive-and-iterative-solution",
                "content": "Recursive:\\n```\\ndef subsets(self, nums):\\n    res = []\\n    self.generateSubsets(nums, res, [], 0)\\n    return res\\ndef generateSubsets(self, nums, res, curr, index):\\n    res.append(list(curr))\\n    for i in range(index, len(nums)):\\n        curr.append(nums[i])\\n        self.generateSubsets(nums, res, curr, i + 1)\\n        curr.pop()\\n```\\n\\nIterative:\\n```\\ndef subsets(self, nums):\\n        result = [[]]\\n        for num in nums:\\n            size = len(result)\\n            for j in range(size):\\n                subset = list(result[j])                \\n                subset.append(num) # or subset += [num]\\n                result.append(subset) # or result += subset\\n            \\n        return result\\n```\\n\\nI think understanding the recursive and iterative solution for this problem helps understand the concept better.\\n(I know there is a shorter one-line iterative solution for this, but I think writing it out helps to better visualize and understand the algorithm)\\n\\n*Note: we do list(result[j]) to manipulate the copy of result[j] instead of the direct reference to result[j]",
                "solutionTags": [
                    "Python",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\ndef subsets(self, nums):\\n    res = []\\n    self.generateSubsets(nums, res, [], 0)\\n    return res\\ndef generateSubsets(self, nums, res, curr, index):\\n    res.append(list(curr))\\n    for i in range(index, len(nums)):\\n        curr.append(nums[i])\\n        self.generateSubsets(nums, res, curr, i + 1)\\n        curr.pop()\\n```\n```\\ndef subsets(self, nums):\\n        result = [[]]\\n        for num in nums:\\n            size = len(result)\\n            for j in range(size):\\n                subset = list(result[j])                \\n                subset.append(num) # or subset += [num]\\n                result.append(subset) # or result += subset\\n            \\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 332547,
                "title": "java-very-simple-bit-manipulation-solution-time-1ms-space-37-5-mb",
                "content": "```\\n public class Solution {\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < 1 << nums.length; ++i) {\\n            List<Integer> subSet = new ArrayList<>();\\n\\n            for (int b = 0; b < nums.length; ++b) {\\n                if (((i >> b) & 1) == 1) {\\n                    subSet.add(nums[b]);\\n                }\\n            }\\n\\n            result.add(subSet);\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\n\\nExplanation:\\nInput: nums = [1,2,3]\\nOutput:\\n *   [3],       0 0 1\\n *   [1],       1 0 0\\n *   [2],       0 1 0\\n *   [1,2,3],   1 1 1\\n *   [1,3],     1 0 1\\n *   [2,3],     0 1 1\\n *   [1,2],     1 1 0\\n *   []         0 0 0",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n public class Solution {\\n\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> result = new ArrayList<>();\\n\\n        for (int i = 0; i < 1 << nums.length; ++i) {\\n            List<Integer> subSet = new ArrayList<>();\\n\\n            for (int b = 0; b < nums.length; ++b) {\\n                if (((i >> b) & 1) == 1) {\\n                    subSet.add(nums[b]);\\n                }\\n            }\\n\\n            result.add(subSet);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 246941,
                "title": "c-solution-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> dp;\\n        \\n        dp.push_back({});\\n        \\n        for (auto i = 0; i < nums.size(); i++) {\\n            auto size = dp.size();\\n\\n            for (auto j = 0; j < size; j++) {\\n                auto v = dp[j];\\n                v.push_back(nums[i]);\\n                dp.push_back(v);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> dp;\\n        \\n        dp.push_back({});\\n        \\n        for (auto i = 0; i < nums.size(); i++) {\\n            auto size = dp.size();\\n\\n            for (auto j = 0; j < size; j++) {\\n                auto v = dp[j];\\n                v.push_back(nums[i]);\\n                dp.push_back(v);\\n            }\\n        }\\n        return dp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611072,
                "title": "c-3-approach-recursive-bit-manipulation-iterative",
                "content": "# Approach 1: Recusion\\n<!-- Describe your approach to solving the problem. -->\\n# Code \\n```\\nclass Solution {\\npublic:\\n    \\n    void sub(int i,vector<int> &nums, vector<int> &temp,vector<vector<int>>&ans)\\n    {\\n        if(i>=nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // pick\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp,ans);\\n\\n        // not pick\\n        temp.pop_back();\\n        //this pop is necessary because we are passing temp by reference. \\n        //if anything will be picked in above call it will remain in temp if we will not pop it.\\n        sub(nums, i+1, temp,ans);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;       \\n        sub(nums, 0, temp,ans); \\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity:O(N*(2^N))`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity: O(N) + O(N*(2^N)) = O(N*(2^N)) `\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. maximum depth of recusion tree will be N hence recursion stack space is O(N).\\n2. we have to store 2^N subsets in ans each of size O(N)\\n\\n# Video Solution by Striver :\\n[https://youtu.be/AxNNVECce8c]()\\n---\\n\\n\\n# Approach 2: Bit Manipulation (Power Set)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> ans;\\n        // (1<<n) =2^n\\n        for(int subset_num=0; subset_num < (1<<n); subset_num++)\\n        {\\n            vector<int> subset;\\n            for(int i=0;i<n;i++)\\n            {\\n                // if the ith bit is set \\n                if( (subset_num & (1<<i)) )\\n                {\\n                    subset.push_back(nums[i]);\\n                }\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity: O(N*(2^N))`\\n1. 2^N subsets will be generated.\\n2. for each subset number we check N bits (set or not)\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity:  O(N*(2^N)) `\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. we have to store 2^N subsets in ans each of size O(N)\\n\\n# Video Solution by Striver :\\n[https://youtu.be/b7AYbpM5YrE]()\\n---\\n\\n# Approach 3: Iterative\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        int n=nums.size();\\n\\n        output.push_back({});\\n        // initialising the output with an empty subset\\n\\n        for(int i=0; i<n;i++)\\n        {\\n            // for every index i in nums make a copy of all the existing rows in output.\\n            // Then add the ith num to the copy and then push it in output \\n            int size=output.size();\\n            for(int j=0;j<size;j++)\\n            {\\n                vector<int> newRow=output[j]; //O(N)\\n                \\n                newRow.push_back(nums[i]);\\n                output.push_back(newRow);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```\\n# Complexity\\n- `Time complexity: O(N*(2^N))`\\n1. 2^N subsets will be generated.\\n2. while generating each subset we have to copy one of the previous subset:\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- `Space complexity:  O(N*(2^N))` \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n1. we have to store 2^N subsets in ans each of size O(N)\\n",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void sub(int i,vector<int> &nums, vector<int> &temp,vector<vector<int>>&ans)\\n    {\\n        if(i>=nums.size())\\n        {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        \\n        // pick\\n        temp.push_back(nums[i]);\\n        sub(nums, i+1, temp,ans);\\n\\n        // not pick\\n        temp.pop_back();\\n        //this pop is necessary because we are passing temp by reference. \\n        //if anything will be picked in above call it will remain in temp if we will not pop it.\\n        sub(nums, i+1, temp,ans);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> temp;       \\n        sub(nums, 0, temp,ans); \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<vector<int>> ans;\\n        // (1<<n) =2^n\\n        for(int subset_num=0; subset_num < (1<<n); subset_num++)\\n        {\\n            vector<int> subset;\\n            for(int i=0;i<n;i++)\\n            {\\n                // if the ith bit is set \\n                if( (subset_num & (1<<i)) )\\n                {\\n                    subset.push_back(nums[i]);\\n                }\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        int n=nums.size();\\n\\n        output.push_back({});\\n        // initialising the output with an empty subset\\n\\n        for(int i=0; i<n;i++)\\n        {\\n            // for every index i in nums make a copy of all the existing rows in output.\\n            // Then add the ith num to the copy and then push it in output \\n            int size=output.size();\\n            for(int j=0;j<size;j++)\\n            {\\n                vector<int> newRow=output[j]; //O(N)\\n                \\n                newRow.push_back(nums[i]);\\n                output.push_back(newRow);\\n            }\\n        }\\n        return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3252865,
                "title": "python3-using-recursion",
                "content": "\\n# Complexity\\n- Time complexity:\\n2^N\\n\\n- Space complexity:\\n0(N) due to recursive stack\\n\\n# Code\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        def solve(idx,lst):\\n            if idx>=n:\\n                ans.append(lst)\\n                return \\n            solve(idx+1,lst)                    #Not Take\\n            solve(idx+1,lst+[nums[idx]])        #Take\\n        solve(0,[])\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n=len(nums)\\n        ans=[]\\n        def solve(idx,lst):\\n            if idx>=n:\\n                ans.append(lst)\\n                return \\n            solve(idx+1,lst)                    #Not Take\\n            solve(idx+1,lst+[nums[idx]])        #Take\\n        solve(0,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1770171,
                "title": "c-iterative-solution-with-explanation",
                "content": "Kindly **upvote** if you find it helpful **: )**\\n```\\n//Consider nums = [1, 2, 3]\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans = {{}}; //Initialize nums with an empty subset\\n        //In first iteration, adding 1 to []: [[], [1]];\\n        //In second iteration, adding 2 to [] and [1]: [[], [1], [2], [1, 2]];\\n        //In third iteration, adding 3 to [], [1], [2] and [1, 2]: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]];\\n        for (int a : nums) { \\n            int n = ans.size();\\n            for (int i = 0; i < n; i++) {\\n                ans.push_back(ans[i]); //adds existing element of ans to ans\\n                ans.back().push_back(a);//adds nums\\'s element to the back of the ans\\'s element\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\n//Consider nums = [1, 2, 3]\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans = {{}}; //Initialize nums with an empty subset\\n        //In first iteration, adding 1 to []: [[], [1]];\\n        //In second iteration, adding 2 to [] and [1]: [[], [1], [2], [1, 2]];\\n        //In third iteration, adding 3 to [], [1], [2] and [1, 2]: [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]];\\n        for (int a : nums) { \\n            int n = ans.size();\\n            for (int i = 0; i < n; i++) {\\n                ans.push_back(ans[i]); //adds existing element of ans to ans\\n                ans.back().push_back(a);//adds nums\\'s element to the back of the ans\\'s element\\n            }\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766515,
                "title": "easy-python-dp-solution",
                "content": "Keep track of all subsets in an array `dp`. Initially add the empty set. Then iterate through the numbers and add each number to all existing solutions, so all possible subsets are generated.\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            tmp = []\\n            for x in dp:\\n                tmp.append(x + [n])\\n            dp += tmp\\n        return dp\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            tmp = []\\n            for x in dp:\\n                tmp.append(x + [n])\\n            dp += tmp\\n        return dp\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1381418,
                "title": "c-solution-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            ans.push_back(output);   \\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void solve(vector<int>input, vector<int>output){\\n        if(input.size() == 0){\\n            ans.push_back(output);   \\n            return;\\n        }\\n        vector<int>op1 = output, op2 = output;\\n        op1.push_back(input[0]);\\n        input.erase(input.begin() + 0);\\n        solve(input, op1);\\n        solve(input, op2);   \\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        solve(nums, {});\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1195865,
                "title": "c-easy-backtracking-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    \\n    vector <vector <int>> powerSet;\\n    void getSubset(vector<int> &nums, vector<int> subset, int i) {\\n        if (i == nums.size()) {\\n            powerSet.push_back(subset);\\n            return;\\n        }\\n        \\n        // accepting element\\n        subset.push_back(nums[i]);\\n        getSubset(nums, subset, i + 1);\\n        \\n        // rejecting element\\n        subset.pop_back();\\n        getSubset(nums, subset, i + 1);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector <int> subset;\\n        getSubset(nums, subset, 0);\\n        return powerSet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector <vector <int>> powerSet;\\n    void getSubset(vector<int> &nums, vector<int> subset, int i) {\\n        if (i == nums.size()) {\\n            powerSet.push_back(subset);\\n            return;\\n        }\\n        \\n        // accepting element\\n        subset.push_back(nums[i]);\\n        getSubset(nums, subset, i + 1);\\n        \\n        // rejecting element\\n        subset.pop_back();\\n        getSubset(nums, subset, i + 1);\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector <int> subset;\\n        getSubset(nums, subset, 0);\\n        return powerSet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 388568,
                "title": "subsets-i-ii-java-solution-with-detailed-explanation-and-comments-recursion-iteration",
                "content": "Reference: [Subsets I](https://leetcode.com/problems/subsets/) & [Subsets II](https://leetcode.com/problems/subsets-ii/) <span class=\"gray\">EPI 15.5</span>\\nDifficulty: <span class=\"orange\">Medium</span> (I think Subsets II should be hard)\\n\\n\\n\\n## Problem\\n\\n> Given a set of `distinct` integers, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n**Example:** \\n\\n```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\\n\\n**Follow up:** Check out the [Subsets II](#subsets_ii) section below.\\n\\n\\n## Analysis\\n\\nThe power set of a set `S` is the set of all subsets of `S`, including both the empty set `emptyset` and `S` itself. The power set of `{1, 2, 3}` is graphically illustrated as follows.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/mgtg8.jpg)\\n\\n\\n### Backtracking\\n\\nThe idea is that we loop over the number list. For each number, we have two choices: pick it, or not. For example, in `[1, 2, 3]`, we pick `1` and then do the same thing for the subproblem `[2, 3]`; and we don\\'t pick `1` and then do the same thing for the subproblem `[2, 3]`.\\n\\nThe size of subproblems is decreasing. When picking `2`, the subproblem becomes `[3]` instead of `[1, 3]`.\\n\\nConsider the following questions:\\n\\n- What is the base case?\\n- When do we add the list to the result?\\n\\nHere is an illustration of recursive process on `[1, 2, 3]`.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/gfdd3.jpg)\\n\\n\\n**Note:** Remember to add empty set manually.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\\n\\n**Time:** `O(N * 2^N)` since the recurrence is `T(N) = 2T(N - 1)` and we also spend at most `O(N)` time within a call.\\n**Space:** `O(N * 2^N)` since there are `2^N` subsets. If we only print the result, we just need `O(N)` space.\\n\\n\\n### Iteration\\n\\nThe idea is simple. We go through the elements in the `nums` list. For each element, we loop over the current `result` list we have constructed so far. For each list in the `result`, we make a copy of this list and append the current element to it (it means picking the element). It is based on the same idea in backtracking (in each step you have choices: `pick` or `not pick`).\\n\\nThe result list initially contains an empty list `[]`. We loop over each element of `nums`, e.g. `[1, 2, 3]`.\\n\\n- After the first round, we have `[[], [1]]`.\\n- After the second round, we have `[[], [1], [2], [1,2]]`.\\n- After the third round, we have `[[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]`.\\n\\nFirst, let\\'s go over an incorrect version. There are two errors:\\n\\n1. We add a new element to `L`, but it changes the existed `L`. Thus, we should make a new copy of it.\\n2. While looping over `result`, we are modifying its size. In Java, the compiler would yell.\\n\\n**Incorrect version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\\n\\n**Correct version:**\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- The outer loop takes `O(N)` time.\\n- The inner loop takes `2, 4, 8, ..., 2^N` time respectively.\\n- In inner loop, making a new copy of `L` takes at most `O(N)` time.\\n- Total runtime `T(N) = N * (2 + 4 + 8 + ... + 2^N) ~= N * 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n### K-Size Subsets\\n\\nActually, we can use the code in [77. Combinations](https://www.junhaow.com/lc/problems/backtracking/77_combinations.html) to solve this problem.\\n\\n\\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n- `C(0, N) + C(1, N) + C(2, N) + C(3, N) + ... + C(N, N) = 2^N`\\n\\n**Space:** `O(N * 2^N)`\\n\\n\\n## Subsets II\\n\\nReference:\\n\\n- [[Java] Two Way of Recursive thinking](https://leetcode.com/problems/subsets-ii/discuss/169226/Java-Two-Way-of-Recursive-thinking)\\n- [Simple iterative solution](https://leetcode.com/problems/subsets-ii/discuss/30137/Simple-iterative-solution)\\n\\n> Given a collection of integers that might **contain duplicates**, `nums`, return all possible subsets (the power set).\\n\\n**Note:** The solution set must not contain duplicate subsets.\\n\\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\\n\\n### Backtracking\\n\\nWe need to know when we **should not** add a list to the result list.\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/wek92.jpg)\\n\\nBy observation, a duplicate list occurs when `offset >= 1` (when `offset = 0`, duplicate cannot occur) and `nums[offset - 1] == nums[offset]` and in the previous step we did not pick `nums[offset - 1]`. The information of whether it picks or not could be passed down by a **boolean parameter** `isPicked`.\\n \\nIf the above condition is satisfied:\\n- Do not add the list to the result list.\\n- Do not do the subproblem after picking the current element.\\n- Only do the subproblem after not picking the current element.\\n\\n**Note:** Be careful where we should put the `numList.add(val)` and `numList.remove(numList.size() - 1)`.\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\\n\\nAnother version (similar): \\n\\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n### Iteration\\n\\nUsing the same idea in backtracking, we need to figure out when we should add a list to the result list. Check out three examples below (`[1,2,3]`, `[1,2,2]`, `[5,5,5]`).\\n\\n![](https://bloggg-1254259681.cos.na-siliconvalley.myqcloud.com/y0inx.jpg)\\n\\nBy observation, we learn that we should start from, if duplicate is detected, a specific location in the result list. In Subsets I, we always start from $0$.\\n\\nInterestingly, the specific location corresponds to the initial size of the result list in the previous round. Since we change the result list in each round, we should cache the size of the result list as `cachedSize`.\\n\\nThen we denote the starting index as `startIdx`. In each round, similar to what we\\'ve done in Subsets I, we set `startIdx` as:\\n\\n- `0` (no duplicate or `i == 0`)\\n- `cachedSize` (duplicate occurs)\\n\\nAfter setting `startIdx`, remember to do the caching job for the current size of the result list. Notice a fact that this cached size may not be used in the next round.\\n\\n\\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\\n\\n**Time:** `O(N * 2^N)`\\n**Space:** `O(N * 2^N)`\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```java\\nInput: nums = [1,2,3]\\nOutput: [\\n  [3],\\n  [1],\\n  [2],\\n  [1,2,3],\\n  [1,3],\\n  [2,3],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  result.add(new ArrayList<>()); // empty set\\n  subsets(0, nums, numList, result);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result);\\n  // add to result\\n  result.add(new ArrayList<>(numList));\\n  // not pick\\n  numList.remove(numList.size() - 1);\\n  subsets(offset + 1, nums, numList, result);\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    for (List<Integer> L : result) {\\n      L.add(nums[i]);\\n      result.add(L);\\n    }\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>(); // used for new lists\\n    for (List<Integer> L : result) {\\n      L = new ArrayList<>(L); // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```\n```java\\npublic List<List<Integer>> subsets(int[] nums) {\\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  \\n  int n = nums.length;\\n  for (int k = 0; k <= n; ++k) { // compatible with empty set\\n    combine(n, k, 1, nums, numList, result);\\n  }\\n  return result;\\n}\\n\\nprivate void combine(int n, int k, int d, int[] nums, List<Integer> numList, List<List<Integer>> result) {\\n  // base case (in order to handle empty set, ordering of two IFs matters)\\n  if (numList.size() == k) { // get a result\\n    result.add(new ArrayList<>(numList));\\n    return;\\n  }\\n  if (n - d + 1 < k - numList.size()) { // remaining elements are not enough\\n    return;\\n  }\\n\\n  for (int i = d; i <= n; ++i) {\\n    int val = nums[i - 1];\\n    numList.add(val);\\n    combine(n, k, i + 1, nums, numList, result);\\n    numList.remove(numList.size() - 1); // remove the last\\n  }\\n}\\n```\n```java\\nInput: [1,2,2]\\nOutput: [\\n  [2],\\n  [1],\\n  [1,2,2],\\n  [2,2],\\n  [1,2],\\n  []\\n]\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sorting\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  List<Integer> numList = new ArrayList<>();\\n  result.add(new ArrayList<>());\\n  subsets(0, nums, numList, result, true);\\n  return result;\\n}\\n\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // duplicate checking (convert && to ||)\\n  if (offset == 0 || nums[offset - 1] != nums[offset] || isPicked == true) {\\n    // pick\\n    numList.add(val);\\n    subsets(offset + 1, nums, numList, result, true);\\n    result.add(new ArrayList<>(numList));  // add to the result list\\n    numList.remove(numList.size() - 1);\\n  }\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n}\\n```\n```java\\nprivate void subsets(int offset, int[] nums, List<Integer> numList, List<List<Integer>> result, boolean isPicked) {\\n  // base case\\n  if (offset >= nums.length) {\\n    return;\\n  }\\n  int val = nums[offset];\\n  // not pick\\n  subsets(offset + 1, nums, numList, result, false);\\n  // duplicate check\\n  if (offset >= 1 && nums[offset - 1] == nums[offset] && isPicked == false) {\\n    return;\\n  }\\n  // pick\\n  numList.add(val);\\n  subsets(offset + 1, nums, numList, result, true);\\n  result.add(new ArrayList<>(numList));  // add to the result list\\n  numList.remove(numList.size() - 1); \\n}\\n```\n```java\\npublic List<List<Integer>> subsetsWithDup(int[] nums) {\\n  // sort\\n  Arrays.sort(nums);\\n  \\n  List<List<Integer>> result = new ArrayList<>();\\n  result.add(new ArrayList<>());  // empty set\\n  \\n  int cachedSize = 0, startIdx = 0;\\n  for (int i = 0; i < nums.length; ++i) {\\n    List<List<Integer>> newResult = new ArrayList<>();  // used for new lists\\n    // set startIdx first before we update cachedSize\\n    startIdx = (i > 0 && nums[i - 1] == nums[i]) ? cachedSize : 0; // if duplicate occurs\\n    cachedSize = result.size(); // cache the size for startIdx in the next round\\n    for (int j = startIdx; j < result.size(); ++j) {\\n      List<Integer> L = result.get(j);\\n      L = new ArrayList<>(L);  // copy\\n      L.add(nums[i]);\\n      newResult.add(L);\\n    }\\n    result.addAll(newResult);  // concatenate\\n  }\\n  return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 363804,
                "title": "python-4-ms-beats-100-00-the-shortest-solution-ever-image-explanation",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res, path = [], []\\n        def inner(nums, path, res):\\n            for i, el in enumerate(nums):\\n                inner(nums[i+1:], path + [el], res)\\n            res.append(path)\\n        inner(nums, path, res)\\n        return res\\n```\\nIllustration for recursion tree in case of nums = [1, 2, 3]\\n![image](https://assets.leetcode.com/users/deniskoder/image_1566992853.png)",
                "solutionTags": [
                    "Python",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res, path = [], []\\n        def inner(nums, path, res):\\n            for i, el in enumerate(nums):\\n                inner(nums[i+1:], path + [el], res)\\n            res.append(path)\\n        inner(nums, path, res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226217,
                "title": "java-super-simple-8-lines-iterative-1-ms-beats-100",
                "content": "I\\'ve seen all sorts of long and complicated solutions to this problem, with backtracking and recursion and bit manipulation and other stuff.  But it\\'s a pretty simple problem.  Each element of nums is either in, or not in, each subset.  So we can start with the empty set, and then just iteratively build up the solution by simply adding each element.\\n```\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> powerSet = new ArrayList<List<Integer>>( 1<<nums.length );\\n        powerSet.add( new ArrayList<Integer>() );\\n        \\n        for( int num: nums )\\n            for( int i=0, j=powerSet.size(); i<j; i++ ) {\\n                List<Integer> withNum = new ArrayList<Integer>( powerSet.get(i) );\\n                withNum.add( num );\\n                powerSet.add( withNum );\\n            }\\n        \\n        return powerSet;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> powerSet = new ArrayList<List<Integer>>( 1<<nums.length );\\n        powerSet.add( new ArrayList<Integer>() );\\n        \\n        for( int num: nums )\\n            for( int i=0, j=powerSet.size(); i<j; i++ ) {\\n                List<Integer> withNum = new ArrayList<Integer>( powerSet.get(i) );\\n                withNum.add( num );\\n                powerSet.add( withNum );\\n            }\\n        \\n        return powerSet;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 216279,
                "title": "python-solution",
                "content": "Recursive algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j - i == 1:\\n                return [[], [nums[i]]]\\n            head = nums[i]\\n            res = helper(nums, i+1, j)\\n            for i in range(len(res)):\\n                res.append(res[i]+[head])\\n            return res\\n        \\n        return helper(nums, 0, len(nums))\\n```\\n\\nIterative algorithm. Time complexity: `O(2^n)`, space complexity: `O(2^n)`.\\n\\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i]+[n])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        def helper(nums, i, j):\\n            if i > j:\\n                return [[]]\\n            if j - i == 1:\\n                return [[], [nums[i]]]\\n            head = nums[i]\\n            res = helper(nums, i+1, j)\\n            for i in range(len(res)):\\n                res.append(res[i]+[head])\\n            return res\\n        \\n        return helper(nums, 0, len(nums))\\n```\n```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for n in nums:\\n            for i in range(len(res)):\\n                res.append(res[i]+[n])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27520,
                "title": "three-ways-to-do-this-c",
                "content": "1. Clone the lists when process each num.\\n-----------------------------------------\\n\\nAt beginning, there is only one empty list. <br>\\n**{{}}**<br>\\nWhen we process the first num( use 1 to represent), clone all the existing list, for the cloned list, add the cur num to the list.  . Add all the cloned list to the result.<br>\\n**{{},{1}}**<br>\\nwhen we process the second num( use 2 to represent), again clone all existing list, and add cur num to the cloned list. Add all the cloned list to the result.<br>\\n**{{},{1},{2},{1,2}}**<br>\\n\\ndo this until n. \\n\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        IList<IList<int>> res = new List<IList<int>>();\\n        res.Add(new List<int>());\\n        if( nums == null || nums.Length == 0 ) return res;\\n        \\n        for( int i = 0; i < nums.Length; ++i )\\n        {\\n            int count = res.Count;\\n            for( int j = 0; j < count; ++j )\\n            {\\n                List<int> newList = new List<int>( res[j] );\\n                newList.Add( nums[i] );\\n                res.Add(newList);\\n            }\\n            \\n        }\\n        return res;\\n    }\\n\\n\\n2.Bit manipulation\\n------------------\\ngo from 0 to Pow(2, nums.Length) <br>\\n0 -> 0000  -> {}<br>\\n1 -> 0001  -> {1}  // {1} means the list contains the first num in the array nums<br>\\n2 -> 0010  -> {2}<br>\\n3 -> 0011  -> {2,1}<br>\\n.....<br>\\nPow(2, nums.Length) -> ......<br>\\nAdd all above list to the result.<br>\\n\\n\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> result = new List<IList<int>>();\\n        \\n        int max =  (int)Math.Pow(2, nums.Length);\\n        for( int counter = 0; counter < max; ++counter )\\n        {\\n           IList<int> subSet = new List<int>();\\n           int mark = 1;\\n           for( int j = 0; j < nums.Length; ++j ) \\n           {\\n               if( (mark & counter) != 0 )\\n               {\\n                  subSet.Add(nums[j]); \\n               }\\n               mark <<= 1;\\n           }\\n           \\n           result.Add(subSet);\\n        } \\n        \\n        return result;\\n        \\n    }\\n\\n\\n3. Back tracking\\n----------------\\nWhen process each num, there're two choice, add or do not add. If add, a back track is needed.<br>\\n\\n    public class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> res = new List<IList<int>>();\\n        IList<int> list = new List<int>();\\n        \\n        Subset(res, list, nums, 0);\\n        \\n        return res;\\n    }\\n    \\n    private void Subset( IList<IList<int>> res, IList<int> list, int[] nums, int index )\\n    {\\n       if( index == nums.Length ) \\n       {\\n           res.Add(new List<int>(list));\\n           return;\\n       }\\n       \\n       int count = list.Count;\\n       Subset( res, list, nums,index +1 );\\n      \\n       list.Add( nums[index] );\\n       Subset( res, list, nums,index +1 );\\n       list.RemoveAt( list.Count -1 );\\n       \\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) \\n    {\\n        Array.Sort(nums);\\n        \\n        IList<IList<int>> res = new List<IList<int>>();\\n        IList<int> list = new List<int>();\\n        \\n        Subset(res, list, nums, 0);\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 27560,
                "title": "1-3-lines-ruby-solutions",
                "content": "**Solution 1**\\n\\n    def subsets(nums)\\n      (0..nums.size).flat_map{ |k| nums.combination(k).to_a }\\n    end\\n\\n**Solution 2**\\n\\n    def subsets(nums)\\n      subsets = [[]]\\n      nums.each { |n| subsets += subsets.map { |s| s + [n] } }\\n      subsets\\n    end\\n\\n**Solution 3**\\n\\n    def subsets(nums)\\n      nums.reduce([[]]) { |subsets, n| subsets + subsets.map { |s| s + [n] } }\\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "**Solution 1**\\n\\n    def subsets(nums)\\n      (0..nums.size).flat_map{ |k| nums.combination(k).to_a }\\n    end\\n\\n**Solution 2**\\n\\n    def subsets(nums)\\n      subsets = [[]]\\n      nums.each { |n| subsets += subsets.map { |s| s + [n] } }\\n      subsets\\n    end\\n\\n**Solution 3**\\n\\n    def subsets(nums)\\n      nums.reduce([[]]) { |subsets, n| subsets + subsets.map { |s| s + [n] } }\\n    end",
                "codeTag": "Python3"
            },
            {
                "id": 27582,
                "title": "java-recursion-solution",
                "content": "    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            List<Integer> subset = new ArrayList<Integer>();\\n            res.add(subset);\\n            \\n            Arrays.sort(nums);\\n            doSubsets(nums,res,subset,0);\\n            return res;\\n        }\\n        \\n        private void doSubsets(int[] nums, List res,List subset,int start){\\n            if(start != nums.length){\\n                for(int i=start; i<nums.length; i++){\\n                    subset.add(nums[i]);\\n                    res.add(new ArrayList(subset));\\n                    doSubsets(nums,res,subset,i+1);\\n                    subset.remove(subset.get(subset.size()-1));\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> res = new ArrayList<List<Integer>>();\\n            List<Integer> subset = new ArrayList<Integer>();\\n            res.add(subset);\\n            \\n            Arrays.sort(nums);\\n            doSubsets(nums,res,subset,0);\\n            return res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3509457,
                "title": "c-recursive-solution-100-beat-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    void subsetsum(int index, vector<int>& nums, vector<int>& subset, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[index]);\\n        subsetsum(index + 1, nums, subset, result);\\n        subset.pop_back();\\n        subsetsum(index + 1, nums, subset, result);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> subset;\\n        vector<vector<int>> result;\\n        subsetsum(0, nums, subset, result);\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void subsetsum(int index, vector<int>& nums, vector<int>& subset, vector<vector<int>>& result) {\\n        if (index == nums.size()) {\\n            result.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[index]);\\n        subsetsum(index + 1, nums, subset, result);\\n        subset.pop_back();\\n        subsetsum(index + 1, nums, subset, result);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<int> subset;\\n        vector<vector<int>> result;\\n        subsetsum(0, nums, subset, result);\\n        return result;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342430,
                "title": "using-bit-manipulation-power-set-concept-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFor each element we need to take two decisions. Either to **take it or not to take it**, this is how we can create all the subsets.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf an array is of \\'n\\' size, then it must have \\'2^n\\' subsets. \\n- So, the outer loop is running till \\'2^n\\' (same as 1<<n).\\n- We need to take decision(take or not take) for each element. As there are \\'n\\' elements in the array, the inner loop is running \\'n\\' times.\\n- In the inner loop **if (1<<j)&i is giving a set bit** then jth element is taken in the subset, otherwise it is not taken.\\n- at the end of the inner loop the subset is inserted in ans (**vector of vectors**) ans.\\n- At the end of the Outer loop ans is returned.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n^2) \\n\\nIf you find it helpful then please upvote\\u2B06\\uFE0F\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>v;\\n            for(int j=0;j<n;j++){\\n                if((1<<j)&i){\\n                    v.push_back(nums[j]);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n=nums.size();\\n        for(int i=0;i<(1<<n);i++){\\n            vector<int>v;\\n            for(int j=0;j<n;j++){\\n                if((1<<j)&i){\\n                    v.push_back(nums[j]);\\n                }\\n            }\\n            ans.push_back(v);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209304,
                "title": "best-c-solution-ever-easy-solution-backtracking-one-stop-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this problem using Array + Backtracking\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand the approach by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time complexity is O(2^N).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so total space complexity is O(2^N*N).\\n\\n# Code\\n```\\n/*\\n\\n    Time complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time\\n    complexity is O(2^N).\\n\\n    Space complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so\\n    total space complexity is O(2^N*N).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> &nums, vector<vector<int>> &output, vector<int>&temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n        temp.pop_back();\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> nums, vector<vector<int>> &output, vector<int> temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```\\n\\n***IF YOU LIKE THE SOLUTION THEN PLEASE UPVOTE MY SOLUTION BECAUSE IT GIVES ME MOTIVATION TO REGULARLY POST THE SOLUTION.***\\n\\n![WhatsApp Image 2023-02-10 at 19.01.02.jpeg](https://assets.leetcode.com/users/images/0a95fea4-64f4-4502-82aa-41db6d77c05c_1676054939.8270252.jpeg)",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Backtracking"
                ],
                "code": "```\\n/*\\n\\n    Time complexity : O(2^N), For every index, we make 2 recursion calls and there are N elements so total time\\n    complexity is O(2^N).\\n\\n    Space complexity : O(2^N*N), There are 2^N-1 subsets and for every subset, we need O(N) space on average so\\n    total space complexity is O(2^N*N).\\n\\n*/\\n\\n\\n/***************************************** Approach 1 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> &nums, vector<vector<int>> &output, vector<int>&temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n        temp.pop_back();\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/***************************************** Approach 2 *****************************************/\\n\\nclass Solution {\\nprivate: \\n    void subsets(vector<int> nums, vector<vector<int>> &output, vector<int> temp, int index){\\n        if(nums.size() == index){\\n            output.push_back(temp);\\n            return;\\n        }\\n        // Exclude Element\\n        subsets(nums, output, temp, index+1);\\n        // Include Element\\n        temp.push_back(nums[index]);\\n        subsets(nums, output, temp, index+1);\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> output;\\n        vector<int> temp;\\n        subsets(nums, output, temp, 0);\\n        return output;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088993,
                "title": "beats-100-simple-c-back-tracking-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple try to generate all the subseqeunces of array and backtrack.\\nSimply in each backtraking problem three steps are there :\\n- Choose \\n- Explore\\n- Unchoose\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Pick a starting point.\\n- while problem is not solved\\n  -  For each path from the starting point\\n      make recursive call to rest of the problem\\n        before which we undo the current move.\\n \\n- Keep adding the answer in ans vector generated at each recursive call.\\n\\n# Complexity\\n- Time complexity:$$O(n*2^n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*2^n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,vector<int>&temp){\\n        ans.push_back(temp);\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i+1,temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>temp;\\n        backtrack(arr,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>ans;\\n    void backtrack(vector<int>&arr,int start,vector<int>&temp){\\n        ans.push_back(temp);\\n        for(int i=start;i<arr.size();i++){\\n            temp.push_back(arr[i]);\\n            backtrack(arr,i+1,temp);\\n            temp.pop_back();\\n        }\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        int n=arr.size();\\n        vector<int>temp;\\n        backtrack(arr,0,temp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2217980,
                "title": "go-bfs",
                "content": "```\\nfunc subsets(nums []int) [][]int {\\n    var queue [][]int\\n    queue = append(queue, []int{})\\n    \\n    for i := 0; i < len(nums); i++ {\\n        length := len(queue)\\n        \\n        for j := 0; j < length; j++ {\\n            item := queue[j]\\n            \\n            tmp := make([]int, len(item))\\n            copy(tmp, item)\\n            tmp = append(tmp, nums[i])\\n            \\n            queue = append(queue, tmp)\\n        }\\n    }\\n    \\n    return queue\\n}\\n\\n```",
                "solutionTags": [
                    "Go",
                    "Breadth-First Search"
                ],
                "code": "```\\nfunc subsets(nums []int) [][]int {\\n    var queue [][]int\\n    queue = append(queue, []int{})\\n    \\n    for i := 0; i < len(nums); i++ {\\n        length := len(queue)\\n        \\n        for j := 0; j < length; j++ {\\n            item := queue[j]\\n            \\n            tmp := make([]int, len(item))\\n            copy(tmp, item)\\n            tmp = append(tmp, nums[i])\\n            \\n            queue = append(queue, tmp)\\n        }\\n    }\\n    \\n    return queue\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1697053,
                "title": "bit-manipulation-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        \\n        int n=nums.size();\\n        int setSize = 1<<n;   // 2^n Number of subset ;\\n        \\n        for(int i=0;i<setSize;i++){\\n            \\n            vector<int>temp;   // for storing values in subsets\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(i & (1<<j)){ //Checking for set bits in number i;\\n                temp.push_back(nums[j]);   // Push the value which is at founded index of setbit \\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\nHow to check if ith bit is set or not of number num i.e. (num & 1<<(i-1))\\n\\n We have to check if ith bit is set or not\\n \\n Step 1 : Take number 1 \\n Step 2 : Left shift this to i-1 times so the number becomes 10000 (like this)\\n Step 3 : DO Bitwise And  with num to check if the ith bit is set or not\\n \\n For Example : \\n      Let\\'s Have number 9 \\n\\t  Its Binary representation is 1001\\n\\t  if we have to check is 4th bit\\n\\t  \\n\\t  According to steps take 1 and left shift it 3 times so Number is 1000\\n\\t  Now \\n\\t   1001\\n\\t&1000\\n\\tResults 1000 that is not zero which means that 4th bit is set.\\n\\t\\n\\tHere is picture how to algorithm works :\\n\\t\\n![image](https://assets.leetcode.com/users/images/197bb06c-5c6b-4bb0-a37f-6701c6b2026d_1642422912.8045533.jpeg)\\n\\n\\n\\n\\t\\n\\tThanks",
                "solutionTags": [
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>ans;\\n        \\n        int n=nums.size();\\n        int setSize = 1<<n;   // 2^n Number of subset ;\\n        \\n        for(int i=0;i<setSize;i++){\\n            \\n            vector<int>temp;   // for storing values in subsets\\n            \\n            for(int j=0;j<n;j++){\\n                \\n                if(i & (1<<j)){ //Checking for set bits in number i;\\n                temp.push_back(nums[j]);   // Push the value which is at founded index of setbit \\n                }\\n            }\\n            ans.push_back(temp);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1628820,
                "title": "78-subsets-c-solution-2-approaches-full-explaination",
                "content": "**Please upvote if you like the solution and any improvements or suggestion are welcomed in the comments.**\\n**Problem Statement:** Given an integer array nums of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.\\n## Approach 1: Using Optimal Substructure\\n**Intuition:** \\nIf we know all the subsets of vector of size n, so, we know the solution for nums[1..n-1]\\nEg - n=3 nums[1,2,3]\\n`Subsets for [1, 2] => {[],[1],[2],[1,2]}`\\nNow, as you can see on adding one more element 3 in above set, \\n* all  the subsets of nums[1..n-1] are also subsets of nums[1..n], so copy them\\n* in all subsets of nums[n-1] add one more element at the end and it will create the subsets resulted by adding the last element\\nSo,\\n```\\nsubsets of [1,2,3]= { [] , [1] , [2] , [1,2] } + { []+[3] , [1] + [3] , [2] + [3] , [1,2] + [3] }\\n                    |  subsets of [1,2]        |   new subsets due to element 3                 | \\n\\t\\t\\t\\t\\t={ [],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]}\\n```\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Subsets.\\nMemory Usage: 7.3 MB, less than 37.30% of C++ online submissions for Subsets\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> superset={{},{nums[0]}};\\n        for(int i=1;i<nums.size();i++){\\n           vector<vector<int>> curr=superset;\\n            for(auto vec : curr){\\n                vec.push_back(nums[i]);\\n                superset.push_back(vec);\\n            }\\n        }\\n        return superset;\\n    }\\n};\\n```\\n**Time Complexity=O(n*2^n)**\\n## Approach 2: Bit Manipulation\\nIntuition-\\nFor set of size n, we know there are 2^n subsets.  So, each element is represented by a bit of N (=2^n)\\nfor i=0 to 2^n-1\\n    select the elements from array whose bit is set\\nExample-\\nFor n=3, there will be N=2^3 = 8 subsets.\\nrepresenting i as 3 bits\\ni=0 => [000] => []\\ni=1 => [00**1**] => [1]\\ni=2 => [0**1**0] => [2]\\ni=3 => [0**11**] => [1,2]\\ni=4 => [**1**00] => [3]\\ni=5 => [**1**0**1**] => [1,3]\\ni=6 => [**11**0] => [2,3]\\ni=7 => [**111**] => [1,2,3]\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            for(int i=0; i < temp.size(); i++)\\n            cout<<temp[i]<<\" \";\\n            cout<<\"\\\\n\";\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Time Complexity=O(n*2^n)**",
                "solutionTags": [
                    "C",
                    "Bit Manipulation"
                ],
                "code": "```\\nsubsets of [1,2,3]= { [] , [1] , [2] , [1,2] } + { []+[3] , [1] + [3] , [2] + [3] , [1,2] + [3] }\\n                    |  subsets of [1,2]        |   new subsets due to element 3                 | \\n\\t\\t\\t\\t\\t={ [],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> superset={{},{nums[0]}};\\n        for(int i=1;i<nums.size();i++){\\n           vector<vector<int>> curr=superset;\\n            for(auto vec : curr){\\n                vec.push_back(nums[i]);\\n                superset.push_back(vec);\\n            }\\n        }\\n        return superset;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        int n = nums.size();\\n        int num = pow(2, n), i = 0;\\n        \\n        while(i<num)\\n        {\\n            vector<int> temp;\\n            for(int j=0; j<n; j++)\\n            {\\n                if(i & 1<<j)\\n                    temp.push_back(nums[j]);\\n            }\\n            for(int i=0; i < temp.size(); i++)\\n            cout<<temp[i]<<\" \";\\n            cout<<\"\\\\n\";\\n            ans.push_back(temp);\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1207948,
                "title": "c-78-backtrack-approach",
                "content": "class Solution {\\npublic:\\n    \\n    int n;\\n    vector<vector<int>> ans;\\n    vector<int> eachpair;\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n = nums.size();\\n        backtrack(0, nums);\\n        \\n        return ans;\\n    }\\n    \\n    void backtrack(int index, vector<int>& nums){\\n        if(index == n){\\n            ans.push_back(eachpair);\\n        }\\n        else{\\n            eachpair.push_back(nums[index]);\\n            backtrack(index+1, nums);\\n            eachpair.pop_back();\\n            backtrack(index+1, nums);\\n        }\\n    }\\n    \\n};\\n\\n![image](https://assets.leetcode.com/users/images/25b23cc5-74c9-45a8-aa6f-a274810c588b_1620993522.5976417.jpeg)\\n",
                "solutionTags": [
                    "C",
                    "Backtracking"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    int n;\\n    vector<vector<int>> ans;\\n    vector<int> eachpair;\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n = nums.size();\\n        backtrack(0, nums);\\n        \\n        return ans;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 348032,
                "title": "swift-one-line-solution",
                "content": "```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n        return nums.reduce([[]]){result, num in\\n              result + result.map{$0 + [num]}\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc subsets(_ nums: [Int]) -> [[Int]] {\\n        return nums.reduce([[]]){result, num in\\n              result + result.map{$0 + [num]}\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27324,
                "title": "simple-c-using-recursion-and-a-template-to-solve-similar-problems",
                "content": "Actually there is a template to those combination problems, you can refer to this post I wrote: [A template to those combination problems](https://discuss.leetcode.com/topic/97538/a-template-to-those-combination-problems).\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        backtrack(nums, 0, vector<int>(), res);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<int>& nums, int k, vector<int> subset, vector<vector<int>>& res){\\n        if(k == nums.size()){\\n            res.push_back(subset);\\n            return;\\n        }\\n        backtrack(nums, k+1, subset, res);\\n        subset.push_back(nums[k]);\\n        backtrack(nums, k+1, subset, res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>res;\\n        backtrack(nums, 0, vector<int>(), res);\\n        return res;\\n    }\\n    \\n    void backtrack(vector<int>& nums, int k, vector<int> subset, vector<vector<int>>& res){\\n        if(k == nums.size()){\\n            res.push_back(subset);\\n            return;\\n        }\\n        backtrack(nums, k+1, subset, res);\\n        subset.push_back(nums[k]);\\n        backtrack(nums, k+1, subset, res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27495,
                "title": "share-my-several-c-solutions-easy-to-understand",
                "content": "***Solution(1):***\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            int i = 0, j = 0, len = 0;\\n            vector<int> temp;\\n            ret.push_back(temp);\\n            \\n            for (i = 0; i < n; i++)\\n            {\\n                len = ret.size();\\n                for (j = 0; j < len; j++)\\n                {\\n                    temp = ret[j];\\n                    temp.push_back(nums[i]);\\n                    ret.push_back(temp);\\n                }\\n            }\\n            \\n            return ret;\\n        }\\n    };\\n\\n***Solution(2):using recursion***\\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            vector<int> temp;\\n            \\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            subsetRecusion(nums, ret, temp, 0);\\n            \\n            return ret;\\n        }\\n        \\n        void subsetRecusion(vector<int>& nums, vector<vector<int>>& ret, vector<int> temp, int i)\\n        {\\n            if (i == nums.size())\\n            {\\n                ret.push_back(temp);\\n                return;\\n            }\\n            \\n            //there is no nums[i]\\n            subsetRecusion(nums, ret, temp, i+1);\\n            \\n            //there is nums[i]\\n            temp.push_back(nums[i]);\\n            subsetRecusion(nums, ret, temp, i+1);\\n        }\\n    };\\n\\n***Solution(3):bit manipulation*** \\n\\n    class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            int total = 1 << n;\\n            int i = 0, j = 0, t = 0;\\n            \\n            sort(nums.begin(), nums.end());\\n            \\n            for (i = 0; i < total; i++)\\n            {\\n                vector<int> temp;\\n                t = i;\\n                j = 0;\\n                \\n                for (j = 0; j < n; j++)\\n                {\\n                    if (t == 0)\\n                        break;\\n                    if (t & 1)\\n                        temp.push_back(nums[j]);\\n                    \\n                    t = t >> 1;\\n                }\\n                \\n                ret.push_back(temp);\\n            }\\n            \\n            return ret;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        vector<vector<int>> subsets(vector<int>& nums) {\\n            int n = nums.size();\\n            vector<vector<int>> ret;\\n            if (n == 0)\\n                return ret;\\n                \\n            sort(nums.begin(), nums.end());\\n            \\n            int i = 0, j = 0, len = 0;\\n            vector<int> temp;\\n            ret.push_back(temp);\\n            \\n            for (i = 0; i < n; i++)\\n            {\\n                len = ret.size();\\n                for (j = 0; j < len; j++)\\n                {\\n                    temp = ret[j];\\n                    temp.push_back(nums[i]);\\n                    ret.push_back(temp);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 27564,
                "title": "simple-python-code",
                "content": "    class Solution:\\n        # @param S, a list of integer\\n        # @return a list of lists of integer\\n        def subsets(self, S):\\n        \\tif S == []:\\n        \\t\\treturn []\\n            S.sort() #sort the array to avoid descending list of int\\n            res=[[]]\\n            for element in S:\\n            \\ttemp = []\\n            \\tfor ans in res:\\n            \\t\\t #append the new int to each existing list\\n            \\t\\ttemp.append(ans+[element])\\n            \\tres += temp\\n            return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param S, a list of integer\\n        # @return a list of lists of integer\\n        def subsets(self, S):\\n        \\tif S == []:\\n        \\t\\treturn []\\n            S.sort() #sort the array to avoid descending list of int\\n            res=[[]]\\n            for element in S:\\n            \\ttemp = []\\n            \\tfor ans in res:\\n            \\t\\t #append the new int to each existing list\\n            \\t\\ttemp.append(ans+[element])\\n            \\tres += temp\\n            return res",
                "codeTag": "Java"
            },
            {
                "id": 3434928,
                "title": "java-100-faster-solution-recursion-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> O(2^n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/d36f503d-b393-4657-a375-4904ec0d9f31_1681911363.8691647.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\n        List<List<Integer>> ans = new ArrayList<>(); // initialize the answer list\\n\\n        ArrayList<Integer> subset = new ArrayList<>(); // initialize the subset list\\n\\n        helper(nums, 0, subset, ans); // call the recursive helper function with initial values\\n\\n        return ans; // return the answer list\\n    }\\n\\n    public void helper(int nums[], int i, ArrayList<Integer> subset, List<List<Integer>> ans){\\n        \\n        // base case: if the index i has reached the end of the array, add the current subset to the answer list and return\\n        if(i == nums.length){\\n            ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n\\n        // add the current element to the subset and recursively call the helper function with the next index\\n        subset.add(nums[i]);\\n        helper(nums, i + 1, subset, ans);\\n\\n        // remove the last element from the subset and recursively call the helper function with the next index\\n        subset.remove(subset.size()-1);\\n        helper(nums, i + 1, subset, ans);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\n        List<List<Integer>> ans = new ArrayList<>(); // initialize the answer list\\n\\n        ArrayList<Integer> subset = new ArrayList<>(); // initialize the subset list\\n\\n        helper(nums, 0, subset, ans); // call the recursive helper function with initial values\\n\\n        return ans; // return the answer list\\n    }\\n\\n    public void helper(int nums[], int i, ArrayList<Integer> subset, List<List<Integer>> ans){\\n        \\n        // base case: if the index i has reached the end of the array, add the current subset to the answer list and return\\n        if(i == nums.length){\\n            ans.add(new ArrayList<>(subset));\\n            return;\\n        }\\n\\n        // add the current element to the subset and recursively call the helper function with the next index\\n        subset.add(nums[i]);\\n        helper(nums, i + 1, subset, ans);\\n\\n        // remove the last element from the subset and recursively call the helper function with the next index\\n        subset.remove(subset.size()-1);\\n        helper(nums, i + 1, subset, ans);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3215703,
                "title": "easiest-solution-have-a-look-java-c",
                "content": "Please Upvote \\uD83D\\uDE0A\\uD83D\\uDE0A\\n\\n# Code\\n```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        IList<IList<int>> subsets = new List<IList<int>>();\\n        subsets.Add(new List<int>()); \\n\\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            int count = subsets.Count;\\n            for(int j=0; j<count; j++)\\n            {\\n                var temp = subsets[j].ToList();\\n                temp.Add(nums[i]);\\n                subsets.Add(temp);\\n\\n            }\\n        }\\n        return subsets;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        IList<IList<int>> subsets = new List<IList<int>>();\\n        subsets.Add(new List<int>()); \\n\\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            int count = subsets.Count;\\n            for(int j=0; j<count; j++)\\n            {\\n                var temp = subsets[j].ToList();\\n                temp.Add(nums[i]);\\n                subsets.Add(temp);\\n\\n            }\\n        }\\n        return subsets;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772766,
                "title": "subsets-java-solution-2-approaches-with-explanation",
                "content": "```\\n1. First Approach\\n\\ndivide task for recursion and for us\\nExample:- a[1,2,3]\\n\\ndivide problem as [1] & [2,3]\\nand for [2,3] subsets are :- [],[2],[3],[2,3] now our task is simply add [1] in [2,3] subsets\\ni.e. [1],[1,2],[1,3],[1,2,3] and before updating [2,3] subsets with [1] make a copy of them\\n\\nsubsets of [1,2,3] = [],[2],[3],[2,3],[1],[1,2],[1,3],[1,2,3] \\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        return helper(nums,0);\\n    }\\n    public List<List<Integer>> helper(int[] nums, int index)\\n    {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(index==nums.length){\\n            List<Integer> store = new ArrayList<>();\\n            ans.add(store);\\n            return ans;\\n        }\\n        \\n        List<List<Integer>> partialAns = helper(nums,index+1);\\n        \\n        //store or make a copy of recursion subsets ans so that when we adding our first elementnit does not effect\\n        for(List<Integer> list : partialAns){\\n            ans.add(list);\\n        }\\n        \\n\\t\\t//adding first element to the recursion ans\\n        for(List<Integer> list : partialAns){\\n           List<Integer> list1 = new ArrayList<>();\\n            list1.add(nums[index]);\\n            for(int elem:list)\\n                list1.add(elem);\\n            \\n            ans.add(list1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n2. Second Approach :- Take or Not Take  || Include or Not include\\n\\nExample :- [1,2,3]\\nin this approach we have two options for each element either take this element in our final ans or not take\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n       \\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(index==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n1. First Approach\\n\\ndivide task for recursion and for us\\nExample:- a[1,2,3]\\n\\ndivide problem as [1] & [2,3]\\nand for [2,3] subsets are :- [],[2],[3],[2,3] now our task is simply add [1] in [2,3] subsets\\ni.e. [1],[1,2],[1,3],[1,2,3] and before updating [2,3] subsets with [1] make a copy of them\\n\\nsubsets of [1,2,3] = [],[2],[3],[2,3],[1],[1,2],[1,3],[1,2,3] \\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        return helper(nums,0);\\n    }\\n    public List<List<Integer>> helper(int[] nums, int index)\\n    {\\n        List<List<Integer>> ans = new ArrayList<>();\\n        if(index==nums.length){\\n            List<Integer> store = new ArrayList<>();\\n            ans.add(store);\\n            return ans;\\n        }\\n        \\n        List<List<Integer>> partialAns = helper(nums,index+1);\\n        \\n        //store or make a copy of recursion subsets ans so that when we adding our first elementnit does not effect\\n        for(List<Integer> list : partialAns){\\n            ans.add(list);\\n        }\\n        \\n\\t\\t//adding first element to the recursion ans\\n        for(List<Integer> list : partialAns){\\n           List<Integer> list1 = new ArrayList<>();\\n            list1.add(nums[index]);\\n            for(int elem:list)\\n                list1.add(elem);\\n            \\n            ans.add(list1);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n2. Second Approach :- Take or Not Take  || Include or Not include\\n\\nExample :- [1,2,3]\\nin this approach we have two options for each element either take this element in our final ans or not take\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n       \\n        List<Integer> subset = new ArrayList<>();\\n        List<List<Integer>> ans = new ArrayList<>();\\n        helper(nums,0,ans,subset);\\n        return ans;\\n    }\\n    public void helper(int[] nums, int index, List<List<Integer>> ans, List<Integer> subset)\\n    {\\n        if(index==nums.length){\\n            ans.add(new ArrayList(subset));\\n            return;\\n        }\\n        \\n        //include\\n        subset.add(nums[index]);\\n        helper(nums,index+1,ans,subset);\\n        \\n        //exclude\\n        subset.remove(subset.size()-1);\\n        helper(nums,index+1,ans,subset);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1877168,
                "title": "c-4-ms-easy-to-understand-recursion",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid solve(vector<int>& nums,vector<int>output,int index,vector<vector<int>>&ans)\\n\\t\\t{\\n\\t\\t\\tif(index>=nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(output);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tsolve(nums,output,index+1,ans);\\n\\n\\t\\t\\tint element=nums[index];\\n\\t\\t\\toutput.push_back(element);\\n\\t\\t\\t solve(nums,output,index+1,ans);\\n\\n\\n\\t\\t}\\n\\t\\tvector<vector<int>> subsets(vector<int>& nums) {\\n\\t\\tvector<vector<int>>ans;\\n\\t\\tvector<int>output;\\n\\t\\tint index=0;\\n\\t\\tsolve(nums,output,index,ans);\\n\\n\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid solve(vector<int>& nums,vector<int>output,int index,vector<vector<int>>&ans)\\n\\t\\t{\\n\\t\\t\\tif(index>=nums.size())\\n\\t\\t\\t{\\n\\t\\t\\t\\tans.push_back(output);\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1855532,
                "title": "java-simple-iterative-solution-with-easy-explanation-0-ms-faster-than-100-00",
                "content": "![image](https://assets.leetcode.com/users/images/f72cdcf3-be55-4ee2-956a-9824dcdb5f59_1647450776.2683885.jpeg)\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        for(int num:nums){\\n            int size=outer.size();\\n            for(int i=0;i<size;i++){\\n                List<Integer> internal=new ArrayList<>(outer.get(i));\\n                internal.add(num);\\n                outer.add(internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n//please give a reputation if it seems to be easy to understand to you\\n```",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer=new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n        for(int num:nums){\\n            int size=outer.size();\\n            for(int i=0;i<size;i++){\\n                List<Integer> internal=new ArrayList<>(outer.get(i));\\n                internal.add(num);\\n                outer.add(internal);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n//please give a reputation if it seems to be easy to understand to you\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1721954,
                "title": "java-easy-and-clean-code-with-comments",
                "content": "Runtime: 1 ms, faster than 71.85% of Java online submissions for Subsets.\\n\\n```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element \\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that\\nelement will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        //main list to store subsets.\\n        List<List<Integer>> ml = new ArrayList<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n; \\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly\\n\\t\\t\\t//by 2 until the remainder becomes 0. After that we write the remainder that has come at every \\n\\t\\t\\t//step of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the main list.\\n            ml.add(cl);\\n        }\\n        \\n        return ml;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\n/*\\n\\nSubsets of an array of length n is (2 to the power n). We will loop i from 0 to (2 to the power n). \\nThen take binary form of i and make a subset. As binary form contains 0 or 1 only, so if 1 comes, \\nthen add the element from the array in the subset list, else not. In a subset of array, each element \\nhas 2 choices, either it will come in the subset, or not come in the subset. So, 1 represents that\\nelement will come in the subset, 0 represents element will not come in the subset. \\n\\nExample : nums = [1,2,3]\\n          Number of subsets = (2 to the power 3) = 8. \\n          So, loop from 0 to 7.\\n\\nLoop (i)     |     Binary form     |     Subset we get\\n0            |       000           |       []\\n1            |       001           |       [3]\\n2            |       010           |       [2]\\n3            |       011           |       [2,3]\\n4            |       100           |       [1]\\n5            |       101           |       [1,3]\\n6            |       110           |       [1,2]\\n7            |       111           |       [1,2,3]\\n\\n*/\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        //main list to store subsets.\\n        List<List<Integer>> ml = new ArrayList<>();\\n        int n = nums.length;\\n        \\n        //total number of subsets = \\'2 to the power n\\' (1 << n = 1 * (2 to the power n) = 2 to the power n).\\n        int numOfSub = 1 << n; \\n        \\n        //As number of subsets of an array of length n is (2 to the power n), so loop i from 0 till (2 to the power n).\\n        for (int i = 0; i < numOfSub; i++) {\\n            //child list to store a subset.\\n            List<Integer> cl = new ArrayList<>();\\n            //Store i in a temp variable as i is controlling outer loop and cannot be messed with.\\n            int temp = i;\\n            \\n            //We are looping backwards, as when we are calculating binary of a number, the first bit that \\n\\t\\t\\t//comes after dividing the number with 2 is the LSB(Least Significant Bit) or the last bit of the \\n\\t\\t\\t//number\\'s binary form. \\n\\t\\t\\t//For more clarification :- When calculating binary form of a number we divide it repeatedly\\n\\t\\t\\t//by 2 until the remainder becomes 0. After that we write the remainder that has come at every \\n\\t\\t\\t//step of division backwards.\\n            for (int j = n - 1; j >= 0; j--) {\\n                //Taking remainder. (temp & 1) is equal to (temp % 2)\\n                int rem = temp & 1;\\n                //Then dividing it by 2. (temp >> 1) is equal to (temp / 2).\\n                temp = temp >> 1;\\n                \\n                //If rem is equal to 1, then add nums[j].\\n                if (rem == 1) {\\n                    cl.add(0, nums[j]);\\n                }\\n            }\\n            \\n            //After a subset is formed, add it in the main list.\\n            ml.add(cl);\\n        }\\n        \\n        return ml;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1473439,
                "title": "python-solutions",
                "content": "attempt 2, bitmap\\n```\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * use a bitmap, each bit represent whethre an element in @nums appears\\n    #       in a subset, e.g., for [1,2,3], 101 => [1,3]\\n    #     * for @nums of length n, we need n bits, so the bitmap would be from 0\\n    #       to 2**(n-1)\\n    #     * then each bit in the bitmap is tested, if the bit is 1, the\\n    #       corresponding element in @nums appears in the current subset\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        for bitmap in range(2**len(nums)): # O(2**n)\\n            cur = []\\n            for i in range(len(nums)):     # O(n)\\n                if bitmap & 2**i:          # note it is 2**i\\n                    cur.append(nums[i])\\n            res.append(cur)\\n        return res\\n```\\nattempt 3, recursion (is this backtrack?)\\n```   \\n   # Runtime: 26 ms, faster than 95.26%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * in each recursion, we decide whether node at current location is\\n    #       added to the subset, so the decision tree for [1,2,3] would be:\\n    #                  ___ 1 ___           -> to make decision for the 1st node\\n    #                y/         \\\\n\\n    #                /           \\\\\\n    #              _2_           _2_       -> to make decision for the 2nd node\\n    #            y/   \\\\n       y/   \\\\n\\n    #            /     \\\\       /     \\\\\\n    #           3       3     3       3    -> to make decision for the 3rd node\\n    #         y/ \\\\n   y/ \\\\n y/ \\\\n   y/ \\\\n\\n    #         /   \\\\   /   \\\\ /   \\\\   /   \\\\\\n    #       123   12 13   1 23  2  3    [] -> leaf nodes are all the subsets\\n    #\\n    # time: O(3*2**n)\\n    #     * number of nodes in the decision tree is:\\n    #         2**0 + 2**1 + ... + 2**n\\n    #       = bit(0) + bit(1) + ... + bit(n)\\n    #       = bit(n+1) - 1\\n    #     * for example, for [1,2,3] number of noeds in the decision tree is:\\n    #         2**0 + 2**1 + 2**2 + 2**3\\n    #       = 00001 + 00010 + 00100 + 01000\\n    #       = 01111\\n    #       = 10000 - 00001\\n    #       = 16 - 1 = 15\\n    #     * and for each of the 2**n result, it is appended to @res, this takes\\n    #       O(1) and the append is called 2**n times so totally O(2**n)\\n    #     * therefore the time complexity is:\\n    #         O(2**(n+1)) + O(2**n)\\n    #       = O(2*2**n) + O(2**n)\\n    #       = O(3*2**n)\\n    # space:\\n    #     * for stack usage, the longest path is log(n)\\n    #     * for the result, since there are 2**n results and each of length\\n    #       O(n), it would be O(n*2**n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            if i == len(nums):\\n                res.append(path) # subset decisided when a leaf is reached\\n                return\\n            backtrack(i + 1, path + [nums[i]]) # current element added (this creates a new list???)\\n            backtrack(i + 1, path)             # current element skipped\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\\nattempt 4, backtrack\\n```\\n    # peeked https://leetcode.com/problems/subsets/discuss/362545/Python3-Backtracking\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 18.88%\\n    #\\n    # note:\\n    #     * the decision tree for [1,2,3], infeasible paths are avoided by\\n    #       adding only elements with greater indices to the subset, this is how\\n    #       element uniqueness in a subset is guaranteed\\n    #                ____[]_______\\n    #               /         \\\\   \\\\\\n    #              [1]        [2] [3]\\n    #             /   \\\\       /\\n    #          [1,2] [1,3] [2,3]\\n    #           /\\n    #       [1,2,3]\\n    #     * this way the nodes and their subtrees like[1,3,1], [1,3,2], ... are\\n    #       \"pruned\"\\n    #     * therefore unlike the previous attempt, this one does not recored\\n    #       result when i==len(nums)\\n    #     * for path.pop():\\n    #       - as an example, if we just finished [1,2,3] and returned from a\\n    #         call to backtrack(), now @path is [1,2,3] and we want to go back\\n    #         to [1,2] and go the next path (which does not exist though)\\n    #       - as another example, if we just finished [1,2] and returned from a\\n    #         call to backtrack(), now @path is [1,2] and the next path is\\n    #         [1,3], so we have to remove 2\\n    #\\n    # time: O(2*2**n)\\n    #     * number of nodes in the decision tree is 2**n\\n    #     * appending a result to @res takes O(1) and it is called 2**n times\\n    # space: O(2**n)\\n    #     * for stack usage, the deepest path is the subset that contains all\\n    #       the element in @nums, and the elements are added one by one, so it\\n    #       is O(n)\\n    #     * for the result, it is O(n*2**n) as there are 2**n results each has\\n    #       length O(n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            # use list() because @path is passed by reference and we want to\\n            # create a new lispt here\\n            res.append(list(path)) # O(1)\\n            for i in range(i, len(nums)):\\n                path.append(nums[i])   # O(1)\\n                backtrack(i + 1, path)\\n                path.pop()             # O(1)\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\\nattempt 6, cascading\\n```\\n    # ref: https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    # Runtime: 28 ms, faster than 95.21%\\n    # Memory Usage: 14.2 MB, less than 92.48%\\n    #\\n    # note:\\n    #     * the challenging part of this method is that we can\\'t just create\\n    #       references to the elements in the lists, but we have to make copy of\\n    #       them\\n    #     * ---> [[]]\\n    #       -1-> [[],[1]]\\n    #       -2-> [[],[1],[2],[1,2]]\\n    #       -3-> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n    #\\n    # time:\\n    #     * the process is taking lists in @res out and append @n for each of\\n    #       them and @res is started with only one element and ends up with 2**n\\n    #       elements\\n    #       - the process is done 2**0 + 2**1 + ... + 2**n = 2**(n+1) - 1 times\\n    #       - each time the list is copied and appended, which takes O(n) ???\\n    #       - so totally O(n*2**(n+1))\\n    #     * number of nodes in the tree:\\n    #\\n    #     * each element in a subset appended one by one\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:          # @n is the element to be added\\n            cur = []            # @cur will be a list in @res each with @n added\\n            for c in res:       # take elements in @res out and add with @n\\n                cur += [c + [n]] # this way we create a new copy of @c with @n added\\n            res += cur\\n        return res\\n```\\nattempt 5, cascading\\n```\\n    # peeked the solution page and\\n    # https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    #\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:\\n            res += [cur + [n] for cur in res]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * use a bitmap, each bit represent whethre an element in @nums appears\\n    #       in a subset, e.g., for [1,2,3], 101 => [1,3]\\n    #     * for @nums of length n, we need n bits, so the bitmap would be from 0\\n    #       to 2**(n-1)\\n    #     * then each bit in the bitmap is tested, if the bit is 1, the\\n    #       corresponding element in @nums appears in the current subset\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = []\\n        for bitmap in range(2**len(nums)): # O(2**n)\\n            cur = []\\n            for i in range(len(nums)):     # O(n)\\n                if bitmap & 2**i:          # note it is 2**i\\n                    cur.append(nums[i])\\n            res.append(cur)\\n        return res\\n```\n```   \\n   # Runtime: 26 ms, faster than 95.26%\\n    # Memory Usage: 14.5 MB, less than 50.73%\\n    #\\n    # note:\\n    #     * in each recursion, we decide whether node at current location is\\n    #       added to the subset, so the decision tree for [1,2,3] would be:\\n    #                  ___ 1 ___           -> to make decision for the 1st node\\n    #                y/         \\\\n\\n    #                /           \\\\\\n    #              _2_           _2_       -> to make decision for the 2nd node\\n    #            y/   \\\\n       y/   \\\\n\\n    #            /     \\\\       /     \\\\\\n    #           3       3     3       3    -> to make decision for the 3rd node\\n    #         y/ \\\\n   y/ \\\\n y/ \\\\n   y/ \\\\n\\n    #         /   \\\\   /   \\\\ /   \\\\   /   \\\\\\n    #       123   12 13   1 23  2  3    [] -> leaf nodes are all the subsets\\n    #\\n    # time: O(3*2**n)\\n    #     * number of nodes in the decision tree is:\\n    #         2**0 + 2**1 + ... + 2**n\\n    #       = bit(0) + bit(1) + ... + bit(n)\\n    #       = bit(n+1) - 1\\n    #     * for example, for [1,2,3] number of noeds in the decision tree is:\\n    #         2**0 + 2**1 + 2**2 + 2**3\\n    #       = 00001 + 00010 + 00100 + 01000\\n    #       = 01111\\n    #       = 10000 - 00001\\n    #       = 16 - 1 = 15\\n    #     * and for each of the 2**n result, it is appended to @res, this takes\\n    #       O(1) and the append is called 2**n times so totally O(2**n)\\n    #     * therefore the time complexity is:\\n    #         O(2**(n+1)) + O(2**n)\\n    #       = O(2*2**n) + O(2**n)\\n    #       = O(3*2**n)\\n    # space:\\n    #     * for stack usage, the longest path is log(n)\\n    #     * for the result, since there are 2**n results and each of length\\n    #       O(n), it would be O(n*2**n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            if i == len(nums):\\n                res.append(path) # subset decisided when a leaf is reached\\n                return\\n            backtrack(i + 1, path + [nums[i]]) # current element added (this creates a new list???)\\n            backtrack(i + 1, path)             # current element skipped\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\n```\\n    # peeked https://leetcode.com/problems/subsets/discuss/362545/Python3-Backtracking\\n    # Runtime: 32 ms, faster than 83.27%\\n    # Memory Usage: 14.5 MB, less than 18.88%\\n    #\\n    # note:\\n    #     * the decision tree for [1,2,3], infeasible paths are avoided by\\n    #       adding only elements with greater indices to the subset, this is how\\n    #       element uniqueness in a subset is guaranteed\\n    #                ____[]_______\\n    #               /         \\\\   \\\\\\n    #              [1]        [2] [3]\\n    #             /   \\\\       /\\n    #          [1,2] [1,3] [2,3]\\n    #           /\\n    #       [1,2,3]\\n    #     * this way the nodes and their subtrees like[1,3,1], [1,3,2], ... are\\n    #       \"pruned\"\\n    #     * therefore unlike the previous attempt, this one does not recored\\n    #       result when i==len(nums)\\n    #     * for path.pop():\\n    #       - as an example, if we just finished [1,2,3] and returned from a\\n    #         call to backtrack(), now @path is [1,2,3] and we want to go back\\n    #         to [1,2] and go the next path (which does not exist though)\\n    #       - as another example, if we just finished [1,2] and returned from a\\n    #         call to backtrack(), now @path is [1,2] and the next path is\\n    #         [1,3], so we have to remove 2\\n    #\\n    # time: O(2*2**n)\\n    #     * number of nodes in the decision tree is 2**n\\n    #     * appending a result to @res takes O(1) and it is called 2**n times\\n    # space: O(2**n)\\n    #     * for stack usage, the deepest path is the subset that contains all\\n    #       the element in @nums, and the elements are added one by one, so it\\n    #       is O(n)\\n    #     * for the result, it is O(n*2**n) as there are 2**n results each has\\n    #       length O(n)\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def backtrack(i, path):\\n            # use list() because @path is passed by reference and we want to\\n            # create a new lispt here\\n            res.append(list(path)) # O(1)\\n            for i in range(i, len(nums)):\\n                path.append(nums[i])   # O(1)\\n                backtrack(i + 1, path)\\n                path.pop()             # O(1)\\n        res = []\\n        backtrack(0, [])\\n        return res\\n```\n```\\n    # ref: https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    # Runtime: 28 ms, faster than 95.21%\\n    # Memory Usage: 14.2 MB, less than 92.48%\\n    #\\n    # note:\\n    #     * the challenging part of this method is that we can\\'t just create\\n    #       references to the elements in the lists, but we have to make copy of\\n    #       them\\n    #     * ---> [[]]\\n    #       -1-> [[],[1]]\\n    #       -2-> [[],[1],[2],[1,2]]\\n    #       -3-> [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n    #\\n    # time:\\n    #     * the process is taking lists in @res out and append @n for each of\\n    #       them and @res is started with only one element and ends up with 2**n\\n    #       elements\\n    #       - the process is done 2**0 + 2**1 + ... + 2**n = 2**(n+1) - 1 times\\n    #       - each time the list is copied and appended, which takes O(n) ???\\n    #       - so totally O(n*2**(n+1))\\n    #     * number of nodes in the tree:\\n    #\\n    #     * each element in a subset appended one by one\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:          # @n is the element to be added\\n            cur = []            # @cur will be a list in @res each with @n added\\n            for c in res:       # take elements in @res out and add with @n\\n                cur += [c + [n]] # this way we create a new copy of @c with @n added\\n            res += cur\\n        return res\\n```\n```\\n    # peeked the solution page and\\n    # https://leetcode.com/problems/subsets/discuss/519823/Simple-Intuitive-Python-Solution\\n    #\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for n in nums:\\n            res += [cur + [n] for cur in res]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 715304,
                "title": "python-2-ways-w-explnation",
                "content": "**IDEA 1:** For every number in nums, we have the option to either include it or exclude it and proceed further. So, if we have 2 choices for each of the \\uD835\\uDC5B elements, the total number of subsets possible is 2\\\\**n.\\nThis method first builds the lists by including numbers and then backtracks to exclude them and proceed further.\\n\\nThe output for the input [1,2,3] looks like:\\n```\\n    level 0: []\\n    level 1: [1]                    [2]                   [3]\\n    level 2: [1,2]               [1,3]                [2,3] \\n    level 3: [1,2,3]\\n\\n```\\nImplementation: \\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.gen_subsets(nums, 0, [], result)\\n        return result\\n\\n    def gen_subsets(self, nums, curr_idx, curr, result):\\n        result.append(list(curr))\\n        # Iterating over all the elements of the array\\n        for i in range(curr_idx, len(nums)):\\n            # Include\\n            curr.append(nums[i])\\n            # Simulate proceeding while including it\\n            self.gen_subsets(nums, i + 1, curr, result)\\n            # Exclude\\n            curr.pop()\\n\\n```\\n\\n----------------------------------------------------------------------------------------------------\\n\\n\\n**IDEA 2:** Build the result list in a bottom-up manner. Here, we consider one number at a time and then keep building the rest of the list over it. This can be illustrated by the following example:\\n\\n```\\nINPUT                                                      OUTPUT\\n[1]                                                       [[], [1]]\\n[1,2]                                                 [[], [1], [2], [1,2]]\\n[1,2,3]                                     [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]\\n```\\n\\nHere, we can see that when the input is [1,2], we have used the output for [1], as it is, and then added \\'2\\' to every list within the output to obtain the result for [1,2].\\nSimilarly, for [1,2,3], we have used the output for [1,2], as it is, and then added \\'3\\' to every list within the output to obtain the result for [1,2,3].\\n\\nThus, its like doubling the results with some modification.\\nA general pattern can be observed as:\\n**Output for [1...k] = Output for [1...(k-1)] + Add k to every entry in Output for [1...(k-1)]**\\n\\nThus, the implementation:\\n\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = [[]]\\n        for ele in nums:\\n            result += [entry + [ele] for entry in result]\\n        return result\\n```\\n\\n\\nIf you found this helpful, please upvote and constructive criticism is always welcome! :)\\nPlease feel free to comment if you\\'ve any doubts! :)",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n    level 0: []\\n    level 1: [1]                    [2]                   [3]\\n    level 2: [1,2]               [1,3]                [2,3] \\n    level 3: [1,2,3]\\n\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = []\\n        self.gen_subsets(nums, 0, [], result)\\n        return result\\n\\n    def gen_subsets(self, nums, curr_idx, curr, result):\\n        result.append(list(curr))\\n        # Iterating over all the elements of the array\\n        for i in range(curr_idx, len(nums)):\\n            # Include\\n            curr.append(nums[i])\\n            # Simulate proceeding while including it\\n            self.gen_subsets(nums, i + 1, curr, result)\\n            # Exclude\\n            curr.pop()\\n\\n```\n```\\nINPUT                                                      OUTPUT\\n[1]                                                       [[], [1]]\\n[1,2]                                                 [[], [1], [2], [1,2]]\\n[1,2,3]                                     [[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]]\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        result = [[]]\\n        for ele in nums:\\n            result += [entry + [ele] for entry in result]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358219,
                "title": "python3-clean-solution-in-5-lines-of-code",
                "content": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans = [[]]\\n        for num in nums:\\n            for i in range(len(ans)):\\n                ans.append(ans[i] + [num])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans = [[]]\\n        for num in nums:\\n            for i in range(len(ans)):\\n                ans.append(ans[i] + [num])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221467,
                "title": "scala-solution",
                "content": "```\\n  def solution(nums: Array[Int]): List[List[Int]] = {\\n    if (nums.isEmpty) return List(List())\\n    val next = solution(nums.tail)\\n    next ++ next.map(_ :+ nums.head)\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  def solution(nums: Array[Int]): List[List[Int]] = {\\n    if (nums.isEmpty) return List(List())\\n    val next = solution(nums.tail)\\n    next ++ next.map(_ :+ nums.head)\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 180242,
                "title": "java-o-n-dfs-iterative-recursive-and-bfs",
                "content": "# DFS Iterative\\nThis Solution is a simple extension of **DFS Iterative Pre-Order Traversal** \\n1. Tree needs to be built. So In-Order or Post-Order cannot be used which require to visit child before visiting parent.\\n2. Only Pre-order (Top-Down) is possible.\\n\\n***DFS Iterative Pre-Order***\\n1. Create nodeStack \\n2. Add root to stack\\n3. while nodeStack not empty\\n\\t* \\tPop a node out of the stack\\n\\t* \\tVisit the node\\n\\t* \\tAdd left child to stack\\n\\t* \\tAdd right child ot stack\\n\\n***Extension for this problem***\\n* We do not have a tree yet.\\n* Need to build the tree\\n* So no point creating nodeStack\\n* Instead create positionStack to keep track of the position ***( nums[position] )*** we are dealing with at the moment.\\n* Each position in num[] array crossponds to each level in the tree\\n* Start with position 0\\n1. Create new levelStack \\n2. Add position 0 to levelStack\\n3. Create a tempList - as a carrier to transport values from parent to child\\n4. while ( levelStack not empty )\\n\\t* pop() position from levelStack\\n\\t* We will be dealing with nums[positon] in THIS iteration\\n\\t* Check Exit Condition\\n\\t* Time to create left child\\n\\t\\t* Do not add this num[position] to tempList for left child\\n\\t\\t* Push position+1 into stack\\n\\t* Right child\\n\\t\\t* Add nums[position] into tempList\\n\\t\\t* Again Push position+1 into stack for right child \\n\\t\\n\\t* Exit condition\\n\\t\\t* Check if we are at the leaf\\n\\t\\t* If yes - Then its time to record the node to result list\\n\\t\\t* Once result is recorded restore tempList to previous state (backtracking)\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\t\\tif(nums == null || nums.length <= 0)\\n\\t\\t\\treturn new ArrayList<>();\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tStack<Integer> levelStack = new Stack<>();\\n\\t\\tList<Integer> tempList = new ArrayList<>();\\n\\t\\tlevelStack.push(0);\\n\\t\\t\\n\\t\\twhile(!levelStack.isEmpty()){\\n\\t\\t\\tint pos = levelStack.pop();\\n\\t\\t\\tif(pos == nums.length){ //Exit condition\\n\\t\\t\\t\\tlistCnt++; \\n\\t\\t\\t\\tres.add(new ArrayList<>(tempList));\\n\\t\\t\\t\\tif(!tempList.isEmpty())\\n\\t\\t\\t\\t\\ttempList.remove(tempList.size()-1);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t//Left child\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t\\t//Right child\\n\\t\\t\\ttempList.add(nums[pos]);\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```\\n\\n# DFS Recursive\\n```\\npublic List<List<Integer>> subsets_DFS_Recursive(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> result = new ArrayList<>();\\n\\tList<Integer> input = new ArrayList<>();\\n\\tdfs_Recursive(nums, 0, input, result);\\n\\treturn result;\\n}\\n\\nprivate void dfs_Recursive(int[] nums, int position, List<Integer> input, List<List<Integer>> result) {\\n\\tif(position == nums.length) {\\n\\t\\tresult.add(new ArrayList<>(input));\\n\\t\\treturn;\\n\\t}\\n\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.add(nums[position]);\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.remove(input.size()-1);\\n}\\n```\\n# BFS\\n```\\npublic List<List<Integer>> subsets_BFS(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> res = new ArrayList<>();\\n\\tQueue<List<Integer>> queue = new LinkedList<>(); \\n\\tqueue.offer(new ArrayList<Integer>());\\n\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tint levelSize = queue.size();\\n\\t\\tfor(int j=0; j<levelSize; j++){\\n\\t\\t\\tList<Integer> polled = queue.poll();\\n\\n\\t\\t\\tList<Integer> leftChild = polled;\\n\\t\\t\\t//Left child - Reuse parent\\'s array list obj\\n\\t\\t\\tqueue.offer(leftChild);\\n\\n\\t\\t\\t//Left child has reused the parent\\'s arraylist.. So right child creates a new copy\\n\\t\\t\\tList<Integer> rightChild = new ArrayList<>(polled);\\n\\t\\t\\trightChild.add(nums[i]);\\n\\t\\t\\tqueue.offer(rightChild);\\n\\t\\t}\\t\\n\\t}\\n\\tres.addAll(queue);\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n\\t\\tif(nums == null || nums.length <= 0)\\n\\t\\t\\treturn new ArrayList<>();\\n\\t\\t\\n\\t\\tList<List<Integer>> res = new ArrayList<>();\\n\\t\\tStack<Integer> levelStack = new Stack<>();\\n\\t\\tList<Integer> tempList = new ArrayList<>();\\n\\t\\tlevelStack.push(0);\\n\\t\\t\\n\\t\\twhile(!levelStack.isEmpty()){\\n\\t\\t\\tint pos = levelStack.pop();\\n\\t\\t\\tif(pos == nums.length){ //Exit condition\\n\\t\\t\\t\\tlistCnt++; \\n\\t\\t\\t\\tres.add(new ArrayList<>(tempList));\\n\\t\\t\\t\\tif(!tempList.isEmpty())\\n\\t\\t\\t\\t\\ttempList.remove(tempList.size()-1);\\n\\t\\t\\t\\tcontinue;\\n\\t\\t\\t}\\n\\t\\t\\t//Left child\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t\\t//Right child\\n\\t\\t\\ttempList.add(nums[pos]);\\n\\t\\t\\tlevelStack.push(pos+1);\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n}\\n```\n```\\npublic List<List<Integer>> subsets_DFS_Recursive(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> result = new ArrayList<>();\\n\\tList<Integer> input = new ArrayList<>();\\n\\tdfs_Recursive(nums, 0, input, result);\\n\\treturn result;\\n}\\n\\nprivate void dfs_Recursive(int[] nums, int position, List<Integer> input, List<List<Integer>> result) {\\n\\tif(position == nums.length) {\\n\\t\\tresult.add(new ArrayList<>(input));\\n\\t\\treturn;\\n\\t}\\n\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.add(nums[position]);\\n\\tdfs_Recursive(nums, position+1, input, result);\\n\\tinput.remove(input.size()-1);\\n}\\n```\n```\\npublic List<List<Integer>> subsets_BFS(int[] nums) {\\n\\tif(nums == null || nums.length <= 0)\\n\\t\\treturn new ArrayList<>();\\n\\n\\tList<List<Integer>> res = new ArrayList<>();\\n\\tQueue<List<Integer>> queue = new LinkedList<>(); \\n\\tqueue.offer(new ArrayList<Integer>());\\n\\n\\tfor(int i=0; i<nums.length; i++){\\n\\t\\tint levelSize = queue.size();\\n\\t\\tfor(int j=0; j<levelSize; j++){\\n\\t\\t\\tList<Integer> polled = queue.poll();\\n\\n\\t\\t\\tList<Integer> leftChild = polled;\\n\\t\\t\\t//Left child - Reuse parent\\'s array list obj\\n\\t\\t\\tqueue.offer(leftChild);\\n\\n\\t\\t\\t//Left child has reused the parent\\'s arraylist.. So right child creates a new copy\\n\\t\\t\\tList<Integer> rightChild = new ArrayList<>(polled);\\n\\t\\t\\trightChild.add(nums[i]);\\n\\t\\t\\tqueue.offer(rightChild);\\n\\t\\t}\\t\\n\\t}\\n\\tres.addAll(queue);\\n\\treturn res;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 178796,
                "title": "kotlin-solution-short-and-simple",
                "content": "Kotlin deals with lists in very elegant way, as you can see below. The only thing that might be not obvious is `result.map { it + num}` which for each list in result adds current element `num`. BUT `map` doesn\\'t modify collection itself (`result` in this case), it returns mapped lists.\\n```\\n    fun subsets(nums: IntArray): List<List<Int>> {\\n        val result = mutableListOf(emptyList<Int>())\\n        nums.forEach { num ->\\n            val newAdditions = result.map { it + num}\\n            result.addAll(newAdditions)\\n        }\\n        return result\\n    }",
                "solutionTags": [],
                "code": "Kotlin deals with lists in very elegant way, as you can see below. The only thing that might be not obvious is `result.map { it + num}` which for each list in result adds current element `num`. BUT `map` doesn\\'t modify collection itself (`result` in this case), it returns mapped lists.\\n```\\n    fun subsets(nums: IntArray): List<List<Int>> {\\n        val result = mutableListOf(emptyList<Int>())\\n        nums.forEach { num ->\\n            val newAdditions = result.map { it + num}\\n            result.addAll(newAdditions)\\n        }\\n        return result\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 27622,
                "title": "share-my-accepted-simple-python-code",
                "content": "    class Solution:\\n    # @param S, a list of integer\\n    # @return a list of lists of integer\\n    def subsets(self, S):\\n        if not S:\\n            return [[]]\\n        else:\\n            S.sort()\\n            pre_subsets = self.subsets(S[1:])\\n            return pre_subsets + [[S[0]]+elem for elem in pre_subsets]",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param S, a list of integer\\n    # @return a list of lists of integer\\n    def subsets(self, S):\\n        if not S:\\n            return [[]]\\n        else:\\n            S.sort()\\n            pre_subsets = self.subsets(S[1:])\\n            return pre_subsets + [[S[0]]+elem for elem in pre_subsets]",
                "codeTag": "Java"
            },
            {
                "id": 27624,
                "title": "accepted-dynamic-solution-with-explanation-in-cpp",
                "content": "    /*\\n       LEgend:\\n            #S -> size of input set\\n            #SS(n) -> total number of subsets for a set with size n (i.e 2^n)\\n            S(i) ->ith element of input set\\n            SS(i) -> ith element of the set of subsets of S (starting from 0)\\n            SSn = set of Subset for Sn\\n            SS(#SS(n)-1) -> Last element in SSn\\n       \\n       Logic:\\n            #SS(n)= 2 * #SS(n-1)\\n            => SSn = SSn-1 U { {SS(0),S(n)} , {SS(1),S(n)} , ...  , {SS(#SS(n-1)-1),S(n)} }\\n      \\n       Explanation :      \\n        In simple words,I am using the logic of Dynamic Programming and breaking the problem in smaller subproblems\\n        \\n        eg. S={1,2}\\n        SS2 = { { } , {1} , {2} , {1,2} }\\n        \\n        now to get the subset for {1,2,3} we add the element 3 \\n         in each of the solution set of SS and with this new set do union of SS\\n        \\n        SS3 = SS2 U { {3} , {1,3} , {2,3} , {1,2,3} }\\n            = { {} , {1} , {2} , {1,2} , {3} , {1,3} , {2,3} , {1,2,3} }  \\n    */\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            vector <int> temp;\\n            vector<vector<int> >ans;\\n            ans.push_back(temp);   //Enters null set\\n            int len=S.size();\\n            int len2;\\n            if(len==0)\\n             return ans;\\n        \\n            sort(S.begin(),S.end());\\n            \\n            for(int i=0 ; i<len ; i++)   //Traverses the whole input array\\n            {    \\n                len2=ans.size();\\n              // Since we cannot append the new number along with the null set therefore this is done outside the loop\\n                temp.clear();\\n                temp.push_back(S[i]);\\n                ans.push_back(temp);\\n            \\n                for(int j=1 ; j<len2 ; j++)\\n                {\\n                    vector<int> temp2(ans[j]);\\n                    temp2.push_back(S[i]);\\n                    ans.push_back(temp2);\\n                }\\n            }\\n            return ans;\\n        }",
                "solutionTags": [],
                "code": "    /*\\n       LEgend:\\n            #S -> size of input set\\n            #SS(n) -> total number of subsets for a set with size n (i.e 2^n)\\n            S(i) ->ith element of input set\\n            SS(i) -> ith element of the set of subsets of S (starting from 0)\\n            SSn = set of Subset for Sn\\n            SS(#SS(n)-1) -> Last element in SSn\\n       \\n       Logic:\\n            #SS(n)= 2 * #SS(n-1)\\n            => SSn = SSn-1 U { {SS(0),S(n)} , {SS(1),S(n)} , ...  , {SS(#SS(n-1)-1),S(n)} }\\n      \\n       Explanation :      \\n        In simple words,I am using the logic of Dynamic Programming and breaking the problem in smaller subproblems\\n        \\n        eg. S={1,2}\\n        SS2 = { { } , {1} , {2} , {1,2} }\\n        \\n        now to get the subset for {1,2,3} we add the element 3 \\n         in each of the solution set of SS and with this new set do union of SS\\n        \\n        SS3 = SS2 U { {3} , {1,3} , {2,3} , {1,2,3} }\\n            = { {} , {1} , {2} , {1,2} , {3} , {1,3} , {2,3} , {1,2,3} }  \\n    */\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            vector <int> temp;\\n            vector<vector<int> >ans;\\n            ans.push_back(temp);   //Enters null set\\n            int len=S.size();\\n            int len2;\\n            if(len==0)\\n             return ans;\\n        \\n            sort(S.begin(),S.end());\\n            \\n            for(int i=0 ; i<len ; i++)   //Traverses the whole input array\\n            {    \\n                len2=ans.size();\\n              // Since we cannot append the new number along with the null set therefore this is done outside the loop\\n                temp.clear();\\n                temp.push_back(S[i]);\\n                ans.push_back(temp);\\n            \\n                for(int j=1 ; j<len2 ; j++)\\n                {\\n                    vector<int> temp2(ans[j]);\\n                    temp2.push_back(S[i]);\\n                    ans.push_back(temp2);\\n                }\\n            }\\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3164338,
                "title": "solution",
                "content": "```C++ []\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> pw_set;\\n        vector<int> subset;\\n        recurse(nums, subset, pw_set, 0);\\n        return pw_set;\\n    }\\nprivate:\\n    void recurse (vector<int>& nums, vector<int>& subset, vector<vector<int>>& pw_set, int i) {\\n        if (i >= nums.size()) {\\n            pw_set.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[i]);\\n        recurse(nums, subset, pw_set, i + 1);\\n\\n        subset.pop_back();\\n        recurse(nums, subset, pw_set, i + 1);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n\\n        for num in nums:\\n            n = len(subsets)\\n\\n            for i in range(n):\\n                subset = list(subsets[i])\\n                subset.append(num)\\n                subsets.append(subset)\\n\\n        return subsets\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer = new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n\\n        for(int num : nums) {\\n            int n = outer.size();\\n            for(int i = 0; i < n; i++) {\\n                List<Integer> list = new ArrayList<>(outer.get(i));\\n                list.add(num);\\n                outer.add(list);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\n#include <vector>\\n\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> pw_set;\\n        vector<int> subset;\\n        recurse(nums, subset, pw_set, 0);\\n        return pw_set;\\n    }\\nprivate:\\n    void recurse (vector<int>& nums, vector<int>& subset, vector<vector<int>>& pw_set, int i) {\\n        if (i >= nums.size()) {\\n            pw_set.push_back(subset);\\n            return;\\n        }\\n        subset.push_back(nums[i]);\\n        recurse(nums, subset, pw_set, i + 1);\\n\\n        subset.pop_back();\\n        recurse(nums, subset, pw_set, i + 1);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        subsets = [[]]\\n\\n        for num in nums:\\n            n = len(subsets)\\n\\n            for i in range(n):\\n                subset = list(subsets[i])\\n                subset.append(num)\\n                subsets.append(subset)\\n\\n        return subsets\\n```\n```Java []\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> outer = new ArrayList<>();\\n        outer.add(new ArrayList<>());\\n\\n        for(int num : nums) {\\n            int n = outer.size();\\n            for(int i = 0; i < n; i++) {\\n                List<Integer> list = new ArrayList<>(outer.get(i));\\n                list.add(num);\\n                outer.add(list);\\n            }\\n        }\\n        return outer;\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2034062,
                "title": "subset-i-4-approaches-java-solution",
                "content": "### Approach 1 :  Recursive\\n```\\n//Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        helper(nums , 0 , new ArrayList<Integer>() , ans );\\n        return ans;\\n    }\\n    \\n    void helper(int[] nums , int i , ArrayList<Integer> list , List<List<Integer>> ans)\\n    {\\n        if(i==nums.length)\\n        {\\n            ans.add(new ArrayList<>(list));\\n            return ;\\n        }\\n        helper(nums,i+1 , new ArrayList<>(list) , ans);\\n        list.add(nums[i]);\\n        helper(nums , i+1 , list , ans);\\n    }\\n}\\n```\\n\\n### Approach 2 :  Recursive Backtracking\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        subset(nums, 0 , new ArrayList<>() , ans);\\n        return ans;\\n    }\\n    \\n    void subset(int[] nums , int p , ArrayList<Integer> list, List<List<Integer>> ans)\\n    {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=p ; i<nums.length;i++)\\n        {\\n            list.add(nums[i]);\\n            subset(nums , i+1, list , ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n\\n```\\n\\n### Approach 3 : Bit Manipulation\\n\\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n       //loop will run for 2^n-1 times\\n       for(int i=0;i<(1<<n) ; i++)\\n       {\\n           ArrayList<Integer> list = new ArrayList<>();\\n           for(int k=0;k<n;k++)\\n           {\\n               if((i & (1<<k))>0)\\n                   list.add(nums[k]);\\n           }\\n               ans.add(new ArrayList<>(list));\\n       }\\n       return ans;   \\n    }\\n}\\n```\\n\\n### Aproach 4 : Iterative Solution\\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        ans.add(new ArrayList<>()); //adding empty arraylist inside ans\\n        for(int i=0;i<nums.length;i++)   \\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                //have added the list with same elements \\n                ans.add(new ArrayList<>(ans.get(j)));\\n                //now make sure to add another element too\\n                ans.get(ans.size()-1).add(nums[i]);\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n* We can see here , Recursive Backtracking is the fastest approach",
                "solutionTags": [
                    "Java",
                    "Backtracking",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "```\\n//Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        helper(nums , 0 , new ArrayList<Integer>() , ans );\\n        return ans;\\n    }\\n    \\n    void helper(int[] nums , int i , ArrayList<Integer> list , List<List<Integer>> ans)\\n    {\\n        if(i==nums.length)\\n        {\\n            ans.add(new ArrayList<>(list));\\n            return ;\\n        }\\n        helper(nums,i+1 , new ArrayList<>(list) , ans);\\n        list.add(nums[i]);\\n        helper(nums , i+1 , list , ans);\\n    }\\n}\\n```\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        subset(nums, 0 , new ArrayList<>() , ans);\\n        return ans;\\n    }\\n    \\n    void subset(int[] nums , int p , ArrayList<Integer> list, List<List<Integer>> ans)\\n    {\\n        ans.add(new ArrayList<>(list));\\n        for(int i=p ; i<nums.length;i++)\\n        {\\n            list.add(nums[i]);\\n            subset(nums , i+1, list , ans);\\n            list.remove(list.size()-1);\\n        }\\n    }\\n}\\n\\n```\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        int n = nums.length;\\n       //loop will run for 2^n-1 times\\n       for(int i=0;i<(1<<n) ; i++)\\n       {\\n           ArrayList<Integer> list = new ArrayList<>();\\n           for(int k=0;k<n;k++)\\n           {\\n               if((i & (1<<k))>0)\\n                   list.add(nums[k]);\\n           }\\n               ans.add(new ArrayList<>(list));\\n       }\\n       return ans;   \\n    }\\n}\\n```\n```\\n// Runtime: 1 ms, faster than 78.66% of Java online submissions\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) \\n    {\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n        ans.add(new ArrayList<>()); //adding empty arraylist inside ans\\n        for(int i=0;i<nums.length;i++)   \\n        {\\n            int n=ans.size();\\n            for(int j=0;j<n;j++)\\n            {\\n                //have added the list with same elements \\n                ans.add(new ArrayList<>(ans.get(j)));\\n                //now make sure to add another element too\\n                ans.get(ans.size()-1).add(nums[i]);\\n            }   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1766605,
                "title": "highly-commented-recursive-javascript-90-faster-easy-understanding",
                "content": "```\\n/* This is a recursive solution\\nFor recursion we need 2 main thing:\\n1) Base case or the terminating condition\\n2) Next state transition/Recurrence Relation i.e\\n A way to move to next from current state/input\\n\\n In this problem our base case will be when we have\\n iterated through the entire length of array i.e\\n when currentIndex >= nums.length\\n\\n And we can apply common sense to derive recurrence relation.\\n So for currentIndex we have only two choices i.e.\\n we can either select/include the number at current index in out set\\n or we can exclude/pass the number at current index.\\n If we choose to include the number in our set when we can do it by [...set,nums[currentIndex]]\\n otherwise if we exclude/pass currentIndex num then our set will remain same as it was earlier i.e set\\n And in either case we will increment our currentIndex so that next time we \\n check for another number in nums array\\n\\n Now let\\'s look into the code \\n */\\nvar subsets = function (nums) {\\n\\t//Array finalOutput stores all the power sets\\n\\tlet finalOutput = [];\\n\\n\\t// Helper method is a recursive function that call\\'s itself\\n\\tconst helper = (currentIndex, set) => {\\n\\t\\t// Check for base case as stated above\\n\\t\\tif (currentIndex >= nums.length) {\\n\\t\\t\\t// push the set of current iteration in finalOutput\\n\\t\\t\\tfinalOutput.push(set);\\n\\t\\t\\treturn; //Necessary to end the recursion iteration\\n\\t\\t}\\n\\n\\t\\t//This is the 1st case where we are including the currentIndex number\\n\\t\\t// We increment currentIndex and add currentNumber i.e nums[currentIndex] in our set i.e. [...set, nums[currentIndex]]\\n\\t\\thelper(currentIndex + 1, [...set, nums[currentIndex]]);\\n\\n\\t\\t// This is the second case where we are excluding the currentIndex number\\n\\t\\t// We increment currentIndex and our set remains unchanged\\n\\t\\thelper(currentIndex + 1, set);\\n\\t};\\n\\t//1st call to recursive function\\n\\thelper(0, []);\\n\\n\\t// return our power set stored in finalOutput\\n\\treturn finalOutput;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/* This is a recursive solution\\nFor recursion we need 2 main thing:\\n1) Base case or the terminating condition\\n2) Next state transition/Recurrence Relation i.e\\n A way to move to next from current state/input\\n\\n In this problem our base case will be when we have\\n iterated through the entire length of array i.e\\n when currentIndex >= nums.length\\n\\n And we can apply common sense to derive recurrence relation.\\n So for currentIndex we have only two choices i.e.\\n we can either select/include the number at current index in out set\\n or we can exclude/pass the number at current index.\\n If we choose to include the number in our set when we can do it by [...set,nums[currentIndex]]\\n otherwise if we exclude/pass currentIndex num then our set will remain same as it was earlier i.e set\\n And in either case we will increment our currentIndex so that next time we \\n check for another number in nums array\\n\\n Now let\\'s look into the code \\n */\\nvar subsets = function (nums) {\\n\\t//Array finalOutput stores all the power sets\\n\\tlet finalOutput = [];\\n\\n\\t// Helper method is a recursive function that call\\'s itself\\n\\tconst helper = (currentIndex, set) => {\\n\\t\\t// Check for base case as stated above\\n\\t\\tif (currentIndex >= nums.length) {\\n\\t\\t\\t// push the set of current iteration in finalOutput\\n\\t\\t\\tfinalOutput.push(set);\\n\\t\\t\\treturn; //Necessary to end the recursion iteration\\n\\t\\t}\\n\\n\\t\\t//This is the 1st case where we are including the currentIndex number\\n\\t\\t// We increment currentIndex and add currentNumber i.e nums[currentIndex] in our set i.e. [...set, nums[currentIndex]]\\n\\t\\thelper(currentIndex + 1, [...set, nums[currentIndex]]);\\n\\n\\t\\t// This is the second case where we are excluding the currentIndex number\\n\\t\\t// We increment currentIndex and our set remains unchanged\\n\\t\\thelper(currentIndex + 1, set);\\n\\t};\\n\\t//1st call to recursive function\\n\\thelper(0, []);\\n\\n\\t// return our power set stored in finalOutput\\n\\treturn finalOutput;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1570009,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions-for-subsets",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n=nums.length;\\n        \\n        int range=1<<n;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<range;i++){\\n            int x=i;\\n            ArrayList<Integer> a=new ArrayList<>();\\n            int j=0;   \\n            while(x>0 && j<n){\\n                if((x&1)==1){\\n                    a.add(nums[n-1-j]);\\n                }\\n                j++;\\n                x=x>>1;\\n            }\\n            ans.add(a);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int n=nums.length;\\n        \\n        int range=1<<n;\\n        List<List<Integer>> ans=new ArrayList<>();\\n        for(int i=0;i<range;i++){\\n            int x=i;\\n            ArrayList<Integer> a=new ArrayList<>();\\n            int j=0;   \\n            while(x>0 && j<n){\\n                if((x&1)==1){\\n                    a.add(nums[n-1-j]);\\n                }\\n                j++;\\n                x=x>>1;\\n            }\\n            ans.add(a);\\n            \\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1308506,
                "title": "java-0ms-easy-solution",
                "content": "```\\nclass Solution {\\n    List<List<Integer>> lists;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        lists = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        solve(list,nums,0);\\n        \\n        return lists;\\n    }\\n    \\n    void solve(List<Integer> list,int[] nums,int curr)\\n    {\\n        \\n        if(curr == nums.length)\\n        {\\n            lists.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        List<Integer> list2 = new ArrayList(list);\\n        list.add(nums[curr]);\\n        solve(list2,nums,curr+1);\\n        solve(list,nums,curr+1);\\n        \\n    }\\n    \\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> lists;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        lists = new ArrayList<>();\\n        List<Integer> list = new ArrayList<>();\\n        solve(list,nums,0);\\n        \\n        return lists;\\n    }\\n    \\n    void solve(List<Integer> list,int[] nums,int curr)\\n    {\\n        \\n        if(curr == nums.length)\\n        {\\n            lists.add(new ArrayList(list));\\n            return;\\n        }\\n        \\n        List<Integer> list2 = new ArrayList(list);\\n        list.add(nums[curr]);\\n        solve(list2,nums,curr+1);\\n        solve(list,nums,curr+1);\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1213159,
                "title": "easiest-solution-with-recursive-tree-intuitive-java-diagram",
                "content": "**Intuition**\\n\\nThe intuition behind the following solution is too simple to believe. Let us first have a look at the following option tree : \\n\\n![image](https://assets.leetcode.com/users/images/1ca8ad88-a0dc-4995-82e0-ce6822177b98_1621218217.2663536.png)\\n\\nAs through observation, it is clear that we start with having a choice to pick or not pick from the first element and then, we propagate this choice down the tree. \\nSo, \\n1. we either pick the element and move ahead ( increment the index ) or,\\n2. we don\\'t pick the element and move ahead\\n\\n```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```\\n\\n\\nProceed to solve this related problem : [https://leetcode.com/problems/subsets-ii/](http://)\\n\\n[ Here is the explanation to the same ]\\n[https://leetcode.com/problems/subsets-ii/discuss/1213326/Simple-Intuitive-Solution-or-Using-HashSet](http://)",
                "solutionTags": [
                    "Java",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    List<List<Integer>> result;\\n    public List<List<Integer>> subsets(int[] nums) {\\n        result = new ArrayList();\\n        if(nums==null || nums.length==0) return result;\\n        \\n        subsets(nums,new ArrayList<Integer>(), 0);\\n        return result;\\n    }\\n    \\n    private void subsets(int[] nums, ArrayList<Integer> temp, int index) {\\n        // base condition\\n        if(index >= nums.length) {\\n            result.add(new ArrayList<>(temp));\\n            return;\\n        }\\n        \\n        // main logic\\n\\t\\t// case 1 : we pick the element\\n        temp.add(nums[index]);\\n        subsets(nums, temp, index+1); // move ahead\\n        temp.remove(temp.size()-1);\\n        \\n\\t\\t// case 2 : we don\\'t pick the element ( notice, we did not add the current element in our temporary list\\n        subsets(nums, temp, index+1); // move ahead\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1161814,
                "title": "java-easy-bit-manipulation",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> ans=  new ArrayList<>();\\n        for(int i= 0; i < (1 << nums.length); ++i){\\n            List<Integer> res = new ArrayList<>();\\n            for(int j= 0; j < nums.length; ++j){\\n                if(((i >> j) & 1 )!= 0)res.add(nums[j]);\\n            }\\n            \\n            ans.add(new ArrayList(res));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> ans=  new ArrayList<>();\\n        for(int i= 0; i < (1 << nums.length); ++i){\\n            List<Integer> res = new ArrayList<>();\\n            for(int j= 0; j < nums.length; ++j){\\n                if(((i >> j) & 1 )!= 0)res.add(nums[j]);\\n            }\\n            \\n            ans.add(new ArrayList(res));\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083568,
                "title": "4-different-solutions-to-find-subsets",
                "content": "**Solution 1: Use python funciton itertools.combinations**\\n````\\nfrom itertools import combinations\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l = len(nums)\\n        ret = []\\n        for i in range(l+1):\\n            temp = list(map(list, combinations(nums, i)))\\n            ret += temp\\n        return ret\\n````\\n**Solution 2: Dynamic programming**\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            dp += [it + [n] for it in dp]\\n        return dp\\n```\\n**Solution 3: General recursion + backtracking solution**\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ret = []\\n        def dfs(i, path):\\n            ret.append(path)\\n            for j in range(i, len(nums)):\\n                dfs(j+1, path + [nums[j]]) # here should be j+1 rather than j!\\n        dfs(0, [])\\n        return ret\\n```\\n**Solution 4: Bit manipulation to find subsets**\\nUse bit manipulation to find subsets might be useful in other LeetCode problems.\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        # for example nums is [5, 6, 1], input number is 3, convert to binary is 011, then return list should be [6, 1]\\n\\t\\t# if input number is 5 which binary is 101, then return list is [5, 1]\\n        def bit2list(n):\\n            ret = []\\n            idx = 0\\n            while n:\\n                if n&1:\\n                    ret.append(nums[idx])\\n                n >>= 1\\n                idx += 1\\n            return ret\\n        # convert nums to binary, if len(nums)=3, output is 111; if len(nums)=4, output is 1111\\n        base, one = 0, 1\\n        for _ in range(len(nums)):\\n            base += one\\n            one <<= 1\\n        # Use bit manipulation to find subsets; e.g. base=11, subsets: 10, 01\\n\\t\\tret = []\\n        mask = base\\n        while mask:\\n            ret.append(bit2list(mask))\\n            mask = (mask - 1) & base\\n        return ret + [[]]\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Bit Manipulation",
                    "Recursion"
                ],
                "code": "````\\nfrom itertools import combinations\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l = len(nums)\\n        ret = []\\n        for i in range(l+1):\\n            temp = list(map(list, combinations(nums, i)))\\n            ret += temp\\n        return ret\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        dp = [[]]\\n        for n in nums:\\n            dp += [it + [n] for it in dp]\\n        return dp\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ret = []\\n        def dfs(i, path):\\n            ret.append(path)\\n            for j in range(i, len(nums)):\\n                dfs(j+1, path + [nums[j]]) # here should be j+1 rather than j!\\n        dfs(0, [])\\n        return ret\\n```\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        # for example nums is [5, 6, 1], input number is 3, convert to binary is 011, then return list should be [6, 1]\\n\\t\\t# if input number is 5 which binary is 101, then return list is [5, 1]\\n        def bit2list(n):\\n            ret = []\\n            idx = 0\\n            while n:\\n                if n&1:\\n                    ret.append(nums[idx])\\n                n >>= 1\\n                idx += 1\\n            return ret\\n        # convert nums to binary, if len(nums)=3, output is 111; if len(nums)=4, output is 1111\\n        base, one = 0, 1\\n        for _ in range(len(nums)):\\n            base += one\\n            one <<= 1\\n        # Use bit manipulation to find subsets; e.g. base=11, subsets: 10, 01\\n\\t\\tret = []\\n        mask = base\\n        while mask:\\n            ret.append(bit2list(mask))\\n            mask = (mask - 1) & base\\n        return ret + [[]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 946533,
                "title": "c-recursve-diagram-to-show-how-backtracking-works-here",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> currvec;\\n        subsets(nums, 0, currvec, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int> nums, int i, vector<int> currvec, vector<vector<int>>& subs) {\\n\\t\\n        subs.push_back(currvec);\\n\\t\\t\\n        for (int j = i; j < nums.size(); j++) {\\n            currvec.push_back(nums[j]);\\n            subsets(nums, j + 1, currvec, subs);\\n            currvec.pop_back();\\n        }\\n    }\\n};\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/c1b75fc0-1b93-4663-a0b1-ce558ffe9a1e_1606145921.6017413.png)\\n",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> subs;\\n        vector<int> currvec;\\n        subsets(nums, 0, currvec, subs);\\n        return subs;\\n    }\\nprivate:\\n    void subsets(vector<int> nums, int i, vector<int> currvec, vector<vector<int>>& subs) {\\n\\t\\n        subs.push_back(currvec);\\n\\t\\t\\n        for (int j = i; j < nums.size(); j++) {\\n            currvec.push_back(nums[j]);\\n            subsets(nums, j + 1, currvec, subs);\\n            currvec.pop_back();\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 917360,
                "title": "c",
                "content": "```\\npublic class Solution {\\n    private IList<IList<int>> res = new List<IList<int>>();\\n    \\n    public IList<IList<int>> Subsets(int[] nums) {\\n        if (nums == null || nums.Length == 0)\\n            return res;\\n        \\n        Backtrack(nums, 0, new List<int>());\\n        \\n        return res;\\n    }\\n    \\n    private void Backtrack(int[] nums, int i, List<int> cur)\\n    {\\n        res.Add(new List<int>(cur));\\n        \\n        if (nums.Length == i)\\n            return;\\n        \\n        for (int j = i; j < nums.Length; j++)\\n        {\\n            cur.Add(nums[j]);\\n            \\n            Backtrack(nums, j + 1, cur);\\n            \\n            cur.RemoveAt(cur.Count - 1);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private IList<IList<int>> res = new List<IList<int>>();\\n    \\n    public IList<IList<int>> Subsets(int[] nums) {\\n        if (nums == null || nums.Length == 0)\\n            return res;\\n        \\n        Backtrack(nums, 0, new List<int>());\\n        \\n        return res;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 891089,
                "title": "c-no-recursion-two-for-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>t;\\n        ans.push_back(t);\\n        for(int n:nums)\\n        {\\n            int s=ans.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                auto t1=ans[i];\\n                t1.push_back(n);\\n                ans.push_back(t1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int>t;\\n        ans.push_back(t);\\n        for(int n:nums)\\n        {\\n            int s=ans.size();\\n            for(int i=0;i<s;i++)\\n            {\\n                auto t1=ans[i];\\n                t1.push_back(n);\\n                ans.push_back(t1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760907,
                "title": "cpp-iterative-solution",
                "content": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**\\n \\n         vector<vector<int>> subsets;\\n         subsets.push_back({});\\n         int size=nums.size();\\n         for(int i=0;i<size;i++){\\n             int subsetsize=subsets.size();\\n             for(int j=0;j<subsetsize;j++){\\n                 vector<int>set=subsets[j];\\n                 set.push_back(nums[i]);\\n                 subsets.push_back(set);\\n             }\\n         }\\n        return subsets;",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "**PLEASE UPVOTE IF YOU LIKE THE SOLUTION**\\n \\n         vector<vector<int>> subsets;\\n         subsets.push_back({});\\n         int size=nums.size();\\n         for(int i=0;i<size;i++){\\n             int subsetsize=subsets.size();\\n             for(int j=0;j<subsetsize;j++){\\n                 vector<int>set=subsets[j];\\n                 set.push_back(nums[i]);\\n                 subsets.push_back(set);\\n             }\\n         }\\n        return subsets;",
                "codeTag": "Unknown"
            },
            {
                "id": 730024,
                "title": "java-clean-code-easy-to-understand-0-ms-time-100-faster",
                "content": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> answer = new ArrayList<> ();\\n        answer.add (new ArrayList<> ());\\n        \\n        for (int num : nums) {\\n            int size = answer.size ();\\n            \\n            for (int i = 0; i < size; i++) {\\n                List<Integer> curr = new ArrayList<> (answer.get (i));\\n                curr.add (num);\\n                answer.add (curr);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        \\n        List<List<Integer>> answer = new ArrayList<> ();\\n        answer.add (new ArrayList<> ());\\n        \\n        for (int num : nums) {\\n            int size = answer.size ();\\n            \\n            for (int i = 0; i < size; i++) {\\n                List<Integer> curr = new ArrayList<> (answer.get (i));\\n                curr.add (num);\\n                answer.add (curr);\\n            }\\n        }\\n        \\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729973,
                "title": "c-2-solutions-with-explanation",
                "content": "The last solution was inspired from leetcode solution\\n### Solution 1\\nThis solution is straightforward. Let\\'s take the example given in the q.\\nnums = [1,2,3]. Let ``i = 0`` the index we are looking at.\\nlet our ans be stored in the array = ans\\nEmpty is set is always a subset. So ans = ``[[]]``\\n\\nApporach: Iterate through the ans array and add nums[i] to that array and add this array to ans.\\n1. ``i=0; nums[i] =1; ans = [[]]``\\nans = [[],[1]];\\n2. ``i=1; nums[i]=2; ans = [[],[1]]``\\nNow we iterate over ans\\n```\\n[]  + 2 = [2]\\n[1] + 2 = [1,2]\\n```\\nPush these two values to ``ans = [[],[1],[2],[1,2]]``\\n3. ``i=2; nums[i]=3; ans = [[],[1],[2],[1,2]]``\\n\\tThis time we iterate over these 4 and inner arrays and add value 3 we get 4 more arrays.\\n```\\n[]    + 3 = [3]\\n[1]   + 3 = [1,3]\\n[2]   + 3 = [2,3]\\n[1,2] + 3 = [1,2,3]\\nadd these 4 new arrays to ans\\nans = [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n```\\nCODE: \\n```\\nclass Solution {\\npublic:\\n\\t//helper method\\n    void fillPowerSet(vector<int>& nums,int i,int n,vector<vector<int>>& ans){\\n        if(i==n) return;  //n is end of nums array if we reach there return\\n        int v = nums[i];  // The current element we are looking at\\n        vector<vector<int>>t = ans;  // temp array to store the arrays for current element\\n        for(auto x: t){\\n            x.push_back(v);   // add the current element\\n            ans.push_back(x);  // insert it to ans array\\n        }\\n        fillPowerSet(nums,i+1,n,ans);  // go for the next element (i = i+1)\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int i = 0, n=nums.size();\\n        if(n==0) return {};  // if empty array\\n        vector<vector<int>>ans;\\n        ans.push_back({});\\n        fillPowerSet(nums,i,n,ans);\\n        return ans;\\n    }\\n};\\n```\\nTime and space complexity will be: O(2^n * n)\\n2^n iteration for each n;\\n\\n### Solution 2 (backtracking)\\n1. Let i denote the length of the current combination\\n\\tWhen i = 0, we are looking for combination []\\n\\tWhen i=1, we want [1], [2], [3] and so on.\\n2. Let start be the index from which we want to have the combination\\n\\tWhen start = 0 and i = 1 we will get [1]  (nums[start] = 1)\\n\\tstart =1 and i=1 we will get [2] (nums[start] = 2)\\n\\tstart =2 and i=1 we will get [3] ((nums[start] = 3))\\n3. It can be seen as take the sub-array from nums as nums(start,i) where start is the starting index and i is the number of element we need from the start index. (This is just an analogy to understand)\\n4. state is a temporary array that will contain the combinations of i lentgth which will be added to ans once the length of state array is same as i which is the length of the combination we need\\n5. After each time we call backtrack function (bt) we will remove the last element to get the next combination\\n\\nCODE: \\n```\\nclass Solution {\\n  void bt(vector<int>& nums,int start,int i,int n,vector<vector<int>>& ans,vector<int>& state) {\\n    // If this state is complete add to ans\\n\\tif (state.size() == i)  ans.push_back(state);\\n\\n    for (int j = start; j < n; j++) {\\n      state.push_back(nums[j]); // push our element to this combination\\n      bt(nums,j + 1, i,n,ans,state); // go to next element (j=j+1)\\n      state.pop_back();  //remove the last element we added \\n    }\\n  }\\n\\n  vector<vector<int>> subsets(vector<int>& nums) {\\n    int n = nums.size();\\n\\tif(!n) return {}; //empty array\\n\\tvector<vector<int>>ans;\\n    for (int i = 0; i <= n; i++) {\\n\\t\\tvector<int>state;\\n      bt(nums,0,i,n,ans,state);\\n    }\\n    return ans;\\n  }\\n}\\n```\\nTIme and space complexity same as the previous solution: O(2^n *  n)\\n\\n- Leetcode solution contains a third solution with same time & same complexity but is better due to bit masking.\\n\\nThank you!",
                "solutionTags": [],
                "code": "```\\n[]  + 2 = [2]\\n[1] + 2 = [1,2]\\n```\n```\\n[]    + 3 = [3]\\n[1]   + 3 = [1,3]\\n[2]   + 3 = [2,3]\\n[1,2] + 3 = [1,2,3]\\nadd these 4 new arrays to ans\\nans = [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\\n```\n```\\nclass Solution {\\npublic:\\n\\t//helper method\\n    void fillPowerSet(vector<int>& nums,int i,int n,vector<vector<int>>& ans){\\n        if(i==n) return;  //n is end of nums array if we reach there return\\n        int v = nums[i];  // The current element we are looking at\\n        vector<vector<int>>t = ans;  // temp array to store the arrays for current element\\n        for(auto x: t){\\n            x.push_back(v);   // add the current element\\n            ans.push_back(x);  // insert it to ans array\\n        }\\n        fillPowerSet(nums,i+1,n,ans);  // go for the next element (i = i+1)\\n    }\\n    \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int i = 0, n=nums.size();\\n        if(n==0) return {};  // if empty array\\n        vector<vector<int>>ans;\\n        ans.push_back({});\\n        fillPowerSet(nums,i,n,ans);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n  void bt(vector<int>& nums,int start,int i,int n,vector<vector<int>>& ans,vector<int>& state) {\\n    // If this state is complete add to ans\\n\\tif (state.size() == i)  ans.push_back(state);\\n\\n    for (int j = start; j < n; j++) {\\n      state.push_back(nums[j]); // push our element to this combination\\n      bt(nums,j + 1, i,n,ans,state); // go to next element (j=j+1)\\n      state.pop_back();  //remove the last element we added \\n    }\\n  }\\n\\n  vector<vector<int>> subsets(vector<int>& nums) {\\n    int n = nums.size();\\n\\tif(!n) return {}; //empty array\\n\\tvector<vector<int>>ans;\\n    for (int i = 0; i <= n; i++) {\\n\\t\\tvector<int>state;\\n      bt(nums,0,i,n,ans,state);\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729931,
                "title": "explanation-provided-c-approach-using-bit-manipulation-bit-masking",
                "content": "```\\nclass Solution {\\npublic:\\n    // Time Complexity: O(N*2^N), Space Complexity: O(N*2^N)\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        // Loop is run from 0 to 2^nums.size()-1 because that will be the total number of subsets.\\n        for(int i=0;i< 1<<nums.size(); i++){\\n            vector<int> subset;\\n            int temp = i, bitPos = 0;\\n            // Checking each bit of a number from the \"for\" loop.\\n            while(temp){\\n                if(temp&1)\\n                    subset.push_back(nums[bitPos]);\\n                bitPos++;\\n                temp = temp>>1;\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nFeel free to ask any doubts in the **comment** section.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Time Complexity: O(N*2^N), Space Complexity: O(N*2^N)\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        // Loop is run from 0 to 2^nums.size()-1 because that will be the total number of subsets.\\n        for(int i=0;i< 1<<nums.size(); i++){\\n            vector<int> subset;\\n            int temp = i, bitPos = 0;\\n            // Checking each bit of a number from the \"for\" loop.\\n            while(temp){\\n                if(temp&1)\\n                    subset.push_back(nums[bitPos]);\\n                bitPos++;\\n                temp = temp>>1;\\n            }\\n            ans.push_back(subset);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519823,
                "title": "simple-intuitive-python-solution",
                "content": "![image](https://assets.leetcode.com/users/tohbaino/image_1582599357.png)\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        result = [[]]\\n        \\n        for num in nums:\\n            curRes = [val for val in result]\\n            for cur in curRes:\\n                result += [cur+[num]]\\n        \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        n = len(nums)\\n        result = [[]]\\n        \\n        for num in nums:\\n            curRes = [val for val in result]\\n            for cur in curRes:\\n                result += [cur+[num]]\\n        \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 347517,
                "title": "swift-solution-backtracking-explanation-with-simple-example",
                "content": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        var result = [[Int]]()\\n        var candidates = [Int]()\\n        let startIndex = 0\\n        \\n        backTracking(&result, &candidates, startIndex, nums)\\n        return result\\n    }\\n    \\n    // assume it\\'s like a tree, we do a similar \"inorder traversal\"\\n    private func backTracking(_ result: inout [[Int]], _ candidates: inout [Int], _ startIndex: Int, _ nums: [Int]) {\\n        // store each case(\"node\")\\'s value\\n        result.append(candidates)\\n        \\n        // try to find if it has \"children\", if no \"child\", we done\\n        for i in startIndex..<nums.count {\\n            // update candidates to next level\\'s value(child\\'s value)\\n            candidates.append(nums[i])\\n            \\n            // startIndex + 1, go next level(go to its child)\\n            backTracking(&result, &candidates, i+1, nums)\\n            \\n            // update candidates to previous level\\'s value(parent\\'s value)\\n            candidates.removeLast()\\n        }\\n    }\\n}\\n\\n// eg: [1, 2, 3]; assume it is like a tree (inorder traversal)\\n//                     []\\n//              /       \\\\       \\\\\\n//            [1]       [2]    [3]\\n//           /   \\\\       |\\n//       [1, 2]  [1, 3] [2, 3]\\n//         /\\n//     [1, 2, 3]\\n\\n// output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\\n```\\n",
                "solutionTags": [
                    "Swift",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        guard nums.count > 0 else { return [] }\\n        \\n        var result = [[Int]]()\\n        var candidates = [Int]()\\n        let startIndex = 0\\n        \\n        backTracking(&result, &candidates, startIndex, nums)\\n        return result\\n    }\\n    \\n    // assume it\\'s like a tree, we do a similar \"inorder traversal\"\\n    private func backTracking(_ result: inout [[Int]], _ candidates: inout [Int], _ startIndex: Int, _ nums: [Int]) {\\n        // store each case(\"node\")\\'s value\\n        result.append(candidates)\\n        \\n        // try to find if it has \"children\", if no \"child\", we done\\n        for i in startIndex..<nums.count {\\n            // update candidates to next level\\'s value(child\\'s value)\\n            candidates.append(nums[i])\\n            \\n            // startIndex + 1, go next level(go to its child)\\n            backTracking(&result, &candidates, i+1, nums)\\n            \\n            // update candidates to previous level\\'s value(parent\\'s value)\\n            candidates.removeLast()\\n        }\\n    }\\n}\\n\\n// eg: [1, 2, 3]; assume it is like a tree (inorder traversal)\\n//                     []\\n//              /       \\\\       \\\\\\n//            [1]       [2]    [3]\\n//           /   \\\\       |\\n//       [1, 2]  [1, 3] [2, 3]\\n//         /\\n//     [1, 2, 3]\\n\\n// output: [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197900,
                "title": "python-solution-with-intuitive-explanation",
                "content": "Find all leaf nodes:\\n```text\\n                        []        \\n                   /          \\\\        \\n                  /            \\\\     \\n                 /              \\\\\\n              [1]                []\\n           /       \\\\           /    \\\\\\n          /         \\\\         /      \\\\        \\n       [1 2]       [1]       [2]     []\\n      /     \\\\     /   \\\\     /   \\\\    / \\\\\\n  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []\\n```\\n\\n```python\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t# DFS\\n        self.res = []\\n        self.dfs(nums, 0, [])\\n        return self.res\\n    \\n    def dfs(self, nums, pos, tmp):\\n        self.res.append(tmp)\\n        for i in range(pos, len(nums)):\\n            self.dfs(nums, i+1, tmp+[nums[i]])\\n        \\n\\t\\t# BFS    \\n        # res = [[]]\\n        # for num in nums:\\n        #     size = len(res)\\n        #     for i in range(size):\\n        #         res.append(copy.deepcopy(res[i]))\\n        #         res[-1].append(num)\\n        # return res\\n```",
                "solutionTags": [],
                "code": "```text\\n                        []        \\n                   /          \\\\        \\n                  /            \\\\     \\n                 /              \\\\\\n              [1]                []\\n           /       \\\\           /    \\\\\\n          /         \\\\         /      \\\\        \\n       [1 2]       [1]       [2]     []\\n      /     \\\\     /   \\\\     /   \\\\    / \\\\\\n  [1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []\\n```\n```python\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n\\t\\t# DFS\\n        self.res = []\\n        self.dfs(nums, 0, [])\\n        return self.res\\n    \\n    def dfs(self, nums, pos, tmp):\\n        self.res.append(tmp)\\n        for i in range(pos, len(nums)):\\n            self.dfs(nums, i+1, tmp+[nums[i]])\\n        \\n\\t\\t# BFS    \\n        # res = [[]]\\n        # for num in nums:\\n        #     size = len(res)\\n        #     for i in range(size):\\n        #         res.append(copy.deepcopy(res[i]))\\n        #         res[-1].append(num)\\n        # return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27430,
                "title": "5-line-python-code-with-easy-explanation",
                "content": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for i in range(len(nums)):\\n            k = nums[i]\\n            res += map(lambda x:x+[k],res)\\n        return res\\n```\\nlet nums = [1,2,3]\\nFirst initialize res as empty list [[]], then pick the first element from nums, that is 1. Then append 1 to all subsets in res, also append the original res to update current res, so res becomes[[],[1]], then pick 2 from nums, res becomes[[],[1],[2],[1,2]]. Finally pick 3 from nums, res becomes [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]. This can be done easily by lambda functions.",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def subsets(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[List[int]]\\n        \"\"\"\\n        res = [[]]\\n        for i in range(len(nums)):\\n            k = nums[i]\\n            res += map(lambda x:x+[k],res)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 27481,
                "title": "java-straight-forward-iteration-method-easy-to-understand",
                "content": "Basic thought is that for every value in nums, generate new list based on result list with adding value to the result list, and add new list to the result list.\\n\\n    public class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n\\n            for(int value : nums) { // for every value in nums, check the list, \\n                if(list.isEmpty()) {\\n                    list.add(new ArrayList(Arrays.asList(value)));\\n                } else {\\n                    int size = list.size();\\n                    for(int i = 0; i < size; i++) {\\n                        List<Integer> temp = new ArrayList<>(list.get(i)); // based on exist list\\n                        temp.add(value); // add value to each list\\n                        list.add(temp);\\n                    }\\n                    list.add(new ArrayList(Arrays.asList(value))); // add current single value\\n                }\\n            }\\n            \\n            list.add(new ArrayList<Integer>());\\n            return list;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public List<List<Integer>> subsets(int[] nums) {\\n            List<List<Integer>> list = new ArrayList<List<Integer>>();\\n            Arrays.sort(nums);\\n\\n            for(int value : nums) { // for every value in nums, check the list, \\n                if(list.isEmpty()) {\\n                    list.add(new ArrayList(Arrays.asList(value)));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3741158,
                "title": "c-bit-mask-vs-backtracking-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe code uses bit manipulation to generate all possible subsets of the input vector. It creates a vector called powerSet to store the subsets. The outer loop iterates from m = 0 to m = Mask - 1, representing all possible binary numbers of length n, where n is the size of the input vector. \\n\\nThe inner loop iterates through the elements of the input vector nums and checks if the i-th bit of m is set (i.e., if m & (1 << i) evaluates to true). If the bit is set, it adds the corresponding element nums[i] to the subset stored in powerSet[m]. Finally, it returns the generated power set powerSet.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$ O(2^N * N)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$ O(2^N * N)$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int Mask=1<<n;\\n        vector<vector<int>> powerSet(Mask);\\n        for (int m=0; m<Mask; m++){\\n            for(int i=0; i<n; i++){\\n                if (m& 1<<i)\\n                    powerSet[m].push_back(nums[i]);\\n            }\\n        }\\n        return powerSet;\\n    }\\n};\\n```\\n# Code with Comments\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();                        // Get the size of the input vector\\n        int Mask = 1 << n;                           // Calculate the maximum number of subsets using bit manipulation\\n        vector<vector<int>> powerSet(Mask);          // Create a vector to store all the subsets\\n        \\n        for (int m = 0; m < Mask; m++) {              // Iterate through all the possible combinations of subsets\\n            for (int i = 0; i < n; i++) {             // Iterate through the elements of the input vector\\n                if (m & (1 << i))                     // Check if the i-th bit of m is set\\n                    powerSet[m].push_back(nums[i]);  // If the bit is set, add the corresponding element to the subset\\n            }\\n        }\\n        \\n        return powerSet;                             // Return the generated power set\\n    }\\n};\\n\\n```\\n# Code using Backtracking beats 100%\\n```\\nclass Solution {\\npublic:\\nint n;\\n    vector<vector<int>> powerSet;\\n    void dfs(int idx, vector<int> subset, vector<int>& nums ){\\n       \\n        powerSet.push_back(subset);\\n        \\n        for(int i=idx; i<n; i++){\\n            subset.push_back(nums[i]);\\n            dfs(i+1, subset, nums);\\n            subset.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n=nums.size();\\n        dfs(0,  {}, nums);\\n        \\n        return powerSet;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Backtracking",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n=nums.size();\\n        int Mask=1<<n;\\n        vector<vector<int>> powerSet(Mask);\\n        for (int m=0; m<Mask; m++){\\n            for(int i=0; i<n; i++){\\n                if (m& 1<<i)\\n                    powerSet[m].push_back(nums[i]);\\n            }\\n        }\\n        return powerSet;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();                        // Get the size of the input vector\\n        int Mask = 1 << n;                           // Calculate the maximum number of subsets using bit manipulation\\n        vector<vector<int>> powerSet(Mask);          // Create a vector to store all the subsets\\n        \\n        for (int m = 0; m < Mask; m++) {              // Iterate through all the possible combinations of subsets\\n            for (int i = 0; i < n; i++) {             // Iterate through the elements of the input vector\\n                if (m & (1 << i))                     // Check if the i-th bit of m is set\\n                    powerSet[m].push_back(nums[i]);  // If the bit is set, add the corresponding element to the subset\\n            }\\n        }\\n        \\n        return powerSet;                             // Return the generated power set\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\nint n;\\n    vector<vector<int>> powerSet;\\n    void dfs(int idx, vector<int> subset, vector<int>& nums ){\\n       \\n        powerSet.push_back(subset);\\n        \\n        for(int i=idx; i<n; i++){\\n            subset.push_back(nums[i]);\\n            dfs(i+1, subset, nums);\\n            subset.pop_back();\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        n=nums.size();\\n        dfs(0,  {}, nums);\\n        \\n        return powerSet;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3596405,
                "title": "best-solution",
                "content": "# Approach\\nUsing Recursion\\n\\n# Complexity\\n- Time complexity:\\n$$O(2^n*k)$$ --> k is average length of every subset\\n\\n- Space complexity:\\n$$O(2^n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[idx]);\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n        temp.pop_back();\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:    \\n    void subsetHelper(int idx, vector<int>& nums, int n, vector<int> &temp, vector<vector<int>>& ans) {\\n        if (idx == n) {\\n            ans.push_back(temp);\\n            return;\\n        }\\n        temp.push_back(nums[idx]);\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n        temp.pop_back();\\n        subsetHelper(idx+1, nums, n, temp, ans);\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> ans;\\n        vector<int> temp;\\n        subsetHelper(0, nums, n, temp, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3432033,
                "title": "easy-python-solution-using-recursion",
                "content": "# Code\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l=[]\\n        def subs(idx,tmp,lst,n,l):\\n            if idx>n:\\n                l.append(lst[:])\\n                return \\n            lst.append(tmp[idx])\\n            subs(idx+1,tmp,lst,n,l)\\n            lst.pop()\\n            subs(idx+1,tmp,lst,n,l)\\n            return \\n        lst=[]\\n        l=[]\\n        n=len(nums)-1\\n        subs(0,nums,lst,n,l)\\n        return sorted(l)\\n\\n       \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        l=[]\\n        def subs(idx,tmp,lst,n,l):\\n            if idx>n:\\n                l.append(lst[:])\\n                return \\n            lst.append(tmp[idx])\\n            subs(idx+1,tmp,lst,n,l)\\n            lst.pop()\\n            subs(idx+1,tmp,lst,n,l)\\n            return \\n        lst=[]\\n        l=[]\\n        n=len(nums)-1\\n        subs(0,nums,lst,n,l)\\n        return sorted(l)\\n\\n       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939690,
                "title": "c-easy-to-understand-best-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void arrr(vector<vector<int>> &ans, int k) {\\n        vector<vector<int>> temp = ans;\\n        for (int i = 0; i < temp.size(); ++i) {\\n            temp[i].push_back(k);\\n            ans.push_back(temp[i]);\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& n) {\\n        vector<vector<int>> ans;\\n        ans.push_back(vector<int>());\\n        for (int i = 0; i < n.size(); ++i) {\\n            arrr(ans, n[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void arrr(vector<vector<int>> &ans, int k) {\\n        vector<vector<int>> temp = ans;\\n        for (int i = 0; i < temp.size(); ++i) {\\n            temp[i].push_back(k);\\n            ans.push_back(temp[i]);\\n        }\\n    }\\n\\n    vector<vector<int>> subsets(vector<int>& n) {\\n        vector<vector<int>> ans;\\n        ans.push_back(vector<int>());\\n        for (int i = 0; i < n.size(); ++i) {\\n            arrr(ans, n[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630421,
                "title": "java-iterative-approach",
                "content": "```\\n        List<List<Integer>> ans=new ArrayList<>();\\n        ans.add(new ArrayList<Integer>());//[]\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int n=ans.size();\\n            for(int j=0;j<n;j++){\\n                List<Integer> temp=new ArrayList(ans.get(j));\\n                temp.add(nums[i]);\\n                ans.add(temp);\\n            }\\n        }\\n       return ans; \\n",
                "solutionTags": [],
                "code": "```\\n        List<List<Integer>> ans=new ArrayList<>();\\n        ans.add(new ArrayList<Integer>());//[]\\n        \\n        for(int i=0;i<nums.length;i++){\\n            int n=ans.size();\\n            for(int j=0;j<n;j++){\\n                List<Integer> temp=new ArrayList(ans.get(j));\\n                temp.add(nums[i]);\\n                ans.add(temp);\\n            }\\n        }\\n       return ans; \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2331563,
                "title": "python-simple-backtracking-solution-clean-and-easy",
                "content": "**UPVOTE PLS :-)**\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        def backtrackMe(i,temp):\\n            if i==len(nums):\\n                ans.append(temp.copy())\\n                return\\n            else:\\n                backtrackMe(i+1,temp+[nums[i]])\\n                backtrackMe(i+1,temp)\\n        backtrackMe(0,[])\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        ans=[]\\n        def backtrackMe(i,temp):\\n            if i==len(nums):\\n                ans.append(temp.copy())\\n                return\\n            else:\\n                backtrackMe(i+1,temp+[nums[i]])\\n                backtrackMe(i+1,temp)\\n        backtrackMe(0,[])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2301048,
                "title": "simple-js-solution-w-comments-bractracking",
                "content": "```\\n/**\\n * *Time: O(N x 2^N)\\n * *Space: O(N)\\n */\\n// Runtime: 112 ms, faster than 21.68% of JavaScript online submissions for Subsets.\\n// Memory Usage: 44.2 MB, less than 35.31% of JavaScript online submissions for Subsets.\\nconst subsets = nums => {\\n\\tconst output = [];\\n\\n\\tconst backtrack = (idx, subset) => {\\n\\t\\toutput.push([...subset]);\\n\\n    // for each of the current subset\\n    // recursively generate all possible subsets by increasing the position by one\\n\\t\\tfor (let i = idx; i < nums.length; i++) {\\n\\t\\t\\tsubset.push(nums[i]);\\n\\t\\t\\tbacktrack(i + 1, subset); // create next subset\\n\\t\\t\\tsubset.pop(); // backtrack\\n\\t\\t}\\n\\t};\\n\\n\\tbacktrack(0, []);\\n\\treturn output;\\n};\\n\\n// subset\\n// []\\n// [ 1 ]\\n// [ 1, 2 ]\\n// [ 1, 2, 3 ]\\n// [ 1, 3 ]\\n// [ 2 ]\\n// [ 2, 3 ]\\n// [ 3 ]\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Backtracking"
                ],
                "code": "```\\n/**\\n * *Time: O(N x 2^N)\\n * *Space: O(N)\\n */\\n// Runtime: 112 ms, faster than 21.68% of JavaScript online submissions for Subsets.\\n// Memory Usage: 44.2 MB, less than 35.31% of JavaScript online submissions for Subsets.\\nconst subsets = nums => {\\n\\tconst output = [];\\n\\n\\tconst backtrack = (idx, subset) => {\\n\\t\\toutput.push([...subset]);\\n\\n    // for each of the current subset\\n    // recursively generate all possible subsets by increasing the position by one\\n\\t\\tfor (let i = idx; i < nums.length; i++) {\\n\\t\\t\\tsubset.push(nums[i]);\\n\\t\\t\\tbacktrack(i + 1, subset); // create next subset\\n\\t\\t\\tsubset.pop(); // backtrack\\n\\t\\t}\\n\\t};\\n\\n\\tbacktrack(0, []);\\n\\treturn output;\\n};\\n\\n// subset\\n// []\\n// [ 1 ]\\n// [ 1, 2 ]\\n// [ 1, 2, 3 ]\\n// [ 1, 3 ]\\n// [ 2 ]\\n// [ 2, 3 ]\\n// [ 3 ]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1995496,
                "title": "easy-to-understand-python-recursion-solution",
                "content": "\\n\\n![image](https://assets.leetcode.com/users/images/88e79e57-7364-4dfa-a858-88c750d129ac_1651349284.1383734.png)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def recursion(idx, currentSet):\\n            if idx == len(nums):\\n                results.append(currentSet)\\n                return\\n            \\n            #including the item at idx\\n            recursion(idx + 1, currentSet + [nums[idx]])\\n            #excluding the item at idx\\n            recursion(idx + 1, currentSet)\\n        \\n        results = []\\n        recursion(0,[])\\n        return results\\n```\\n\\nplease UPVOTE if you like \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        \\n        def recursion(idx, currentSet):\\n            if idx == len(nums):\\n                results.append(currentSet)\\n                return\\n            \\n            #including the item at idx\\n            recursion(idx + 1, currentSet + [nums[idx]])\\n            #excluding the item at idx\\n            recursion(idx + 1, currentSet)\\n        \\n        results = []\\n        recursion(0,[])\\n        return results\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1858250,
                "title": "python-solutions-dp-bit-masking-recursion",
                "content": "# Method 1: using Dp.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for i in nums: res += [j+[i] for j in res]\\n        return res\\n# Method 2: using bit masking.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        for i in range(1<<n):\\n            ans = []\\n            for j in range(n):\\n                if i & 1<<j: ans.append(nums[j])\\n            res.append(ans)\\n        return res\\n\\n# Method 3: using recursion.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        def sub(i, l):\\n            if i == n:\\n                res.append(l)\\n                return\\n            sub(i + 1, l + [nums[i]])\\n            sub(i + 1, l)\\n        sub(0,[])\\n        return res\\n# please upvote if you like it!!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "# Method 1: using Dp.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res = [[]]\\n        for i in nums: res += [j+[i] for j in res]\\n        return res\\n# Method 2: using bit masking.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        for i in range(1<<n):\\n            ans = []\\n            for j in range(n):\\n                if i & 1<<j: ans.append(nums[j])\\n            res.append(ans)\\n        return res\\n\\n# Method 3: using recursion.\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        res, n = [], len(nums)\\n        def sub(i, l):\\n            if i == n:\\n                res.append(l)\\n                return\\n            sub(i + 1, l + [nums[i]])\\n            sub(i + 1, l)\\n        sub(0,[])\\n        return res\\n# please upvote if you like it!!",
                "codeTag": "Python3"
            },
            {
                "id": 1767767,
                "title": "c-simplest-short-solution-no-recursion-0-ms-faster-than-100",
                "content": "We start with a group that contains only the empty group.\\nThem, for each number in `nums`, we add it to all the previous groups.\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> res = {{}};\\n        vector<int> curr;\\n        int size;\\n        \\n        for (auto num : nums) {\\n            size = res.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                curr = res[i];\\n                curr.push_back(num);\\n                res.push_back(curr);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1767761,
                "title": "all-subsets-short-simple-8-lines-of-code-in-c-using-power-set",
                "content": "**Intuition :** Total number of subsets will be 2 to the power of `n` where n is the length of the given `nums` array. So if we find all the set bits for each positions for all the number between 0 to 2 to the power of `n`, we can replace the `nums[i]` (where i is the position of the number\\'s bit representation, if i th position is set bit or not) for each set bit positions consecutively. If we find that the i th position is set bit then we\\'ll put nums[i] in the postion and we\\'ll push back that into the resultant vector `res` and res vector into `ans`.\\n\\n**Note :** `1<<nums.size()` == `2 to the power of n` and `i & (1<<j)` with this we are checking if the jth position is set bit or not.\\n\\nIf you like this solution please upvote this THANKS **: )** \\n\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<(1<<nums.size()); i++){\\n            vector<int> res;\\n            \\n            for(int j=0; j<nums.size(); j++){\\n                if(i & (1<<j))\\n                    res.push_back(nums[j]);\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nIf you get any doubt  please comment down below...I\\'ll give my best to clear your doubtsb",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        \\n        for(int i=0; i<(1<<nums.size()); i++){\\n            vector<int> res;\\n            \\n            for(int j=0; j<nums.size(); j++){\\n                if(i & (1<<j))\\n                    res.push_back(nums[j]);\\n            }\\n            ans.push_back(res);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1603493,
                "title": "rust-fast-100",
                "content": "```\\nimpl Solution {\\n    pub fn subsets(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        if nums.len() == 0{\\n            return vec![vec![]];\\n        }\\n        let last = nums.pop().unwrap();\\n        let remain_subsets = Self::subsets(nums);\\n        let mut res = remain_subsets.clone();\\n        for mut v in remain_subsets{\\n            v.push(last);\\n            res.push(v);\\n        }\\n        res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn subsets(mut nums: Vec<i32>) -> Vec<Vec<i32>> {\\n        if nums.len() == 0{\\n            return vec![vec![]];\\n        }\\n        let last = nums.pop().unwrap();\\n        let remain_subsets = Self::subsets(nums);\\n        let mut res = remain_subsets.clone();\\n        for mut v in remain_subsets{\\n            v.push(last);\\n            res.push(v);\\n        }\\n        res\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899942,
                "title": "simple-recursive-scala",
                "content": "```scala\\nobject Solution {\\n  def subsets(nums: Array[Int]): List[List[Int]] = {\\n    @annotation.tailrec\\n    def go(as: List[Int], acc: List[List[Int]]): List[List[Int]] = {\\n      as match {\\n        case Nil => acc\\n        case h::t => go(t, acc ::: acc.map(_.appended(h)))\\n      }\\n    }\\n\\n    go(nums.toList, List(List()))\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```scala\\nobject Solution {\\n  def subsets(nums: Array[Int]): List[List[Int]] = {\\n    @annotation.tailrec\\n    def go(as: List[Int], acc: List[List[Int]]): List[List[Int]] = {\\n      as match {\\n        case Nil => acc\\n        case h::t => go(t, acc ::: acc.map(_.appended(h)))\\n      }\\n    }\\n\\n    go(nums.toList, List(List()))\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 852038,
                "title": "simple-cpp-recursive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        return v;\\n    }\\n};\\n```\\nFor understanding the concept behind this solution check this-\\nhttps://www.youtube.com/watch?v=Yg5a2FxU4Fo&list=PL_z_8CaSLPWeT1ffjiImo0sYTcnLzo-wY&index=12",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<int>nums,vector<int>op,vector<vector<int>>& v)\\n    {  if(nums.size()==0)\\n        {   v.push_back(op);\\n            return;\\n        }\\n        vector<int>op1;\\n        vector<int>op2;\\n        for(int i=0;i<op.size();i++)\\n        {   op1.push_back(op[i]);\\n            op2.push_back(op[i]);\\n        }\\n        op2.push_back(nums[0]);\\n        vector<int>::iterator it;\\n        it=nums.begin();\\n        nums.erase(it);\\n        solve(nums,op1,v);\\n        solve(nums,op2,v);\\n        return;\\n    }\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>>v;\\n        vector<int>op;\\n        solve(nums,op,v);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730432,
                "title": "swift-8ms-solution",
                "content": "```\\nfinal class Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var arrayVales = [[Int]]()\\n        arrayVales.append([])\\n        for num in nums {\\n            for val in arrayVales {\\n                var valUpdate = val\\n                valUpdate.append(num)\\n                arrayVales.append(valUpdate)\\n            }\\n        }\\n        return arrayVales\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nfinal class Solution {\\n    func subsets(_ nums: [Int]) -> [[Int]] {\\n        var arrayVales = [[Int]]()\\n        arrayVales.append([])\\n        for num in nums {\\n            for val in arrayVales {\\n                var valUpdate = val\\n                valUpdate.append(num)\\n                arrayVales.append(valUpdate)\\n            }\\n        }\\n        return arrayVales\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729871,
                "title": "java-bitmask-solution",
                "content": "Explanation: In order to generate every subset, we decide wether or not to put an element of the array. Using combinatorics, the number of different subsets is `2^(num_of_elements)`, because for every element, we put it or not.\\n\\nInterestingly, if we take the binary representation of all the numbers from zero up to `2^(num_of_elements) - 1`, we can use the bits of those numbers to decide wether or not to put the corresponding number from the array. Notice that, starting from zero and going up to `2^(num_of_elements) - 1`, there are `2^(num_of_elements)` different values.\\n\\nIt works like this. Suppose your array has 5 elements. We then start from `0` and go up to `(2^5) - 1`. Using the describe approach, we then start with a bitmask containing `00000`. If a bit is zero it means `do not put the element at the correspoding bit position on the subset` and 1 means `put it on the subset`. For the first number, we have the empty subset. We then add one to our bitmask, resulting in `00001`, meaning we now have a subset with the first element only. The next one would be `00010`, and the next `00011`, and so on. This way we generate all the possible subsets. The last bitmask has all the ones set (`11111`).\\n\\n**Remarks**\\n- Why `2^(num_of_elements) - 1` ? When doing, for example, `2^5` you will have `100000`, if you do `-1` on that you will have `11111`.\\n\\n```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int total = (int)Math.pow(2,nums.length)-1;\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\t//for every bitmask\\n        for(int i = 0; i <= total; i++) {\\n\\t\\t\\n            List<Integer> set = new ArrayList<Integer>();\\n\\t\\t\\t//for every element in the array\\n            for(int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\t//if the corresponding bit is set on the bitmask\\n                if ( ((i>>j)&1) == 1) set.add(nums[j]);\\n            }\\n\\t\\t\\t\\n            ans.add(set);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        int total = (int)Math.pow(2,nums.length)-1;\\n        List<List<Integer>> ans = new ArrayList<List<Integer>>();\\n\\t\\t//for every bitmask\\n        for(int i = 0; i <= total; i++) {\\n\\t\\t\\n            List<Integer> set = new ArrayList<Integer>();\\n\\t\\t\\t//for every element in the array\\n            for(int j = 0; j < nums.length; j++) {\\n\\t\\t\\t\\t//if the corresponding bit is set on the bitmask\\n                if ( ((i>>j)&1) == 1) set.add(nums[j]);\\n            }\\n\\t\\t\\t\\n            ans.add(set);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 707102,
                "title": "python-short-10-lines-with-complete-explanation",
                "content": "n is the length of the array.A subset is represented by a binarynumber of n bits.Each bit represents whether the number of that index exists in the subset or not.And the numbers that has this binary representation are [0,2^n-1] Now,we need to obtain the bits that are one\\'s in every number.\\n```Eg: input array = [4,7,6]\\n\\tExplanation:\\n\\tsubsets =[ ] [4] [7] [6] [4,7] [4,6]  [7,6] [4,7,6]\\n\\tThere are 3 numbers in the array i.e n = 3\\n\\tTherefore, no of subsets = 2^n = 2^3 = 8\\n\\tEach subset can be represented by a number in [0,2^n -1] i.e [0,1,2,3,4,5,6,7]\\n\\tbinary rep of 7 = \\'111\\'  => [4, 7, 6]\\n\\tbinary rep of 6 = \\'110\\'  => [4, 7   ]\\n\\tbinary rep of 5 = \\'101\\'  => [4,   ,6]\\n\\tbinary rep of 4 = \\'100\\'  => [4,      ]\\n\\t...... binary rep of 0 =\\'000\\' =>[ ]  i.e null set. \\n\\tSo,The idea is to represent [0,2^n -1] numbers in n-bit binary.\\n\\tFor each such number,find the subset by parsing the set-bits of binary number.\\n``` \\nNow, into the code. `Time:O(2^n),SpaceO(2^n)`\\n    \\n\\t\\t```python\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\trightEnd = 2**n\\n\\t\\t\\tres = []\\n\\t\\t\\tfor number in range(rightEnd):\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tfor bit in range(n):\\n\\t\\t\\t\\t\\tif 1<<bit & number:\\n\\t\\t\\t\\t\\t\\tans.append(nums[bit])\\n\\t\\t\\t\\tres.append(ans)\\n\\t\\t\\treturn res\\n\\t\\t\\t```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation"
                ],
                "code": "```Eg: input array = [4,7,6]\\n\\tExplanation:\\n\\tsubsets =[ ] [4] [7] [6] [4,7] [4,6]  [7,6] [4,7,6]\\n\\tThere are 3 numbers in the array i.e n = 3\\n\\tTherefore, no of subsets = 2^n = 2^3 = 8\\n\\tEach subset can be represented by a number in [0,2^n -1] i.e [0,1,2,3,4,5,6,7]\\n\\tbinary rep of 7 = \\'111\\'  => [4, 7, 6]\\n\\tbinary rep of 6 = \\'110\\'  => [4, 7   ]\\n\\tbinary rep of 5 = \\'101\\'  => [4,   ,6]\\n\\tbinary rep of 4 = \\'100\\'  => [4,      ]\\n\\t...... binary rep of 0 =\\'000\\' =>[ ]  i.e null set. \\n\\tSo,The idea is to represent [0,2^n -1] numbers in n-bit binary.\\n\\tFor each such number,find the subset by parsing the set-bits of binary number.\\n```\n```python\\t\\n\\t\\tclass Solution:\\n\\t\\t\\tdef subsets(self, nums: List[int]) -> List[List[int]]:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\trightEnd = 2**n\\n\\t\\t\\tres = []\\n\\t\\t\\tfor number in range(rightEnd):\\n\\t\\t\\t\\tans = []\\n\\t\\t\\t\\tfor bit in range(n):\\n\\t\\t\\t\\t\\tif 1<<bit & number:\\n\\t\\t\\t\\t\\t\\tans.append(nums[bit])\\n\\t\\t\\t\\tres.append(ans)\\n\\t\\t\\treturn res\\n\\t\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 364179,
                "title": "python-iterative-backtracking-with-detail-explanation-and-deep-copy-problem",
                "content": "**Iterative Approach**\\nThe ituition is that when we have a subset of itmes a[0] to a[k-1] (we name this subset S(k-1)) what we could do to obtain the subset of a[0] to a[k] (S(k)).\\nSince for new item a[k], the subset of a[0] to a[k] could eigher contain a[k] or not. And when it not caintain a[k], this part of subset becomes S(k-1). when it caintains a[k], we could just add a[k] to all the subset of a[0] to a[k-1]. So we could write down the following fomula:\\nS(k) = S(k-1) + S(k-1)Ua[k]\\nthen we could write down the following codes:\\n```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in nums:\\n            res = res + [s+[num] for s in res]\\n        return res\\n```\\ntime analysis:\\n* we iterate over all the element in nums. For each element a[i], we iterate all the subset of a[0] to a[i-1]. So every step the time complexity if O(|S(i-1)|)\\n* according to the S(k) = S(k-1) + S(k-1)Ua[k], we could know that the |S(k)| (which is the number of subset of a[0] to a[k]) have the relationship: |S(k)| = 2|S(k-1)| =...=2^k|S(0)|=O(2^k)\\n* so the total time complexity would be O(1)+O(2)+...+O(2^n)=O(2^n)\\nspace complexity:\\n* since we only use res to store results, so it\\'s O(2^n)\\n\\n**Backtracking**\\nSince it\\'s hard to decide what is the subset of n items, we could try to the  break big one to some smaller problems. For k items, we could decide whether or not to include the first one in k items. Then the problem becomes for k-1 items what is their subset. After obtaining k-1\\'s subsets, we know that the subsets of k-1 items are also subsets of k items for the reason that k items include k-1 items. And we could also add the first one in k items to all the subsets of k-1\\'s subsets. So the algorithm becomes:\\n* when the nums equals zero, it means there is zero elements to work. We have chosen all the elements in the subsets, we could append them in the result and return.\\n* choose not to include nums[0] in the subsets and explore all the subsets of nums[1:]\\n* choose to include nums[0] in the subsets and explore all the subsets of nums[1:]. So the choose becomes choose+nums[0]\\n*  unchoose nums[0] so when backtrack to the uppper level, so, we donot let chosen array grow without control\\n```\\nimport copy\\nclass Solution:\\n    def subsets(self, nums):\\n        N = len(nums)\\n        res = []\\n        def helper(nums, chosen):\\n            if nums == []:\\n                res.append(copy.deepcopy(chosen))\\n                return\\n\\t\\t\\t#choose & explore\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#choose & explore\\n            chosen.append(nums[0])\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#unchoose\\n            chosen.pop()\\n            return\\n        helper(nums, [])\\n        return res\\n```\\n**Deep copy problem!**\\nI try to use `res.append(chosen)` in the first time, but find ou the output is very wired!! If you try the code without use of deepcopy then you would find that every time you change chosen, the res also changes. This is because how python pass parameters and the effect of shallow copy. After appending chosen, res[-1] and chosen reference points to the same memory location. As a result even since you append chosen to res, every time you modify chosen, you also change the element in res.\\nBTW, I am also wondering if it is okay to work on the results in the base case. We could also modify the method so it returns the subsets. I am not sure which one is better.\\n\\nIf there is anything confusing or misleading, please comment below. I would try my best to clarify.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums):\\n        res = [[]]\\n        for num in nums:\\n            res = res + [s+[num] for s in res]\\n        return res\\n```\n```\\nimport copy\\nclass Solution:\\n    def subsets(self, nums):\\n        N = len(nums)\\n        res = []\\n        def helper(nums, chosen):\\n            if nums == []:\\n                res.append(copy.deepcopy(chosen))\\n                return\\n\\t\\t\\t#choose & explore\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#choose & explore\\n            chosen.append(nums[0])\\n            helper(nums[1:], chosen)\\n\\t\\t\\t#unchoose\\n            chosen.pop()\\n            return\\n        helper(nums, [])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351704,
                "title": "javascript-recursive",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let res = [];\\n    const helper = (nums, i, arr) => {\\n        if(i === nums.length) {\\n            res.push(arr);\\n            return;\\n        }\\n        helper(nums, i+1, arr);\\n        helper(nums, i+1, arr.concat(nums[i]));\\n    };\\n    helper(nums, 0, []);\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[][]}\\n */\\nvar subsets = function(nums) {\\n    let res = [];\\n    const helper = (nums, i, arr) => {\\n        if(i === nums.length) {\\n            res.push(arr);\\n            return;\\n        }\\n        helper(nums, i+1, arr);\\n        helper(nums, i+1, arr.concat(nums[i]));\\n    };\\n    helper(nums, 0, []);\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 310034,
                "title": "simple-python-dfs-solutions-for-similar-backtrack-problems",
                "content": "Please see and vote for my simple solutions for\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n\\n[39. Combination Sum](https://leetcode.com/problems/combination-sum/discuss/310038/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[40. Combination Sum II](https://leetcode.com/problems/combination-sum-ii/discuss/310039/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\\n[216. Combination Sum III](https://leetcode.com/problems/combination-sum-iii/discuss/310040/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\\n[77. Combinations](https://leetcode.com/problems/combinations/discuss/1023998/Simple-Python-DFS-solutions-for-similar-backtrack-problems)\\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\\n[46. Permutation](https://leetcode.com/problems/permutations/discuss/309478/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[47. Permutation II](https://leetcode.com/problems/permutations-ii/discuss/309479/Simple-Python-DFS-solution)\\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\\n[267. Palindrome Permutation II](https://leetcode.com/problems/palindrome-permutation-ii/discuss/310033/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\\n[78. Subsets](https://leetcode.com/problems/subsets/discuss/310034/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\\n[90. Subsets II](https://leetcode.com/problems/subsets-ii/discuss/310037/Simple-Python-DFS-solutions-for-8-backtrack-problems)\\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], i+j, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\\n        def dfs(comb, i, target, res):\\n            if target == 0:\\n                res.append(comb)\\n                return\\n            selected = set()\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target and x not in selected:\\n                    selected.add(x)\\n                    target -= x\\n                    dfs(comb + [x], i+j+1, target, res)\\n                    target += x\\n        \\n        candidates.sort()\\n        res = []\\n        dfs([], 0, target, res)\\n        return res\\n```\n```\\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\\n        def dfs(comb, res, k, target, i):\\n            if len(comb) == k and target == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(candidates[i:]):\\n                if x <= target:\\n                    target -= x\\n                    dfs(comb + [x], res, k, target, i+j+1)\\n                    target += x\\n        \\n        candidates = [1, 2, 3, 4, 5, 6, 7, 8, 9]\\n        res = []\\n        dfs([], res, k, n, 0)\\n        return res\\n```\n```\\n    def combine(self, n: int, k: int) -> List[List[int]]:\\n        def dfs(i, k, comb):\\n            if k == 0:\\n                res.append(comb)\\n                return\\n            for j,x in enumerate(nums[i:]):\\n                dfs(i + j + 1, k - 1, comb + [x])\\n            \\n        nums = list(range(1, n + 1))\\n        res = []\\n        dfs(0, k, [])\\n        return res\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            for i,x in enumerate(nums):\\n\\t\\t\\t    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, permutation, result):\\n            if nums == []:\\n                result.append(permutation)\\n            selected = set()\\n            for i,x in enumerate(nums):\\n                if x not in selected:\\n\\t\\t\\t\\t    selected.add(x)\\n                    dfs(nums[:i] + nums[i+1:], permutation + [nums[i]], result)\\n        \\n        result = []\\n        dfs(nums, [], result)\\n        return result\\n```\n```\\n    def generatePalindromes(self, s: str) -> List[str]:\\n        def dfs(freq, fst_half, mid, res):\\n            if sum(freq.values()) == 0:\\n                res.append(fst_half + mid + fst_half[::-1])\\n                return\\n            for char in freq:\\n                if freq[char] > 0:\\n                    freq[char] -= 1\\n                    dfs(freq, fst_half + char, mid, res)\\n                    freq[char] += 1\\n                    \\n        freq = Counter(s)\\n        single = [char for char in freq if freq[char] % 2 == 1]\\n        if len(single) > 1:\\n            return []\\n        mid = single[0] if single else \\'\\'\\n        for char in freq:\\n            freq[char] //= 2\\n        res = []\\n        dfs(freq, \\'\\', mid, res)\\n        return res\\n```\n```\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(nums, res, path):\\n            if not nums:\\n                res.append(path)\\n                return\\n            dfs(nums[1:], res, path) # ignore the current element\\n            dfs(nums[1:], res, path+[nums[0]]) # select the current element\\n        \\n        res  = []\\n        dfs(nums, res, [])\\n        return res\\n```\n```\\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\\n        def dfs(count, res, path):\\n            if not count:\\n                res.append(path)\\n                return\\n            x = list(count.keys())[0]\\n            x_freq = count[x]\\n            del count[x]\\n            for i in range(x_freq + 1):\\n                dfs(count, res, path + i * [x])\\n            count[x] = x_freq\\n        \\n        c = Counter(nums)\\n        res  = []\\n        dfs(c, res, [])\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 277064,
                "title": "bfs-to-generate-subset",
                "content": "Recursion is my favorite solution. However, the interviewer might ask non-recursion solution. In this case, BFS could be helpful. \\n\\nImagine sub-set generation as an implicit binary tree, where the node is a set A, and its 2 children are A + [x] and A + []. \\n\\nDo a level order BFS, and stop at `level == len(nums)`\\n\\n```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        from collections import deque\\n        \\n        qu = deque([[]])\\n        \\n        i = 0\\n        while qu and i < len(nums):\\n            N = len(qu)\\n            \\n            for _ in range(N):\\n                lst = qu.popleft()\\n                \\n                qu.append(lst[:])\\n                qu.append(lst + [nums[i]])\\n            \\n            \\n            i += 1\\n            \\n        return list(qu)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def subsets(self, nums: List[int]) -> List[List[int]]:\\n        from collections import deque\\n        \\n        qu = deque([[]])\\n        \\n        i = 0\\n        while qu and i < len(nums):\\n            N = len(qu)\\n            \\n            for _ in range(N):\\n                lst = qu.popleft()\\n                \\n                qu.append(lst[:])\\n                qu.append(lst + [nums[i]])\\n            \\n            \\n            i += 1\\n            \\n        return list(qu)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231695,
                "title": "why-everybody-overthink-it-just-simple-recursion-beats-100-c",
                "content": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        return helper(nums, new List<IList<int>>(), 0);\\n    }\\n    \\n    public IList<IList<int>> helper(int[] nums, IList<IList<int>> ans, int index)\\n    {\\n        if(index == 0) ans.Add(new List<int>());\\n        if(index == nums.Length) return ans;\\n        int precount = ans.Count;\\n        for(int i = 0; i < precount; i++)\\n        {\\n            IList<int> cur = new List<int>(ans[i]);\\n            cur.Add(nums[index]);\\n            ans.Add(cur);\\n        }\\n        return helper(nums, ans, index + 1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<IList<int>> Subsets(int[] nums) {\\n        return helper(nums, new List<IList<int>>(), 0);\\n    }\\n    \\n    public IList<IList<int>> helper(int[] nums, IList<IList<int>> ans, int index)\\n    {\\n        if(index == 0) ans.Add(new List<int>());\\n        if(index == nums.Length) return ans;\\n        int precount = ans.Count;\\n        for(int i = 0; i < precount; i++)\\n        {\\n            IList<int> cur = new List<int>(ans[i]);\\n            cur.Add(nums[index]);\\n            ans.Add(cur);\\n        }\\n        return helper(nums, ans, index + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197551,
                "title": "simple-javascript-recursive-solution-inspired-by-sicp-exercise-2-32",
                "content": "```\\nfunction subsets(s) {\\n    if (s.length === 0) {\\n        return [[]]\\n    } else {\\n        let rest = subsets(s.slice(1))  \\n        let newSets = rest.map(         \\n            (set) => [s[0], ...set]\\n        )\\n        return [...rest, ...newSets]    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunction subsets(s) {\\n    if (s.length === 0) {\\n        return [[]]\\n    } else {\\n        let rest = subsets(s.slice(1))  \\n        let newSets = rest.map(         \\n            (set) => [s[0], ...set]\\n        )\\n        return [...rest, ...newSets]    \\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172300,
                "title": "java-a-dp-solution",
                "content": "```\npublic List<List<Integer>> subsets( int[] nums ) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> emptySubset = new ArrayList<>(); // 每个集合都有的 空子集\n        res.add(emptySubset);\n\n        for (int i = 0; i < nums.length; i++) {\n            // 遍历元素，将元素依次加进res的每个子集末尾，形成一个新子集；\n            int length = res.size();\n            for (int j = 0; j < length; j++) {\n                List<Integer> newSubset = new ArrayList<>(res.get(j));\n                newSubset.add(nums[i]);\n                res.add(newSubset);\n            }\n        }\n        return res;\n    }\n```",
                "solutionTags": [],
                "code": "```\npublic List<List<Integer>> subsets( int[] nums ) {\n        List<List<Integer>> res = new ArrayList<>();\n        List<Integer> emptySubset = new ArrayList<>(); // 每个集合都有的 空子集\n        res.add(emptySubset);\n\n        for (int i = 0; i < nums.length; i++) {\n            // 遍历元素，将元素依次加进res的每个子集末尾，形成一个新子集；\n            int length = res.size();\n            for (int j = 0; j < length; j++) {\n                List<Integer> newSubset = new ArrayList<>(res.get(j));\n                newSubset.add(nums[i]);\n                res.add(newSubset);\n            }\n        }\n        return res;\n    }\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 142650,
                "title": "a-c-0ms-solution-with-annotation",
                "content": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** subsets(int* nums, int numsSize, int** columnSizes, int* returnSize) {\\n        *returnSize = 1 << numsSize;                                    // Power set of S always has 2^|S| elements\\n\\n        /* Allocating memory dynamically */\\n        int** rv = malloc(sizeof(*rv) * *returnSize);                   // Returned array of arrays\\n        *columnSizes = malloc(sizeof(**columnSizes) * *returnSize);     // columnSizes output\\n        \\n        for (int i = 0; i < *returnSize; ++i) {\\n                \\n                /* popcount is an x86 instruction which returns the number of 1 bits in a register */\\n                /* GCC compiler supports a similar instruction, regardless of platform */\\n                (*columnSizes)[i] = __builtin_popcount(i);              // Let client know length of array\\n\\n                rv[i] = malloc(sizeof(*(rv[i])) * (*columnSizes)[i]);   // Allocate array\\n\\n                int rvi_idx = 0;                                        // Index into newly allocated rv[i] array\\n                \\n                /* Each of the first numsSize bits of `i` is associated with an integer in nums */\\n                for (int idx = 0; idx < numsSize; ++idx) {\\n                        if ((1 << idx) & i) {\\n                                /* If the idx\\'th bit of `i` is 1, then we add the idx\\'th num to rv[i] */\\n                                rv[i][rvi_idx++] = nums[idx];\\n                        }\\n                }\\n        }\\n        return rv;\\n        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Return an array of arrays of size *returnSize.\\n * The sizes of the arrays are returned as *columnSizes array.\\n * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().\\n */\\nint** subsets(int* nums, int numsSize, int** columnSizes, int* returnSize) {\\n        *returnSize = 1 << numsSize;                                    // Power set of S always has 2^|S| elements\\n\\n        /* Allocating memory dynamically */\\n        int** rv = malloc(sizeof(*rv) * *returnSize);                   // Returned array of arrays\\n        *columnSizes = malloc(sizeof(**columnSizes) * *returnSize);     // columnSizes output\\n        \\n        for (int i = 0; i < *returnSize; ++i) {\\n                \\n                /* popcount is an x86 instruction which returns the number of 1 bits in a register */\\n                /* GCC compiler supports a similar instruction, regardless of platform */\\n                (*columnSizes)[i] = __builtin_popcount(i);              // Let client know length of array\\n\\n                rv[i] = malloc(sizeof(*(rv[i])) * (*columnSizes)[i]);   // Allocate array\\n\\n                int rvi_idx = 0;                                        // Index into newly allocated rv[i] array\\n                \\n                /* Each of the first numsSize bits of `i` is associated with an integer in nums */\\n                for (int idx = 0; idx < numsSize; ++idx) {\\n                        if ((1 << idx) & i) {\\n                                /* If the idx\\'th bit of `i` is 1, then we add the idx\\'th num to rv[i] */\\n                                rv[i][rvi_idx++] = nums[idx];\\n                        }\\n                }\\n        }\\n        return rv;\\n        \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 27456,
                "title": "python-solution-inspired-by-prime-products",
                "content": "Python solution, similar to Prime Products and all kinds of num combination problems:\\n\\nReference: http://sahandsaba.com/interview-question-facebook-primes.html \\n\\n       class Solution:\\n            # @param S, a list of integer\\n            # @return a list of lists of integer\\n            def subsets(self, S):\\n                # Base result\\n                result = [[]]\\n                for num in S:\\n                    for element in result[:]:\\n                        x=element[:]\\n                        x.append(num)\\n                        result.append(x)\\n                return result",
                "solutionTags": [],
                "code": "Python solution, similar to Prime Products and all kinds of num combination problems:\\n\\nReference: http://sahandsaba.com/interview-question-facebook-primes.html \\n\\n       class Solution:\\n            # @param S, a list of integer\\n            # @return a list of lists of integer\\n            def subsets(self, S):\\n                # Base result\\n                result = [[]]\\n                for num in S:\\n                    for element in result[:]:\\n                        x=element[:]\\n                        x.append(num)\\n                        result.append(x)\\n                return result",
                "codeTag": "Java"
            },
            {
                "id": 27583,
                "title": "simple-backtracking-minimal-copying-16ms",
                "content": "Simply back-track, try both choosing the value at the given index or skipping it. \\n\\n    public:\\n        void op(const vector<int>& S, int idx){\\n            if(idx >= S.size()){\\n                mRes.push_back(mVec);\\n                return;\\n            }\\n            \\n            mVec.push_back(S[idx]);\\n            op(S, idx + 1);\\n            mVec.pop_back();\\n            op(S, idx + 1);\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            op(S, 0);\\n            return mRes;\\n        }\\n    \\n    private:\\n        vector<int> mVec;\\n        vector< vector<int> > mRes;",
                "solutionTags": [
                    "C++"
                ],
                "code": "Simply back-track, try both choosing the value at the given index or skipping it. \\n\\n    public:\\n        void op(const vector<int>& S, int idx){\\n            if(idx >= S.size()){\\n                mRes.push_back(mVec);\\n                return;\\n            }\\n            \\n            mVec.push_back(S[idx]);\\n            op(S, idx + 1);\\n            mVec.pop_back();\\n            op(S, idx + 1);\\n        }\\n    \\n        vector<vector<int> > subsets(vector<int> &S) {\\n            sort(S.begin(), S.end());\\n            op(S, 0);\\n            return mRes;\\n        }\\n    \\n    private:\\n        vector<int> mVec;\\n        vector< vector<int> > mRes;",
                "codeTag": "Unknown"
            },
            {
                "id": 27649,
                "title": "accepted-java-solution-dfs",
                "content": "Basic idea is: \\n\\n1. sort the array\\n2. start from the end of the array, for each element, do recursive call to get subset for element 'n-1'.  \\n3. Once get all sebset for n-1, then your subset for n will be :  Subset(n)= Subset(n-1)+(n itself) +(add n to Subset(n-1))\\n4. at last, don't forget to add [] , from OJ, it counts as one subset as well.\\n\\n \\n\\n      public class Solution {\\n    \\n        public List <List <Integer>> subsets (int[] S) {\\n            if (S == null)\\n                return null;\\n            Arrays.sort (S);\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            result = getSubSet (S, S.length - 1);\\n            result.add (new ArrayList <Integer> ());\\n            return result;\\n        }\\n    \\n        List <List <Integer>> getSubSet (int[] s, int index) {\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            if (index < 0) {\\n                return result;\\n            }\\n            List <List <Integer>> subResult = getSubSet (s, index - 1);\\n            result.addAll (subResult);\\n            for (int i = 0; i < subResult.size (); i++) {\\n                List <Integer> bList = new ArrayList <> ();\\n                bList.addAll (subResult.get (i));\\n                bList.add (s[index]);\\n                result.add (bList);\\n            }\\n            result.add (Arrays.asList (s[index]));\\n            return result;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    \\n        public List <List <Integer>> subsets (int[] S) {\\n            if (S == null)\\n                return null;\\n            Arrays.sort (S);\\n            List <List <Integer>> result = new ArrayList <List <Integer>> ();\\n            result = getSubSet (S, S.length - 1);\\n            result.add (new ArrayList <Integer> ());\\n            return result;\\n        }",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1804734,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575501,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1566209,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1926509,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1570208,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1568898,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1567345,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575771,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 2014481,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1936905,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1804734,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575501,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1566209,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1926509,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1570208,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1568898,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1567345,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1575771,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 2014481,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1936905,
                "content": [
                    {
                        "username": "sam02202001",
                        "content": "I am in a big confusion man !!\nHow these two codes are getting accepted successfully\nFirst - https://leetcode.com/problems/subsets/submissions/899975210/\nSecond - https://leetcode.com/problems/subsets/submissions/899974496/\n\nIn first i have used `if( ( i & (1 << j )) != 0 )` \nwhile in second I have used  `if( ( i & (1 << j )) == 0 )` \nHow these totally opposite conditions are leading to same answer "
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "https://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "YoussefMorad1",
                        "content": "Because you can have literally the same different subsets if you track the zeros (== 0) or you track the ones ( != 0), in the binary numbers from 0 to (2 ^ n) - 1\\n\\nLet n = 3, then in your code the i loop goes from 0 -> 7\\nnow let\\'s see the binary numbers of them\\n0 - 000\\n1 - 001\\n2 - 010\\n3 - 011\\n4 - 100\\n5 - 101\\n6 - 110\\n7 - 111\\n\\nNow if you notice, tracking 0s or 1s will give you the same different subsets of your array.\\n\\nwith the condition set as == 0:\\n000 -> gets the subset that has all 3 numbers from our array\\nBut\\n111 -> get an empty subset\\n\\nbut If the condition is != 0:\\n000 -> gets an empty subset\\nBut\\n111 -> gets the subset that has all 3 numbers from our array\\n\\nSo for example, the binary number 010 with condition set as == 0 gets you a subset, that 101 will get exactly the same subset with condition set as != 0, and so on\\n\\nwith this observation you can track each binary representation from 0 to (2^n) - 1. You can see that:\\neach binary representation has its complement (for example complement of 010 is 101), so if you did make your condition the opposite you still find the complement of each binary representation that gets you the same subset.\\n\\n\\n\\n"
                    },
                    {
                        "username": "penrosecat",
                        "content": "The subsets problem has two backtracking solutions, one in which we loop over all the elements in the rest of the array and add an element recur and remove the element and one in which we have two recursive calls for each element, one in which the present element is added and one in which the present element is skipped.\\n\\nThese can be explained as follows. \\n\\nIn the **first** way, we use the mathematical logic \"create every subset which contains this element for every element\".  Starting from a blank array, we first want to create every subset which contains nums[0]. So, we add nums[0] to a blank array. \\n\\nThinking mathematically again, all the subsets that contain nums[0] are all the subsets of the array excluding nums[0] to which nums[0] is added. Since the recursive function returns all the subsets beginning from the next index, it is time for a recursive call where the present element is included. After this call, all the subsets containing this element have been added and so it may be removed. \\n\\nThe reason for the loop to go over every element is that the subsets excluding the current element are always given by all the subsets that can be formed by including each one of the following elements as the beginning of the rest of the subset.\\n\\nIn the **second** way we use the combinatorial logic of every element can either \"be present or not be present\" in a subset. We make a recursive call where the element is not present and then one where it is present. There is no need for loops and when the present index reaches the end of the array it means another subset is completed and can be added to the result.\\n\\nThe second way is more straightforward since that is how most people view the construction of a subset, however the first way is more suited to a variety of approaches. For example in Subsets II, for both the approaches the only difference from Subsets is an if statement, however it is much easier to write this statement in the first case than in the second.\\n\\nFor Subsets II, repetitions are not allowed. So by sorting the array before performing either method, we ensure that we can easily check for the last inserted element.\\n\\nIn the first method if i > idx && A[idx-1] == A[idx] where idx is the beginning index for the iteration it suggests a duplicate element. However once we have a single copy inserted then the recursive calls will make sure that any copies are places always at i == idx and hence recursive calls will only add the duplicate values, never replace them.\\n\\nIn the second method, the recursive call to the non-appended array should be made only either the current array is empty or if the last element in the current array is not equal to the present element. Again, the appended call is always made since the subset with different number of duplicates is counted but one with replaced duplicates is not.\\n\\n"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\n\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "You are right. See my explanation: https://leetcode.com/problems/subsets/discussion/comments/1758105"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for February, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/subsets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Cascading\n\n  \n**Approach 2:** Backtracking\n\n  \n**Approach 3:** Lexicographic (Binary Sorted) Subsets\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "RedHessian",
                        "content": "Apparently the return order does matter.\n![image](https://i.imgur.com/rD0KZHZ.png)"
                    },
                    {
                        "username": "kaziabrarfiyaz",
                        "content": "\"The solution set must not contain duplicate subsets. Return the solution in any order.\" Read again. And your result contain duplicate subsets."
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "leetcodermax",
                        "content": "The description says, \"The solution set must not contain duplicate subsets.\", but the solution prints out duplicates incase input has duplicate numbers. For eg: [1,1,3]"
                    },
                    {
                        "username": "bizzy_",
                        "content": "Input cannot have duplicate numbers. Constraints are that all elements of nums are unique."
                    },
                    {
                        "username": "prasad_r",
                        "content": "Submission Result: Wrong Answer\\n\\nInput:\\t[1,2]\\nOutput:\\t[[],[1],[2],[2,1]]\\nExpected:\\t[[],[1],[2],[1,2]]"
                    },
                    {
                        "username": "muhammedirshadismail0722",
                        "content": "dp bottom up and recursive solution in python\\n\\nhttps://leetcode.com/problems/subsets/solutions/3929458/dp-bottom-up-and-recursive-solution-in-python/"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rahulpal201464",
                        "content": "show your code\\n"
                    },
                    {
                        "username": "dtorba",
                        "content": "Simple one liner in Python\\n\\n\\treturn [[nums[j] for j in range(len(nums)) if i >> j & 1] for i in range(2 ** len(nums))]"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "Understand is below INT_MIN."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/subsets/solutions/2887145/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "rajanbhagat92",
                        "content": "My code is working for the input [0] when click on the run button. However when I click on the submit button, it gives me error. Attached is the screenshot for clarity.\\n\\n![image](https://assets.leetcode.com/users/images/6aa833ba-3992-4889-aea5-b89c6c02a7cb_1632151978.9490027.jpeg)\\n"
                    },
                    {
                        "username": "rahulgupta1597",
                        "content": "don't declare global variable like this pass result array in function\n"
                    },
                    {
                        "username": "ab09",
                        "content": "HELP SOMEONE :(\nwhy my code passed [1,9,8,3,-1,5] testcase but fails for [1,9,8,3,-1,0]?\nit passes for any digit other than 0 at last place.\nmy code:\nclass Solution {\n    public void generate(HashSet<Integer> set, int i,int[] nums,HashSet<List<Integer>> result){\n        if(i==nums.length){\n            return;\n        }\n        for(int j=0;j<nums.length;j++){\n            if(!set.contains(nums[j])){\n                set.add(nums[j]);\n                if(!result.contains(new ArrayList<>(set))){\n                    result.add(new ArrayList<>(set));\n                }\n                generate(set,i+1,nums,result);\n                set.remove(nums[j]);\n            }\n        }\n    }\n    public List<List<Integer>> subsets(int[] nums) {\n      HashSet<Integer> set = new HashSet<Integer>();\n      HashSet<List<Integer>> result = new HashSet<List<Integer>>();\n      result.add(new ArrayList<>(set));\n      generate(set,0,nums,result);\n      List<List<Integer>> ans = new ArrayList<List<Integer>>(result);\n      return ans;\n    }\n}"
                    },
                    {
                        "username": "zimex",
                        "content": "I have the same problem. Why 0 is causing a problem?\\n"
                    },
                    {
                        "username": "Syed_Waseem",
                        "content": "This Problem has 2 solution \\n1) Power Set method\\n2) Recursion\\n\\nIn recursion we just pick or discard the current element\\nso in parameter you can add array, index to point element which is to be picked/discarded, data structure which will store your 1 subset when base condition hits\\n\\nfirst add element in data structure (pick) then call recursive function call to process that subset further\\n\\nsecond call will be of discarding element from our subset, now as we add that element to our answer data structure we need to remove it and again call a recursive function call for processing the subset\\n\\nMy Advise would be please draw recursion tree then it will be very easy for u code based on recursion tree\\n\\nRecursion is easy if you draw recursion tree"
                    }
                ]
            },
            {
                "id": 1935017,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1758105,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1715583,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1572036,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1571182,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2060599,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2026476,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2013160,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 2006087,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1951263,
                "content": [
                    {
                        "username": "sumantaraj",
                        "content": "CAN BE SIMPLY SOLVED BY INCLUDE EXCLUDE METHOD"
                    },
                    {
                        "username": "king_sized_life",
                        "content": "VERY IMP: Don't fool your self with complexity of backtrack approach num 2. I spent hours to wrap my head around this.\n\nFor all those wondering how the complexity of approach 2 is 2^N, they are not fool. On one side, its taught that the way to calculate complexity of backtracking solution is to know what are our choices (k) on each recursion and how many times we recurse (N)..so if we have k choices each time and we recurse N times, complexity of backtrack solution is typically k^N...\n\nIn this case, folks could be genuinely confused, when the code looks exactly same, but complexity is 2^N and not N^N (as it seems like we have N choices at each step and we iterate N times in approach 2 code). However, that is *not true* bcz for such backtracking solutions, the choices should always remains N..however in this case, you can see that if we have taken an number, it is not available for reuse in next recursion..so the choices does not always remain N on each nested recursion but reduces...\n\nThis is where we have to do the hard thing, i.e. draw out the recursion tree manually and you will see the nested recursion happens 2^N times. And looking at solution 3, people know that we are kind of generating bitmask in which if we have N bits, the number of solutions becomes 2^N..so people often try to retrofit that complexity for approach 2 backtrack solution bcz deriving a mathematic formula is tricky in approach 2.\n\nThus, it would be helpful where we can clearly see that we are taking 2 choices. A loop doesn't help on that bcz it gives impression of N choices. That's why I have written backtrack code without loop that clearly shows 2 choices and helps derive 2^N complexity in backtrack solution. Checkout code here: https://leetcode.com/problems/subsets/solutions/3052149/simple-intuitive-solution-that-describes-the-backtrack-complexity-as-2-n/"
                    },
                    {
                        "username": "DeonChoi",
                        "content": "Why does this add the single element arrays multiple times?\\n\\n`const subsets = (nums: number[]): number[][] => {\\n    const results = [[], [...nums]]\\n    const traverse = (i, nums) => {\\n        for (let j=i; j<nums.length; j++){\\n            let tempNums = [...nums]\\n            nums.splice(j,1)\\n            console.log(nums)\\n            if (!results.includes([...nums]) && nums.length !== 0) {\\n                results.push([...nums])\\n            }\\n            traverse(i, nums)\\n            nums = [...tempNums]\\n        }\\n    }\\n    traverse(0, nums)\\n\\n    return results\\n};`"
                    },
                    {
                        "username": "kaustubhmallik",
                        "content": "In the problem, it is clearly mentioned that \"The solution set must not contain duplicate subsets\". But, below test cases are generating incorrect expected answer from OJ:\\n\\nInput: [1,2,2]\\nExpected Output: [[],[1],[2],[1,2],[2],[1,2],[2,2],[1,2,2]] (given by OJ)\\nCorrect Expected Output: [[],[1],[2],[1,2],[2,2],[1,2,2]]\\n\\nAs you can see above, the expected output from the OJ consists of duplicated subsets, which is contradicting with the problem constraints. Can anyone correct me, if I am mistaken here."
                    },
                    {
                        "username": "shahrukh777",
                        "content": "just read the constraints bro, you should be choose only unique elements. "
                    },
                    {
                        "username": "sriharip",
                        "content": "Given two strings S1 and S2, find the shortest subsequence in S1 that contains all the characters in S2.\\nNote: the order in which S2's characters appear in S1 does not matter\\n\\nEx: \\nS1 = \"ABCKLADEKCLB\"\\nS2 = \"BEK\"\\n\\nshortest subsequence is \"EKCLB\""
                    },
                    {
                        "username": "Harshal2022",
                        "content": "class Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> ans = new ArrayList<>();\\n        if(nums.length==0){\\n            return ans;\\n        }\\n       if(nums.length==1){\\n           ans.add(0,new ArrayList<>());\\n           List<Integer> last = new ArrayList<>();\\n           last.add(nums[0]);\\n           ans.add(1,last);\\n           return ans;\\n       }\\n       List<List<Integer>> small = subsets(Arrays.copyOfRange(nums,0,nums.length-1));\\n       for(int i=0;i<small.size();i++){\\n           ans.add(2*i,small.get(i));\\n           List<Integer> next = new ArrayList<>();\\n           for(int k=0;k<small.get(i).size();k++){\\n               next.add(small.get(i).get(k));\\n           }\\n           next.add(nums[nums.length-1]);\\n           ans.add(2*i+1,next);\\n       }\\n       return ans;\\n    }\\n}\\n"
                    },
                    {
                        "username": "Aaryan_0001",
                        "content": "APPROACH   | |   BEATS 100%\\nwe can solve this problem using recursion.\\nThe main logic is that we are given the array and in each pass we will exclude the array and include the array. i.e in simple terms we start our index with \\'0\\' , in 1st pass we will ignore the value at 0th index and also include the value at 0th index , so in next pass for index \\'1\\' we exclude this but also include this. \\n\\nI know I am a bad teacher , so catch watch this video instead :https://youtu.be/V0IgCltYgg4\\n\\n\\n#include<vector>\\nclass Solution {\\nprivate:\\n    void subset(vector<int> &nums,vector<vector<int>> &ans,int index,vector<int> output){\\n        if(index>=nums.size()){\\n            ans.push_back(output);\\n            return;\\n        }\\n        subset(nums,ans,index+1,output);    //exclude\\n        output.push_back(nums[index]);\\n        subset(nums,ans,index+1,output);    //include\\n    }\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        vector<vector<int>> ans;\\n        vector<int> output;\\n        int index=0;\\n        subset(nums,ans,index,output);\\n        return ans;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "sjhunter86",
                        "content": "I strongly disagree that this is a Medium. If something like this is Medium but Trapping Rainwater is a Hard, I need to know what the definition of Medium is. I\\'m being dramatic, but seriously working out iterative recursive backtracking is rough for a medium."
                    },
                    {
                        "username": "bharatsachya",
                        "content": "can anyone please kindly tell me mistake in this?\\n\\nclass Solution {\\npublic:\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<vector<int>> subset;\\n        for(int i=0;i<(1<<n);i++){\\n             vector<int>ans;\\n            for(int bits = 0;i<n-1;bits++){               \\n                if(i & (1<<bits)) {\\n                 ans.push_back(nums[i]);\\n                }\\n            }\\n            subset.push_back(ans);\\n        }\\n        return subset;\\n    }\\n};"
                    },
                    {
                        "username": "ore_wa_susumi_tsuzukeru",
                        "content": "Why is this code not working?\n     ` vector<vector<int>> subsets(vector<int>& nums) {\n        vector<vector<int>> ans;\n        helper(nums, ans);\n        return ans;\n    }\n\n    void helper(vector<int>& nums, vector<vector<int>>& ans){\n        if (nums.empty()){\n            ans.push_back(nums);\n        } else {\n            int t = nums[nums.size()-1];\n            nums.pop_back();\n            helper(nums, ans);\n            for (vector<int> i: ans){\n                vector<int> temp = i;\n                temp.push_back(t);\n                ans.push_back(temp);\n            }\n        }\n    }`\n\nIt is throwing AddressSanitizer Heap-use-after-free error. I am unable to figure out why tho. Can someone please explain it to me."
                    }
                ]
            },
            {
                "id": 1936909,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1911128,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1808352,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1800858,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1781924,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1776381,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1767466,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1754131,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1739549,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            },
            {
                "id": 1733505,
                "content": [
                    {
                        "username": "Syed_Waseem",
                        "content": "There are 2 ways to solve \\n1) Power Set Method\\n2)Recursion\\n\\nMy Recursion Solution :- https://leetcode.com/problems/subsets/submissions/974968426/\\n\\nSubset is picking or discarding a element \\nso you need to call 2 recursion call 1)pick  2)not pick\\n\\nIN parameter list take array, index(point the element which is to be picked or discard), datastructure(to store 1 subset when base condition hits), ans list\\n\\n\\nIn this approach we will be modifying our data structure in recursion calls and when the base condition hits(when u traversed the whole array) we will add a copy of our datastructure to ans list\\n\\nNote :-Don\\'t add the datastructure because it is pass by reference\\n\\nIf any doubt refer my attached solution\\n\\nMy advise would be draw recursion tree until you understand the code\\n"
                    },
                    {
                        "username": "aarya_choudhary",
                        "content": "Is there anyway we can do this question only using recursion without backtracking?"
                    },
                    {
                        "username": "anubhav_21",
                        "content": " class Solution {\\n    public:\\n    void solve(vector<int>& arr,int index,vector<int> subset,vector<vector<int>> &powerset){\\n        if(index==arr.size()){\\n            powerset.push_back(subset);\\n            return;\\n        }\\n        solve(arr,index+1,subset,powerset);\\n        subset.push_back(arr[index]);\\n        solve(arr,index+1,subset,powerset);\\n    }\\n    vector<vector<int>> subsets(vector<int>& arr) {\\n        vector<int> subset;\\n        vector<vector<int>> powerset;\\n        int index = 0;\\n        solve(arr,index,subset,powerset);\\n        return powerset;\\n    }\\n};\\n        \\n    "
                    },
                    {
                        "username": "ankush920",
                        "content": "100% fastest code with easy readable format :-\\n// find useful upvote it vro :)\\nclass Solution {\\npublic:\\n\\nvoid help ( vector<int> nums  ,int n  ,vector<vector<int>>&ans)\\n{\\n     if( n==0)\\n     {\\n          ans.push_back({});\\n          return ;\\n     }\\n \\n\\n   help( nums , n-1 , ans );\\n\\n     int m = ans.size();\\n\\n     for( int i = 0 ; i<m ;i++)\\n     {\\n      vector<int> temp = ans[i];\\n      temp.push_back(nums[n-1]);\\n      ans.push_back(temp);    \\n     }\\n     \\nreturn ;\\n\\n}\\n    vector<vector<int>> subsets(vector<int>& nums) {\\n      vector<vector<int>>ans;\\n\\n       help ( nums , nums.size() ,ans);\\n\\n       return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "Karmvir_Jadeja",
                        "content": "EASY SOLUTION USING RECURSION STEP WISE EXPLANATION\\n\\n\\nclass Solution {\\n    // Main aim is to solve using recursion example {a,b,c} we would calculate the subsets for and {a} and recursion will give us the subsets {b,c}\\n    //And on merging our solution and recursive solution in double vector ans we would get ans \\npublic:\\n      vector<vector<int>> helper(vector<int>&nums,int i)\\n      {\\n         if(i>=nums.size()) return {{}}; // when the i is greater that or equal to size of the vector  return NULL vector of vector\\n         vector<vector<int>> partialans=helper(nums,i+1); //creating a vector of vector to store the partial ans\\n         vector<vector<int>> ans;        // creating vector of vector for final ans\\n         for(vector<int> x:partialans)\\n         {\\n             ans.push_back(x);\\n         }\\n\\n        for(vector<int> x:partialans)\\n         {\\n             vector<int> temp;\\n             temp.push_back(nums[i]);\\n             for(int y:x)\\n             {\\n                 temp.push_back(y);\\n             }\\n             ans.push_back(temp);\\n         }\\n         return ans;\\n      }\\n      \\n    vector<vector<int>> subsets(vector<int>& nums) {\\n       return helper(nums,0);\\n\\n\\n    }\\n};"
                    },
                    {
                        "username": "tomarsuraj2589",
                        "content": "Simple Java solution, with Time Complexity - (logN)*2^N.\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n         List<List<Integer>> list = new ArrayList<>();\\n        List<Integer> sub = new ArrayList<>();\\n        list.add(sub);\\n        for (int i = 1; i < Math.pow(2, nums.length); i++) {\\n            sub = new ArrayList<>();\\n            int j = i;\\n            int index = 0;\\n            while(j != 0){\\n                if((j&1) != 0){\\n                    sub.add(nums[index]);\\n                }\\n                 j >>=1;\\n                 index++;\\n            }\\n\\n            list.add(sub);\\n        }\\n\\n        return list;\\n    }\\n}"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/78_subsets.cpp"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Anuj_Agrawal2004",
                        "content": "VERY EASY SOLUTION USING BACKTRACKING ||  JAVA ||  BACKTRACKING ||  RECURSION\\n\\n\\nclass Solution {\\n    public List<List<Integer>> subsets(int[] nums) {\\n        List<List<Integer>> answer = new ArrayList<>();\\n        backtrace(nums, 0, new ArrayList<Integer>(), answer);\\n        return answer;\\n    }\\n    public void backtrace(int[] nums, int start, List<Integer> track, List<List<Integer>> answer){\\n        answer.add(new ArrayList<>(track));\\n        for(int i= start; i<nums.length; i++){\\n            track.add(nums[i]);\\n            backtrace(nums, i+1, track , answer);\\n           track.remove(track.size()-1);\\n        }\\n    }\\n}"
                    },
                    {
                        "username": "DavalC",
                        "content": "This function uses a recursive helper function to generate all possible subsets of the input array. The helper function generates the subsets by considering each element in the array in turn and recursively generating the subsets both with and without the element.\\n\\nThe time complexity of this solution is O(2^n), where n is the number of elements in the array, because there are 2^n possible subsets of an array with n elements.\\n\\nThe space complexity of this solution is O(2^n), because the function stores all the subsets in the result array. The space complexity is not affected by the structure of the array, only by the number of elements."
                    }
                ]
            }
        ]
    },
    {
        "title": "Rank Scores",
        "question_content": "<p>Table: <code>Scores</code></p>\n\n<pre>\n+-------------+---------+\n| Column Name | Type    |\n+-------------+---------+\n| id          | int     |\n| score       | decimal |\n+-------------+---------+\nid is the primary key (column with unique values) for this table.\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\n</pre>\n\n<p>&nbsp;</p>\n\n<p>Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules:</p>\n\n<ul>\n\t<li>The scores should be ranked from the highest to the lowest.</li>\n\t<li>If there is a tie between two scores, both should have the same ranking.</li>\n\t<li>After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.</li>\n</ul>\n\n<p>Return the result table ordered by <code>score</code> in descending order.</p>\n\n<p>The result format is in the following example.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> \nScores table:\n+----+-------+\n| id | score |\n+----+-------+\n| 1  | 3.50  |\n| 2  | 3.65  |\n| 3  | 4.00  |\n| 4  | 3.85  |\n| 5  | 4.00  |\n| 6  | 3.65  |\n+----+-------+\n<strong>Output:</strong> \n+-------+------+\n| score | rank |\n+-------+------+\n| 4.00  | 1    |\n| 4.00  | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.50  | 4    |\n+-------+------+\n</pre>\n",
        "solutions": [
            {
                "id": 53094,
                "title": "simple-short-fast",
                "content": "These are four different solutions.\\n\\n---\\n**With Variables:** 841 ms\\n\\nFirst one uses two variables, one for the current rank and one for the previous score.\\n\\n    SELECT\\n      Score,\\n      @rank := @rank + (@prev <> (@prev := Score)) Rank\\n    FROM\\n      Scores,\\n      (SELECT @rank := 0, @prev := -1) init\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count:** 1322 ms\\n\\nThis one counts, for each score, the number of distinct greater or equal scores.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(distinct Score) FROM Scores WHERE Score >= s.Score) Rank\\n    FROM Scores s\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count, Pre-uniqued:** 795 ms\\n\\nSame as the previous one, but faster because I have a subquery that \"uniquifies\" the scores first. Not entirely sure *why* it's faster, I'm guessing MySQL makes `tmp` a temporary table and uses it for every outer Score.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) tmp WHERE s >= Score) Rank\\n    FROM Scores\\n    ORDER BY Score desc\\n\\n---\\n\\n**Filter/count Scores^2:** 1414 ms\\n\\nInspired by the attempt in wangkan2001's answer. Finally `Id` is good for something :-)\\n\\n    SELECT s.Score, count(distinct t.score) Rank\\n    FROM Scores s JOIN Scores t ON s.Score <= t.score\\n    GROUP BY s.Id\\n    ORDER BY s.Score desc",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "These are four different solutions.\\n\\n---\\n**With Variables:** 841 ms\\n\\nFirst one uses two variables, one for the current rank and one for the previous score.\\n\\n    SELECT\\n      Score,\\n      @rank := @rank + (@prev <> (@prev := Score)) Rank\\n    FROM\\n      Scores,\\n      (SELECT @rank := 0, @prev := -1) init\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count:** 1322 ms\\n\\nThis one counts, for each score, the number of distinct greater or equal scores.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(distinct Score) FROM Scores WHERE Score >= s.Score) Rank\\n    FROM Scores s\\n    ORDER BY Score desc\\n\\n---\\n\\n**Always Count, Pre-uniqued:** 795 ms\\n\\nSame as the previous one, but faster because I have a subquery that \"uniquifies\" the scores first. Not entirely sure *why* it's faster, I'm guessing MySQL makes `tmp` a temporary table and uses it for every outer Score.\\n\\n    SELECT\\n      Score,\\n      (SELECT count(*) FROM (SELECT distinct Score s FROM Scores) tmp WHERE s >= Score) Rank\\n    FROM Scores\\n    ORDER BY Score desc\\n\\n---\\n\\n**Filter/count Scores^2:** 1414 ms\\n\\nInspired by the attempt in wangkan2001's answer. Finally `Id` is good for something :-)\\n\\n    SELECT s.Score, count(distinct t.score) Rank\\n    FROM Scores s JOIN Scores t ON s.Score <= t.score\\n    GROUP BY s.Id\\n    ORDER BY s.Score desc",
                "codeTag": "Unknown"
            },
            {
                "id": 456610,
                "title": "mysql-two-simple-solutions-and-explanations-for-beginners",
                "content": "# **1. MySQL Solution: (777ms)**\\n```\\nSELECT S.Score, COUNT(S2.Score) AS Rank FROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id \\nORDER BY S.Score DESC;\\n```\\n![image](https://assets.leetcode.com/users/sophiesu0827/image_1576871668.png)\\n\\n\\n\\n\\n# **2. Optional MySQL solution using Variables: (397ms)**\\n```\\nSELECT Score, convert(Rank,SIGNED) AS Rank FROM\\n    (SELECT Score, @rank:=CASE WHEN Score=@previous THEN @rank ELSE @rank+1 END AS Rank, @previous:=Score FROM Scores,\\n        (SELECT @previous:=-1,@rank:=0) AS initial\\n    ORDER BY Score DESC) A;  \\n```\\n**Intuition:** \\nFirst we sort the table by descending scores. We check each score to see if it is equal to or lower than the previous score. If equal, keep the same rank; If lower, increase the rank by 1.\\n\\n**Yes! We\\'ve found that using Variables would save half of the running time.**\\n",
                "solutionTags": [],
                "code": "```\\nSELECT S.Score, COUNT(S2.Score) AS Rank FROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id \\nORDER BY S.Score DESC;\\n```\n```\\nSELECT Score, convert(Rank,SIGNED) AS Rank FROM\\n    (SELECT Score, @rank:=CASE WHEN Score=@previous THEN @rank ELSE @rank+1 END AS Rank, @previous:=Score FROM Scores,\\n        (SELECT @previous:=-1,@rank:=0) AS initial\\n    ORDER BY Score DESC) A;  \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218193,
                "title": "dense-rank-sql-server-604-ms",
                "content": "Hello,\\n\\nI am not sure why I have not come across a solution using DENSE_RANK() since it\\'s made for exactly this purpose. Please do let me know if the goal of the question is to arrive at a solution without using DENSE_RANK().\\n\\nNOTE : I am using MS SQL SERVER and not MySQL. It accepts my solution.\\n\\nHere is my solution :\\n\\n```\\nSELECT s.Score as Score,\\nDENSE_RANK() OVER (ORDER BY s.Score DESC) as Rank\\nFROM Scores s\\n\\n```\\n\\nit does exactly what the question asks us to do. If you want ranks with gaps, we can use RANK() instead of DENSE_RANK()",
                "solutionTags": [],
                "code": "```\\nSELECT s.Score as Score,\\nDENSE_RANK() OVER (ORDER BY s.Score DESC) as Rank\\nFROM Scores s\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3861595,
                "title": "pandas-simple-2-step-approach-additional-knowledge-at-the-end",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use the rank method with method=\\'dense\\' to assign ranks to the scores in descending order while handling ties. Add a new column \\'rank\\' to the scores DataFrame to store the ranks.\\n2. Sort the DataFrame by score in descending order. This can be achieved using the sort_values method.\\n\\n\\n# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    # Use the rank method to assign ranks to the scores in descending order with no gaps\\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    # Drop id column & Sort the DataFrame by score in descending order\\n    result_df = scores.drop(\\'id\\',axis=1).sort_values(by=\\'score\\', ascending=False)\\n    \\n    return result_df\\n```\\n\\n# Additional Knowledge \\uD83E\\uDD29\\nThe Approach is super simple if we know about the rank method and method = \\'dense\\', but we should not stop here for this question let\\'s explore and increase our knowledge.\\n\\nwhat are other available options like dense? \\uD83E\\uDD14\\nIn Pandas\\' rank method, there are several options available for the method parameter to handle ties when assigning ranks. Here are the available options:\\n\\n**\\'average\\' (default):** This method assigns the average rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 2.5, and the next rank will be 4.\\n\\n**\\'min\\':** This method assigns the minimum rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 2, and the next rank will be 4.\\n\\n**\\'max\\':** This method assigns the maximum rank to tied elements. For example, if two elements tie for the second rank, they both get the rank of 3, and the next rank will be 4.\\n\\n**\\'first\\':** This method assigns ranks in the order they appear in the input data, without using any average or other calculations for ties. For example, if two elements tie for the second rank, the first element gets the rank of 2, and the next rank will be 4.\\n\\n**\\'dense\\':** This method assigns dense ranks to tied elements, meaning there are no gaps in the ranks. For example, if two elements tie for the second rank, they both get the rank of 2, and the next rank will be 3.\\n\\n**\\'ordinal\\':** This method is similar to \\'dense\\', but it considers the order of appearance in the data for assigning ranks to tied elements. For example, if two elements tie for the second rank, the first element gets the rank of 2, and the next rank will be 3.\\n\\nThese methods allow you to choose how ties in the data should be handled while assigning ranks. You can select the appropriate method based on your specific requirements. By default, \\'average\\' is used when the method parameter is not provided.\\n\\n## Please upvote the solution which gives me motivation to share high quality solutions like this. Thank You.\\n\\n\\n",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    # Use the rank method to assign ranks to the scores in descending order with no gaps\\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    # Drop id column & Sort the DataFrame by score in descending order\\n    result_df = scores.drop(\\'id\\',axis=1).sort_values(by=\\'score\\', ascending=False)\\n    \\n    return result_df\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1967099,
                "title": "mysql-solution",
                "content": "# Solution\\n```\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\\nThe **DENSE_RANK()** is a window function that assigns a rank to each row within a partition of a result set. Unlike the **RANK()** function, the **DENSE_RANK()** function returns consecutive rank values. Rows in each partition receive the same ranks if they have the same values.\\nIf you find this **solution** and **explanation** helpful, please **upvote** it for others people.\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53096,
                "title": "accepted-solution-using-innerjoin-and-groupby",
                "content": "    SELECT Scores.Score, COUNT(Ranking.Score) AS RANK\\n      FROM Scores\\n         , (\\n           SELECT DISTINCT Score\\n             FROM Scores\\n           ) Ranking\\n     WHERE Scores.Score <= Ranking.Score\\n     GROUP BY Scores.Id, Scores.Score\\n     ORDER BY Scores.Score DESC;",
                "solutionTags": [],
                "code": "    SELECT Scores.Score, COUNT(Ranking.Score) AS RANK\\n      FROM Scores\\n         , (\\n           SELECT DISTINCT Score\\n             FROM Scores\\n           ) Ranking\\n     WHERE Scores.Score <= Ranking.Score\\n     GROUP BY Scores.Id, Scores.Score\\n     ORDER BY Scores.Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 570963,
                "title": "logically-simple-4-lines-mysql-solution-701ms",
                "content": "```\\nSELECT S1.Score, (\\n    SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= S1.Score) AS Rank\\nFROM Scores S1\\nORDER BY S1.Score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT S1.Score, (\\n    SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= S1.Score) AS Rank\\nFROM Scores S1\\nORDER BY S1.Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53129,
                "title": "maybe-the-simpest-solution",
                "content": "Maybe the simplest solution I guess\\n-----------\\n\\nSELECT score,(SELECT COUNT(DISTINCT score) FROM Scores where score > a.score) + 1 rank\\n from Scores a  \\nORDER by score DESC;\\n\\n-----------\\n\\nInspired by Oracle Function row_number()\\uff0crank()\\uff0cdense()",
                "solutionTags": [],
                "code": "Maybe the simplest solution I guess\\n-----------\\n\\nSELECT score,(SELECT COUNT(DISTINCT score) FROM Scores where score > a.score) + 1 rank\\n from Scores a  \\nORDER by score DESC;\\n\\n-----------\\n\\nInspired by Oracle Function row_number()\\uff0crank()\\uff0cdense()",
                "codeTag": "Unknown"
            },
            {
                "id": 1803710,
                "title": "best-smart-mysql-solution-178-rank-scores",
                "content": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"rank\" from scores s1\\norder by s1.score DESC;\\n\\n#pls upvote if you find solution easy to understand..Thanks..!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"rank\" from scores s1\\norder by s1.score DESC;\\n\\n#pls upvote if you find solution easy to understand..Thanks..!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53110,
                "title": "accepted-solution-with-subqueries-and-group-by",
                "content": "# Solution with sub-queries\\n\\nWe just get the rows the distinct rows that are <= that each score, count them and wrap them in an external SELECT for formatting. \\n\\n    SELECT Scores.Score, Q3.Rank\\n    FROM(\\n        SELECT Q1.Score as Score, COUNT(Q1.Score) as Rank\\n        FROM \\n            (SELECT DISTINCT Score from Scores) as Q1,\\n            (SELECT DISTINCT Score from Scores) as Q2\\n        WHERE Q1.Score <= Q2.Score\\n        GROUP BY Q1.Score\\n        ) as Q3, Scores\\n    WHERE Q3.Score = Scores.Score\\n    ORDER BY Scores.Score DESC",
                "solutionTags": [],
                "code": "# Solution with sub-queries\\n\\nWe just get the rows the distinct rows that are <= that each score, count them and wrap them in an external SELECT for formatting. \\n\\n    SELECT Scores.Score, Q3.Rank\\n    FROM(\\n        SELECT Q1.Score as Score, COUNT(Q1.Score) as Rank\\n        FROM \\n            (SELECT DISTINCT Score from Scores) as Q1,\\n            (SELECT DISTINCT Score from Scores) as Q2\\n        WHERE Q1.Score <= Q2.Score\\n        GROUP BY Q1.Score\\n        ) as Q3, Scores\\n    WHERE Q3.Score = Scores.Score\\n    ORDER BY Scores.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 1046525,
                "title": "solution-without-dense-rank",
                "content": "```\\nSELECT \\n    b.Score, \\n\\t(SELECT COUNT(DISTINCT a.Score) FROM Scores a WHERE b.Score <= a.Score) as `Rank`\\nFROM Scores b ORDER BY `Rank`\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    b.Score, \\n\\t(SELECT COUNT(DISTINCT a.Score) FROM Scores a WHERE b.Score <= a.Score) as `Rank`\\nFROM Scores b ORDER BY `Rank`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3301918,
                "title": "fast-windows-vs-windowless-function-examples",
                "content": "Generally, interviewers want you to use a Windows Function to solve a problem like this.  \\n\\nHowever, you might have an interviewer who specifically says, don\\'t use a Windows Function, so it\\'s good to know both ways.\\n\\nHas anyone every asked you to answer a question like this without a subquery?\\n\\nThanks!\\n\\n[@easyCodingSolutions](https://youtu.be/K3KFG8Hpb2M)\\n\\nhttps://youtu.be/K3KFG8Hpb2M\\n\\nWith Windows Function:\\n\\n```\\n# Using DENSE_RANK - generally what interviewers want\\nSELECT\\n    score\\n    , DENSE_RANK() OVER (ORDER BY score DESC) \\'rank\\'\\nFROM Scores\\n    ORDER BY score DESC\\n```\\n\\nSame as Windows Function:\\n```\\nSELECT\\n  score,\\n  (SELECT COUNT(*) FROM (SELECT distinct score s FROM Scores) CTE WHERE s >= score) \\'Rank\\'\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Using DENSE_RANK - generally what interviewers want\\nSELECT\\n    score\\n    , DENSE_RANK() OVER (ORDER BY score DESC) \\'rank\\'\\nFROM Scores\\n    ORDER BY score DESC\\n```\n```\\nSELECT\\n  score,\\n  (SELECT COUNT(*) FROM (SELECT distinct score s FROM Scores) CTE WHERE s >= score) \\'Rank\\'\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884813,
                "title": "simple-mysql-solution-with-and-without-window-function",
                "content": "```\\n# Window Function Approach\\nselect score, dense_rank() over (order by score desc) as \"Rank\" from scores;\\n\\n# Using count method\\nselect score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"Rank\"\\nfrom scores s1\\norder by score desc;\\n\\n# Do upvote if you like both the approaches!!\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Window Function Approach\\nselect score, dense_rank() over (order by score desc) as \"Rank\" from scores;\\n\\n# Using count method\\nselect score, (select count(distinct score) from scores s2 where s2.score >= s1.score) as \"Rank\"\\nfrom scores s1\\norder by score desc;\\n\\n# Do upvote if you like both the approaches!!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082561,
                "title": "faster-than-96-memory-less-than-100",
                "content": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2420861,
                "title": "mysql-easy-understanding-beginner-level-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome.***\\n____________________________________________________________________________________________________________________________\\n\\u2705 **MySQL Code :**\\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```\\n____________________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \\'Rank\\'\\nFROM Scores \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1756654,
                "title": "concise-solution-with-sql-ranking",
                "content": "There are many ways we can calculate the rank of each score, the easiest is to use a built in method named `DENSE_RANK()`. \\n\\n```\\nSELECT \\n    score, \\n    DENSE_RANK() OVER(ORDER BY score desc) AS `rank` \\nFROM scores\\nORDER BY `rank`\\n```\\n\\nTwo things to take in consideration here:\\n\\n1. There is another method called `RANK()` which will give different result for the same query. If you don\\'t understand their difference, I would suggest you to try this with `RANK()` and see the difference in results, it will help you.\\n2. In the 3rd line you have to put the alias `rank` inside `` or `\"\"`, otherwise mysql will give error. This is because `rank` is a syntax used by mysql itself so you have to tell the db engine explicitely that it\\'s not the build in method, it\\'s a string.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score, \\n    DENSE_RANK() OVER(ORDER BY score desc) AS `rank` \\nFROM scores\\nORDER BY `rank`\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 115770,
                "title": "accepted-solution-with-subquery-for-rank",
                "content": "SELECT s1.Score AS Score, \n(SELECT COUNT(DISTINCT S2.Score) FROM Scores as S2 WHERE S2.Score > S1.Score)+1 AS Rank\nFROM Scores AS s1\nORDER BY Rank ASC",
                "solutionTags": [],
                "code": "(SELECT COUNT(DISTINCT S2.Score) FROM Scores as S2 WHERE S2.Score > S1.Score)+1 AS Rank",
                "codeTag": "Unknown"
            },
            {
                "id": 3907201,
                "title": "pandas-2-lines-very-easy-and-simple-beginners-solution-with-comments",
                "content": "# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n\\n    #Sorting the table in descending Order\\n    scores=scores.sort_values(by=[\\'score\\'],ascending=False)\\n\\n    #Using \\'rank\\' to rank the rows in descending method\\n    #\\'dense\\' method gives ranks continuous without any gap. \\n    scores[\\'rank\\']=(scores[\\'score\\'].rank(method=\\'dense\\',ascending=False))\\n\\n    return scores[[\\'score\\',\\'rank\\']]\\n```\\n\\n---\\n\\n\\n# PLEASE UPVOTE :)",
                "solutionTags": [
                    "Python",
                    "Database",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n\\n    #Sorting the table in descending Order\\n    scores=scores.sort_values(by=[\\'score\\'],ascending=False)\\n\\n    #Using \\'rank\\' to rank the rows in descending method\\n    #\\'dense\\' method gives ranks continuous without any gap. \\n    scores[\\'rank\\']=(scores[\\'score\\'].rank(method=\\'dense\\',ascending=False))\\n\\n    return scores[[\\'score\\',\\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3350226,
                "title": "mysql-simple-dense-rank-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nusing ranking method\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nusing dense_rank() approach\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nselect round(score,2) as score , \\ndense_rank() \\nOVER (  order by score desc ) \\nAS \\'rank\\'\\n from scores order by score desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nselect round(score,2) as score , \\ndense_rank() \\nOVER (  order by score desc ) \\nAS \\'rank\\'\\n from scores order by score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 329735,
                "title": "mysql-and-ms-sql-accepted-solutions",
                "content": "1. MySQL Solution:\\n```\\nSELECT s1.Score as score, \\n(SELECT COUNT(DISTINCT s2.Score)+1 FROM Scores s2 WHERE s1.Score< s2.Score) AS \\'Rank\\' \\nFROM Scores s1\\nORDER BY 1 DESC\\n```\\n2. MS SQL Solution\\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s1.Score as score, \\n(SELECT COUNT(DISTINCT s2.Score)+1 FROM Scores s2 WHERE s1.Score< s2.Score) AS \\'Rank\\' \\nFROM Scores s1\\nORDER BY 1 DESC\\n```\n```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2648415,
                "title": "rank-scores-one-liner",
                "content": "\\tselect score, dense_rank() over(order by score desc) as \\'rank\\' from scores;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tselect score, dense_rank() over(order by score desc) as \\'rank\\' from scores;",
                "codeTag": "Unknown"
            },
            {
                "id": 190760,
                "title": "simple-subquery-solution",
                "content": "My solution using subquery and allowing dense ranking\n```\nSELECT Score\n  \t   ,(SELECT count(distinct score)\n  \t   \t FROM scores b\n  \t   \t WHERE b.score>= a.score ) as Rank\nFROM scores a\nORDER BY Rank;\n```\n",
                "solutionTags": [],
                "code": "```\nSELECT Score\n  \t   ,(SELECT count(distinct score)\n  \t   \t FROM scores b\n  \t   \t WHERE b.score>= a.score ) as Rank\nFROM scores a\nORDER BY Rank;\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 431650,
                "title": "simple-mysql-solution-not-using-dense-rank",
                "content": "Simple mySql solution not using dense_rank()\\n\\n```\\nselect s.Score, count(a.Score) as rank \\nfrom scores s, (\\n    select distinct Score \\n    FROM Scores) a\\nwhere s.Score <= a.Score\\ngroup by s.Id, s.Score\\norder by s.Score desc;\\n```",
                "solutionTags": [],
                "code": "```\\nselect s.Score, count(a.Score) as rank \\nfrom scores s, (\\n    select distinct Score \\n    FROM Scores) a\\nwhere s.Score <= a.Score\\ngroup by s.Id, s.Score\\norder by s.Score desc;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3872817,
                "title": "pandas-vs-sql-elegant-short-all-30-days-of-pandas-solutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```Python []\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    return scores.sort_values(\\n        by=\\'score\\', ascending=False,\\n    ).assign(\\n        rank=scores[\\'score\\'].rank(method=\\'dense\\', ascending=False),\\n    )[[\\'score\\', \\'rank\\']]\\n```\\n```SQL []\\nSELECT s1.score,\\n       count(s2.score) AS \"Rank\"\\n  FROM Scores s1,\\n      (SELECT DISTINCT score FROM Scores) s2\\n WHERE s1.score <= s2.score\\n GROUP BY s1.id\\n ORDER BY s1.score DESC;\\n```\\n\\n# Important!\\n###### If you like the solution or find it useful, feel free to **upvote** for it, it will support me in creating high quality solutions)\\n\\n# 30 Days of Pandas solutions\\n\\n### Data Filtering \\u2705\\n- [Big Countries](https://leetcode.com/problems/big-countries/solutions/3848474/pandas-elegant-short-1-line/)\\n- [Recyclable and Low Fat Products](https://leetcode.com/problems/recyclable-and-low-fat-products/solutions/3848500/pandas-elegant-short-1-line/)\\n- [Customers Who Never Order](https://leetcode.com/problems/customers-who-never-order/solutions/3848527/pandas-elegant-short-1-line/)\\n- [Article Views I](https://leetcode.com/problems/article-views-i/solutions/3867192/pandas-elegant-short-1-line/)\\n\\n\\n### String Methods \\u2705\\n- [Invalid Tweets](https://leetcode.com/problems/invalid-tweets/solutions/3849121/pandas-elegant-short-1-line/)\\n- [Calculate Special Bonus](https://leetcode.com/problems/calculate-special-bonus/solutions/3867209/pandas-elegant-short-1-line/)\\n- [Fix Names in a Table](https://leetcode.com/problems/fix-names-in-a-table/solutions/3849167/pandas-elegant-short-1-line/)\\n- [Find Users With Valid E-Mails](https://leetcode.com/problems/find-users-with-valid-e-mails/solutions/3849177/pandas-elegant-short-1-line/)\\n- [Patients With a Condition](https://leetcode.com/problems/patients-with-a-condition/solutions/3849196/pandas-elegant-short-1-line-regex/)\\n\\n\\n### Data Manipulation \\u2705\\n- [Nth Highest Salary](https://leetcode.com/problems/nth-highest-salary/solutions/3867257/pandas-elegant-short-1-line/)\\n- [Second Highest Salary](https://leetcode.com/problems/second-highest-salary/solutions/3867278/pandas-elegant-short/)\\n- [Department Highest Salary](https://leetcode.com/problems/department-highest-salary/solutions/3867312/pandas-elegant-short-1-line/)\\n- [Rank Scores](https://leetcode.com/problems/rank-scores/solutions/3872817/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Delete Duplicate Emails](https://leetcode.com/problems/delete-duplicate-emails/solutions/3849211/pandas-elegant-short/)\\n- [Rearrange Products Table](https://leetcode.com/problems/rearrange-products-table/solutions/3849226/pandas-elegant-short-1-line/)\\n\\n\\n### Statistics \\u2705\\n- [The Number of Rich Customers](https://leetcode.com/problems/the-number-of-rich-customers/solutions/3849251/pandas-elegant-short-1-line/)\\n- [Immediate Food Delivery I](https://leetcode.com/problems/immediate-food-delivery-i/solutions/3872719/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Count Salary Categories](https://leetcode.com/problems/count-salary-categories/solutions/3872801/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Find Total Time Spent by Each Employee](https://leetcode.com/problems/find-total-time-spent-by-each-employee/solutions/3872715/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Game Play Analysis I](https://leetcode.com/problems/game-play-analysis-i/solutions/3863223/pandas-elegant-short-1-line/)\\n- [Number of Unique Subjects Taught by Each Teacher](https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/solutions/3863239/pandas-elegant-short-1-line/)\\n- [Classes More Than 5 Students](https://leetcode.com/problems/classes-more-than-5-students/solutions/3863249/pandas-elegant-short/)\\n- [Customer Placing the Largest Number of Orders](https://leetcode.com/problems/customer-placing-the-largest-number-of-orders/solutions/3863257/pandas-elegant-short-1-line/)\\n- [Group Sold Products By The Date](https://leetcode.com/problems/group-sold-products-by-the-date/solutions/3863267/pandas-elegant-short-1-line/)\\n- [Daily Leads and Partners](https://leetcode.com/problems/daily-leads-and-partners/solutions/3863279/pandas-elegant-short-1-line/)\\n\\n\\n### Data Aggregation \\u2705\\n- [Actors and Directors Who Cooperated At Least Three Times](https://leetcode.com/problems/actors-and-directors-who-cooperated-at-least-three-times/solutions/3863309/pandas-elegant-short/)\\n- [Replace Employee ID With The Unique Identifier](https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/solutions/3872822/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Students and Examinations](https://leetcode.com/problems/students-and-examinations/solutions/3872699/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n- [Managers with at Least 5 Direct Reports](https://leetcode.com/problems/managers-with-at-least-5-direct-reports/solutions/3872861/pandas-elegant-short/)\\n- [Sales Person](https://leetcode.com/problems/sales-person/solutions/3872712/pandas-elegant-short-1-line-all-30-days-of-pandas-solutions/)\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "MySQL",
                    "Pandas"
                ],
                "code": "```Python []\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    return scores.sort_values(\\n        by=\\'score\\', ascending=False,\\n    ).assign(\\n        rank=scores[\\'score\\'].rank(method=\\'dense\\', ascending=False),\\n    )[[\\'score\\', \\'rank\\']]\\n```\n```SQL []\\nSELECT s1.score,\\n       count(s2.score) AS \"Rank\"\\n  FROM Scores s1,\\n      (SELECT DISTINCT score FROM Scores) s2\\n WHERE s1.score <= s2.score\\n GROUP BY s1.id\\n ORDER BY s1.score DESC;\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3212948,
                "title": "178-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo rank the scores, we can use a window function DENSE_RANK() in SQL. The DENSE_RANK() function assigns ranks to rows within the partition of a result set. If two or more rows have the same value, they receive the same rank, and the next rank is assigned to the next row.\\n\\nHere\\'s the SQL query to rank the scores:\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n```\\nThis query selects the score column and applies the DENSE_RANK() function to it, which will generate the ranking. We order the result set by the score in descending order, which means the highest score will have the rank 1.\\n\\nThe output of the query for the given input in the problem statement will be:\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n\\n```\\nSecond example solution:\\n\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as `rank`\\nFROM Scores\\nORDER BY score DESC;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2517177,
                "title": "two-mysql-solutions-simple-dense-rank-and-complex-row-number",
                "content": "1. Simple Method (which a lot of people have used)\\n\\n```\\nSELECT score, DENSE_RANK() over (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\n```\\n\\n2. Complex Method (if dense_rank did not exist) - Faster than 88.95% of MySQL submissions\\n\\n```\\nWITH s1 AS (SELECT score, \\n            ROW_NUMBER() OVER (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\nGROUP BY score) # First create a table with unique row numbers for each distinct score\\n\\nSELECT s1.score, s1.rank\\nFROM s1\\nRIGHT JOIN Scores AS s2  \\nUSING (score) # join two tables using score as the foreign key\\nORDER BY score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() over (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\n```\n```\\nWITH s1 AS (SELECT score, \\n            ROW_NUMBER() OVER (ORDER BY score DESC) AS \\'rank\\'\\nFROM Scores\\nGROUP BY score) # First create a table with unique row numbers for each distinct score\\n\\nSELECT s1.score, s1.rank\\nFROM s1\\nRIGHT JOIN Scores AS s2  \\nUSING (score) # join two tables using score as the foreign key\\nORDER BY score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850672,
                "title": "best-solutions-mysql-pandas-beats-100",
                "content": "\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n```",
                "solutionTags": [
                    "MySQL",
                    "Pandas"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT score, dense_rank() OVER(ORDER BY score DESC) as \"rank\"\\nFROM Scores\\n```\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3824711,
                "title": "100-easy-fast-clean-solution",
                "content": "IF THIS WILL BE HELPFUL TO YOU, PLEASE UPVOTE 1\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT score, DENSE_RANK () OVER (ORDER BY score DESC) \\n\\nRANK FROM Scores;\\n```\\nIF THIS WILL BE HELPFUL TO YOU,PLEASE UPVOTE!![5kej8w.jpg](https://assets.leetcode.com/users/images/6bae3f42-eb8f-4240-a2a7-fd40f588350a_1690475198.0246775.jpeg)\\n",
                "solutionTags": [
                    "Oracle",
                    "Database"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT score, DENSE_RANK () OVER (ORDER BY score DESC) \\n\\nRANK FROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2308104,
                "title": "row-number-vs-rank-vs-dense-rank",
                "content": "This question is a great place to learn these 3 functions. The best way for you to understand these 3 functions is to simply run the below code for them and see why and what they produce as output. The correct answer is given by DENSE_RANK() but a beginner will always get confused on why and when to use DENSE_RANK() or RANK() or ROW_NUMBER()\\n\\n**ROW_NUMBER()** is like a basic counting function, where it will give continous ranks like 1-2-3-4-5-6 and does not care if the values are same or not. So lets suppose we have three people with marks as 100, 100 and 99. ROW_NUMBER() will give rank 1 to person with 100/100 marks and then give rank 2 to person with 100/100 marks and then give rank 3 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 2 --- 100/100 marks Person B\\n* Rank 3 --- 99/100 marks Person C\\n\\n```\\nSELECT \\n    score AS \"score\",\\n    ROW_NUMBER() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\\n\\n**RANK()** is the very close to the correct answer for this question but RANK() leaves hole when it operates. So lets suppose we have three people with marks as 100, 100 and 99. RANK() will give rank 1 to person with 100/100 marks and then give rank 1 to person with 100/100 marks but in the end it will give rank 3 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 1 --- 100/100 marks Person B\\n* Rank 3 ---  99/100 marks Person C\\n\\n```\\nSELECT \\n    score AS \"score\",\\n    RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\\n\\n**DENSE_RANK()** is the perfect function as per our given requirments. So lets suppose we have three people with marks as 100, 100 and 99. DENSE_RANK() will give rank 1 to person with 100/100 marks and then give rank 1 to person with 100/100 marks but in the end it will give rank 2 to person with 99 marks.\\n\\n* Rank 1 --- 100/100 marks Person A\\n* Rank 1 --- 100/100 marks Person B\\n* Rank 2 ---  99/100 marks Person C\\n```\\nSELECT \\n    score AS \"score\",\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score AS \"score\",\\n    ROW_NUMBER() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\n```\\nSELECT \\n    score AS \"score\",\\n    RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```\n```\\nSELECT \\n    score AS \"score\",\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \"rank\"\\nFROM\\n    Scores\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2234543,
                "title": "mysql-solution",
                "content": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY\\n            score DESC\\n    ) AS \\'rank\\'\\nFROM\\n    SCORES;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY\\n            score DESC\\n    ) AS \\'rank\\'\\nFROM\\n    SCORES;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1711996,
                "title": "super-simple-solution",
                "content": "select\\nscore, (select count(distinct score)+1 from Scores where score>s.score) as \"rank\"\\nfrom Scores s\\norder by score desc",
                "solutionTags": [],
                "code": "select\\nscore, (select count(distinct score)+1 from Scores where score>s.score) as \"rank\"\\nfrom Scores s\\norder by score desc",
                "codeTag": "Unknown"
            },
            {
                "id": 1698301,
                "title": "3-easiest-ways",
                "content": "Classic way\\n```\\nSELECT s.score\\n     , DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC\\n```\\nOne stupid way. Use on the interview is your interviewer doesn\\'t know or hates window functions\\n```\\nSELECT t.score\\n     , (SELECT COUNT(DISTINCT s.score)  FROM scores s WHERE s.score >=t.score)  AS rank \\n  FROM scores t\\n ORDER BY t.score DESC\\n```\\n\\n3th way (MySQL):\\n```\\nSELECT s1.score\\n, 1+COUNT(DISTINCT CASE WHEN s2.score>s1.score AND s1.id!=s2.id THEN s2.score ELSE NULL END) AS \"rank\"\\nFROM scores s1\\nCROSS JOIN\\nscores s2\\nGROUP BY s1.id\\n, s1.score\\nORDER BY 2 ASC\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT s.score\\n     , DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC\\n```\n```\\nSELECT t.score\\n     , (SELECT COUNT(DISTINCT s.score)  FROM scores s WHERE s.score >=t.score)  AS rank \\n  FROM scores t\\n ORDER BY t.score DESC\\n```\n```\\nSELECT s1.score\\n, 1+COUNT(DISTINCT CASE WHEN s2.score>s1.score AND s1.id!=s2.id THEN s2.score ELSE NULL END) AS \"rank\"\\nFROM scores s1\\nCROSS JOIN\\nscores s2\\nGROUP BY s1.id\\n, s1.score\\nORDER BY 2 ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 719776,
                "title": "easy-using-methods-to-rank-rows-in-sql",
                "content": "```\\nSELECT score, dense_rank() over (order by score desc) as \\'Rank\\'\\nFROM scores\\n```\\n\\n\\n\\nPlease note that the description says \"If there is a tie between two scores, both should have the same ranking. Note that after a tie, the next ranking number should be the next consecutive integer value\" \\n\\nThat\\'s why you need to use **DENSE_RANK** instead of rank or row_number. \\n\\nSee the functions for other rank methods:\\n-- row_number() : \"Returns a unique number for each row\" IN CASE OF A TIE: with rankings arbitrarily assigned \\n-- rank() \"Returns the same ranking\" IN CASE OF A TIE: gaps* in the rankings\\n-- dense_rank() \"Returns the same ranking\" IN CASE OF A TIE: no gaps in the rankings",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nSELECT score, dense_rank() over (order by score desc) as \\'Rank\\'\\nFROM scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53130,
                "title": "my-800ms-simple-solution-without-variables",
                "content": "    SELECT T2.Score Score, (SELECT COUNT(*) + 1 FROM (SELECT T1.Score FROM Scores T1 GROUP BY Score ORDER BY Score DESC) TEMP WHERE T2.Score < TEMP.Score) Rank FROM Scores T2 ORDER BY Score DESC;",
                "solutionTags": [],
                "code": "    SELECT T2.Score Score, (SELECT COUNT(*) + 1 FROM (SELECT T1.Score FROM Scores T1 GROUP BY Score ORDER BY Score DESC) TEMP WHERE T2.Score < TEMP.Score) Rank FROM Scores T2 ORDER BY Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 53148,
                "title": "very-concise-accepted-solution-without-variables-check-it-out",
                "content": "    Select sc.Score,\\n           (Select count(*)+1 from (select distinct (Score) from Scores)\\n            as uniqeScores where Score > sc.Score) as rank \\n    from Scores sc order by sc.Score desc;",
                "solutionTags": [],
                "code": "    Select sc.Score,\\n           (Select count(*)+1 from (select distinct (Score) from Scores)\\n            as uniqeScores where Score > sc.Score) as rank \\n    from Scores sc order by sc.Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 53152,
                "title": "1169ms-solution-without-variables-and-union",
                "content": "    SELECT\\n      s2.`Score`,\\n      (SELECT COUNT(DISTINCT s1.`Score`) FROM `Scores` s1 WHERE s1.`Score` >= s2.`Score`)\\n        FROM `Scores` s2\\n          ORDER BY s2.`Score` DESC\\n\\np.s. please share more faster solutions!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "    SELECT\\n      s2.`Score`,\\n      (SELECT COUNT(DISTINCT s1.`Score`) FROM `Scores` s1 WHERE s1.`Score` >= s2.`Score`)\\n        FROM `Scores` s2\\n          ORDER BY s2.`Score` DESC\\n\\np.s. please share more faster solutions!",
                "codeTag": "Unknown"
            },
            {
                "id": 3146556,
                "title": "easy-method-by-oracle",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* Write your PL/SQL query statement below */\\nSELECT s.score,\\n DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\n/* Write your PL/SQL query statement below */\\nSELECT s.score,\\n DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\n  FROM scores s\\n ORDER BY s.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2740501,
                "title": "sql-multiple-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/rank-scores.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nSELECT s.score,\\n    (\\n        SELECT count(DISTINCT (ss.score)) + 1\\n        FROM Scores ss\\n        WHERE ss.score > s.score\\n        ) AS \\'rank\\'\\nFROM Scores s\\nORDER BY s.score DESC\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT s.score,\\n    (\\n        SELECT count(DISTINCT (ss.score)) + 1\\n        FROM Scores ss\\n        WHERE ss.score > s.score\\n        ) AS \\'rank\\'\\nFROM Scores s\\nORDER BY s.score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1719541,
                "title": "faster-than-99",
                "content": "Subquery the grouped score with a rank so that you can duplicate the rows.\\n```\\nSELECT Scores.score, x.rank\\nFROM Scores\\nINNER JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) as \"rank\"\\n    FROM Scores\\n    GROUP BY score\\n) x ON x.score = Scores.score\\nORDER BY x.rank\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Scores.score, x.rank\\nFROM Scores\\nINNER JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) as \"rank\"\\n    FROM Scores\\n    GROUP BY score\\n) x ON x.score = Scores.score\\nORDER BY x.rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1641262,
                "title": "good-of-sql-beginner-to-understand",
                "content": "select a.score, (select count(distinct b.score) from Scores b \\n                 where a.score <= b.score) as \"rank\"\\nfrom Scores a\\norder by score desc;",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "select a.score, (select count(distinct b.score) from Scores b \\n                 where a.score <= b.score) as \"rank\"\\nfrom Scores a\\norder by score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 1066148,
                "title": "no-dense-rank-faster-than-96-63-mysql",
                "content": "```\\nSELECT s.score, u.rank\\nFROM Scores s\\nLEFT JOIN(\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS `rank`\\n    FROM (SELECT DISTINCT score FROM Scores ORDER BY score DESC) d\\n) u\\nON s.score=u.score\\nORDER BY score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.score, u.rank\\nFROM Scores s\\nLEFT JOIN(\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS `rank`\\n    FROM (SELECT DISTINCT score FROM Scores ORDER BY score DESC) d\\n) u\\nON s.score=u.score\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750332,
                "title": "mysql-dense-rank",
                "content": "```\\nSELECT score, dense_rank() over(order by score DESC) as \\'Rank\\'\\nFROM Scores\\n```\\nLeetcode updates the version of the MYSQL!!! Thank god.",
                "solutionTags": [],
                "code": "```\\nSELECT score, dense_rank() over(order by score DESC) as \\'Rank\\'\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 676422,
                "title": "ms-sql-server-solution-simple-and-fast",
                "content": "```\\nSELECT Score AS score,\\n       DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\n```\\n\\nRuntime: 825 ms, faster than 91.66% of MS SQL Server online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MS SQL Server online submissions for Rank Scores.\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT Score AS score,\\n       DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 665469,
                "title": "solution-with-and-without-window-function",
                "content": "If you are allowed to use window functions, then a simple dense_rank() will work.\\nIf you are not allowed to use window functions:\\n```\\nSelect \\nScore,\\n(SELECT COUNT(*) FROM \\n        (SELECT DISTINCT Score S FROM Scores) TMP\\nWHERE S >= Score\\n) \"Rank\"\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSelect \\nScore,\\n(SELECT COUNT(*) FROM \\n        (SELECT DISTINCT Score S FROM Scores) TMP\\nWHERE S >= Score\\n) \"Rank\"\\nFROM Scores\\nORDER BY Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525229,
                "title": "mysql-solution-works-on-leetcode-s-version-5-7",
                "content": "Generating `row_number` would have been a lot easier with version 8 with `ROW_NUMBER() OVER()`. Unfornately LeetCode has an older version of MySQL that does not have this feature.\\n```SQL\\nSELECT s.Score, r.Rank\\nFROM (\\n    --  Subquery 2: Generate row_number\\n    SELECT Score, (@row_number:=@row_number + 1) AS `Rank`\\n    FROM (\\n        -- Subquery 1: Generate ranked, unique scores\\n        SELECT Score\\n        FROM Scores\\n        GROUP BY Score\\n        ORDER BY Score DESC\\n    ) AS s, (SELECT @row_number:=0) AS dummie\\n) AS r\\nRIGHT JOIN Scores AS s\\n    ON s.Score = r.Score\\nORDER BY r.Rank;\\n```",
                "solutionTags": [],
                "code": "```SQL\\nSELECT s.Score, r.Rank\\nFROM (\\n    --  Subquery 2: Generate row_number\\n    SELECT Score, (@row_number:=@row_number + 1) AS `Rank`\\n    FROM (\\n        -- Subquery 1: Generate ranked, unique scores\\n        SELECT Score\\n        FROM Scores\\n        GROUP BY Score\\n        ORDER BY Score DESC\\n    ) AS s, (SELECT @row_number:=0) AS dummie\\n) AS r\\nRIGHT JOIN Scores AS s\\n    ON s.Score = r.Score\\nORDER BY r.Rank;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 354027,
                "title": "sql-easy-to-understand",
                "content": "SELECT s.Score, COUNT(t.Score) AS Rank FROM\\n(SELECT DISTINCT Score FROM Scores) AS t, Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.Id, s.Score\\nORDER BY s.Score DESC;",
                "solutionTags": [],
                "code": "SELECT s.Score, COUNT(t.Score) AS Rank FROM\\n(SELECT DISTINCT Score FROM Scores) AS t, Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.Id, s.Score\\nORDER BY s.Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 163333,
                "title": "no-variable-no-group-by",
                "content": "SELECT t1.Score,(\\nSELECT COUNT(DISTINCT t2.Score)+1\\n    FROM Scores t2\\n    WHERE t1.Score < t2.Score\\n) AS Rank\\nFROM Scores t1\\nORDER BY t1.Score DESC",
                "solutionTags": [],
                "code": "SELECT t1.Score,(\\nSELECT COUNT(DISTINCT t2.Score)+1\\n    FROM Scores t2\\n    WHERE t1.Score < t2.Score\\n) AS Rank\\nFROM Scores t1\\nORDER BY t1.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 3979058,
                "title": "sql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nSelect score, dense_rank() over (Order By score DESC) as \\'rank\\' from Scores ;\\n```",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSelect score, dense_rank() over (Order By score DESC) as \\'rank\\' from Scores ;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3466260,
                "title": "easy-approach",
                "content": "\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over( order by score desc) as \\'rank\\' from scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over( order by score desc) as \\'rank\\' from scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324093,
                "title": "mysql-solution",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over (order by score desc) as `rank`\\nfrom Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over (order by score desc) as `rank`\\nfrom Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2797938,
                "title": "oracle-solution-with-correlated-subquery",
                "content": "```\\nSELECT s1.score AS score, \\n(\\n    SELECT COUNT(DISTINCT s2.score) \\n    FROM scores s2 \\n    WHERE s1.score < s2.score \\n) + 1 AS rank\\nFROM Scores s1\\nORDER BY score DESC;\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nSELECT s1.score AS score, \\n(\\n    SELECT COUNT(DISTINCT s2.score) \\n    FROM scores s2 \\n    WHERE s1.score < s2.score \\n) + 1 AS rank\\nFROM Scores s1\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2620875,
                "title": "sql-easy-approach-simple-and-fast",
                "content": "**If You Like, Please Upvote.**\\n![image](https://assets.leetcode.com/users/images/326dcf2e-e386-4ecf-8eb7-49c26770842f_1664080468.680641.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "**If You Like, Please Upvote.**\\n![image](https://assets.leetcode.com/users/images/326dcf2e-e386-4ecf-8eb7-49c26770842f_1664080468.680641.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2411341,
                "title": "simple-solution-using-correlated-subquery",
                "content": "```\\nselect score,\\n(select count(s2.score) from (select distinct score from scores) s2 \\nwhere s2.score >= s1.score) as \"RANK\"\\nfrom scores s1 \\nORDER BY score DESC;\\n```\\n\\nApproach : Rank will be decided based on unique scores. We want rank of all the scores. So the idea is to loop for all distinct scores and find the count of scores(s2) greater than or equal to current distinct score (s1) and store it as rank and display it in descending order.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\n(select count(s2.score) from (select distinct score from scores) s2 \\nwhere s2.score >= s1.score) as \"RANK\"\\nfrom scores s1 \\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1305451,
                "title": "mysql-no-dense-rank-436ms-17-66",
                "content": "I was not aware that SQL had a function for this already, so after quite a bit of trial and error I arrived at this solution.\\n\\n```\\nSELECT s3.Score, s4.Rank\\nFROM Scores s3\\nINNER JOIN ( SELECT Score, @i:=@i+1 \\'Rank\\'\\n            FROM ( SELECT DISTINCT Score\\n                    FROM Scores\\n                    ORDER BY Score DESC) s1\\n            CROSS JOIN (SELECT @i:=0) s2) s4\\nON s3.Score = s4.Score\\nORDER BY s3.Score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s3.Score, s4.Rank\\nFROM Scores s3\\nINNER JOIN ( SELECT Score, @i:=@i+1 \\'Rank\\'\\n            FROM ( SELECT DISTINCT Score\\n                    FROM Scores\\n                    ORDER BY Score DESC) s1\\n            CROSS JOIN (SELECT @i:=0) s2) s4\\nON s3.Score = s4.Score\\nORDER BY s3.Score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1122959,
                "title": "using-dense-rank-in-mysql-97-faster",
                "content": "```\\nSelect score, DENSE_RANK() over (\\norder by Score desc\\n)\\'Rank\\' from Scores;\\n```",
                "solutionTags": [],
                "code": "```\\nSelect score, DENSE_RANK() over (\\norder by Score desc\\n)\\'Rank\\' from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 374182,
                "title": "simply-answer",
                "content": "select s1.score, count(distinct s2.score) as Rank\\nfrom scores s1, scores s2\\nwhere s1.score <=s2.score\\ngroup by s1.id\\norder by s1.score desc\\n",
                "solutionTags": [],
                "code": "select s1.score, count(distinct s2.score) as Rank\\nfrom scores s1, scores s2\\nwhere s1.score <=s2.score\\ngroup by s1.id\\norder by s1.score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 259968,
                "title": "solution-accepted",
                "content": "SELECT Score, \\n       (SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= s.Score) Rank\\nFROM Scores s\\nORDER BY Score DESC",
                "solutionTags": [],
                "code": "SELECT Score, \\n       (SELECT COUNT(DISTINCT Score) FROM Scores WHERE Score >= s.Score) Rank\\nFROM Scores s\\nORDER BY Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 187650,
                "title": "simple-dense-rank-solution",
                "content": "select score, dense_rank() over (  order by Score desc) [Rank] from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (  order by Score desc) [Rank] from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 53141,
                "title": "runtime-704-ms-use-two-variables",
                "content": "    select Score,Rank from \\n    (\\n    SELECT Score,\\n           CASE\\n               WHEN @dummy <=> Score THEN @Rank := @Rank \\n               ELSE @Rank := @Rank +1\\n    \\tEND AS Rank,@dummy := Score as dummy\\n    FROM\\n      (SELECT @Rank := 0,@dummy := NULL) r,\\n         Scores\\n    ORDER BY Score DESC\\n    ) AS C",
                "solutionTags": [],
                "code": "    select Score,Rank from \\n    (\\n    SELECT Score,\\n           CASE\\n               WHEN @dummy <=> Score THEN @Rank := @Rank \\n               ELSE @Rank := @Rank +1\\n    \\tEND AS Rank,@dummy := Score as dummy\\n    FROM\\n      (SELECT @Rank := 0,@dummy := NULL) r,\\n         Scores\\n    ORDER BY Score DESC\\n    ) AS C",
                "codeTag": "Unknown"
            },
            {
                "id": 53101,
                "title": "accepted-solution-with-variables",
                "content": "    select Score,\\n      case \\n        when @prevScore = Score then @rank\\n        when (@prevScore := Score) is not null then @rank := @rank+1\\n      end as Rank\\n    from Scores, (select @rank := 0, @prevScore := NULL) a\\n    order by Score desc;",
                "solutionTags": [],
                "code": "    select Score,\\n      case \\n        when @prevScore = Score then @rank\\n        when (@prevScore := Score) is not null then @rank := @rank+1\\n      end as Rank\\n    from Scores, (select @rank := 0, @prevScore := NULL) a\\n    order by Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 3872696,
                "title": "simple-mysql-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over (order by score desc) as \\'Rank\\' from Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score,dense_rank() over (order by score desc) as \\'Rank\\' from Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3855743,
                "title": "simple-approach-beats-98",
                "content": "```\\nselect score,\\ndense_rank() over (order by score desc) as \\'Rank\\'\\nfrom Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\ndense_rank() over (order by score desc) as \\'Rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3850396,
                "title": "pandas-3-lines-sort-dense-rank",
                "content": "\\n# Code\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    # assign lowest rank to highest value\\n    # `method=\\'dense\\'` assigns same rank to equal values without skipping ranks\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    # assign lowest rank to highest value\\n    # `method=\\'dense\\'` assigns same rank to equal values without skipping ranks\\n    df[\\'rank\\'] = df[\\'score\\'].rank(method=\\'dense\\', ascending=False) \\n    return df[[\\'score\\',\\'rank\\']]\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3523708,
                "title": "mysql-server-solution-for-rank-scores-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal of this SQL query is to retrieve the scores from the Scores table along with their corresponding rank, where the rank is determined by the score in descending order.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Use the dense_rank() function to assign a rank to each score in the Scores table, ordered by score in descending order.\\n2. Select the Score column and the rank assigned by the dense_rank() function.\\n3. The result set will contain one row for each score in the Scores table, with the score and its corresponding rank.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n The time complexity of this query depends on the size of the Scores table and the efficiency of the database engine\\'s query optimizer. In general, the time complexity of a query with an ORDER BY clause is O(n * log n), where n is the number of rows in the table. However, the dense_rank() function may help to optimize the query execution plan and reduce the actual time complexity.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this query depends on the size of the result set and the size of the columns being selected. In this case, the result set will have at most as many rows as the Scores table, and each row will have two columns (Score and Rank). Therefore, the space complexity is O(n), where n is the number of rows in the Scores table.\\n\\n\\n# Code\\n```\\n/* Write your T-SQL query statement below */\\nselect Score, dense_rank() over(order by Score desc) as Rank from Scores;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\n/* Write your T-SQL query statement below */\\nselect Score, dense_rank() over(order by Score desc) as Rank from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2908530,
                "title": "mysql-dense-rank-vs-rank",
                "content": "\\n\\n# Using **DENSE_RANK()**\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\\n\\n# Using **RANK()**\\nRank() not assigning rank in a consecutive order, it is assigning by a rank of row within same categories/ score in this case.\\n\\n\\n```\\nSELECT score, RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\\nThe following are the differences between using **DENSE_RANK()** and **RANK()**:\\n![image.png](https://assets.leetcode.com/users/images/db3ecabf-c532-4ee5-9e36-3ca47585bc47_1671004821.9050007.png)\\n\\n\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```\n```\\nSELECT score, RANK() OVER (ORDER BY score desc) as \\'rank\\'\\nFROM Scores\\nORDER BY score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2607382,
                "title": "178-rank-scores",
                "content": "```\\nSELECT score,\\n    DENSE_RANK() OVER (\\n    ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM SCORES;",
                "solutionTags": [],
                "code": "```\\nSELECT score,\\n    DENSE_RANK() OVER (\\n    ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM SCORES;",
                "codeTag": "Unknown"
            },
            {
                "id": 2237222,
                "title": "simplest-oracle-solution",
                "content": "select score,DENSE_RANK() over(order by score desc ) as rank from Scores\\norder by score desc\\n",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "select score,DENSE_RANK() over(order by score desc ) as rank from Scores\\norder by score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1730791,
                "title": "dense-rank-can-not-think-of-a-simpler-solution",
                "content": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS `rank` FROM Scores ORDER BY score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS `rank` FROM Scores ORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1660727,
                "title": "dense-rank",
                "content": "```\\nSELECT \\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM \\n    Scores;\\n```\\n\\nThe difference between rank and dense_rank is rank will skip numbers after ranking two equal values. Dense_rank will always rank with consecutive numbers.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT \\n    score,\\n    DENSE_RANK() OVER (\\n        ORDER BY score DESC\\n    ) AS \\'rank\\'\\nFROM \\n    Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1556821,
                "title": "faster-than-99-95-solution-using-mysql-s-built-in-windowing-s-dense-rank",
                "content": "Runtime: 208 ms, faster than 99.95% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores.\\n\\nThe simplest solution is to use built-in Windowing with a [`DENSE_RANK` function](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_dense-rank), which by design gives exactly what we need.\\n\\nTo learn more, please see [MySQL documentation and examples on Windowing](https://dev.mysql.com/doc/refman/8.0/en/window-functions-usage.html). Windowing concept is very powerful and is definitely the fastest way to calculate ranks, sums, averages, counts on \"buckets\" of data, where by the bucket I understand a group of data (groupped by a certain characteristic, like date, category or a given value type). Whereas Windowing is a bit harder to master, it\\'s definitely useful when creating reports.\\n\\n```sql\\n# Write your MySQL query statement below\\nSELECT\\n    s.score,\\n    DENSE_RANK() OVER (\\n        ORDER BY s.score DESC\\n    ) \\'rank\\'\\nFROM Scores s;\\n```\\n",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "```sql\\n# Write your MySQL query statement below\\nSELECT\\n    s.score,\\n    DENSE_RANK() OVER (\\n        ORDER BY s.score DESC\\n    ) \\'rank\\'\\nFROM Scores s;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1516798,
                "title": "without-dense-rank",
                "content": "Select s1.Score, count(distinct s2.Score) as \"Rank\"\\n    From Scores s1\\n    Join Scores s2 \\n    where s1.Score<=s2.Score\\n    Group by s1.Id\\n    order by Score DESC",
                "solutionTags": [],
                "code": "Select s1.Score, count(distinct s2.Score) as \"Rank\"\\n    From Scores s1\\n    Join Scores s2 \\n    where s1.Score<=s2.Score\\n    Group by s1.Id\\n    order by Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 1507145,
                "title": "mssql-dense-rank",
                "content": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY SCORE DESC) Rank\\nFROM SCORES S;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Score, DENSE_RANK() OVER (ORDER BY SCORE DESC) Rank\\nFROM SCORES S;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1174149,
                "title": "solution-without-dense-rank",
                "content": "select c.score, d.ran as \\'Rank\\' from (\\nselect a.score, ROW_NUMBER() OVER (ORDER BY a.score desc) AS ran from\\n(select distinct score from Scores) as a ) as d \\ninner join\\nScores as c \\non c.score = d.score\\norder by ran asc",
                "solutionTags": [],
                "code": "select c.score, d.ran as \\'Rank\\' from (\\nselect a.score, ROW_NUMBER() OVER (ORDER BY a.score desc) AS ran from\\n(select distinct score from Scores) as a ) as d \\ninner join\\nScores as c \\non c.score = d.score\\norder by ran asc",
                "codeTag": "Unknown"
            },
            {
                "id": 972814,
                "title": "intuitive-answer-with-inner-join",
                "content": "Per question description, the rank of a number $a$ is the number of unique numbers larger than or equal to $a$. Translate that into sql:\\n\\n```sql\\n# Write your MySQL query statement below\\n\\nselect a.score\\n    , count(distinct(b.score)) as `Rank`\\nfrom Scores a\\ninner join Scores b\\non b.score >= a.score\\ngroup by a.id, a.score\\norder by `Rank` ASC\\n```",
                "solutionTags": [],
                "code": "```sql\\n# Write your MySQL query statement below\\n\\nselect a.score\\n    , count(distinct(b.score)) as `Rank`\\nfrom Scores a\\ninner join Scores b\\non b.score >= a.score\\ngroup by a.id, a.score\\norder by `Rank` ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 902347,
                "title": "one-line-with-dense-rank",
                "content": "select score, dense_rank() over (order by score desc) as \\'Rank\\' from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as \\'Rank\\' from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 586577,
                "title": "1-liner",
                "content": "select score, dense_rank() over (order by score desc) as rank from scores",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as rank from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 437961,
                "title": "simple-mysql-solution-accepted-runtime-264-ms",
                "content": "SELECT t1.Score,(SELECT count(distinct Score)+1 from Scores t2 where t2.Score-t1.Score>0.00001) Rank FROM Scores t1 ORDER BY Rank;",
                "solutionTags": [],
                "code": "SELECT t1.Score,(SELECT count(distinct Score)+1 from Scores t2 where t2.Score-t1.Score>0.00001) Rank FROM Scores t1 ORDER BY Rank;",
                "codeTag": "Unknown"
            },
            {
                "id": 415318,
                "title": "one-more-simple-solution",
                "content": "Select s1.Score, ((Select  COUNT(DISTINCT Score)  From Scores Where Score > s1.Score) + 1) as Rank From Scores  s1    ORDER BY s1.Score DESC",
                "solutionTags": [],
                "code": "Select s1.Score, ((Select  COUNT(DISTINCT Score)  From Scores Where Score > s1.Score) + 1) as Rank From Scores  s1    ORDER BY s1.Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 268759,
                "title": "very-simple-solution",
                "content": "```\\nSELECT  Score, DENSE_RANK( ) OVER (ORDER BY Score DESC ) as Rank\\nFROM Scores;",
                "solutionTags": [],
                "code": "```\\nSELECT  Score, DENSE_RANK( ) OVER (ORDER BY Score DESC ) as Rank\\nFROM Scores;",
                "codeTag": "Unknown"
            },
            {
                "id": 261595,
                "title": "solution-accepted",
                "content": "# Write your MySQL query statement below\\n```sql\\nSELECT Scores.Score as Score, count(rankings.Score) as Rank\\nFROM Scores, (Select Distinct Score from Scores) as rankings\\nWhere rankings.Score >= Scores.Score\\nGroup by Scores.id\\nOrder by Scores.Score DESC;\\n```",
                "solutionTags": [],
                "code": "```sql\\nSELECT Scores.Score as Score, count(rankings.Score) as Rank\\nFROM Scores, (Select Distinct Score from Scores) as rankings\\nWhere rankings.Score >= Scores.Score\\nGroup by Scores.id\\nOrder by Scores.Score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 229353,
                "title": "mysql-solution-not-use-row-number-function",
                "content": "This question seems to be not allowed row_number function.\\n```\\nselect score, rank\\nfrom\\n(\\n select \\n  a.id, \\n  a.score, \\n  count(distinct b.score) + 1 as rank \\n from Scores a \\n left outer join Scores b \\n on a.score < b.score\\n group by a.id, a.score\\n) tbl\\norder by rank\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, rank\\nfrom\\n(\\n select \\n  a.id, \\n  a.score, \\n  count(distinct b.score) + 1 as rank \\n from Scores a \\n left outer join Scores b \\n on a.score < b.score\\n group by a.id, a.score\\n) tbl\\norder by rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 175722,
                "title": "simple-and-easy-to-understand",
                "content": "```\\nSELECT Scores.Score ,COUNT(DISTINCT greater.Score)+1 AS Rank\\nFROM Scores\\nLEFT JOIN Scores greater ON greater.Score>Scores.Score\\nGROUP BY Scores.Id\\nORDER BY Rank\\n```\\n\\nNotice that \\'rank of a score\\' = \\'#unique scores\\' + 1. For example, rank(4.0) = 0(no unique score greater than 4.0) + 1 = 1. \\nWe want to count unique score here because we want dense rank, which means all scores with the same value will be calculated as one rank (say two 4.0 won\\'t let 3.85 be rank3)\\u3002\\nIn the sql\\uFF0Cwe left join the original table with itself and calculate distinct count of scores greater than the current value. And the rank of current value = this count+1 ",
                "solutionTags": [],
                "code": "```\\nSELECT Scores.Score ,COUNT(DISTINCT greater.Score)+1 AS Rank\\nFROM Scores\\nLEFT JOIN Scores greater ON greater.Score>Scores.Score\\nGROUP BY Scores.Id\\nORDER BY Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 170610,
                "title": "using-dense-rank-387ms-sql-server",
                "content": "```select  Score, dense_rank() over (order by Score DESC) as Rank from Scores;```",
                "solutionTags": [],
                "code": "```select  Score, dense_rank() over (order by Score DESC) as Rank from Scores;```",
                "codeTag": "Unknown"
            },
            {
                "id": 143486,
                "title": "accepted-solution-looking-for-simplified-idea",
                "content": "SELECT Score, CAST(Rank AS UNSIGNED) AS Rank\\nFROM (\\n    SELECT Score, CASE \\n        WHEN @preScore = Score \\n        THEN @countRank \\n        ELSE @countRank := @countRank + 1 \\n        END AS Rank, @preScore := Score AS preScore\\n    FROM Scores AS s, (SELECT @countRank := 0, @preScore := NULL) AS p\\n    ORDER BY Score DESC) AS sr;\\n",
                "solutionTags": [],
                "code": "SELECT Score, CAST(Rank AS UNSIGNED) AS Rank\\nFROM (\\n    SELECT Score, CASE \\n        WHEN @preScore = Score \\n        THEN @countRank \\n        ELSE @countRank := @countRank + 1 \\n        END AS Rank, @preScore := Score AS preScore\\n    FROM Scores AS s, (SELECT @countRank := 0, @preScore := NULL) AS p\\n    ORDER BY Score DESC) AS sr;\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 124148,
                "title": "184ms-solution-beats-100-submission-easy-to-understand",
                "content": "Runtime 184ms\\n\\nFirst, create a table with distinct score and generate new rank id from 1 to 4.\\nSecond, left join with Scores table on score, keep score and rank id, then order by rank.\\n\\n```\\nSelect Scores.score as Score, rank.rankid as Rank\\nfrom\\nscores left join\\n(select @rowid := @rowid + 1 as rankid, temp1.score\\nfrom \\n    (select distinct score from scores order by score desc) as temp1, \\n    (select @rowid:=0) as temp2) as rank\\non Scores.score = rank.score\\norder by Rank\\n```",
                "solutionTags": [],
                "code": "```\\nSelect Scores.score as Score, rank.rankid as Rank\\nfrom\\nscores left join\\n(select @rowid := @rowid + 1 as rankid, temp1.score\\nfrom \\n    (select distinct score from scores order by score desc) as temp1, \\n    (select @rowid:=0) as temp2) as rank\\non Scores.score = rank.score\\norder by Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 53147,
                "title": "my-accepted-solution",
                "content": "# Write your MySQL query statement below\\nselect a.Score, count(b.Score) as Rank\\nfrom Scores as a, \\n    (select distinct Score\\n     from Scores) as b\\nwhere a.Score <= b.Score\\ngroup by a.ID\\norder by a.Score desc\\n;",
                "solutionTags": [],
                "code": "# Write your MySQL query statement below\\nselect a.Score, count(b.Score) as Rank\\nfrom Scores as a, \\n    (select distinct Score\\n     from Scores) as b\\nwhere a.Score <= b.Score\\ngroup by a.ID\\norder by a.Score desc\\n;",
                "codeTag": "Unknown"
            },
            {
                "id": 53151,
                "title": "solution-accepted-by-the-sqlfiddle-but-get-runtime-error-in-oj",
                "content": "[http://www.sqlfiddle.com/#!2/dc9b4d/3][1]\\n\\n\\n  [1]: http://www.sqlfiddle.com/#!2/dc9b4d/3",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 3983443,
                "title": "extremely-simple-solution-in-mysql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nSELECT s1.score, count(s2.score) AS \\'rank\\'\\nFROM scores s1, (SELECT DISTINCT score FROM scores) s2\\nWHERE s2.score>=s1.Score\\nGROUP BY s1.Id \\nORDER BY s1.score DESC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s1.score, count(s2.score) AS \\'rank\\'\\nFROM scores s1, (SELECT DISTINCT score FROM scores) s2\\nWHERE s2.score>=s1.Score\\nGROUP BY s1.Id \\nORDER BY s1.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3931507,
                "title": "pandas-2-easy-and-different-ways-to-solve",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**Method 1:**\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    \\n    rank = []\\n    max_score = 1e9\\n    curr_rank = 0\\n    \\n    for idx, row in df.iterrows():\\n        if row.score == max_score:\\n            rank.append(curr_rank)\\n        else:\\n            max_score = row.score\\n            curr_rank += 1\\n            rank.append(curr_rank)\\n            \\n    df[\\'rank\\'] = rank\\n    \\n    return df[[\\'score\\', \\'rank\\']]\\n```\\n\\n**Method 2:**\\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    return scores[[\\'score\\', \\'rank\\']].sort_values(by=\\'score\\', ascending=False)\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    df = scores.sort_values(by=\\'score\\', ascending=False)\\n    \\n    rank = []\\n    max_score = 1e9\\n    curr_rank = 0\\n    \\n    for idx, row in df.iterrows():\\n        if row.score == max_score:\\n            rank.append(curr_rank)\\n        else:\\n            max_score = row.score\\n            curr_rank += 1\\n            rank.append(curr_rank)\\n            \\n    df[\\'rank\\'] = rank\\n    \\n    return df[[\\'score\\', \\'rank\\']]\\n```\n```\\nimport pandas as pd\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    \\n    scores[\\'rank\\'] = scores[\\'score\\'].rank(method=\\'dense\\', ascending=False)\\n    \\n    return scores[[\\'score\\', \\'rank\\']].sort_values(by=\\'score\\', ascending=False)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3678531,
                "title": "one-liner-solution-with-explanation",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe intuition behind the solution is to use the **dense_rank()** function to assign ranks to the scores in descending order, ensuring that higher scores receive lower ranks.\\n\\n\\n# Approach\\nTo solve the problem, we need to rank the scores in descending order and assign a rank to each score. Here\\'s how your SQL query accomplishes this:\\n\\n1. The SELECT statement is used to select the \"Score\" column from the \"Scores\" table. This retrieves all the scores from the table.\\n\\n1. The **DENSE_RANK() OVER (ORDER BY Score DESC)** function is used to calculate the rank of each score. The DENSE_RANK() function assigns the same rank to scores with the same value, and the ranks are determined based on the score values. The ORDER BY Score DESC part ensures that the scores are sorted in descending order before assigning the ranks.\\n\\n1. The result of the query includes both the \"Score\" and \"Rank\" columns. This means that for each score, you will see its corresponding rank in the output.\\n\\n1. The query handles the ranking and ordering of the scores for us, so we don\\'t need to manually implement any logic to determine the ranks. By using the **DENSE_RANK()** function, the query efficiently assigns ranks to the scores in descending order.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this approach is dependent on the number of scores in the Scores table and the efficiency of the DENSE_RANK() function. The time complexity is typically $$O(n log n)$$ or better, as it involves sorting the scores.\\n\\n- Space complexity:\\nThe space complexity is determined by the size of the input data (the Scores table) and the storage required for the result set. In this case, the space complexity is $$O(n)$$, where n is the number of scores in the table.\\n\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\n\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores;\\n\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/d3db36f0-8de0-4f9d-96d2-b38b6d7bf201_1687639061.1030006.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "MySQL",
                    "Database"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3534148,
                "title": "direct-by-using-dense-rank-method",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect Score as score , (dense_rank() over(order by Score desc)) as \"rank\" from Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect Score as score , (dense_rank() over(order by Score desc)) as \"rank\" from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3171344,
                "title": "mysql-easy-approach",
                "content": "Here is my MYSQL code for this problem.\\n\\n# Code\\n```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over(order by score desc) as \"Rank\" from Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nselect score, dense_rank() over(order by score desc) as \"Rank\" from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2761644,
                "title": "simple-solution-two-approaches-sql",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThanks for the question. I learned about Rank and Dense Rank functions in sql\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitially tried with the regular approach using subquery but came to know we can do quickly using rank function.\\n\\n\\n\\n\\n# Code\\n```\\n#Subquery\\nselect s1.score,(select count(distinct s2.score) from scores s2\\nwhere s2.score>=s1.score) \\'rank\\'\\nfrom scores s1\\norder by score desc\\n\\n#Functions\\nselect score, DENSE_RANK () OVER( Order by score desc ) \\'rank\\' \\nfrom scores \\norder by score desc\\n```\\n\\nPlease upvote if you find the solution useful :) Happy Learning!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n#Subquery\\nselect s1.score,(select count(distinct s2.score) from scores s2\\nwhere s2.score>=s1.score) \\'rank\\'\\nfrom scores s1\\norder by score desc\\n\\n#Functions\\nselect score, DENSE_RANK () OVER( Order by score desc ) \\'rank\\' \\nfrom scores \\norder by score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2581831,
                "title": "simple-solution-mysql",
                "content": "```\\nselect score, dense_rank() over(order by score desc) as \\'Rank\\' from Scores;\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) as \\'Rank\\' from Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2567630,
                "title": "using-dense-rank-in-single-select",
                "content": "**Upvote if you feel it easy :)**\\n```\\nSELECT score, DENSE_RANK() OVER(ORDER BY score DESC) as Rank\\nFROM Scores\\nORDER BY score DESC;\\n```",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "```\\nSELECT score, DENSE_RANK() OVER(ORDER BY score DESC) as Rank\\nFROM Scores\\nORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2555084,
                "title": "mysql-two-apparoches",
                "content": "```\\n-- approach 1 \\n# SELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \"rank\"\\n# FROM scores;\\n\\n\\n-- approach 2 \\nSELECT s1.score,\\n     (SELECT count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nFROM scores s1\\norder by s1.score desc;",
                "solutionTags": [],
                "code": "```\\n-- approach 1 \\n# SELECT score, DENSE_RANK() OVER (ORDER BY score desc) as \"rank\"\\n# FROM scores;\\n\\n\\n-- approach 2 \\nSELECT s1.score,\\n     (SELECT count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nFROM scores s1\\norder by s1.score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 2451783,
                "title": "solution-with-proper-explanation-easy-to-understand",
                "content": "**Please  Press the ^ Star above**\\n\\nThere is RANK() and DENSE_RANK()\\n\\nUnlike the RANK() function, the DENSE_RANK() function returns consecutive rank values. Rows in each partition receive the same ranks if they have the same values.\\n\\n```\\nSELECT score , DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score , DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2446634,
                "title": "mysql-using-dense-rank-100-fast-solution",
                "content": "Simple, Short, Fast\\n\\n```\\nSELECT score,  \\n       DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```\\n\\nDo comment your suggestions!!",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score,  \\n       DENSE_RANK() OVER(ORDER BY score DESC) as \\'rank\\'\\nFROM Scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2397131,
                "title": "sql-server-one-line-dense-rank-easy-understanding",
                "content": "\\tSELECT SCORE , DENSE_RANK() OVER (ORDER BY SCORE DESC) AS RANK FROM Scores",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "\\tSELECT SCORE , DENSE_RANK() OVER (ORDER BY SCORE DESC) AS RANK FROM Scores",
                "codeTag": "Unknown"
            },
            {
                "id": 2203985,
                "title": "mysql-without-dense-rank-easy",
                "content": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nfrom scores s1 order by s1.score desc\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect s1.score, (select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\"\\nfrom scores s1 order by s1.score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2061067,
                "title": "simple-easy-mysql-solution-using-dense-rank",
                "content": "```\\nSELECT SCORE,\\nDENSE_RANK() OVER(ORDER BY SCORE DESC) AS \\'rank\\'\\nFROM SCORES;\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT SCORE,\\nDENSE_RANK() OVER(ORDER BY SCORE DESC) AS \\'rank\\'\\nFROM SCORES;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2012104,
                "title": "ms-sql",
                "content": "Select A.score,B.rank FROM Scores A Inner JOIN \\n(Select score,ROW_NUMBER() OVER (ORDER BY score desc) as rank  FROM Scores A with(nolock) group by score ) B ON A.score = B.score\\norder by B.rank",
                "solutionTags": [],
                "code": "Select A.score,B.rank FROM Scores A Inner JOIN \\n(Select score,ROW_NUMBER() OVER (ORDER BY score desc) as rank  FROM Scores A with(nolock) group by score ) B ON A.score = B.score\\norder by B.rank",
                "codeTag": "Unknown"
            },
            {
                "id": 1974551,
                "title": "a-short-and-clean-solution-through-dense-rank",
                "content": "```\\nselect score, dense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score, dense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971713,
                "title": "t-sql-3-ways-dense-rank-groupby-subquery",
                "content": "```\\n/* Write your T-SQL query statement below */\\n--select score, dense_rank() over (order by score desc) as rank from Scores order by 1 desc\\n--select score,  (select count(*) from (select distinct score from Scores) t where t.score>=s.score) rank from Scores s order by 1 desc\\nselect s.score, count(distinct t.score) as rank\\nfrom Scores s join Scores t on s.score<=t.score \\ngroup by s.id,s.score\\norder by 1 desc\\n```",
                "solutionTags": [],
                "code": "```\\n/* Write your T-SQL query statement below */\\n--select score, dense_rank() over (order by score desc) as rank from Scores order by 1 desc\\n--select score,  (select count(*) from (select distinct score from Scores) t where t.score>=s.score) rank from Scores s order by 1 desc\\nselect s.score, count(distinct t.score) as rank\\nfrom Scores s join Scores t on s.score<=t.score \\ngroup by s.id,s.score\\norder by 1 desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1860356,
                "title": "easy-to-understand-solution-no-window-function-no-subqueries",
                "content": "```\\nselect a.score , count(distinct b.score) rank\\nfrom scores a inner join scores b on b.score >= a.score\\ngroup by a.id , a.score \\norder by 2 asc\\n```",
                "solutionTags": [
                    "Oracle"
                ],
                "code": "```\\nselect a.score , count(distinct b.score) rank\\nfrom scores a inner join scores b on b.score >= a.score\\ngroup by a.id , a.score \\norder by 2 asc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1793653,
                "title": "easy-ms-sql-dense-rank",
                "content": "select score, dense_rank() over (order by score desc) as rank from Scores",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "select score, dense_rank() over (order by score desc) as rank from Scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1659612,
                "title": "solution",
                "content": "select score, dense_rank() over (order by score desc) as rank from Scores order by rank",
                "solutionTags": [],
                "code": "select score, dense_rank() over (order by score desc) as rank from Scores order by rank",
                "codeTag": "Unknown"
            },
            {
                "id": 1611930,
                "title": "use-dense-rank-with-mysql-very-simple",
                "content": "```\\nSELECT\\n    score, DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM\\n    Scores\\n;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT\\n    score, DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM\\n    Scores\\n;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1600162,
                "title": "short-simple-using-dense-rank-224ms",
                "content": "simple and short answer using dense_rank()\\n```\\nselect score, dense_rank() over (order by score desc ) \"rank\" from scores;\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over (order by score desc ) \"rank\" from scores;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1588386,
                "title": "very-easy-solution-using-window-function",
                "content": "SELECT score, DENSE_RANK() OVER (ORDER BY Score DESC) as \\'rank\\' FROM scores",
                "solutionTags": [
                    "MySQL",
                    "Sliding Window"
                ],
                "code": "SELECT score, DENSE_RANK() OVER (ORDER BY Score DESC) as \\'rank\\' FROM scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1581489,
                "title": "3-lines-using-dense-rank-384ms",
                "content": "**** i don\\'t know why the answers provided by y\\'all are so complicated. So complicated that I don\\'t even understand. Here is a simple solution that works.\\n```\\nselect score, \\ndense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "solutionTags": [],
                "code": "```\\nselect score, \\ndense_rank() over (order by score desc) \\'rank\\'\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1512713,
                "title": "ms-sql",
                "content": "#### Question\\n````\\nSQL Schema\\nTable: Scores\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Score       | decimal |\\n+-------------+---------+\\nId is the primary key for this table.\\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\\n \\n\\nWrite an SQL query to rank the scores. The ranking should be calculated according to the following rules:\\n\\nThe scores should be ranked from the highest to the lowest.\\nIf there is a tie between two scores, both should have the same ranking.\\nAfter a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.\\nReturn the result table ordered by score in descending order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nScores table:\\n+----+-------+\\n| Id | Score |\\n+----+-------+\\n| 1  | 3.50  |\\n| 2  | 3.65  |\\n| 3  | 4.00  |\\n| 4  | 3.85  |\\n| 5  | 4.00  |\\n| 6  | 3.65  |\\n+----+-------+\\nOutput: \\n+-------+------+\\n| Score | Rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n````\\n#### Answer\\n```\\nselect Score, dense_rank() over (order by Score desc) as Rank from Scores\\norder by Score desc\\n",
                "solutionTags": [
                    "MS SQL Server"
                ],
                "code": "````\\nSQL Schema\\nTable: Scores\\n\\n+-------------+---------+\\n| Column Name | Type    |\\n+-------------+---------+\\n| Id          | int     |\\n| Score       | decimal |\\n+-------------+---------+\\nId is the primary key for this table.\\nEach row of this table contains the score of a game. Score is a floating point value with two decimal places.\\n \\n\\nWrite an SQL query to rank the scores. The ranking should be calculated according to the following rules:\\n\\nThe scores should be ranked from the highest to the lowest.\\nIf there is a tie between two scores, both should have the same ranking.\\nAfter a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.\\nReturn the result table ordered by score in descending order.\\n\\nThe query result format is in the following example.\\n\\n \\n\\nExample 1:\\n\\nInput: \\nScores table:\\n+----+-------+\\n| Id | Score |\\n+----+-------+\\n| 1  | 3.50  |\\n| 2  | 3.65  |\\n| 3  | 4.00  |\\n| 4  | 3.85  |\\n| 5  | 4.00  |\\n| 6  | 3.65  |\\n+----+-------+\\nOutput: \\n+-------+------+\\n| Score | Rank |\\n+-------+------+\\n| 4.00  | 1    |\\n| 4.00  | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.50  | 4    |\\n+-------+------+\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1487318,
                "title": "without-dense-rank",
                "content": "```\\nSELECT s.score, l.rank \\nFROM scores s\\nLEFT JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS rank \\n    FROM scores \\n    GROUP BY score\\n) l ON l.score=s.score\\nORDER BY s.score DESC;",
                "solutionTags": [],
                "code": "```\\nSELECT s.score, l.rank \\nFROM scores s\\nLEFT JOIN (\\n    SELECT score, ROW_NUMBER() OVER (ORDER BY score DESC) AS rank \\n    FROM scores \\n    GROUP BY score\\n) l ON l.score=s.score\\nORDER BY s.score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 1423441,
                "title": "simple-dense-rank",
                "content": "select Score as score,\\n        dense_rank() over(order by Score desc) as \\'Rank\\'\\nfrom Scores\\norder by Score desc\\n",
                "solutionTags": [],
                "code": "select Score as score,\\n        dense_rank() over(order by Score desc) as \\'Rank\\'\\nfrom Scores\\norder by Score desc\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1383076,
                "title": "using-corelated-subqueries",
                "content": "```\\nSELECT score, (select count(distinct score) from scores s2 where s1.score<=s2.score ) AS \"Rank\"\\nFROM Scores s1 ORDER BY score DESC;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, (select count(distinct score) from scores s2 where s1.score<=s2.score ) AS \"Rank\"\\nFROM Scores s1 ORDER BY score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1362374,
                "title": "my-sql-sol-dense-rank",
                "content": "\\n\\n    select score , dense_rank() over(order by score desc) as `Rank`\\n    from scores",
                "solutionTags": [],
                "code": "\\n\\n    select score , dense_rank() over(order by score desc) as `Rank`\\n    from scores",
                "codeTag": "Unknown"
            },
            {
                "id": 1359601,
                "title": "steps-by-step-groupby-orderby-simple-and-crisp",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT S.Score, COUNT(S2.Score) as `Rank`\\nFROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id\\nORDER BY S.Score DESC;\\n\\n/*\\nSTEPS : \\n\\n1- create a new table s2 which contains all distinct salaries. ( LINE 3)\\n2- find the number of salaries which is >= entry created in step 1 ( LINE 4 )\\n3- group them on basis of id and sort them in desc order. (LINE 5-6)\\n4- Finally, display score and count of the score. ( Line 2 ).\\n*/",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT S.Score, COUNT(S2.Score) as `Rank`\\nFROM Scores S,\\n(SELECT DISTINCT Score FROM Scores) S2\\nWHERE S.Score<=S2.Score\\nGROUP BY S.Id\\nORDER BY S.Score DESC;\\n\\n/*\\nSTEPS : \\n\\n1- create a new table s2 which contains all distinct salaries. ( LINE 3)\\n2- find the number of salaries which is >= entry created in step 1 ( LINE 4 )\\n3- group them on basis of id and sort them in desc order. (LINE 5-6)\\n4- Finally, display score and count of the score. ( Line 2 ).\\n*/",
                "codeTag": "Unknown"
            },
            {
                "id": 1320960,
                "title": "join-286ms",
                "content": "\\n\\'\\'\\'\\nselect s1.Score, s2.Rank from Scores s1\\nleft join (\\n    select Score, row_number() over (order by Score desc) as \"Rank\" from Scores\\ngroup by Score) as s2 \\non s1.Score = s2.Score\\norder by s1.Score desc \\n\\'\\'\\'",
                "solutionTags": [],
                "code": "\\n\\'\\'\\'\\nselect s1.Score, s2.Rank from Scores s1\\nleft join (\\n    select Score, row_number() over (order by Score desc) as \"Rank\" from Scores\\ngroup by Score) as s2 \\non s1.Score = s2.Score\\norder by s1.Score desc \\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 1217702,
                "title": "row-number-solution",
                "content": "```\\nselect s.Score, srn.rn as \\'rank\\'\\nfrom Scores s left join (select a.Score, row_number() over (order by a.Score desc) as rn\\n                         from (select distinct Score from Scores) a) srn\\non s.Score = srn.Score\\norder by Score desc\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect s.Score, srn.rn as \\'rank\\'\\nfrom Scores s left join (select a.Score, row_number() over (order by a.Score desc) as rn\\n                         from (select distinct Score from Scores) a) srn\\non s.Score = srn.Score\\norder by Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158391,
                "title": "easy-2-line-solution-mysql",
                "content": "Select score, Dense_Rank() OVER(order by score DESC) as \\'Rank\\'\\nfrom Scores\\n",
                "solutionTags": [],
                "code": "Select score, Dense_Rank() OVER(order by score DESC) as \\'Rank\\'\\nfrom Scores\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1132103,
                "title": "mysql-subquery-and-inner-join-where-in",
                "content": "```\\nSELECT s.Score, rnk.Rank\\nFROM Scores s, (SELECT *, ROW_NUMBER() OVER (ORDER BY Score DESC) AS \\'Rank\\' FROM (SELECT DISTINCT Score FROM Scores) AS r2) AS rnk \\nWHERE s.Score=rnk.Score\\nORDER BY rnk.Rank ASC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT s.Score, rnk.Rank\\nFROM Scores s, (SELECT *, ROW_NUMBER() OVER (ORDER BY Score DESC) AS \\'Rank\\' FROM (SELECT DISTINCT Score FROM Scores) AS r2) AS rnk \\nWHERE s.Score=rnk.Score\\nORDER BY rnk.Rank ASC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1095407,
                "title": "mysql-single-line",
                "content": "SELECT Score,  DENSE_RANK ()  OVER( ORDER BY Score desc) AS \\'Rank\\'\\nFROM Scores\\n",
                "solutionTags": [],
                "code": "SELECT Score,  DENSE_RANK ()  OVER( ORDER BY Score desc) AS \\'Rank\\'\\nFROM Scores\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1075937,
                "title": "simple-solution",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT score,\\nDENSE_RANK() OVER(ORDER BY score DESC) AS \\'Rank\\'\\nFROM Scores\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT score,\\nDENSE_RANK() OVER(ORDER BY score DESC) AS \\'Rank\\'\\nFROM Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1037049,
                "title": "easy-solution-only-use-rank-faster-than-96-memory-less-than-100",
                "content": "The difference in using between **dense_rank** or **rank** is that, the former one would consider the tied numbers only will take one position in the rank, while the later one would consider the tied numbers will take consecutive potitions in the rank, which will leave holes in the rank.\\n\\nEasy to understood coding part:\\n\\n```\\nselect score, dense_rank() over(order by score desc) as Rank\\nfrom scores\\norder by 1 desc\\n```\\nThis is the reference link for SQL RANK functions, very helpful:\\nhttps://www.sqlshack.com/overview-of-sql-rank-functions/",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) as Rank\\nfrom scores\\norder by 1 desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1023926,
                "title": "dense-rank",
                "content": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \"rank\"\\nFROM\\n    scores\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT\\n    score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \"rank\"\\nFROM\\n    scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 820791,
                "title": "simple-mysql-solution",
                "content": "```\\nselect score, dense_rank() over(order by score desc) \\'Rank\\' from scores\\n```\\n",
                "solutionTags": [],
                "code": "```\\nselect score, dense_rank() over(order by score desc) \\'Rank\\' from scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 792226,
                "title": "360-ms-simple-solution",
                "content": "```\\nselect Score, \\n    (select count(s2.Score) \\n     from (select distinct Score from Scores) s2 \\n     where s2.Score >= s1.Score\\n    ) \\'Rank\\'\\nfrom Scores s1 \\norder by Score desc;",
                "solutionTags": [],
                "code": "```\\nselect Score, \\n    (select count(s2.Score) \\n     from (select distinct Score from Scores) s2 \\n     where s2.Score >= s1.Score\\n    ) \\'Rank\\'\\nfrom Scores s1 \\norder by Score desc;",
                "codeTag": "Unknown"
            },
            {
                "id": 759504,
                "title": "using-row-number",
                "content": "```\\n\\nSELECT d.score, e.rank FROM scores d INNER JOIN\\n(SELECT e.score, ROW_NUMBER() OVER( ORDER BY score DESC) `rank` \\nFROM (SELECT DISTINCT score FROM scores) e) e \\nON d.score=e.score\\nORDER BY d.score DESC;\\n```",
                "solutionTags": [],
                "code": "```\\n\\nSELECT d.score, e.rank FROM scores d INNER JOIN\\n(SELECT e.score, ROW_NUMBER() OVER( ORDER BY score DESC) `rank` \\nFROM (SELECT DISTINCT score FROM scores) e) e \\nON d.score=e.score\\nORDER BY d.score DESC;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 751692,
                "title": "with-out-dense-rank",
                "content": "```\\nselect a.score,count(distinct b.score) as \\'rank\\'\\nfrom scores a, scores b\\nwhere a.score<=b.score\\ngroup by a.id\\norder by 2\\n```",
                "solutionTags": [],
                "code": "```\\nselect a.score,count(distinct b.score) as \\'rank\\'\\nfrom scores a, scores b\\nwhere a.score<=b.score\\ngroup by a.id\\norder by 2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 629140,
                "title": "easy-to-understand-mysql-with-explanation",
                "content": "First, we need 2 tables: The original table and another table where we only have distinct scores\\nTable A: `SELECT A.id, A.score FROM Scores A`\\nTable B: `SELECT DISTINCT(score) as score FROM Scores B`\\n\\nThen we JOIN both the tables where the scores from Table A <= Table B:\\n```\\nSELECT A.id, A.score, B.score\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nORDER BY A.id, A.score DESC, B.score ASC\\n```\\nThe trick here is where A.score <= B.score.\\n\\nNow, we GROUP BY A.id, COUNT B.score and lastly order A.score in descending order.\\n```\\nSELECT A.score as Score, COUNT(B.score) as \\'Rank\\'\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nGROUP BY A.id\\nORDER BY A.score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT A.id, A.score, B.score\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nORDER BY A.id, A.score DESC, B.score ASC\\n```\n```\\nSELECT A.score as Score, COUNT(B.score) as \\'Rank\\'\\nFROM Scores A JOIN (SELECT DISTINCT(score) as score FROM Scores) B ON A.score<=B.score\\nGROUP BY A.id\\nORDER BY A.score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 619623,
                "title": "mysql-using-subquery",
                "content": "```\\nSELECT \\n    score,\\n    (SELECT COUNT(DISTINCT score) FROM scores WHERE score > s.score) + 1 AS \\'Rank\\'\\nFROM Scores s\\nORDER BY score DESC\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT \\n    score,\\n    (SELECT COUNT(DISTINCT score) FROM scores WHERE score > s.score) + 1 AS \\'Rank\\'\\nFROM Scores s\\nORDER BY score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508386,
                "title": "non-dense-rank-solution",
                "content": "\\n```\\nselect Score,\\n    (select COUNT(DISTINCT S2.Score)\\n    from Scores as S2\\n    where S2.Score > S1.Score) +1  as Rank\\nfrom Scores as S1\\norder by Rank\\n```",
                "solutionTags": [],
                "code": "```\\nselect Score,\\n    (select COUNT(DISTINCT S2.Score)\\n    from Scores as S2\\n    where S2.Score > S1.Score) +1  as Rank\\nfrom Scores as S1\\norder by Rank\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 501553,
                "title": "dense-rank",
                "content": "SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\n    FROM Scores \\n    ORDER BY Score DESC",
                "solutionTags": [],
                "code": "SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank\\n    FROM Scores \\n    ORDER BY Score DESC",
                "codeTag": "Unknown"
            },
            {
                "id": 491921,
                "title": "solution-use-dense-rank-not-rank",
                "content": "```\\nSELECT\\n        Score,\\n        dense_rank() OVER (ORDER BY SCORE DESC) AS Rank\\nfrom Scores\\n```\\n\\nYou want to use `dense_rank()` instead of `rank()` because using `rank()` does not account for ties.\\n\\n![image](https://assets.leetcode.com/users/mahnillas/image_1580162909.png)\\n",
                "solutionTags": [],
                "code": "```\\nSELECT\\n        Score,\\n        dense_rank() OVER (ORDER BY SCORE DESC) AS Rank\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386393,
                "title": "let-s-just-use-dense-rank-and-call-it-a-day",
                "content": "Hello All!\\nHere\\'s a solution via Dense_Rank():\\n```\\nSELECT\\nScore as Score,\\ndense_rank() over(order by Score desc) as Rank\\nFROM Scores\\nORDER BY 2;\\n```\\nPS. I used MS SQL Server for this one.\\n\\nCheers,\\nGeorge John Jordan Thomas Aquinas Hayward, Optimist <br>\\nhttps://ghayward.github.io\\n\\n[![GJJTAHO](https://i.ibb.co/wBjBb4G/gjjtah.jpg)](https://ghayward.github.io)\\n\\nThe Lord Always Delivers",
                "solutionTags": [],
                "code": "```\\nSELECT\\nScore as Score,\\ndense_rank() over(order by Score desc) as Rank\\nFROM Scores\\nORDER BY 2;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 370393,
                "title": "ms-sql-with-and-without-dense-rank",
                "content": "```\\n\\nselect a.score,\\n        count(distinct b.score)AS rank\\n from Scores a\\n  inner join scores b\\n  on a.score<=b.score\\n group by a.id,a.score\\n order by score desc\\n\\n--with dense rank\\nselect \\n    Score,\\n    dense_rank() over (order by score desc) As Rank\\nfrom Scores\\norder by score desc\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "```\\n\\nselect a.score,\\n        count(distinct b.score)AS rank\\n from Scores a\\n  inner join scores b\\n  on a.score<=b.score\\n group by a.id,a.score\\n order by score desc\\n\\n--with dense rank\\nselect \\n    Score,\\n    dense_rank() over (order by score desc) As Rank\\nfrom Scores\\norder by score desc\\n\\n\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 331532,
                "title": "3-lines-easy-solution",
                "content": "```\\nSELECT Score,DENSE_RANK () OVER (ORDER BY Score DESC) AS Rank\\n  FROM Scores\\n ORDER BY Score DESC;",
                "solutionTags": [],
                "code": "```\\nSELECT Score,DENSE_RANK () OVER (ORDER BY Score DESC) AS Rank\\n  FROM Scores\\n ORDER BY Score DESC;",
                "codeTag": "Unknown"
            },
            {
                "id": 255124,
                "title": "easy-to-understand",
                "content": "```\\nSELECT Score, (\\n    SELECT COUNT(DISTINCT Score)\\n    FROM Scores\\n    WHERE Score >= s.Score\\n) as Rank\\nFROM Scores s\\nORDER BY Score desc\\n```\\n",
                "solutionTags": [],
                "code": "```\\nSELECT Score, (\\n    SELECT COUNT(DISTINCT Score)\\n    FROM Scores\\n    WHERE Score >= s.Score\\n) as Rank\\nFROM Scores s\\nORDER BY Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 203972,
                "title": "using-dense-rank",
                "content": "Elegant solution that works in all modern normal systems:\\n```\\nselect Score, \\ndense_rank() over (partition by Id order by Score) as Rank\\nfrom Scores\\n```",
                "solutionTags": [],
                "code": "```\\nselect Score, \\ndense_rank() over (partition by Id order by Score) as Rank\\nfrom Scores\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 181899,
                "title": "ac-mysql-solution",
                "content": "First, we need a table which includes scores and the rank of the score.\\n```\\nSELECT Score, (SELECT COUNT(DISTINCT Score)  AS rank\\nFROM Scores\\nWHERE Score >= S1.Score) AS Rank\\nFROM Scores AS S1\\norder by Score desc\\n```",
                "solutionTags": [],
                "code": "```\\nSELECT Score, (SELECT COUNT(DISTINCT Score)  AS rank\\nFROM Scores\\nWHERE Score >= S1.Score) AS Rank\\nFROM Scores AS S1\\norder by Score desc\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 179378,
                "title": "my-solution-is-75-ms",
                "content": "```\\nSELECT Score, \\n    (\\n        SELECT COUNT(DISTINCT b.Score) + 1 \\n        FROM Scores AS b \\n        WHERE b.Score > Scores.Score \\n        LIMIT 1\\n    ) AS Rank \\nFROM Scores order by Rank ;",
                "solutionTags": [],
                "code": "```\\nSELECT Score, \\n    (\\n        SELECT COUNT(DISTINCT b.Score) + 1 \\n        FROM Scores AS b \\n        WHERE b.Score > Scores.Score \\n        LIMIT 1\\n    ) AS Rank \\nFROM Scores order by Rank ;",
                "codeTag": "Unknown"
            },
            {
                "id": 172094,
                "title": "oracle-using-dense-rank",
                "content": "worked with Oracle. I just needed to round the decimal part of scores to 2\\n```select ROUND(sc.Score,2) Score, dense_rank() over (order by Score desc) Rank from Scores sc```",
                "solutionTags": [],
                "code": "```select ROUND(sc.Score,2) Score, dense_rank() over (order by Score desc) Rank from Scores sc```",
                "codeTag": "Unknown"
            },
            {
                "id": 136900,
                "title": "simple-approach",
                "content": "The following is an accepted and simple solution to the problem: \\n\\n1. Get a table of distinct scores ordered from highest to lowest. \\n2. Add a serial colum to the table from step 1, the values of the new column are incremented starting from zero and going down.\\n3. Merge the table from step 2 with the Scores table.\\n\\nExecution time < 200 ms. \\n\\n```\\nSELECT      Scores.Score, Rank \\nFROM        Scores \\nLEFT JOIN   (                                       -- Last: Join with original scores table on the score value.\\n                SELECT  Score, @a:=@a+1 Rank        -- Second: Add column of serial values starting from 1 to the ordered scores.\\n                FROM    (                           -- First: Get table of distinct scores ordered from highest to lowers.\\n                            SELECT DISTINCT Score\\n                            FROM Scores\\n                            ORDER BY Score DESC\\n                        ) AS orderedScores, (SELECT @a:= 0) AS a\\n            ) AS rankedScores ON (rankedScores.Score = Scores.Score)\\nORDER BY    Scores.Score DESC\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nSELECT      Scores.Score, Rank \\nFROM        Scores \\nLEFT JOIN   (                                       -- Last: Join with original scores table on the score value.\\n                SELECT  Score, @a:=@a+1 Rank        -- Second: Add column of serial values starting from 1 to the ordered scores.\\n                FROM    (                           -- First: Get table of distinct scores ordered from highest to lowers.\\n                            SELECT DISTINCT Score\\n                            FROM Scores\\n                            ORDER BY Score DESC\\n                        ) AS orderedScores, (SELECT @a:= 0) AS a\\n            ) AS rankedScores ON (rankedScores.Score = Scores.Score)\\nORDER BY    Scores.Score DESC\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 117265,
                "title": "dense-rank-throwing-error",
                "content": "```SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC; ```\n\nTrying to use Dense Rank function but keep getting this error - \"Line 1: SyntaxError: near '(ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC\". Although the query works fine in sql server.",
                "solutionTags": [],
                "code": "```SELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS Rank FROM Scores ORDER BY Score DESC; ```",
                "codeTag": "Unknown"
            },
            {
                "id": 3860654,
                "title": "pandas-dense-rank",
                "content": "```\\nimport pandas as pd\\n\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    scores[\\'rank\\'] = (\\n        scores\\n        .score\\n        .rank(method=\\'dense\\', ascending=False)\\n        .astype(int)\\n    )\\n\\n    scores.sort_values(\\'score\\', inplace=True, ascending=False)\\n\\n    return scores[[\\'score\\', \\'rank\\']]\\n```",
                "solutionTags": [
                    "Pandas"
                ],
                "code": "```\\nimport pandas as pd\\n\\n\\ndef order_scores(scores: pd.DataFrame) -> pd.DataFrame:\\n    scores[\\'rank\\'] = (\\n        scores\\n        .score\\n        .rank(method=\\'dense\\', ascending=False)\\n        .astype(int)\\n    )\\n\\n    scores.sort_values(\\'score\\', inplace=True, ascending=False)\\n\\n    return scores[[\\'score\\', \\'rank\\']]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3629436,
                "title": "178-rank-scores-java",
                "content": "```\\n# Write your MySQL query statement below\\nSELECT s1.Score , \\n(SELECT COUNT(DISTINCT score) from Scores s2 where s1.score<=s2.score) as `Rank`\\nfrom Scores s1\\norder by s1.score desc;\\n\\n```",
                "solutionTags": [],
                "code": "```\\n# Write your MySQL query statement below\\nSELECT s1.Score , \\n(SELECT COUNT(DISTINCT score) from Scores s2 where s1.score<=s2.score) as `Rank`\\nfrom Scores s1\\norder by s1.score desc;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3245773,
                "title": "using-different-types-of-window-functions",
                "content": "# Code\\n```\\n# Write your MySQL query statement below\\n\\n    SELECT score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\n    FROM Scores\\n```\\n# DENSE_RANK()\\nDENSE_RANK() is a window function in SQL that is used to calculate the rank of each row within a result set. It works similarly to the RANK() function, but unlike RANK(), DENSE_RANK() doesn\\'t leave gaps between the ranks when there are ties.\\n\\nHere\\'s an example to illustrate the difference between RANK() and DENSE_RANK(). Suppose we have the following table:\\n\\n```\\n+------+-------+\\n| id   | score |\\n+------+-------+\\n| 1    | 90    |\\n| 2    | 85    |\\n| 3    | 80    |\\n| 4    | 80    |\\n| 5    | 75    |\\n+------+-------+\\n```\\nIf we use RANK() to calculate the ranks of the scores, we get the following:\\n\\n```\\nSELECT score, RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 5    |\\n+-------+------+\\n```\\nAs you can see, there is a gap between ranks 2 and 3 because there is a tie between scores 80 and 80.\\n\\nIf we use DENSE_RANK() instead, we get the following:\\n\\n\\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\\n\\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 4    |\\n+-------+------+\\n```\\nAs you can see, DENSE_RANK() assigns the same rank to the tied scores (80 and 80) and doesn\\'t leave any gaps between ranks.\\n\\nIn summary, DENSE_RANK() is a window function that calculates the rank of each row in a result set, but doesn\\'t leave gaps between the ranks when there are ties.",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\n# Write your MySQL query statement below\\n\\n    SELECT score,\\n    DENSE_RANK() OVER(ORDER BY score DESC) AS \\'rank\\'\\n    FROM Scores\\n```\n```\\n+------+-------+\\n| id   | score |\\n+------+-------+\\n| 1    | 90    |\\n| 2    | 85    |\\n| 3    | 80    |\\n| 4    | 80    |\\n| 5    | 75    |\\n+------+-------+\\n```\n```\\nSELECT score, RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 5    |\\n+-------+------+\\n```\n```\\nSELECT score, DENSE_RANK() OVER (ORDER BY score DESC) AS \\'rank\\' FROM Scores;\\n```\n```\\n+-------+------+\\n| score | rank |\\n+-------+------+\\n| 90    | 1    |\\n| 85    | 2    |\\n| 80    | 3    |\\n| 80    | 3    |\\n| 75    | 4    |\\n+-------+------+\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2751622,
                "title": "dense-rank-solution",
                "content": "SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) \"rank\"\\nFROM scores\\nORDER BY score DESC\\n\\nHere we just have to mention the rank in the \"\" as the rank word is a keyword and cannot be used as a identifier in MySQL. so to explicitly use it as an identifier we have to mention it in \"\".",
                "solutionTags": [],
                "code": "SELECT score, DENSE_RANK() OVER(ORDER BY score DESC) \"rank\"\\nFROM scores\\nORDER BY score DESC\\n\\nHere we just have to mention the rank in the \"\" as the rank word is a keyword and cannot be used as a identifier in MySQL. so to explicitly use it as an identifier we have to mention it in \"\".",
                "codeTag": "Unknown"
            },
            {
                "id": 2718259,
                "title": "mysql-ranking-functions-implementation-and-explanation",
                "content": "### Ranking functions in MySQL\\n\\n```\\nSELECT score, dense_rank() OVER (\\n                ORDER BY score DESC\\n            ) AS \\'rank\\'\\nFROM Scores;\\n```\\n\\n***REFERENCE***\\n[https://www.sqlshack.com/overview-of-sql-rank-functions/](http://)\\n***about ROWNUMBER(), RANK(), denserank(), NTILE(N)\\n\\nWe use DENSERANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\n\\nIn the SQL RANK function DENSERANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nLet\\u2019s execute the following query with the DENSERANK() function.\\n```\\nSELECT Studentname, \\n       Subject, \\n       Marks, \\n       DENSERANK() OVER(ORDER BY Marks DESC) Rank\\nFROM ExamResult\\nORDER BY Rank;\\n```\\nIn the output, you can see we have the same rank for both Lily and Isabella who scored 70 marks.***\\n\\n![image](https://assets.leetcode.com/users/images/8a8c58ed-64ee-40a5-b59a-efd8a59576d6_1666098734.50629.png)\\n",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nSELECT score, dense_rank() OVER (\\n                ORDER BY score DESC\\n            ) AS \\'rank\\'\\nFROM Scores;\\n```\n```\\nSELECT Studentname, \\n       Subject, \\n       Marks, \\n       DENSERANK() OVER(ORDER BY Marks DESC) Rank\\nFROM ExamResult\\nORDER BY Rank;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2639499,
                "title": "faster-easy-to-understand-dense-rank",
                "content": "* ***Using dense_rank()***\\n\\n```\\nselect score,\\ndense_rank() over(order by score desc) as \\'rank\\'\\nfrom Scores;\\n```",
                "solutionTags": [
                    "MySQL"
                ],
                "code": "```\\nselect score,\\ndense_rank() over(order by score desc) as \\'rank\\'\\nfrom Scores;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1570638,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567130,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567547,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570938,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567402,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569773,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568565,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568567,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567902,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570217,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570638,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567130,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567547,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570938,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567402,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569773,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568565,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1568567,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1567902,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1570217,
                "content": [
                    {
                        "username": "ramanbhandari24",
                        "content": "Rank is a keyword so use  \\'Rank\\' with single quotes while giving column name"
                    },
                    {
                        "username": "ski900",
                        "content": "[@ishtiaq755](/ishtiaq755) That\\'s not what OP is talking about. They are talking about labeling your column name as \"rank\". If you don\\'t use quotations then it will throw a runtime error for the reason OP listed."
                    },
                    {
                        "username": "ski900",
                        "content": "omg, thank you so much"
                    },
                    {
                        "username": "ishtiaq755",
                        "content": "we need to use DENSE_RANK here , because only RANK keyword wont give you consecutive ranking numbers."
                    },
                    {
                        "username": "mithun_krr",
                        "content": "Thanks"
                    },
                    {
                        "username": "ceo-s",
                        "content": "Thanks mate"
                    },
                    {
                        "username": "dev-null0",
                        "content": "Drove me insane before I figured it out"
                    },
                    {
                        "username": "Dysania",
                        "content": "Oh my god! I have been KILLING myself trying to figure out why I was getting runtime errors. This was it!! Thank you!!!"
                    },
                    {
                        "username": "AbrorErgashev",
                        "content": "1)\\nselect score,  dense_rank()over( order by score desc) rank from scores\\n\\n2)\\nselect a.score, count(b.score) as rank\\nfrom scores a\\n join\\n(\\nselect distinct score\\nfrom scores\\n) b\\non a.score <= b.score\\ngroup by a.id, a.score\\norder by a.score desc\\n\\n***Upvote if liked it***"
                    },
                    {
                        "username": "yaitme",
                        "content": "Thank you so much for ruining the problem in the discussion. We all appreciate it. "
                    },
                    {
                        "username": "rupam416",
                        "content": "**# Write your MySQL query statement below\\nSELECT s.Score , COUNT(t.Score) AS \\'Rank\\' FROM\\n(SELECT DISTINCT Score FROM Scores) AS t ,  Scores AS s\\nWHERE s.Score <= t.Score\\nGROUP BY s.id,s.Score\\nORDER BY s.Score DESC;**"
                    },
                    {
                        "username": "KarthikPrabhu2541",
                        "content": "[@KrishnaSeven](/KrishnaSeven) you basically have to create two copies of the table scores, one is the normal one and the other one with just the distinct scores which will be helpful to rank the scores. for each current score check with the other copy table you created . The number of distinct scores that are more than the current score will be its rank logically. After that just group it by id and score then order it by the scores to get the desired query output."
                    },
                    {
                        "username": "KrishnaSeven",
                        "content": "can you please explain?"
                    },
                    {
                        "username": "ylyu1",
                        "content": "Here is the right MySQL code: \\n\\'\\'\\'\\nSELECT \\n    score, \\n    DENSE_RANK() OVER (ORDER BY score DESC) AS  \\'rank\\'\\nFROM Scores\\nORDER BY score DESC\\n\\'\\'\\'\\n\\nI can only run with rank surrounded by single quotation. But Alias does not require single quotation, right? Why can\\'t I run with AS rank?"
                    },
                    {
                        "username": "Shaik-Misba",
                        "content": "you should write like this (DENSE_RANK() OVER (ORDER BY score DESC)) as 'Rank'\nhere we have multiple words so mysql cannot understand for which element it should use name so by default it assumes (order by score desc) as rank"
                    },
                    {
                        "username": "hoxtar",
                        "content": "Because in MySQL the word RANK is a reserved word."
                    },
                    {
                        "username": "xiakaifeng66",
                        "content": "# Write your MySQL query statement below\\nselect s1.Score, count(distinct s2.Score) as Rank from Scores s1, Scores s2 \\nwhere s2.Score >= s1.Score\\ngroup by s1.Id\\norder by Rank\\n; \\n\\nPlease make sure using where **s2**.Score >= **s1**.Score. Think in this way: Use table s2 to store the cumulative count(), and rank means \"how many other scores greater than or equal to itself\". For example, rank = 1 means there are only 1 another score >= itself, while rank = 6 means there are other 6 scores >= itself. Hope this makes sense."
                    },
                    {
                        "username": "victorlifan",
                        "content": "i got an error when i used mysql with this query:\\n\\'\\'\\'SELECT Score,\\nDENSE_RANK()OVER(ORDER BY Score DESC) AS Rank\\nFROM Scores;\\'\\'\\'\\nso i looked up online, seems like mysql does have dense_rank() clause, but there are some popel say it doesn\\'t. Mysql workbench have this clause![image](https://assets.leetcode.com/users/victorlifan/image_1581621601.png).\\ni am assuming leetcode need to update their mysql platform perhaps?\\n"
                    },
                    {
                        "username": "wolfgang_amadeus",
                        "content": "`select Score, dense_rank() over(order by Score desc) as \\'Rank\\' from Scores`"
                    },
                    {
                        "username": "Gupta_Priya",
                        "content": "`select s1.score ,(select count(distinct score) from scores s2 where s2.score>=s1.score) as \"rank\" \\n from scores s1 order by s1.score desc`"
                    },
                    {
                        "username": "luogaoqi",
                        "content": "Does anyone know why I can't initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains  distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "lisayang0620",
                        "content": "**Dense Rank:**\\n\\nSELECT Score,\\n        DENSE_RANK() OVER (ORDER BY score DESC) `Rank`\\nFROM Scores\\n\\n**Not Dense Rank:**\\n\\nSELECT Score,\\n        (SELECT COUNT(DISTINCT b.Score)+1 FROM Scores b WHERE b.Score > Scores.Score) as `Rank`\\nFROM Scores\\nOrder by 1 desc;\\n\\nSubquery shows number of score that\\'s larger than the score in the original table. So the max one has 0 score larger than itself. \\'+1\\' to get the rank as \\'1\\'. This is similar to question 185:)"
                    }
                ]
            },
            {
                "id": 1569713,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1569526,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1729657,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576958,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576930,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576917,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576809,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576503,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576418,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1576323,
                "content": [
                    {
                        "username": "GNKR",
                        "content": "with rank as (\\nselect score, rank() over (order by score desc) as rank\\nfrom(\\n    select distinct score\\n    from Scores\\n) a\\n)\\n\\nselect a.score , b.rank \\nfrom Scores a\\njoin rank b\\non a.score = b.score\\norder by a.score desc"
                    },
                    {
                        "username": "camlow",
                        "content": "I originally submitted my SQL as:\\n\\nSELECT\\n  score AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores\\n  \\n  but it said it was wrong, and upon looking at the results it looks like LeetCode added trailing 0\\'s to the \"score\" column in the output. So instead of \"3.76\" it would show something like \"3.76000000000002\" and render my solution incorrect, when it was actually correct. I overrode the bug with the following SQL:\\n  \\n  SELECT\\n  TRUNC(score,2) AS \"Score\", dense_rank() OVER (ORDER BY score DESC NULLS LAST) as \"Rank\"\\nFROM\\n  scores"
                    },
                    {
                        "username": "jnh03336",
                        "content": "Anyone can help?\n\nselect score, \n    CASE\n        WHEN @pv = score THEN @vrank\n        WHEN @pv := score THEN @vrank := @vrank + 1\n    END as 'rank'\nfrom scores, (select @vrank := 0, @pv := NULL) r\norder by score desc\n\nthis one gives correct answer just like below\n\nOutput\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nExpected\n| score | rank |\n| ----- | ---- |\n| 4     | 1    |\n| 4     | 1    |\n| 3.85  | 2    |\n| 3.65  | 3    |\n| 3.65  | 3    |\n| 3.5   | 4    |\n\nI checked that there is no difference in terms of output string value.\nbut leetcode judges it wrong. What is the problem?"
                    },
                    {
                        "username": "safety",
                        "content": "I have the same problem. Did you found solution?"
                    },
                    {
                        "username": "abhiuser14",
                        "content": "...\\nselect score, \\ndense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores;\\n..."
                    },
                    {
                        "username": "Rubinov",
                        "content": "/* Write your T-SQL query statement below */\\nselect s.score as score, \\n(select count(distinct (ss.score)) + 1 from Scores ss where ss.score > s.score) as rank\\nfrom Scores s\\norder by s.score desc\\n\\nDid anyone solve it the same way as me?"
                    },
                    {
                        "username": "sfyu95",
                        "content": "# DO NOT USE (PARTITION BY)\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores"
                    },
                    {
                        "username": "ajitraut",
                        "content": "\\nselect score, \\n dense_rank() over (order by score desc) as rank \\n from scores \\n order by score desc;"
                    },
                    {
                        "username": "user2626ee",
                        "content": "Please find solution below\\n`select score, dense_rank() over(order by score desc) as \\'rank\\' from scores`"
                    },
                    {
                        "username": "defoez93",
                        "content": "Just wondering if window function is acceptable in an interview."
                    },
                    {
                        "username": "husky23",
                        "content": "Took some help from other posts -\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores"
                    }
                ]
            },
            {
                "id": 1575483,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1575471,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574629,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574578,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574096,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1574066,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573703,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1576441,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573457,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573167,
                "content": [
                    {
                        "username": "mehulsatardekar",
                        "content": "# MYSQL Solution \\n**select score,  Dense_RANK() OVER( order by score desc ) as \\'Rank\\' from Scores order by score desc;**\\n\\n\\no/p\\n\\nRuntime: 224 ms, faster than 83.93% of MySQL online submissions for Rank Scores.\\nMemory Usage: 0B, less than 100.00% of MySQL online submissions for Rank Scores."
                    },
                    {
                        "username": "Samiudeen",
                        "content": "\\nselect score,dense_rank() over(order by score desc) as \\'Rank\\' from scores;"
                    },
                    {
                        "username": "yiang386",
                        "content": "if you don\\'t want a simple solution, here it is.\\n\\nselect s1.Score, s3.Rank from scores s1\\njoin (select s2.Score, rank() over (order by s2.Score desc) \\'Rank\\' from scores s2\\ngroup by Score order by \\'Rank\\' desc) s3 on s1.Score = s3.Score\\norder by s1.Score desc"
                    },
                    {
                        "username": "jainshubhi09",
                        "content": "**ACCEPTED SOLUTION USING DENSE_RANK( ) FUNCTION OF MYSQL**\\nSELECT Score, DENSE_RANK() over(order by Score desc) \\'Rank\\' from Scores order by \\'Rank\\' asc;"
                    },
                    {
                        "username": "jhilik08",
                        "content": "\\'\\'\\'\\nselect s1.score, (select count(distinct s2.score) from scores s2 where s1.score<=s2.score) \\'Rank\\' \\nfrom scores s1\\norder by s1.score desc\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "lename",
                        "content": "with cte as (Select s1.score, ifnull(count(s2.score)+1,1) as rn\\nfrom\\n(Select distinct score\\nfrom scores) as s1\\nleft join\\n(select distinct score\\nfrom scores) as s2\\non s1.score < s2.score\\ngroup by s1.score)\\n\\nSelect s.score, cte.rn as \\'Rank\\'\\nfrom scores s\\njoin cte\\non s.score = cte.score\\norder by rn \\n"
                    },
                    {
                        "username": "aishwaryachoudhary92",
                        "content": "\\'\\'\\'\\nwith ref_table as \\n(select distinct Score, row_number() over (order by Score desc) as rankk\\nfrom Scores\\ngroup by Score)\\n\\nselect a.Score, b.rankk\\nfrom Scores a left join ref_table b on a.score=b.score\\norder by a.Score desc\\n\\'\\'\\'\\nThis is my solution, but it is not accepted because it is wants 4.00000 instead of 4.00 for MS Sql Server.\\nDon\\'t know why?"
                    },
                    {
                        "username": "crystal_huangjin",
                        "content": "The following is accepted as Oracle and MS Server but failed if MySQL is selected. DENSE_RANK is valid under MySQL.\\n\\nselect Score, dense_rank() OVER(ORDER BY Score desc) AS Rank\\nFROM Scores"
                    },
                    {
                        "username": "jingsixu8",
                        "content": "![image](https://assets.leetcode.com/users/jingsixu8/image_1582158091.png)\\n"
                    },
                    {
                        "username": "pinkinathani",
                        "content": "can some one please tell me why dense rank is not working in MYSQL?\\nSELECT Score,\\n\\tDENSE_RANK() OVER(ORDER BY Score DESC) As Rank\\nFROM Scores\\nORDER By Score Desc\\n"
                    }
                ]
            },
            {
                "id": 1573163,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572465,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572400,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572317,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1572085,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1570731,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1575671,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 1573030,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2045169,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2036550,
                "content": [
                    {
                        "username": "OrangeGun",
                        "content": "\\nselect Score, \\ndense_rank() over (order by score desc) as Rank\\nfrom Scores"
                    },
                    {
                        "username": "crgandhi86",
                        "content": "No where in the question, it asks to display ROUND\\'ed score value but accepts only query with it rounded.\\n\\nSELECT\\n**ROUND(SCORE,2)** \"Score\",\\nDENSE_RANK() OVER(\\nORDER BY\\nSCORE DESC\\n) \"Rank\"\\nFROM\\nSCORES;"
                    },
                    {
                        "username": "Changyu007",
                        "content": "when it comes to rank 17, 3.8, it appears as 3.80000000003, something like that, which is different from the expected answer\\n\\nsomeone please fix it"
                    },
                    {
                        "username": "Galaljn",
                        "content": "\\'\\'\\'/* Write your T-SQL query statement below */\\n\\nSELECT SCORES.Score, B.rank\\n\\nFROM (\\n\\nSELECT SCORE, ROW_NUMBER () OVER(ORDER BY SCORE DESC ) AS RANK\\nFROM (\\n\\nSELECT DISTINCT SCORE \\nFROM SCORES) as A ) as B\\n\\nRIGHT JOIN SCORES ON\\nSCORES.SCORE = B.SCORE\\n\\nORDER BY SCORES.SCORE DESC\\n\\n\\'\\'\\'"
                    },
                    {
                        "username": "YoniWitz",
                        "content": "instead of \\'from select distinct\\' you can just group by \\'score\\'. avoid a third select"
                    },
                    {
                        "username": "zhengyao3",
                        "content": "There is a problem with the ninth TestCase data, and the data will generate problem data such as [3.8000000000000003, 17], which will lead to failure.\\n![image](https://s3-lc-upload.s3.amazonaws.com/users/zhengyao3/image_1534349204.png)\\n"
                    },
                    {
                        "username": "auu123",
                        "content": "The accepted answer is \\n\\nSelect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom Scores\\n\\nbut why rank needs to have \\'\\'?"
                    },
                    {
                        "username": "lchesn2",
                        "content": "\\n\\nselect Score, DENSE_RANK() OVER(order by Score Desc) as \\'Rank\\' from Scores;"
                    },
                    {
                        "username": "foxyz",
                        "content": "I tried to use window function: https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_rank\\nbut it\\'s not accepted. Why? Leetcode\\'s using archaic version MySQL?"
                    },
                    {
                        "username": "thotabhargav111",
                        "content": "Does anyone know why I can\\'t initialize variable like this \"set @rank:=0\"?\\n\\nIf I can do this, this problem would be very easy.\\n\\nJust create an intermediate table which contains distinct, sorted score and its ranking, then join it with original table.\\n\\nHere is the code:\\n\\nset @rank:=0;\\n\\nselect myScore.Score, myRank.Rank\\n\\nfrom (select Score from Scores order by Score desc) as myScore, (select Score, @rank:=@rank+1 as Rank from Scores group by Score order by Score desc) as myRank\\n\\nwhere myScore.Score = myRank.Score"
                    },
                    {
                        "username": "desurkumaran777",
                        "content": "What is wrong here.\\n\\nWrong Answer\\nRuntime: 510 ms\\nCase 1\\nInput\\nScores =\\n| id | score |\\n| -- | ----- |\\n| 1  | 3.5   |\\n| 2  | 3.65  |\\n| 3  | 4     |\\n| 4  | 3.85  |\\n| 5  | 4     |\\n| 6  | 3.65  |\\n\\nOutput\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n\\nExpected\\n\\n| score | rank |\\n| ----- | ---- |\\n| 4     | 1    |\\n| 4     | 1    |\\n| 3.85  | 2    |\\n| 3.65  | 3    |\\n| 3.65  | 3    |\\n| 3.5   | 4    |\\n"
                    },
                    {
                        "username": "Yokeinee",
                        "content": "leetcode wrong!"
                    }
                ]
            },
            {
                "id": 2030245,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 2012878,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1937632,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1921264,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1880387,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1812246,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1811065,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1787452,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1774146,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1773269,
                "content": [
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "Pandas\\n\\nyou can add a column with rank like so\\n\\n`df[\\'rank\\'] = df.score.rank(ascending=False)`"
                    },
                    {
                        "username": "aleh_dalzh",
                        "content": "T-SQL RANK func\\n\\nSELECT \\n  score,\\n  DENSE_RANK() OVER(ORDER BY score DESC) AS rank\\nFROM Scores\\nORDER BY score DESC"
                    },
                    {
                        "username": "kirubeladamu",
                        "content": "...and I thought doing rank on excel was hard!!"
                    },
                    {
                        "username": "abhradip_360",
                        "content": "rank will produce runtime error as it is a keyword. Quote rank to avoid error i.e. \\'rank\\' or \"rank\""
                    },
                    {
                        "username": "Ashi786123",
                        "content": "Why we dint use Partition BY here?"
                    },
                    {
                        "username": "vivekmavilla",
                        "content": "select score, dense_rank() over(order by score Desc) as \\'rank\\'\\nfrom scores;"
                    },
                    {
                        "username": "sabarissh",
                        "content": "# Write your MySQL query statement below\\nSELECT score, \\n       (SELECT COUNT(DISTINCT score) \\n        FROM scores \\n        WHERE score >= s.score) AS `rank`\\nFROM scores s \\norder by score desc;\\n\\n"
                    },
                    {
                        "username": "Shivani_2802",
                        "content": "can anyone tell me why are we using DENSE_RANK word ?"
                    },
                    {
                        "username": "omehdiakram",
                        "content": "SELECT score, DENSE_RANK() OVER (ORDER BY score DESC) as \\'rank\\' FROM Scores;"
                    },
                    {
                        "username": "pepesenaris",
                        "content": "with ranks\\nas (\\n    select score, ROW_NUMBER() over (order by score desc) rank_num\\n    from Scores\\n    group by score\\n    order by score desc\\n)\\nselect Scores.score, ranks.rank_num as \"rank\"\\nfrom Scores join ranks\\n    on Scores.score = ranks.score\\norder by Scores.score desc;\\n"
                    }
                ]
            },
            {
                "id": 1773252,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1766060,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1752287,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1751074,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1745965,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1741770,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1722521,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1716289,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1575697,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            },
            {
                "id": 1576399,
                "content": [
                    {
                        "username": "tource",
                        "content": "you can\\'t save the name as rank and set it as a test case..."
                    },
                    {
                        "username": "lttdvrs",
                        "content": "try putting rank in backticks : `rank` "
                    },
                    {
                        "username": "amar777amartya",
                        "content": "select a.score, a.rank_\\nfrom\\n(select score, dense_rank() over(order by score desc) as rank_\\nfrom Scores) a"
                    },
                    {
                        "username": "Adil142",
                        "content": "SELECT SCORE , DENSE_RANK()OVER(ORDER BY SCORE DESC ) AS \\'RANK\\'\\nFROM SCORES\\nORDER BY SCORE desc;"
                    },
                    {
                        "username": "candy2321",
                        "content": "\\nselect score,\\ndense_rank() over (order by score desc) as rank\\nfrom scores;\\n\\nwhy this query is now working in mysql ?"
                    },
                    {
                        "username": "PratikB10",
                        "content": "What is wrong with this oracle solution?\\nselect score, dense_rank() over (order by score desc) as rank\\nfrom scores;\\n"
                    },
                    {
                        "username": "vaishno_raizada",
                        "content": "We use DENSE_RANK() function to specify a unique rank number within the partition as per the specified column value. It is similar to the Rank function with a small difference.\\nIn the SQL RANK function DENSE_RANK(), if we have duplicate values, SQL assigns different ranks to those rows as well. Ideally, we should get the same rank for duplicate or similar values.\\n\\nselect score, dense_rank() over (order by score desc) as \\'rank\\'\\nfrom scores\\norder by score desc\\n\\n!!! upvote if you like "
                    },
                    {
                        "username": "mrempirio",
                        "content": "SELECT score,\\n    DENSE_RANK() OVER(\\n        ORDER BY \\n        score DESC) AS \\'rank\\'\\nFROM Scores "
                    },
                    {
                        "username": "patnanavarun",
                        "content": "This code is working but the issue is rank is a reserved keyword in sql, so an error is thrown,\\nselect score, DENSE_Rank() over (order by score desc) AS rank  from scores \\nalternatively  we can use \\nselect score, DENSE_Rank() over (order by score desc) AS rank_t from scores\\nwhich will not satisfy the test case as rank_t is not the expected column name. \\n\\nAny ways to fix this?  "
                    },
                    {
                        "username": "user8811j",
                        "content": "\\'\\'\\'\\nSELECT Score, DENSE_RANK() OVER (ORDER BY Score DESC) AS \"Rank\" FROM Scores\\n\\'\\'\\'"
                    },
                    {
                        "username": "user3091T",
                        "content": "simple way to solve,\\n\\nSELECT score, DENSE_RANK()OVER(ORDER BY score DESC) AS \\'rank\\'\\nFROM SCORES;"
                    }
                ]
            }
        ]
    },
    {
        "title": "First Bad Version",
        "question_content": "<p>You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.</p>\n\n<p>Suppose you have <code>n</code> versions <code>[1, 2, ..., n]</code> and you want to find out the first bad one, which causes all the following ones to be bad.</p>\n\n<p>You are given an API <code>bool isBadVersion(version)</code> which returns whether <code>version</code> is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 5, bad = 4\n<strong>Output:</strong> 4\n<strong>Explanation:</strong>\ncall isBadVersion(3) -&gt; false\ncall isBadVersion(5)&nbsp;-&gt; true\ncall isBadVersion(4)&nbsp;-&gt; true\nThen 4 is the first bad version.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> n = 1, bad = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= bad &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 71311,
                "title": "a-good-warning-to-me-to-use-start-end-start-2-to-avoid-overflow",
                "content": "Before this problem, I have always use\\n\\n      mid = (start+end)) / 2;\\n\\nTo get the middle value, but this can caused OVERFLOW ! \\n\\nwhen start and end are all about INT_MAX , then (start+end) of course will be overflow !\\n\\nTo avoid the problem we can use\\n       \\n      mid =  start+(end-start)/2;\\n\\nHere is the AC implementation \\n\\n// Forward declaration of isBadVersion API.\\nbool isBadVersion(int version);\\n\\n    class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int start=0, end=n;\\n            cout<<end-start<<end;\\n            while(end-start>1){\\n                int mid=start+(end-start)/2;\\n                /** mid = (start+end)) / 2; **/\\n                if(isBadVersion(mid))  end=mid;\\n                else  start=mid;\\n            }\\n            return end;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int start=0, end=n;\\n            cout<<end-start<<end;\\n            while(end-start>1){\\n                int mid=start+(end-start)/2;\\n                /** mid = (start+end)) / 2; **/\\n                if(isBadVersion(mid))  end=mid;\\n                else  start=mid;\\n            }",
                "codeTag": "C++"
            },
            {
                "id": 71296,
                "title": "o-lgn-simple-java-solution",
                "content": "**The binary search code:**\\n\\n\\tpublic int firstBadVersion(int n) {\\n\\t    int start = 1, end = n;\\n\\t    while (start < end) {\\n\\t        int mid = start + (end-start) / 2;\\n\\t        if (!isBadVersion(mid)) start = mid + 1;\\n\\t        else end = mid;            \\n\\t    }        \\n\\t    return start;\\n\\t}",
                "solutionTags": [],
                "code": "**The binary search code:**\\n\\n\\tpublic int firstBadVersion(int n) {\\n\\t    int start = 1, end = n;\\n\\t    while (start < end) {\\n\\t        int mid = start + (end-start) / 2;\\n\\t        if (!isBadVersion(mid)) start = mid + 1;\\n\\t        else end = mid;            \\n\\t    }        \\n\\t    return start;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 71366,
                "title": "python-simple-2-lines-solution",
                "content": "    import bisect\\n    class Solution():\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.__getitem__ = isBadVersion\\n        return bisect.bisect_left(self, True, 1, n)",
                "solutionTags": [
                    "Python"
                ],
                "code": "    import bisect\\n    class Solution():\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        self.__getitem__ = isBadVersion\\n        return bisect.bisect_left(self, True, 1, n)",
                "codeTag": "Java"
            },
            {
                "id": 606080,
                "title": "java-binary-search-clean-code-o-logn",
                "content": "```java\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int left = 1, right = n, ans = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2; // to avoid overflow incase (left+right)>2147483647\\n            if (isBadVersion(mid)) {\\n                ans = mid; // record mid as current answer\\n                right = mid - 1; // try to find smaller version in the left side\\n            } else {\\n                left = mid + 1; // try to find in the right side\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\nComplexity:\\n- Time: `O(logN)`\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```java\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int left = 1, right = n, ans = -1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2; // to avoid overflow incase (left+right)>2147483647\\n            if (isBadVersion(mid)) {\\n                ans = mid; // record mid as current answer\\n                right = mid - 1; // try to find smaller version in the left side\\n            } else {\\n                left = mid + 1; // try to find in the right side\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71312,
                "title": "short-c-answer-and-minimize-api-calls",
                "content": "    class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int lower = 1, upper = n, mid;\\n            while(lower < upper) {\\n                mid = lower + (upper - lower) / 2;\\n                if(!isBadVersion(mid)) lower = mid + 1;   /* Only one call to API */\\n                else upper = mid;\\n            }\\n            return lower;   /* Because there will alway be a bad version, return lower here */\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int lower = 1, upper = n, mid;\\n            while(lower < upper) {\\n                mid = lower + (upper - lower) / 2;\\n                if(!isBadVersion(mid)) lower = mid + 1;   /* Only one call to API */\\n                else upper = mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 71324,
                "title": "python-understand-easily-from-binary-search-idea",
                "content": "    class Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        r = n-1\\n        l = 0\\n        while(l<=r):\\n            mid = l + (r-l)/2\\n            if isBadVersion(mid)==False:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return l",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        r = n-1\\n        l = 0\\n        while(l<=r):\\n            mid = l + (r-l)/2\\n            if isBadVersion(mid)==False:\\n                l = mid+1\\n            else:\\n                r = mid-1\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 3112480,
                "title": "easy-solution-in-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code uses a binary search algorithm to find the first bad version of a software.\\n\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n\\n    public int firstBadVersion(int n) {\\n        int low = 0;\\n        int high = n;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(isBadVersion(mid)==true && isBadVersion(mid-1)==false)   return mid;\\n            else if(isBadVersion(mid)==false ) low = mid+1;\\n            else high= mid;\\n        }     \\n        return -1;\\n    }\\n}\\n```\\n### If you like the solution then please upvote me it gives me encouragement to do more...........",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n\\n    public int firstBadVersion(int n) {\\n        int low = 0;\\n        int high = n;\\n\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(isBadVersion(mid)==true && isBadVersion(mid-1)==false)   return mid;\\n            else if(isBadVersion(mid)==false ) low = mid+1;\\n            else high= mid;\\n        }     \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71386,
                "title": "an-clear-way-to-use-binary-search",
                "content": "It is obvious that the version would looks like the following:\\nFFTTTT (The first two are correct version, the rest are bad ones)\\nSo we can use binary search to find the rightmost F or the leftmost T\\n\\nTo find the leftmost T\\n\\n    public int firstBadVersionLeft(int n) {\\n\\t\\tint i = 1;\\n\\t\\tint j = n;\\n\\n\\t\\twhile (i < j) {\\n\\n\\t\\t\\tint mid = i + (j - i) / 2;\\n\\n\\t\\t\\tif (isBadVersion(mid)) {\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn i;\\n\\n\\t}\\n\\nTo find the right most F we need to notice that since we are looking for the first bad version not the last correct version, we need to return the (position when the binary search stop) + 1\\n\\n    public int firstBadVersion(int n) {\\n\\n\\t\\tif (isBadVersion(1)) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint i = 1;\\n\\t\\tint j = n;\\n\\n\\t\\twhile (i < j) {\\n\\t\\t\\tint mid = i + (j - i) / 2 + 1;\\n\\t\\t\\tif (!isBadVersion(mid)) {\\n\\t\\t\\t\\ti = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn j + 1;\\n\\n\\t}\\n\\nBTW, understanding how to use binary search to find the most left target or the most right target (when the target is duplicated) is very useful to solve binary search related problems. =)",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "It is obvious that the version would looks like the following:\\nFFTTTT (The first two are correct version, the rest are bad ones)\\nSo we can use binary search to find the rightmost F or the leftmost T\\n\\nTo find the leftmost T\\n\\n    public int firstBadVersionLeft(int n) {\\n\\t\\tint i = 1;\\n\\t\\tint j = n;\\n\\n\\t\\twhile (i < j) {\\n\\n\\t\\t\\tint mid = i + (j - i) / 2;\\n\\n\\t\\t\\tif (isBadVersion(mid)) {\\n\\t\\t\\t\\tj = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ti = mid + 1;\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\n\\t\\treturn i;\\n\\n\\t}\\n\\nTo find the right most F we need to notice that since we are looking for the first bad version not the last correct version, we need to return the (position when the binary search stop) + 1\\n\\n    public int firstBadVersion(int n) {\\n\\n\\t\\tif (isBadVersion(1)) {\\n\\t\\t\\treturn 1;\\n\\t\\t}\\n\\n\\t\\tint i = 1;\\n\\t\\tint j = n;\\n\\n\\t\\twhile (i < j) {\\n\\t\\t\\tint mid = i + (j - i) / 2 + 1;\\n\\t\\t\\tif (!isBadVersion(mid)) {\\n\\t\\t\\t\\ti = mid;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tj = mid - 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn j + 1;\\n\\n\\t}\\n\\nBTW, understanding how to use binary search to find the most left target or the most right target (when the target is duplicated) is very useful to solve binary search related problems. =)",
                "codeTag": "Unknown"
            },
            {
                "id": 1591935,
                "title": "python-solution-easy-to-understand-binary-search-with-detailed-explanation",
                "content": "### Solution\\n```\\ndef firstBadVersion(self, n):\\n        i = 1\\n        j = n\\n        while (i < j):\\n            pivot = (i+j) // 2\\n            if (isBadVersion(pivot)):\\n                j = pivot       # keep track of the leftmost bad version\\n            else:\\n                i = pivot + 1   # the one after the rightmost good version\\n        return i\\n```\\n\\n### Remarks\\n* We use` i = 1` instead of `0` as base case because there\\'s no index operation involved and the product version starts from 1.\\n* We use `j` to keep track of the leftmost bad version we have checked, so that any version after` j `would not be the first bad version we want.\\n* We use `i `to keep track of the leftmost unknown version which has a good version before it, so that any version before` i` would be a good version.\\n* Therefore, `i` would move towards `j` step by step and stop when it becomes the first bad version.\\n\\n****Please upvote if you find this post useful, and welcome to any further discussion!***",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\ndef firstBadVersion(self, n):\\n        i = 1\\n        j = n\\n        while (i < j):\\n            pivot = (i+j) // 2\\n            if (isBadVersion(pivot)):\\n                j = pivot       # keep track of the leftmost bad version\\n            else:\\n                i = pivot + 1   # the one after the rightmost good version\\n        return i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 71333,
                "title": "1-liner-in-ruby-python",
                "content": "**Python 3.10+**\\n\\nWoohoo, `bisect` has a `key` parameter now. So:\\n\\n    def firstBadVersion(self, n: int) -> int:\\n        return bisect_left(range(n), True, 1, key=isBadVersion)\\n\\n---\\n\\n**Ruby**\\n\\n    def first_bad_version(n)\\n      (1..n).bsearch { |i| is_bad_version(i) }\\n    end\\n\\nOr:\\n\\n    def first_bad_version(n)\\n      (1..n).bsearch(&method(:is_bad_version))\\n    end\\n\\n---\\n\\n**Python**\\n\\nIn Python I was only able to do it with a rather ugly wrapper:\\n\\n    def firstBadVersion(self, n):\\n        return bisect.bisect(type(\\'\\', (), {\\'__getitem__\\': lambda self, i: isBadVersion(i)})(), False, 0, n)\\n\\nNicer, more readable version:\\n\\n    def firstBadVersion(self, n):\\n        class Wrap:\\n            def __getitem__(self, i):\\n                return isBadVersion(i)\\n        return bisect.bisect(Wrap(), False, 0, n)",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "**Python 3.10+**\\n\\nWoohoo, `bisect` has a `key` parameter now. So:\\n\\n    def firstBadVersion(self, n: int) -> int:\\n        return bisect_left(range(n), True, 1, key=isBadVersion)\\n\\n---\\n\\n**Ruby**\\n\\n    def first_bad_version(n)\\n      (1..n).bsearch { |i| is_bad_version(i) }\\n    end\\n\\nOr:\\n\\n    def first_bad_version(n)\\n      (1..n).bsearch(&method(:is_bad_version))\\n    end\\n\\n---\\n\\n**Python**\\n\\nIn Python I was only able to do it with a rather ugly wrapper:\\n\\n    def firstBadVersion(self, n):\\n        return bisect.bisect(type(\\'\\', (), {\\'__getitem__\\': lambda self, i: isBadVersion(i)})(), False, 0, n)\\n\\nNicer, more readable version:\\n\\n    def firstBadVersion(self, n):\\n        class Wrap:\\n            def __getitem__(self, i):\\n                return isBadVersion(i)\\n        return bisect.bisect(Wrap(), False, 0, n)",
                "codeTag": "Java"
            },
            {
                "id": 3137516,
                "title": "easy-java-solution-runtime-1ms-beats-98-7",
                "content": "\\n\\n# Code\\n```java []\\n/* The isBadVersion API is already defined.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int f = 1, l = n;\\n        while(f<=l){\\n            int m = f+(l-f)/2;\\n            if(!isBadVersion(m)){\\n                f = m+1;\\n            }else{\\n                l = m-1;\\n            }\\n        }\\n        return f;\\n    }\\n}\\n```\\n`Please UPVOTE. It\\'s free.`\\n\\n![upvote1.png](https://assets.leetcode.com/users/images/4977788f-a408-4c63-bab3-064e18a1226c_1675881902.1163795.png)\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```java []\\n/* The isBadVersion API is already defined.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int f = 1, l = n;\\n        while(f<=l){\\n            int m = f+(l-f)/2;\\n            if(!isBadVersion(m)){\\n                f = m+1;\\n            }else{\\n                l = m-1;\\n            }\\n        }\\n        return f;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454609,
                "title": "c-simple-and-short-solution-o-log-n-0ms-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int lo = 1, hi = n, mid;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (isBadVersion(mid)) hi = mid;\\n            else lo = mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int lo = 1, hi = n, mid;\\n        while (lo < hi) {\\n            mid = lo + (hi - lo) / 2;\\n            if (isBadVersion(mid)) hi = mid;\\n            else lo = mid+1;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71344,
                "title": "javascript-solution-key-subtle-difference-from-other-languages",
                "content": "This is the standard binary search solution, but what's crucial is that in JS you need to use Math.floor on mid. That caught me out for a little bit. Otherwise you get a float mid which will cause wrong answers.\\n```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        // binary search\\n       var start = 1, end = n;\\n       while(start < end){\\n           var mid = Math.floor(start + (end-start) / 2);\\n           if(isBadVersion(mid)){\\n                end = mid; // look on left side of mid\\n           }else{\\n               start = mid+1; // look on the right side of mid\\n           }\\n       }\\n       return start;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        // binary search\\n       var start = 1, end = n;\\n       while(start < end){\\n           var mid = Math.floor(start + (end-start) / 2);\\n           if(isBadVersion(mid)){\\n                end = mid; // look on left side of mid\\n           }else{\\n               start = mid+1; // look on the right side of mid\\n           }\\n       }\\n       return start;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2575109,
                "title": "java-4-lines-code-log-n-time-space-o-1-binary-search",
                "content": "if u like this kindly upvote \\n\\n```\\n public class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=1;\\n        while(l<=n){\\n            int m=l+(n-l)/2;\\n            if(isBadVersion(m)){\\n                n=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n public class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=1;\\n        while(l<=n){\\n            int m=l+(n-l)/2;\\n            if(isBadVersion(m)){\\n                n=m-1;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1500450,
                "title": "clear-concept-tle-overflow-mechanism-what-s-wrong-with-left-right-2",
                "content": "The only **trap** in this question is regarding *integer overflow.*\\nLet\\'s grab the underlying **OVERFLOW CONCEPT.**\\nInteger range in most of programming languages like C++, Java is **-2147483648 to 2147483647**.\\n\\nFor all those who used ```int mid = (left + right)/2;``` \\nWhen you check the reason of TLE, it says one of following test case: *2126753390  1702766719*\\nThe values for *left, right, and mid* in the subsequent iterations are:\\n\\n\\tleft = 1             right = 2126753390,  mid = 1063376695\\n\\tleft = 1063376696    right = 2126753390,  mid = -552418605\\n\\tleft = -552418604    right = 2126753390,  mid = 787167393\\n\\tleft = 787167394     right = 2126753390,  mid = -690523256\\n\\t.\\n\\t.\\n\\tand so on...\\n\\n### REASON OF TLE :\\nThe value of **mid** switches between positive and negative signs. **This will never stop, resulting in an infinite loop and hence TLE.**\\n\\n### WHY it behaves this way?\\nIn the second iteration, mathematically it should be\\n```(1063376696 + 2126753390) /2 = (3190130086) /2   = 1595065043```\\nbut but due to *overflows of the integer range*, it will be interpreted as\\n```(1063376696 + 2126753390) / 2 = (-1104837210) / 2   = -552418605```\\n\\nLet\\'s understand it in a more intuitive way, by taking easier example:\\nQue: **How can we store value 10 in a data structure which can hold values in range [-4,3] ?**\\nIt will overflow and handled by complier by its **overflow and underflow mechanism.**\\nThe following section describes its inner working.\\n# OVERFLOW MECHANISM :\\nThe range is specified as -4 to 3. If given num falls in this range, it will be stored as it is. \\nOtherwise it will start filling in cyclic manner from opposite end. \\nFor e.g., \\n-12, 4, 12 will be represented as -4,\\n-14, -6, 10 will be represented as 2, etc.\\n( Ans:- num=10, lower=-4, upper=3. Hence, representational value = 2 )\\n\\n![image](https://assets.leetcode.com/users/images/4d0e04b5-4879-4d5e-9e97-38094eb10bcb_1662454758.777058.png)\\n\\n(Above diagram shows 3-bit signed representation of a number)\\n\\nThis value can be calculated by recursive calls as follows: [RECURSIVE APPROACH]\\n```\\n public static long dataType(long num, long lower, long upper){\\n        long range = upper-lower+1;\\n        if(num > upper)              // num is greater than upper, so we substract the range\\n            return dataType(num - range, lower, upper);\\n        if(num < lower)              // num is lesser than lower, so we add the range\\n            return dataType(num + range, lower, upper);\\n\\t\\t\\t\\n\\t\\t// num lies between lower and upper, so we return it\\n\\t\\treturn num;          \\n    }\\n```\\nHowever, recursive calls may fill up memory. Using modular arithmetic, we can solve this in O(1) constant time.\\nSimilar function as below is called, each time you do TYPE CASTING - NARROWING.\\n\\n### Working of Type Casting (narrowing) :\\n```\\npublic static long dataType(long num, long lower, long upper){\\n        if(lower<=num && num<=upper)\\n            return num;                  // if num lies between lower and upper, we return it\\n            \\n        long range = upper-lower+1;     // size of window in which num can be stored\\n        long value = num % range;       // to bring the num in the range\\n        if(num > upper){\\n            if(value > upper) value -= range;  //if value exceeds, bring it back in range\\n        }\\n        if(num < lower){\\n            if(value < lower) value += range; //if value preceeds, bring it back in range\\n        }\\n        return value;  // the representational value of the num\\n    }\\n```\\n\\nNow, you can create your custom range data type with different lower and upper bounds and have fun :)\\nlike lower=69, upper=96, num=116 hehe!\\n\\nVoila, we have made an exellent *DISCOVERY !!*\\n**The data types in java, c++ etc. are nothing but an *special case* of our program.**\\nAny num can be taken and change in values of lower and upper given:\\n![image](https://assets.leetcode.com/users/images/8b365166-8a41-4310-902f-835adb7a4d60_1662460446.4986744.png)\\n\\n### FLAW in behaviour of mid :\\n*After an overflow, the compiler starts again from the least limit of value (i.e. -2147483648 in integer case) and adds the remaining surplus value.*\\n*[ num=3190130086, lower=-2147483648, upper=2147483647 ]*\\n\\nHere, 3190130086 - 2147483648 - 2147483648 = -1104837210. \\nThe limit has crossed twice here, followed by a division giving -552418605\\n\\n**Understand it like, you need to give someone 4.5 litre of water but you have only bottle of 1 litre. What will you do?\\nYou will reuse(or recycle) the bottle 4 times, then last time you give 500mL as per mark. *Compiler works the same way!***\\n\\n### isBadVersion( ) API working :\\nFor those who think, this is implemented using arrays, and accessing **-ve** value value from array will give *Runtime Error*(IndexOutOfBound)\\nIts not! **The inner working of API** is similar as follows, where *firstBadIndex* is passed by different method. \\n```\\nbool isBadVersion(int value, int firstBadIndex){\\n        if(value < firstBadIndex) return false;\\n        else return true;\\n    }\\n```\\n\\n#### HOW TO FIX?\\nTo solve this anomaly, an equivalent mathematical formula, which is,\\n```int mid = left + (right-left)/2;``` is used,\\n\\n```\\nRHS = left + (right-left)/2\\n    = left + right/2 - left/2\\n\\t= left/2 + right/2\\n    = (left + right)/2\\n```\\nThis equivalent formula ensures that `(right-left)/2` lies between the bounds of integer range and does not overflows.\\nKeep this formula in mind, as it also performs better in sorting techniques like quick sort and others.\\n\\nAlternatively, to avoid overflow, one can also use higher range limit data types like **long**. But then you will miss this beauty behind the code. \\n**Don\\'t waste unnecessary space by taking higher data range (some people make a habit to do so) instead, understand the underlying concept.**\\nMake program less space complex and yourself a better programmer. ; )\\n#keepGrinding #happyCoding",
                "solutionTags": [
                    "Java",
                    "C",
                    "Binary Search"
                ],
                "code": "```int mid = (left + right)/2;```\n```(1063376696 + 2126753390) /2 = (3190130086) /2   = 1595065043```\n```(1063376696 + 2126753390) / 2 = (-1104837210) / 2   = -552418605```\n```\\n public static long dataType(long num, long lower, long upper){\\n        long range = upper-lower+1;\\n        if(num > upper)              // num is greater than upper, so we substract the range\\n            return dataType(num - range, lower, upper);\\n        if(num < lower)              // num is lesser than lower, so we add the range\\n            return dataType(num + range, lower, upper);\\n\\t\\t\\t\\n\\t\\t// num lies between lower and upper, so we return it\\n\\t\\treturn num;          \\n    }\\n```\n```\\npublic static long dataType(long num, long lower, long upper){\\n        if(lower<=num && num<=upper)\\n            return num;                  // if num lies between lower and upper, we return it\\n            \\n        long range = upper-lower+1;     // size of window in which num can be stored\\n        long value = num % range;       // to bring the num in the range\\n        if(num > upper){\\n            if(value > upper) value -= range;  //if value exceeds, bring it back in range\\n        }\\n        if(num < lower){\\n            if(value < lower) value += range; //if value preceeds, bring it back in range\\n        }\\n        return value;  // the representational value of the num\\n    }\\n```\n```\\nbool isBadVersion(int value, int firstBadIndex){\\n        if(value < firstBadIndex) return false;\\n        else return true;\\n    }\\n```\n```int mid = left + (right-left)/2;```\n```\\nRHS = left + (right-left)/2\\n    = left + right/2 - left/2\\n\\t= left/2 + right/2\\n    = (left + right)/2\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2700688,
                "title": "simple-python-solution-using-binary-search",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation: https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left = 1\\n        right = n\\n        result = 1\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            if isBadVersion(mid) == False:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n                result = mid\\n                \\n        return result\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left = 1\\n        right = n\\n        result = 1\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            if isBadVersion(mid) == False:\\n                left = mid+1\\n            else:\\n                right = mid-1\\n                result = mid\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71342,
                "title": "what-s-the-difference-between-left-right-2-and-left-right-left-2",
                "content": "Below is my code, it got TLE. But I can't see the difference between my code and [this one][1] except for how I calculated mid. So is there any difference between \"(left + right) / 2\" and \"left + (right - left) / 2\"? \\n\\n    bool isBadVersion(int version);\\n    \\n    class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int left = 1;\\n            int right = n;\\n            int mid;\\n            while(left < right) {\\n                mid = (left + right) / 2;\\n                if(isBadVersion(mid)) {\\n                    right = mid - 1;\\n                }\\n                else {\\n                    left = mid + 1;\\n                }\\n            }\\n            return left;\\n        }\\n    };\\n\\n\\n  [1]: https://leetcode.com/discuss/56550/short-c-answer-and-minimize-api-calls",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int left = 1;\\n            int right = n;\\n            int mid;\\n            while(left < right) {\\n                mid = (left + right) / 2;\\n                if(isBadVersion(mid)) {\\n                    right = mid - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3324195,
                "title": "awesome-logic-with-binary-search",
                "content": "\\n# Binary Search\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left,right=0,n-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            if isBadVersion(mid)==False:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return left\\n            \\n//please upvote me it would encourage me alot\\n\\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left,right=0,n-1\\n        while left<=right:\\n            mid=(left+right)//2\\n            if isBadVersion(mid)==False:\\n                left=mid+1\\n            else:\\n                right=mid-1\\n        return left\\n            \\n//please upvote me it would encourage me alot\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240775,
                "title": "c-easy-using-binary-search",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long int start = 0 ; \\n        long long int end = n ; \\n        long long int minBadVersion ;\\n         \\n        while (start <= end)\\n        {\\n            long long int mid = (start + end) / 2 ; \\n\\n            if (isBadVersion(mid) == 1)\\n            {\\n                minBadVersion = mid ; \\n                end = mid - 1 ; \\n            }\\n            else\\n            {\\n                start = mid + 1 ; \\n            }\\n        }\\n        return minBadVersion ;\\n    }\\n};\\n```\\n![815a317f-9cdf-46e2-a397-af8869dafa2e_1673498197.3721023.png](https://assets.leetcode.com/users/images/65eeb207-f2a9-4d1b-9d13-2c8573d657ed_1677603105.5077243.png)\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long int start = 0 ; \\n        long long int end = n ; \\n        long long int minBadVersion ;\\n         \\n        while (start <= end)\\n        {\\n            long long int mid = (start + end) / 2 ; \\n\\n            if (isBadVersion(mid) == 1)\\n            {\\n                minBadVersion = mid ; \\n                end = mid - 1 ; \\n            }\\n            else\\n            {\\n                start = mid + 1 ; \\n            }\\n        }\\n        return minBadVersion ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236373,
                "title": "278-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this solution, we maintain two pointers left and right that represent the range of versions we are searching. We start with left = 1 and right = n. At each iteration of the while loop, we compute the midpoint mid of the range as (left + right) // 2, and we call the isBadVersion API to check whether version mid is bad or not.\\n\\nIf isBadVersion(mid) returns True, then we know that the first bad version must be in the range [left, mid], so we update right = mid. Otherwise, the first bad version must be in the range [mid+1, right], so we update left = mid + 1. We continue this process until left and right converge to a single version, which must be the first bad version.\\n\\nThis algorithm runs in logarithmic time and makes only O(1) calls to the isBadVersion API at each iteration, which minimizes the total number of calls to the API.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71356,
                "title": "simple-python-solution-binary-search-both-iterative-and-recursive-versions",
                "content": "Iterative version:\\n```\\ndef firstBadVersion(self, n):\\n        low = 1\\n        high = n\\n        while(low < high):\\n            mid = (low + high)/2\\n            if isBadVersion(mid) == True:\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return high\\n```\\n\\nRecursive version:\\n```\\n    def firstBadVersion(self, n):\\n        return self.binarySearch(1, n)\\n    \\n    def binarySearch(self, low, high):\\n        if low == high:\\n            return low\\n        mid = (low + high)/2\\n        if isBadVersion(mid) == True:\\n            return self.binarySearch(low, mid)\\n        else:\\n            return self.binarySearch(mid + 1, high)",
                "solutionTags": [],
                "code": "```\\ndef firstBadVersion(self, n):\\n        low = 1\\n        high = n\\n        while(low < high):\\n            mid = (low + high)/2\\n            if isBadVersion(mid) == True:\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return high\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 606739,
                "title": "javascript-clean-binary-search-solution",
                "content": "```javascript\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let min = null;\\n        let start = 1;\\n        let end = n;\\n        \\n        while(start <= end) {\\n            const mid = Math.floor((start + end) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                min = mid;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return min;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let min = null;\\n        let start = 1;\\n        let end = n;\\n        \\n        while(start <= end) {\\n            const mid = Math.floor((start + end) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                min = mid;\\n                end = mid - 1;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n        return min;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2724423,
                "title": "3-lines-binary-search-java-c",
                "content": "\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int st = 1,end = n;\\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            if(isBadVersion(mid) == false) st = mid+1;\\n            else end = mid-1;\\n        }\\n        return st;\\n    }\\n};\\n```\\n\\n# Java  Code\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int st = 1,end = n;\\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            if(isBadVersion(mid) == false) st = mid+1;\\n            else end = mid-1;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\nif(you like)\\n\\tplease please UPVOTE\\uD83D\\uDE0A\\uD83D\\uDE0A;\\n```\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int st = 1,end = n;\\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            if(isBadVersion(mid) == false) st = mid+1;\\n            else end = mid-1;\\n        }\\n        return st;\\n    }\\n};\\n```\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int st = 1,end = n;\\n        while(st <= end){\\n            int mid = st + (end-st)/2;\\n            if(isBadVersion(mid) == false) st = mid+1;\\n            else end = mid-1;\\n        }\\n        return st;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743709,
                "title": "python-simple-python-solution-using-binary-search",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 30 ms, faster than 93.38% of Python3 online submissions for First Bad Version.\\n# Memory Usage: 13.7 MB, less than 96.91% of Python3 online submissions for First Bad Version.\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\n\\tclass Solution:\\n\\t\\tdef firstBadVersion(self, n: int) -> int:\\n\\n\\t\\t\\tresult = 1\\n\\t\\t\\tstart, end = 1, n\\n\\n\\t\\t\\twhile start <= end:\\n\\n\\t\\t\\t\\tmid = (start + end) // 2\\n\\n\\t\\t\\t\\tif isBadVersion(mid) == False:\\n\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend = mid - 1\\n\\t\\t\\t\\t\\tresult = mid\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83D\\uDD25\\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Runtime: 30 ms, faster than 93.38% of Python3 online submissions for First Bad Version.\\n# Memory Usage: 13.7 MB, less than 96.91% of Python3 online submissions for First Bad Version.\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\n\\tclass Solution:\\n\\t\\tdef firstBadVersion(self, n: int) -> int:\\n\\n\\t\\t\\tresult = 1\\n\\t\\t\\tstart, end = 1, n\\n\\n\\t\\t\\twhile start <= end:\\n\\n\\t\\t\\t\\tmid = (start + end) // 2\\n\\n\\t\\t\\t\\tif isBadVersion(mid) == False:\\n\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend = mid - 1\\n\\t\\t\\t\\t\\tresult = mid\\n\\n\\t\\t\\treturn result\\n\\n# Thank You \\uD83D\\uDD25\\uD83E\\uDD73\\u270C\\uD83D\\uDC4D\\n",
                "codeTag": "Java"
            },
            {
                "id": 1555825,
                "title": "java-tc-o-logn-sc-o-1-simple-binary-search-w-minimum-api-calls",
                "content": "```\\n/**\\n * Binary Search\\n *\\n * Time Complexity: O(log N). N = Number of versions.\\n *\\n * Space Complexity: O(1)\\n */\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        // If nth version is not a bad version, then all versions are good.\\n        if (n <= 0 || !isBadVersion(n)) {\\n            return -1;\\n        }\\n        // If first version is a bad version, then all versions are bad.\\n        if (isBadVersion(1)) {\\n            return 1;\\n        }\\n\\n        // Search space is from 1 to n (All possible version numbers)\\n        int start = 1;\\n        int end = n;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (isBadVersion(mid)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Binary Search\\n *\\n * Time Complexity: O(log N). N = Number of versions.\\n *\\n * Space Complexity: O(1)\\n */\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        // If nth version is not a bad version, then all versions are good.\\n        if (n <= 0 || !isBadVersion(n)) {\\n            return -1;\\n        }\\n        // If first version is a bad version, then all versions are bad.\\n        if (isBadVersion(1)) {\\n            return 1;\\n        }\\n\\n        // Search space is from 1 to n (All possible version numbers)\\n        int start = 1;\\n        int end = n;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (isBadVersion(mid)) {\\n                end = mid;\\n            } else {\\n                start = mid + 1;\\n            }\\n        }\\n\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2433696,
                "title": "java-solution-with-comments",
                "content": "PLEASE UPVOTE IF IT\\'S HELPFUL-\\n\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start=1, end=n;\\n        while(start<end){\\n\\t\\t\\n            //Implement binary search logic\\n            //get the mid and pass it to function isBadVersion()\\n            //If mid is bad version (false) -> then start will be mid+1\\n            //If mid is good version (true) -> then end is mid\\n\\t\\t\\t\\n            int mid=  start+(end-start)/2;\\n            if(!isBadVersion(mid))\\n                start=mid+1;\\n            else\\n                end=mid;\\n        }\\n        return start;\\n        \\n    }\\n}\\n```\\n\\n\\n**24 / 24 test cases passed.\\nStatus: Accepted\\nRuntime: 26 ms\\nMemory Usage: 40.1 MB**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start=1, end=n;\\n        while(start<end){\\n\\t\\t\\n            //Implement binary search logic\\n            //get the mid and pass it to function isBadVersion()\\n            //If mid is bad version (false) -> then start will be mid+1\\n            //If mid is good version (true) -> then end is mid\\n\\t\\t\\t\\n            int mid=  start+(end-start)/2;\\n            if(!isBadVersion(mid))\\n                start=mid+1;\\n            else\\n                end=mid;\\n        }\\n        return start;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676519,
                "title": "python-binary-search-simple-solution",
                "content": "**Python :**\\n\\nTime complexity : *O(logn)*\\nSpace complexity :*O(1)*\\n\\n```\\ndef firstBadVersion(self, n):\\n\\t\"\"\"\\n\\t:type n: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tlow = 0\\n\\thigh = n - 1\\n\\n\\twhile low <= high:\\n\\t\\tmid = (low + high) // 2\\n\\t\\tif not isBadVersion(mid):\\n\\t\\t\\tlow = mid + 1\\n\\n\\t\\telse:\\n\\t\\t\\thigh = mid - 1\\n\\n\\treturn low\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\ndef firstBadVersion(self, n):\\n\\t\"\"\"\\n\\t:type n: int\\n\\t:rtype: int\\n\\t\"\"\"\\n\\tlow = 0\\n\\thigh = n - 1\\n\\n\\twhile low <= high:\\n\\t\\tmid = (low + high) // 2\\n\\t\\tif not isBadVersion(mid):\\n\\t\\t\\tlow = mid + 1\\n\\n\\t\\telse:\\n\\t\\t\\thigh = mid - 1\\n\\n\\treturn low\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1475526,
                "title": "java-99-percent-faster-solution-easy-binary-search",
                "content": "Please upvote if it helped.\\n\\nThis is a problem associated with binary search\\nLets take an example\\n1-2-3-4-5\\nG-B-B-B-B\\n\\nOur objective is to find the first bad version. You can assume it is sorted array by substituting Good by zero and Bad by 1\\n1-2-3-4-5\\n0-1-1-1-1\\nWe have to find first 1. We start by find value 1. \\n```\\nmid = low + (high-low)/2; // First approach\\nmid = (low+high)/2 //second approach.\\n```\\nWe followed first approach as it would prevent integer overflow, i.e, if sum of low and high is more than the capacity of integer it would pick next number which can become negative. You can read more about it [here](https://en.wikipedia.org/wiki/Integer_overflow)\\n\\nWe are interested in finding lower bound where value becomes 1, i.e, Bad, so we need to track only **low**. When our function **isBadVersion** returns true. It means we can find lower bound or if the mid is the lower bound. If mid is lower bound, in next iterations, low will be assigned the value of current **mid**.\\n\\nIterations:\\n1. low=1, high=5, mid = 2, badversion = true\\n2. low =1, high = 2, mid = 1, badversion = false\\n3. low=2, high=2, it comes out of loop as low == high\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n       int low = 1, high = n;\\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            boolean answer = isBadVersion(mid);\\n            if(answer==false){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n        }\\n        \\n        return low;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nmid = low + (high-low)/2; // First approach\\nmid = (low+high)/2 //second approach.\\n```\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n       int low = 1, high = n;\\n        while(low<high){\\n            int mid = low + (high-low)/2;\\n            boolean answer = isBadVersion(mid);\\n            if(answer==false){\\n                low = mid+1;\\n            }\\n            else{\\n                high = mid;\\n            }\\n        }\\n        \\n        return low;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606857,
                "title": "java-python-3-2-similar-o-logn-clean-codes-w-brief-explanation",
                "content": "**Method 1:**\\nUse `<=` in while loop condition, hence `l > r` is the termination condition; The code ends up with that `r` and `l` are last good and first bad versions, respectively.\\n```java\\n    public int firstBadVersion(int n) {\\n        int l = 0, r = n;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (isBadVersion(mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n```\\n```python\\n    def firstBadVersion(self, n):\\n        l, r =  1, n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```\\n\\n----\\n\\n**Method 2:**\\nUse `<` in while loop condition, hence `l == r` is the termination condition; The code ends up with that both `r` and `l` are first bad version.\\n```java\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isBadVersion(mid)) {\\n                r = mid;\\n            }else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n```\\n```python\\n    def firstBadVersion(self, n):\\n        l, r =  1, n\\n        while l < r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int firstBadVersion(int n) {\\n        int l = 0, r = n;\\n        while (l <= r) {\\n            int mid = l + (r - l) / 2;\\n            if (isBadVersion(mid))\\n                r = mid - 1;\\n            else\\n                l = mid + 1;\\n        }\\n        return l;\\n    }\\n```\n```python\\n    def firstBadVersion(self, n):\\n        l, r =  1, n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return l\\n```\n```java\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (isBadVersion(mid)) {\\n                r = mid;\\n            }else {\\n                l = mid + 1;\\n            }\\n        }\\n        return l;\\n    }\\n```\n```python\\n    def firstBadVersion(self, n):\\n        l, r =  1, n\\n        while l < r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                r = mid\\n            else:\\n                l = mid + 1\\n        return l\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2833450,
                "title": "python-binary-search-bonus-one-liner",
                "content": "**\\u2705 IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n****\\n\\n**Python #1.** Binary search from scratch.\\n```\\nclass Solution:\\n    def firstBadVersion_(self, n, s = 1):\\n        \\n        while s < n:\\n            i = (n + s) // 2\\n            if isBadVersion(i) : n = i\\n            else               : s = i + 1\\n        return s\\n```\\n\\n**Python #2.** One-liner using a built-in *bisect_left*.\\n```\\nclass Solution:\\n    def firstBadVersion(self, n, s = 1):\\n        \\n        return bisect.bisect_left(range(n), True, key=lambda x: isBadVersion(x))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstBadVersion_(self, n, s = 1):\\n        \\n        while s < n:\\n            i = (n + s) // 2\\n            if isBadVersion(i) : n = i\\n            else               : s = i + 1\\n        return s\\n```\n```\\nclass Solution:\\n    def firstBadVersion(self, n, s = 1):\\n        \\n        return bisect.bisect_left(range(n), True, key=lambda x: isBadVersion(x))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658129,
                "title": "java-simple-code-to-find-first-bad-version-using-binary-search",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(log N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int low = 0, high = n , mid = 0;\\n        while(low <= high){\\n            mid = low + (high - low) / 2;\\n            if(isBadVersion(mid)){\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\\n\\n## **If you find this helpful, please upvote \\uD83D\\uDE0A**",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int low = 0, high = n , mid = 0;\\n        while(low <= high){\\n            mid = low + (high - low) / 2;\\n            if(isBadVersion(mid)){\\n                high = mid - 1;\\n            }else{\\n                low = mid + 1;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670019,
                "title": "elegant-o-log-n-python-solution-with-explanation",
                "content": "The solution is quite simple and elegant. Since we know the version numbers are distinct and are in ascending order, we can simply use binary search to search for the first bad version.\\n\\nSteps:\\n1. Start with how every binary search starts. With two pointers, one at the first element of the array and one at the last.\\n\\t```\\n\\tlow, high = 1, n\\n\\t```\\n2. Run a while loop as long as low is less than high. (The reason to check ```low < high ```  will be explained below)\\n\\t```\\n\\twhile low < high: mid = (low + high) // 2\\n\\t```\\n3. Next check if the low pointer is not a bad version then set ```low = mid + 1``` else ```high = mid ```. \\n\\n\\nThe reason to set `low = mid + 1` and `high = mid` and not `high = mid - 1`. Since the bad version is the second part of the array we can\\'t remove all the bad versions from the binary search since we have to return the recent bad version not the most stable version. The is the exact reason why we don\\'t check for low <= high in the while loop since it can cause an infinite loop. You can return both low and high since they will be both equal at the end of the binary search. \\n\\nSolution:\\n```\\nlow, high = 1, n\\nwhile low < high:\\n\\tmid = (low + high) // 2\\n\\tif not isBadVersion(mid):\\n\\t\\tlow = mid + 1\\n\\telse:\\n\\t\\thigh = mid \\nreturn high\\n```\\n\\nFirst solution in leetcode. Happy to help! Thanks for the great community :)",
                "solutionTags": [
                    "Array",
                    "Binary Tree"
                ],
                "code": "```\\n\\tlow, high = 1, n\\n\\t```\n```low < high ```\n```\\n\\twhile low < high: mid = (low + high) // 2\\n\\t```\n```low = mid + 1```\n```high = mid ```\n```\\nlow, high = 1, n\\nwhile low < high:\\n\\tmid = (low + high) // 2\\n\\tif not isBadVersion(mid):\\n\\t\\tlow = mid + 1\\n\\telse:\\n\\t\\thigh = mid \\nreturn high\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 71408,
                "title": "java-simple-clean",
                "content": "it looks very simple, but actually a little tricky. Have to pay attention to the detail.\\n<br>\\nAlgo. 1 --\\n\\n      public int firstBadVersion(int n) {\\n        int lo = 1, hi = n;\\n        while (lo < hi) {\\n        \\tint med = lo + (hi -  lo)/2;\\n        \\tif (isBadVersion(med)) {\\n        \\t\\thi = med;\\n        \\t} else {\\n        \\t\\tlo = med + 1;\\n        \\t}\\n        }\\n        return lo;\\n    }\\n\\nAlgo.2 --\\n\\n        public int firstBadVersion(int n) {\\n        int lo = 1, hi = n;\\n        while (lo <= hi) {\\n        \\tint med = lo + (hi -  lo)/2;\\n        \\tif (isBadVersion(med)) {\\n        \\t\\tif (med == 1 || !isBadVersion(med-1))\\n        \\t\\t\\treturn med;\\n        \\t\\thi = med;\\n        \\t} else {\\n        \\t\\tlo = med + 1;\\n        \\t}\\n        }\\n        return -1; //no solution found.\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "it looks very simple, but actually a little tricky. Have to pay attention to the detail.\\n<br>\\nAlgo. 1 --\\n\\n      public int firstBadVersion(int n) {\\n        int lo = 1, hi = n;\\n        while (lo < hi) {\\n        \\tint med = lo + (hi -  lo)/2;\\n        \\tif (isBadVersion(med)) {\\n        \\t\\thi = med;\\n        \\t} else {\\n        \\t\\tlo = med + 1;\\n        \\t}\\n        }\\n        return lo;\\n    }\\n\\nAlgo.2 --\\n\\n        public int firstBadVersion(int n) {\\n        int lo = 1, hi = n;\\n        while (lo <= hi) {\\n        \\tint med = lo + (hi -  lo)/2;\\n        \\tif (isBadVersion(med)) {\\n        \\t\\tif (med == 1 || !isBadVersion(med-1))\\n        \\t\\t\\treturn med;\\n        \\t\\thi = med;\\n        \\t} else {\\n        \\t\\tlo = med + 1;\\n        \\t}\\n        }\\n        return -1; //no solution found.\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3347493,
                "title": "c-easy-using-binary-search-o-logn",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nWe call the `isBadVersion` function with `mid` as an argument. \\n\\nIf the **result** is `true`, it means that the bad version is in the lower half of the search range, so it updates `e = mid-1` and continues the search in the lower half.\\n\\n If the **result** is `false`, it means that the bad version is in the upper half of the search range, so it updates `s = mid+1` and continues the search in the upper half.\\n\\nThe function returns the value of `s`, which is the index of the **first bad version**.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(log(n))$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=1,e=n;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(isBadVersion(mid)){\\n                e=mid-1;\\n            }\\n            else if(!isBadVersion(mid)){\\n                 s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=1,e=n;\\n        while(s<=e){\\n            int mid=s+(e-s)/2;\\n\\n            if(isBadVersion(mid)){\\n                e=mid-1;\\n            }\\n            else if(!isBadVersion(mid)){\\n                 s=mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1924090,
                "title": "first-bad-version-binary-search-c-approach-explained",
                "content": "<hr/>\\n\\n### Approach:\\n1. Find the `mid` element from 1 to `n`\\n2. Check if `mid` is bad or not\\n3. If mid is bad, store it in variable and go to left part of array, because we need to find first bad version. **(end = mid-1)**\\n4. If number is not bad, go to right part of an array. **(start=mid+1)**\\n<hr/>\\n\\n### Code:\\n<hr/>\\n\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 0;\\n        int e = n;\\n        int bad;\\n        while(s<=e){\\n            \\n            int mid = s + (e-s)/2;\\n            \\n            if(isBadVersion(mid)){\\n                bad = mid;\\n                e = mid-1;\\n            }\\n            else\\n                s = mid+1;\\n            \\n        }\\n        return bad;\\n    }\\n};\\n```\\nPlease **UPVOTE** if you find this helpful!\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 0;\\n        int e = n;\\n        int bad;\\n        while(s<=e){\\n            \\n            int mid = s + (e-s)/2;\\n            \\n            if(isBadVersion(mid)){\\n                bad = mid;\\n                e = mid-1;\\n            }\\n            else\\n                s = mid+1;\\n            \\n        }\\n        return bad;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1705959,
                "title": "python-faster-than-regular-binary-search-100-faster-solution-optimal",
                "content": "\\n```\\n\\nclass Solution(object):\\n   \\n    def firstBadVersion(self, n):\\n        start =1\\n        end =n\\n        \\n        while start<=end:\\n            mid = (start+end)//2\\n            if (isBadVersion(mid) and not isBadVersion(mid-1)): #optimization using second parameter\\n                return mid\\n            elif(not isBadVersion(mid)):\\n                start = mid+1 \\n            else:\\n                end = (mid-1)\\n```\\n            \\n\\t\\t\\t\\n****\\t\\t\\tIf this solution helped you, please upvote****",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n\\nclass Solution(object):\\n   \\n    def firstBadVersion(self, n):\\n        start =1\\n        end =n\\n        \\n        while start<=end:\\n            mid = (start+end)//2\\n            if (isBadVersion(mid) and not isBadVersion(mid-1)): #optimization using second parameter\\n                return mid\\n            elif(not isBadVersion(mid)):\\n                start = mid+1 \\n            else:\\n                end = (mid-1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71436,
                "title": "javascript-solution",
                "content": "    function solution(isBadVersion) {\\n      return function(n) {\\n        var left = 0;\\n        var right = n;\\n    \\n        while (right - left !== 1) {\\n          var mid = parseInt((left + right) / 2);\\n    \\n          if (isBadVersion(mid)) {\\n            right = mid;\\n          } else {\\n            left = mid;\\n          }\\n        }\\n        return right;\\n      };\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function solution(isBadVersion) {\\n      return function(n) {\\n        var left = 0;\\n        var right = n;\\n    \\n        while (right - left !== 1) {\\n          var mid = parseInt((left + right) / 2);\\n    \\n          if (isBadVersion(mid)) {\\n            right = mid;\\n          } else {\\n            left = mid;\\n          }\\n        }\\n        return right;\\n      };\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3601993,
                "title": "easy-and-optimum-solution-using-binary-search-beats-96-11",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem requires finding the first bad version in a given range of versions. A bad version indicates that all subsequent versions are also bad. We need to optimize the solution to minimize the number of calls to the isBadVersion() API.\\n\\n# Approach\\n1. Initially, we have the range of versions from 1 to n, where n is the total number of versions.\\n1. We want to find the first bad version, which indicates that all subsequent versions are also bad.\\n1. To optimize our search, we use a binary search algorithm.\\n1. We start with the middle version and check if it is a bad version.\\n1. If it is a bad version, we can conclude that all versions after it are also bad.\\n1. If it is not a bad version, we can conclude that all versions before it are good.\\n1. Based on this information, we update our search range accordingly.\\n1. If the middle version is bad, we search in the left half (lower versions).\\n1. If the middle version is good, we search in the right half (higher versions).\\n1. We repeat steps 4 and 5 until we narrow down the search range to a single version.\\n1. At this point, we have found the first bad version.\\n1. Finally, we return the index of the first bad version.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the binary search algorithm is $$O(log n)$$, where n is the number of versions. This is because we divide the range of versions in half at each step of the binary search, reducing the search space exponentially.\\n\\n- Space complexity:\\nThe space complexity is $$O(1)$$ since the solution uses only a constant amount of additional space to store the variables start, end, and mid.\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n\\n        int start = 1; // Start of the search range\\n        int end = n; // End of the search range\\n        int mid = 0; // Variable to store the middle version\\n        \\n        while (start <= end) {\\n            mid = start + (end - start) / 2; // Calculate the middle version\\n\\n            if (isBadVersion(mid)) {\\n                end = mid - 1; // Adjust the end to search in the left half (lower versions)\\n            } else {\\n                // If the middle version is not bad, all versions before it are good\\n                start = mid + 1; // Adjust the start to search in the right half (higher versions)\\n            }\\n        }\\n\\n        return end + 1; // Return the index of the first bad version\\n    }\\n}\\n\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/6964a8ad-0038-4c2d-858d-a3700cdd2d03_1685993019.7458081.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n\\n        int start = 1; // Start of the search range\\n        int end = n; // End of the search range\\n        int mid = 0; // Variable to store the middle version\\n        \\n        while (start <= end) {\\n            mid = start + (end - start) / 2; // Calculate the middle version\\n\\n            if (isBadVersion(mid)) {\\n                end = mid - 1; // Adjust the end to search in the left half (lower versions)\\n            } else {\\n                // If the middle version is not bad, all versions before it are good\\n                start = mid + 1; // Adjust the start to search in the right half (higher versions)\\n            }\\n        }\\n\\n        return end + 1; // Return the index of the first bad version\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2975645,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n         int lower = 1, upper = n, mid;\\n        while(lower < upper) {\\n            mid = lower + (upper - lower) / 2;\\n            if(!isBadVersion(mid))\\n             lower = mid + 1;\\n            else\\n             upper = mid;\\n        }\\n        return lower;   \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n         int lower = 1, upper = n, mid;\\n        while(lower < upper) {\\n            mid = lower + (upper - lower) / 2;\\n            if(!isBadVersion(mid))\\n             lower = mid + 1;\\n            else\\n             upper = mid;\\n        }\\n        return lower;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688057,
                "title": "java-solution-with-o-log-n-time-complexity",
                "content": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1, end = n, result = 0;\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n            if(isBadVersion(mid)) {\\n                result = mid;\\n                end = mid - 1;\\n            } else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\n}\\n```\\nGuy\\'s if you find this solution helpful \\uD83D\\uDE0A, PLEASE do UPVOTE.\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1, end = n, result = 0;\\n        while(start <= end) {\\n            int mid = start + (end - start)/2;\\n            if(isBadVersion(mid)) {\\n                result = mid;\\n                end = mid - 1;\\n            } else\\n                start = mid + 1;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466178,
                "title": "first-bad-version-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(logn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long int low=1, high=n, mid;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(isBadVersion(mid))\\n            {\\n                if(mid-1>=0 && !isBadVersion(mid-1))\\n                {\\n                    return mid;\\n                }\\n                high = mid-1;\\n            }\\n            else if(!isBadVersion(mid))\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return mid;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/b30dac90-160c-4547-b84b-504589b13664_1682772442.0565617.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long int low=1, high=n, mid;\\n        while(low<=high)\\n        {\\n            mid=(low+high)/2;\\n            if(isBadVersion(mid))\\n            {\\n                if(mid-1>=0 && !isBadVersion(mid-1))\\n                {\\n                    return mid;\\n                }\\n                high = mid-1;\\n            }\\n            else if(!isBadVersion(mid))\\n            {\\n                low = mid+1;\\n            }\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3081374,
                "title": "javascript-simple-upvote-if",
                "content": "```\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let nBad = n;\\n        let nGood = 0;\\n        while (nBad - nGood > 1) {\\n            let nCurr = Math.round((nBad + nGood)/2); // center\\n            if (isBadVersion(nCurr)) {                // only one API call\\n                nBad = nCurr;\\n            } else {\\n                nGood = nCurr;\\n            }\\n        }\\n        return nBad;\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let nBad = n;\\n        let nGood = 0;\\n        while (nBad - nGood > 1) {\\n            let nCurr = Math.round((nBad + nGood)/2); // center\\n            if (isBadVersion(nCurr)) {                // only one API call\\n                nBad = nCurr;\\n            } else {\\n                nGood = nCurr;\\n            }\\n        }\\n        return nBad;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2668808,
                "title": "js-binary-search-with-explanation",
                "content": "A binary search algorithm is used to solve the problem. We check the average value of n(mid), if it is true(bad), then we do an additional check for a false value in front of it, if so, we return our mid, otherwise we continue our search.\\nIf our average value is false, we \"reject\" the half that comes before this value, and repeat the search again, already among the \"new\" half.\\n\\n```\\nvar solution = function (isBadVersion) {\\n\\n    return function (n) {\\n        let low = 1;\\n        let high = n;\\n        let mid;\\n        while (low <= high) {\\n            mid = ~~(low + (high - low) / 2);\\n            if (isBadVersion(mid)) {\\n                if (isBadVersion(mid - 1)) high = mid - 1;\\n                else return mid;\\n            } else low = mid + 1;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nvar solution = function (isBadVersion) {\\n\\n    return function (n) {\\n        let low = 1;\\n        let high = n;\\n        let mid;\\n        while (low <= high) {\\n            mid = ~~(low + (high - low) / 2);\\n            if (isBadVersion(mid)) {\\n                if (isBadVersion(mid - 1)) high = mid - 1;\\n                else return mid;\\n            } else low = mid + 1;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2180671,
                "title": "python3-clean-code-faster-than-96",
                "content": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low,high = 1, n\\n        while low<=high:\\n            mid=(low+high)//2\\n            isBad = isBadVersion(mid)\\n            if(isBad):\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        return low\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low,high = 1, n\\n        while low<=high:\\n            mid=(low+high)//2\\n            isBad = isBadVersion(mid)\\n            if(isBad):\\n                high = mid-1\\n            else:\\n                low = mid+1\\n        return low\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767773,
                "title": "binary-search-template-solution-intuition-explained-in-detail-video-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhey every one i have made video playlist for binary search where i discuss a template solution and intuition behind it, this template solution will be very useful as this will help you solve many other questions in binary search this question is the part of that playlist:\\n\\nVideo link for question: https://youtu.be/EzCvKAnU5f0\\n\\nPlaylist ink: https://youtube.com/playlist?list=PLICVjZ3X1AcYYdde4GTp79zfdp_VACSkX\\n\\n\\n\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int left=1;\\n        int right=n;\\n        while(left<right){\\n            int mid= left+ (right-left)/2;\\n            if(isBadVersion(mid)){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int left=1;\\n        int right=n;\\n        while(left<right){\\n            int mid= left+ (right-left)/2;\\n            if(isBadVersion(mid)){\\n                right=mid;\\n            }\\n            else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206120,
                "title": "finding-the-first-bad-version-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo find the first bad version, we need to perform a search. However, we don\\'t want to search all the versions one by one because that would take a long time. Instead, we can use the binary search algorithm to search for the first bad version in a more efficient way.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nOur approach will be to use binary search to search for the first bad version. We will start by initializing two pointers, left and right, to 1 and n, respectively. We will then find the middle version by computing the average of left and right, and call isBadVersion on the middle version. If it returns True, then we know that the first bad version is either the middle version or a version before it. So we will move the right pointer to the middle version. If it returns False, then we know that the first bad version is either the middle version or a version after it. So we will move the left pointer to the middle version + 1. We will repeat this process until left and right converge to the first bad version.\\n# Complexity\\n- Time complexity:$$O(log n)$$, where $$ n$$ is the number of versions.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$, because we are only using constant extra space.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left = 1\\n        right = n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left = 1\\n        right = n\\n        while left < right:\\n            mid = left + (right - left) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2530017,
                "title": "c-binary-search-easy-to-understand",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long int left = 1;\\n        long int right = n;\\n        long int mid;\\n        \\n        while(left <= right){\\n            mid = (left+right)/2;\\n            if(isBadVersion(mid)){\\n                right = mid-1;\\n            }\\n            else left = mid+1;\\n            \\n            if(isBadVersion(mid) && !(isBadVersion(mid - 1))){\\n                return mid;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long int left = 1;\\n        long int right = n;\\n        long int mid;\\n        \\n        while(left <= right){\\n            mid = (left+right)/2;\\n            if(isBadVersion(mid)){\\n                right = mid-1;\\n            }\\n            else left = mid+1;\\n            \\n            if(isBadVersion(mid) && !(isBadVersion(mid - 1))){\\n                return mid;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1968674,
                "title": "binary-search-o-log-n-start-end-start-2-c-0ms-faster-than-100-easy-solution",
                "content": "**Best Approach C++**\\n\\n```\\nint firstBadVersion(int n) {\\n        int l=1,r=n;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2; // This is same as (l+r)/2 \\n            if(isBadVersion(mid))   // If this will return true then either this will be the first bad or first bad is in the left of it.\\n                r=mid-1;\\n            else\\n                l=mid+1;    // else bad on the right side.\\n        }\\n        if(isBadVersion(r)) // We have to check this condition because if we find true and then we assign r=mid-1 and this element will be false so we havbe to check this.\\n            return r;\\n        else\\n            return r+1;\\n    }\\n```\\n**If you find it helpful kindly UPVOTE**",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nint firstBadVersion(int n) {\\n        int l=1,r=n;\\n        while(l<=r)\\n        {\\n            int mid=l+(r-l)/2; // This is same as (l+r)/2 \\n            if(isBadVersion(mid))   // If this will return true then either this will be the first bad or first bad is in the left of it.\\n                r=mid-1;\\n            else\\n                l=mid+1;    // else bad on the right side.\\n        }\\n        if(isBadVersion(r)) // We have to check this condition because if we find true and then we assign r=mid-1 and this element will be false so we havbe to check this.\\n            return r;\\n        else\\n            return r+1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 204313,
                "title": "javascript",
                "content": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let left = 1, right = n\\n        while(left < right) {\\n            const mid = Math.floor((right + left) / 2)\\n            if(isBadVersion(mid)) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return right\\n    };\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let left = 1, right = n\\n        while(left < right) {\\n            const mid = Math.floor((right + left) / 2)\\n            if(isBadVersion(mid)) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        return right\\n    };\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3397965,
                "title": "binary-search",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\n  var solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n     \\n    return function(n) {\\n       let start = 1\\n       let end = n\\n       while (start <= end) {\\n           let mid = Math.floor((start + end) / 2)\\n           if (!isBadVersion(mid)) {\\n               start = mid + 1\\n           } else {\\n               end = mid - 1\\n           }\\n       }\\n       return start\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\n  var solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n     \\n    return function(n) {\\n       let start = 1\\n       let end = n\\n       while (start <= end) {\\n           let mid = Math.floor((start + end) / 2)\\n           if (!isBadVersion(mid)) {\\n               start = mid + 1\\n           } else {\\n               end = mid - 1\\n           }\\n       }\\n       return start\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3181875,
                "title": "python-binary-search-clean-code-o-logn",
                "content": "# Complexity\\n- Time complexity:$$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l , r , ans = 1, n, -1\\n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                ans = mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l , r , ans = 1, n, -1\\n\\n        while l <= r:\\n            mid = (l + r) >> 1\\n            if isBadVersion(mid):\\n                ans = mid\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072120,
                "title": "92-56-faster-binary-search-4-line-code",
                "content": "***PLEASE UPVOTE IF YOU LIKE THIS SOLUTION***\\n\\n# Code\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int i = 0, j = n;\\n\\n        while(i <= j){\\n            int mid = i + (j - i)/2;\\n            if(isBadVersion(mid) == true && isBadVersion(mid - 1) == false) return mid;\\n            else if(isBadVersion(mid) == false) i = mid + 1;\\n            else j = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Binary Search"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int i = 0, j = n;\\n\\n        while(i <= j){\\n            int mid = i + (j - i)/2;\\n            if(isBadVersion(mid) == true && isBadVersion(mid - 1) == false) return mid;\\n            else if(isBadVersion(mid) == false) i = mid + 1;\\n            else j = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600247,
                "title": "java-binary-search-solution",
                "content": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        int ans =0;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                ans=mid;\\n                e = mid-1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        int ans =0;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                ans=mid;\\n                e = mid-1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2505675,
                "title": "python-easy-binary-search-solution",
                "content": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        k, left, right = 0, 1, n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid - 1\\n                k = mid\\n            else:\\n                left = mid + 1\\n        return k\\n```\\nIf you found it useful please upvote, any comments are welcome!",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        k, left, right = 0, 1, n\\n        while left <= right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid - 1\\n                k = mid\\n            else:\\n                left = mid + 1\\n        return k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2375631,
                "title": "easy-c-solution-100-beat",
                "content": "# ***<<-- upvote***\\ntotal simple binary search type solution\\n\\n```\\nint firstBadVersion(int n) {\\n   long int f=1,mid;\\n    while(f<n) {\\n        mid = (f+n) / 2;\\n        if(isBadVersion(mid) == true) {\\n            n=mid;\\n        }\\n        else {\\n            f=mid+1;\\n        }\\n    }\\n    return f;\\n}\\n```\\n\\nbuddy don\\'t try for only using int for space efficient it needed long int \\u2665",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint firstBadVersion(int n) {\\n   long int f=1,mid;\\n    while(f<n) {\\n        mid = (f+n) / 2;\\n        if(isBadVersion(mid) == true) {\\n            n=mid;\\n        }\\n        else {\\n            f=mid+1;\\n        }\\n    }\\n    return f;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2102227,
                "title": "c-100-beats-0ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start=1,end=n;\\n        while (start<=end) {\\n            int mid=start+(end-start)/2;\\n            if (isBadVersion(mid)) {\\n                if (mid==1||isBadVersion(mid-1)==false) return mid;\\n                else end=mid-1;\\n            }\\n            else start=mid+1;\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start=1,end=n;\\n        while (start<=end) {\\n            int mid=start+(end-start)/2;\\n            if (isBadVersion(mid)) {\\n                if (mid==1||isBadVersion(mid-1)==false) return mid;\\n                else end=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1476803,
                "title": "beautiful-binary-search-application-o-n-to-o-log-n",
                "content": "Hi Everyone, \\n\\nIn this solution, we will move from ***Brute Force Solution Approach to Optimal Solution Approach***.\\n\\nIn Optimal Solution, we will see a ***beautiful application of Binary Search***.\\n\\n**Brute Force Approach**\\n\\nWe will do a simple scan from 1 till n and as soon as we find the first number which is a bad version, we return it. \\n\\n* ***Time Complexity - O(N)***\\n* ***Space Complexity - O(1)***\\n     \\n**Optimal Approach**\\n\\nSince we know that 1 to n is going to behave like a sorted array, let us fix our left to 1 and right to n. (Imagine 1,2,3,4.....n)\\n\\n**Applying Binary Search, suppose we have a mid and at this mid, our function says it is a good version**. \\n\\n* It means that the required first bad version will definitely lie towards right hand side, so do left = mid + 1.\\n\\n* Again, if the function says this mid is a bad version, then our answer can be this mid or somewhere before this. To check, we can check if (mid-1) is a good version or bad. If it is a good version, mid will be our answer. If it is a bad version, we will do right = mid - 1 as answer will definitely be before mid.\\n\\n* To handle edge cases, conditions are added below (when mid == 1)\\n\\n***Points to note*** : \\n***The given function returns True for a value, it means the version is bad.***\\n***mid = left + (right - left)// 2 is done to avoid integer overflow issues.***\\n\\n\\n* ***Time Complexity - O(log(N))***\\n* ***Space Complexity - O(1)***\\n        \\nHere is the code for Brute Force Approach - \\n```\\n\\tfor i in range(1, n+1):\\n\\t\\tif isBadVersion(i) == True:\\n\\t\\t\\treturn i\\n```\\n\\nHere is the code for Optimal Approach - \\n     \\n   ```\\n\\t\\tleft = 1\\n        right = n\\n        while left <= right:\\n            \\n            mid = left + (right - left) // 2\\n            \\n            if isBadVersion(mid) == False: #== if a version is not bad, answer will definitely lie after m\\n                left = mid + 1 \\n                \\n            else: #== if a version is bad \\n\\t\\t\\t\\n                #we will check (m-1)th number - if it is bad, we will do right = m - 1\\n                #if it is good, we will return answer\\n                if mid == 1:\\n                    return mid\\n\\t\\t\\t\\t\\t\\n                if isBadVersion(mid-1):\\n                    right = mid - 1\\n\\t\\t\\t\\t\\t\\n                else:\\n                    return mid\\n                \\n```\\n         \\n\\n     \\n#Time Complexity - O(log(N)) and Space Complexity - O(1)\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\tfor i in range(1, n+1):\\n\\t\\tif isBadVersion(i) == True:\\n\\t\\t\\treturn i\\n```\n```\\n\\t\\tleft = 1\\n        right = n\\n        while left <= right:\\n            \\n            mid = left + (right - left) // 2\\n            \\n            if isBadVersion(mid) == False: #== if a version is not bad, answer will definitely lie after m\\n                left = mid + 1 \\n                \\n            else: #== if a version is bad \\n\\t\\t\\t\\n                #we will check (m-1)th number - if it is bad, we will do right = m - 1\\n                #if it is good, we will return answer\\n                if mid == 1:\\n                    return mid\\n\\t\\t\\t\\t\\t\\n                if isBadVersion(mid-1):\\n                    right = mid - 1\\n\\t\\t\\t\\t\\t\\n                else:\\n                    return mid\\n                \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 708387,
                "title": "yet-another-python-solution",
                "content": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return an integer\\n# def isBadVersion(version):\\n\\nclass Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        l,r=0,n\\n        while l<r:\\n            mid = (l+r)//2\\n            if isBadVersion(mid):\\n                r=mid\\n            else:\\n                l=mid+1\\n        return l   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return an integer\\n# def isBadVersion(version):\\n\\nclass Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        l,r=0,n\\n        while l<r:\\n            mid = (l+r)//2\\n            if isBadVersion(mid):\\n                r=mid\\n            else:\\n                l=mid+1\\n        return l   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3590078,
                "title": "easiest-c-code-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int i,j,k,c=0;\\n        int h=n,l=0,m;\\n\\n        while(l<=h)\\n        {\\n            m=l+(h-l)/2;\\n            int res=isBadVersion(m);\\n            if(res==1 and (m==0 or isBadVersion(m-1)!=1)){\\n                return m;\\n            }\\n            else if(res==0){\\n                l=m+1;\\n            }else\\n            h=m-1;\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int i,j,k,c=0;\\n        int h=n,l=0,m;\\n\\n        while(l<=h)\\n        {\\n            m=l+(h-l)/2;\\n            int res=isBadVersion(m);\\n            if(res==1 and (m==0 or isBadVersion(m-1)!=1)){\\n                return m;\\n            }\\n            else if(res==0){\\n                l=m+1;\\n            }else\\n            h=m-1;\\n        }\\n        return m;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3467616,
                "title": "easy-to-understand-explained-with-example",
                "content": "# Intuition\\njust use Binary search\\n\\n# Approach\\nat first we took 3 variable \\'low\\',\\'high\\',\\'mid\\'. \\'Low\\' set at first ,\\'high\\' set at last of the index .\\nthen we used a while loop until low becomes \\'equal\\' of high.\\nthen we calculated the mid;\\n\\nwe checked if our mid is Bad .if then we will check the previous(mid-1) value is good or not .if previous is good then the bad starts from mid; ----------so return mid \\nfor example [low(good),mid-1(good),mid(bad),#(bad),high(bad)]\\n\\n\\nif mid is bad but the previous one(mid-1) is also bad \\nfor example [low(good),mid-1(bad),mid(bad),#(bad),high(bad)]\\nthen we will shift our high value to mid-1 position;\\n\\n\\nif mid is not bad\\nfor example [low(good),mid-1(good),mid(good),#(bad),high(bad)]\\nthen our \\'low\\' will be \\'mid+1\\'.because we dont have to check till mid because till mid is all good;\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long low=1;\\n        long high=n;\\n        long mid;\\n        \\n        while(low<=high){\\n            mid=(low+high)/2;\\n\\n            // if mid is bad\\n            if(isBadVersion(mid)){\\n\\n                if(!isBadVersion(mid-1)){ \\n                    return mid;\\n                }\\n                else high=mid-1;\\n            }\\n\\n            //if mid is not BAD\\n            else{\\n                low=mid+1;\\n                //our low will set in mid+1 position\\n            }\\n        }\\n        return mid;\\n    }\\n};\\n```\\n# Brother Please Upvote :(",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long low=1;\\n        long high=n;\\n        long mid;\\n        \\n        while(low<=high){\\n            mid=(low+high)/2;\\n\\n            // if mid is bad\\n            if(isBadVersion(mid)){\\n\\n                if(!isBadVersion(mid-1)){ \\n                    return mid;\\n                }\\n                else high=mid-1;\\n            }\\n\\n            //if mid is not BAD\\n            else{\\n                low=mid+1;\\n                //our low will set in mid+1 position\\n            }\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3320800,
                "title": "best-solution-in-java-look-at-once",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple Binary search approach\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1;\\n        int end = n;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(isBadVersion(mid) == true && isBadVersion(mid-1) == false){\\n                return mid;\\n            }\\n            else if(isBadVersion(mid) == false){\\n                start = mid+1;\\n            }\\n            else {\\n                end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\nplease upvote this for better solution of other questions![download.jfif](https://assets.leetcode.com/users/images/088df835-440e-4393-bbf4-8aa8e03aca02_1679330376.257638.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1;\\n        int end = n;\\n        while(start<=end){\\n            int mid = start+(end-start)/2;\\n            if(isBadVersion(mid) == true && isBadVersion(mid-1) == false){\\n                return mid;\\n            }\\n            else if(isBadVersion(mid) == false){\\n                start = mid+1;\\n            }\\n            else {\\n                end = mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3011922,
                "title": "binary-search-c",
                "content": "\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       int l = 1, r = n;\\n       while(l<r)\\n       {\\n           int mid = l+(r-l)/2;\\n           if(isBadVersion(mid))\\n           r=mid;\\n           else\\n           l=mid+1;\\n       }\\n       return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       int l = 1, r = n;\\n       while(l<r)\\n       {\\n           int mid = l+(r-l)/2;\\n           if(isBadVersion(mid))\\n           r=mid;\\n           else\\n           l=mid+1;\\n       }\\n       return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672082,
                "title": "python-binary-search-two-approaches",
                "content": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n  def firstBadVersion(self, n: int) -> int:\\n  \"\"\"Optimised version.\\n  \"\"\"\\n    left, right = 1, n\\n    while left <= right:\\n      mid = (left + right)//2\\n      if left == right:\\n        if isBadVersion(left) == True:\\n          return left\\n      elif isBadVersion(mid) == True:\\n        right = mid\\n      else:\\n        left = mid + 1\\n```\\n\\n\\n\\n```\\nclass Solution:\\n  def firstBadVersion(self, n: int) -> int:\\n    right, left = n, 1\\n    while left <= right:\\n      mid = (left + right)//2\\n      is_bad = isBadVersion(mid)\\n      if  is_bad == True:\\n        if isBadVersion(mid - 1) == False: # here we are checking if the previous version is good.\\n          return mid\\n        right = mid - 1 \\n      elif is_bad == False:\\n        left = mid + 1\\n```\\n\\nPlease upvote if you like my solution :) Thank you !",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n  def firstBadVersion(self, n: int) -> int:\\n  \"\"\"Optimised version.\\n  \"\"\"\\n    left, right = 1, n\\n    while left <= right:\\n      mid = (left + right)//2\\n      if left == right:\\n        if isBadVersion(left) == True:\\n          return left\\n      elif isBadVersion(mid) == True:\\n        right = mid\\n      else:\\n        left = mid + 1\\n```\n```\\nclass Solution:\\n  def firstBadVersion(self, n: int) -> int:\\n    right, left = n, 1\\n    while left <= right:\\n      mid = (left + right)//2\\n      is_bad = isBadVersion(mid)\\n      if  is_bad == True:\\n        if isBadVersion(mid - 1) == False: # here we are checking if the previous version is good.\\n          return mid\\n        right = mid - 1 \\n      elif is_bad == False:\\n        left = mid + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1550677,
                "title": "binary-search-c",
                "content": "\\n\\nclass Solution {\\npublic:\\n\\n\\n    int firstBadVersion(int n) {\\n          if(n<1) return 1;\\n        int ans=1,l=1,r=n;\\n        while(l<=r){\\n           int m=l+(r-l)/2;\\n           if(isBadVersion(m)){\\n             ans=m;\\n             r=m-1;\\n           }\\n           else l=m+1;\\n       }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n\\n    int firstBadVersion(int n) {\\n          if(n<1) return 1;\\n        int ans=1,l=1,r=n;\\n        while(l<=r){\\n           int m=l+(r-l)/2;\\n           if(isBadVersion(m)){\\n             ans=m;\\n             r=m-1;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1498375,
                "title": "binary-search-on-the-answer-approach-with-lower-bound-built-in-function",
                "content": "[This is kind of a shitpost lol]\\nI\\'m creating a range iterator, which I\\'ll use with lower_bound to search for answer.\\n```cpp\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\n\\nclass range {\\n  using ll = long long;\\n  ll strt;\\n  ll last;\\n\\npublic:\\n  range(ll l, ll r) : strt(l), last(r) {}\\n\\n  struct const_iterator {\\n    using iterator_category = std::random_access_iterator_tag;\\n    using difference_type = std::ptrdiff_t;\\n    using value_type = ll;\\n    using pointer = ll;\\n    using reference = const ll &;\\n\\n    pointer m_ptr;\\n\\n    const_iterator() =default;\\n    const_iterator(pointer ptr) : m_ptr(ptr) {}\\n    const_iterator(const const_iterator &iter) = default;\\n\\n    reference operator*() const { return m_ptr; }\\n\\n    const_iterator &operator++() {\\n      m_ptr++;\\n      return *this;\\n    }\\n    const_iterator operator++(int) {\\n      auto tmp = *this;\\n      ++(*this);\\n      return tmp;\\n    }\\n\\n    const_iterator &operator--() {\\n      m_ptr--;\\n      return *this;\\n    }\\n\\n    const_iterator operator--(int) {\\n      auto tmp = *this;\\n      --(*this);\\n      return tmp;\\n    }\\n    friend const_iterator operator+(const const_iterator &self,\\n                                    const difference_type &other) {\\n      return const_iterator(self.m_ptr + other);\\n    }\\n    const_iterator operator+=(const difference_type &other) {\\n      return *this = *this + other;\\n    }\\n    difference_type operator-(const const_iterator &other) {\\n      return this->m_ptr - other.m_ptr;\\n    }\\n    difference_type operator-=(const const_iterator &other) {\\n      return this->m_ptr - other.m_ptr;\\n    }\\n\\n    bool operator<(const const_iterator &b) const {\\n      return this->m_ptr < b.m_ptr;\\n    }\\n    bool operator>(const const_iterator &b) const {\\n      return this->m_ptr > b.m_ptr;\\n    }\\n    friend bool operator==(const const_iterator &a, const const_iterator &b) {\\n      return a.m_ptr == b.m_ptr;\\n    }\\n\\n    friend bool operator!=(const const_iterator &a, const const_iterator &b) {\\n      return a.m_ptr != b.m_ptr;\\n    }\\n    bool operator<=(const const_iterator &b) const {\\n      return this->m_ptr < b.m_ptr;\\n    }\\n    bool operator>=(const const_iterator &b) const {\\n      return this->m_ptr > b.m_ptr;\\n    }\\n  };\\n\\n  const const_iterator cbegin() { return const_iterator(strt); }\\n  const const_iterator cend() { return const_iterator(last); }\\n  const const_iterator begin() { return const_iterator(strt); }\\n  const const_iterator end() { return const_iterator(last); }\\n};\\n\\nclass Solution {\\npublic:\\n  int firstBadVersion(int n) {\\n    auto rng = range(0, ((long long)n) + 1);\\n    auto it = std::lower_bound(rng.begin(), rng.end(), true, [](auto  x, bool y) {\\n      return isBadVersion(x) < y;\\n    });\\n    return it - rng.begin();\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\n\\nclass range {\\n  using ll = long long;\\n  ll strt;\\n  ll last;\\n\\npublic:\\n  range(ll l, ll r) : strt(l), last(r) {}\\n\\n  struct const_iterator {\\n    using iterator_category = std::random_access_iterator_tag;\\n    using difference_type = std::ptrdiff_t;\\n    using value_type = ll;\\n    using pointer = ll;\\n    using reference = const ll &;\\n\\n    pointer m_ptr;\\n\\n    const_iterator() =default;\\n    const_iterator(pointer ptr) : m_ptr(ptr) {}\\n    const_iterator(const const_iterator &iter) = default;\\n\\n    reference operator*() const { return m_ptr; }\\n\\n    const_iterator &operator++() {\\n      m_ptr++;\\n      return *this;\\n    }\\n    const_iterator operator++(int) {\\n      auto tmp = *this;\\n      ++(*this);\\n      return tmp;\\n    }\\n\\n    const_iterator &operator--() {\\n      m_ptr--;\\n      return *this;\\n    }\\n\\n    const_iterator operator--(int) {\\n      auto tmp = *this;\\n      --(*this);\\n      return tmp;\\n    }\\n    friend const_iterator operator+(const const_iterator &self,\\n                                    const difference_type &other) {\\n      return const_iterator(self.m_ptr + other);\\n    }\\n    const_iterator operator+=(const difference_type &other) {\\n      return *this = *this + other;\\n    }\\n    difference_type operator-(const const_iterator &other) {\\n      return this->m_ptr - other.m_ptr;\\n    }\\n    difference_type operator-=(const const_iterator &other) {\\n      return this->m_ptr - other.m_ptr;\\n    }\\n\\n    bool operator<(const const_iterator &b) const {\\n      return this->m_ptr < b.m_ptr;\\n    }\\n    bool operator>(const const_iterator &b) const {\\n      return this->m_ptr > b.m_ptr;\\n    }\\n    friend bool operator==(const const_iterator &a, const const_iterator &b) {\\n      return a.m_ptr == b.m_ptr;\\n    }\\n\\n    friend bool operator!=(const const_iterator &a, const const_iterator &b) {\\n      return a.m_ptr != b.m_ptr;\\n    }\\n    bool operator<=(const const_iterator &b) const {\\n      return this->m_ptr < b.m_ptr;\\n    }\\n    bool operator>=(const const_iterator &b) const {\\n      return this->m_ptr > b.m_ptr;\\n    }\\n  };\\n\\n  const const_iterator cbegin() { return const_iterator(strt); }\\n  const const_iterator cend() { return const_iterator(last); }\\n  const const_iterator begin() { return const_iterator(strt); }\\n  const const_iterator end() { return const_iterator(last); }\\n};\\n\\nclass Solution {\\npublic:\\n  int firstBadVersion(int n) {\\n    auto rng = range(0, ((long long)n) + 1);\\n    auto it = std::lower_bound(rng.begin(), rng.end(), true, [](auto  x, bool y) {\\n      return isBadVersion(x) < y;\\n    });\\n    return it - rng.begin();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462171,
                "title": "c-two-solutions-recursion-optimized-using-binary-search",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\n///////Recursion//////\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       if(n<1) return 1;\\n       if(!isBadVersion(n)) return n+1;\\n       return firstBadVersion(n-1);\\n    }\\n};\\n\\n\\n///////Binary Search//////\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       if(n<1) return 1;\\n       int ans=1,l=1,r=n;\\n       while(l<=r){\\n           int m=l+(r-l)/2;\\n           if(isBadVersion(m)){\\n             ans=m;\\n             r=m-1;\\n           }\\n           else l=m+1;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\n///////Recursion//////\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       if(n<1) return 1;\\n       if(!isBadVersion(n)) return n+1;\\n       return firstBadVersion(n-1);\\n    }\\n};\\n\\n\\n///////Binary Search//////\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       if(n<1) return 1;\\n       int ans=1,l=1,r=n;\\n       while(l<=r){\\n           int m=l+(r-l)/2;\\n           if(isBadVersion(m)){\\n             ans=m;\\n             r=m-1;\\n           }\\n           else l=m+1;\\n       }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 606617,
                "title": "kotlin",
                "content": "```\\nclass Solution: VersionControl() {\\n    override fun firstBadVersion(number: Int) : Int {\\n        var high: Int = number\\n        var low: Int = 0\\n        \\n        while (low < high) {\\n            val mid: Int = low + ((high - low) / 2)\\n            val isBad: Boolean = isBadVersion(mid)\\n            \\n            if (isBad) {\\n                high = mid\\n            } else {\\n                low = mid + 1\\n            }\\n        }\\n        \\n        return high\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution: VersionControl() {\\n    override fun firstBadVersion(number: Int) : Int {\\n        var high: Int = number\\n        var low: Int = 0\\n        \\n        while (low < high) {\\n            val mid: Int = low + ((high - low) / 2)\\n            val isBad: Boolean = isBadVersion(mid)\\n            \\n            if (isBad) {\\n                high = mid\\n            } else {\\n                low = mid + 1\\n            }\\n        }\\n        \\n        return high\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 340759,
                "title": "simple-binary-search-c-with-detailed-explanation",
                "content": "Since we need leftmost value, we can use another binary search that is setting high to mid and return low.\\n\\nThink about the case when mid is bad version, in that case the bad version started at some x <= mid, the required result will be in range [low, mid] so we set high to mid.\\n\\nThe terminating condition is low >= high, in that case low is first bad version since any elements below low are always good version.\\n\\n```csharp\\npublic int FirstBadVersion(int n) \\n{\\n\\tint low = 0;\\n\\tint high = n;\\n\\n\\twhile(low < high)\\n\\t{\\n\\t\\tint mid = low + (high - low)/2;\\n\\t\\tif(IsBadVersion(mid))\\n\\t\\t{\\n\\t\\t\\thigh = mid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn low;\\n}\\n```\\n\\nIt can be re-written in general binary search, note that we update low in else branch, as follows:\\n\\n``` csharp\\npublic int FirstBadVersion(int n) \\n{\\n\\tint low = 0;\\n\\tint high = n - 1;\\n\\tint mid;\\n\\n\\twhile(low <= high)\\n\\t{\\n\\t\\tmid = low + (high - low)/2;\\n\\n\\t\\tif(IsBadVersion(mid))\\n\\t\\t{\\n\\t\\t\\thigh = mid - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}           \\n\\t}\\n\\treturn low;\\n}\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```csharp\\npublic int FirstBadVersion(int n) \\n{\\n\\tint low = 0;\\n\\tint high = n;\\n\\n\\twhile(low < high)\\n\\t{\\n\\t\\tint mid = low + (high - low)/2;\\n\\t\\tif(IsBadVersion(mid))\\n\\t\\t{\\n\\t\\t\\thigh = mid;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn low;\\n}\\n```\n``` csharp\\npublic int FirstBadVersion(int n) \\n{\\n\\tint low = 0;\\n\\tint high = n - 1;\\n\\tint mid;\\n\\n\\twhile(low <= high)\\n\\t{\\n\\t\\tmid = low + (high - low)/2;\\n\\n\\t\\tif(IsBadVersion(mid))\\n\\t\\t{\\n\\t\\t\\thigh = mid - 1;\\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tlow = mid + 1;\\n\\t\\t}           \\n\\t}\\n\\treturn low;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 215805,
                "title": "python-solution",
                "content": "Time complexity: `O(log n)`, space complexity: `O(1)`.\\n\\n```\\nclass Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        j = n\\n        while i < j:\\n            mid = i + (j-i) // 2\\n            if isBadVersion(mid):\\n                j = mid\\n            else:\\n                i = mid+1\\n        return i\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        i = 1\\n        j = n\\n        while i < j:\\n            mid = i + (j-i) // 2\\n            if isBadVersion(mid):\\n                j = mid\\n            else:\\n                i = mid+1\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344962,
                "title": "java-code-beats-95-in-time-complexity",
                "content": "**Beats 95% in Time Complexity**\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n       int start = 1;\\n            while(start <= n){ \\n                int mid = start+(n-start)/2;\\n                if(isBadVersion(mid)){\\n                    n = mid-1;\\n                }\\n                else start = mid+1;\\n            }\\n            return start;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n       int start = 1;\\n            while(start <= n){ \\n                int mid = start+(n-start)/2;\\n                if(isBadVersion(mid)){\\n                    n = mid-1;\\n                }\\n                else start = mid+1;\\n            }\\n            return start;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3207455,
                "title": "first-bad-version-easy-solution-in-c",
                "content": "# Intuition\\n- Since we need to find the first bad product and all after that are same.\\n-  We can make use of binary search to shorten the no of products.\\n\\n# Approach\\n- Initialize s with 0 and e with end(n) and calculate mid using it\\n- Check if mid is a bad product, if its a bad product then check for mid-1 also\\n- If mid-1 is not a bad product then we can say that the previous products are good version and then return mid\\n- if mid-1 is bad product then follow the next conditions of binary search as given below\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 0;\\n        int e = n;\\n        int mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(isBadVersion(mid)==true){\\n               if(isBadVersion(mid-1)==false){\\n                    return mid;\\n               }\\n            }\\n            if(isBadVersion(mid)==false){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s)/2;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 0;\\n        int e = n;\\n        int mid = s + (e-s)/2;\\n        while(s<=e){\\n            if(isBadVersion(mid)==true){\\n               if(isBadVersion(mid-1)==false){\\n                    return mid;\\n               }\\n            }\\n            if(isBadVersion(mid)==false){\\n                s = mid+1;\\n            }\\n            else{\\n                e = mid - 1;\\n            }\\n            mid = s + (e-s)/2;\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3145817,
                "title": "easy-binary-search-c-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int n,int l,int r){\\n     \\n        if(r>=l){\\n            int mid=l+(r-l)/2;\\n            if(isBadVersion(mid-1)==false && isBadVersion(mid)==true){\\n                return mid;\\n            }\\n            if(isBadVersion(mid-1)==true && isBadVersion(mid)==true){\\n                return binarySearch(n,l,mid-1);\\n            }\\n            if(isBadVersion(mid)==false){\\n                return binarySearch(n,mid+1,r);\\n            }\\n\\n        }\\n        return -1;\\n    }\\n    int firstBadVersion(int n) {\\n       \\n       int l=1,r=n;\\n       return binarySearch(n,1,n);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int binarySearch(int n,int l,int r){\\n     \\n        if(r>=l){\\n            int mid=l+(r-l)/2;\\n            if(isBadVersion(mid-1)==false && isBadVersion(mid)==true){\\n                return mid;\\n            }\\n            if(isBadVersion(mid-1)==true && isBadVersion(mid)==true){\\n                return binarySearch(n,l,mid-1);\\n            }\\n            if(isBadVersion(mid)==false){\\n                return binarySearch(n,mid+1,r);\\n            }\\n\\n        }\\n        return -1;\\n    }\\n    int firstBadVersion(int n) {\\n       \\n       int l=1,r=n;\\n       return binarySearch(n,1,n);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3065272,
                "title": "first-bad-version-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: 58ms || beats: 91%\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 41.2Mb || beats: 96% \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let start = 0;\\n        let end = n;\\n        let mid = Math.floor((start + end)/2);\\n        while(start < end) {\\n            if(isBadVersion(mid) && !isBadVersion(mid - 1)) return mid;\\n            else if(!isBadVersion(mid) && isBadVersion(mid + 1)) return mid + 1;\\n            else if(!isBadVersion(mid)) start = mid;\\n            else end = mid;\\n            mid = Math.floor((start + end)/2);\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let start = 0;\\n        let end = n;\\n        let mid = Math.floor((start + end)/2);\\n        while(start < end) {\\n            if(isBadVersion(mid) && !isBadVersion(mid - 1)) return mid;\\n            else if(!isBadVersion(mid) && isBadVersion(mid + 1)) return mid + 1;\\n            else if(!isBadVersion(mid)) start = mid;\\n            else end = mid;\\n            mid = Math.floor((start + end)/2);\\n        }\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2984733,
                "title": "python3-while-loop-binary-search",
                "content": "https://leetcode.com/submissions/detail/869576931/\\nRuntime: 28 ms, faster than 93.52% of Python3 online submissions for First Bad Version.\\nMemory Usage: 13.8 MB, less than 62.32% of Python3 online submissions for First Bad Version.\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low, high = 1, n\\n        while low<high:\\n            mid = (low + high)//2\\n            if isBadVersion(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return low \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low, high = 1, n\\n        while low<high:\\n            mid = (low + high)//2\\n            if isBadVersion(mid):\\n                high = mid\\n            else:\\n                low = mid + 1\\n        return low \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802692,
                "title": "python-simple-solution-to-find-the-first-bad-version-in-o-log-n-using-binary-search",
                "content": "# Intuition\\nUse Binary seach to solve the problem\\n\\n# Approach\\nFind whether the mid version is BadVersion or not, using Binary search, reduce the n versions to halves until the source of bad version found.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        if n==1 and isBadVersion(n):\\n            return 1\\n        l = 1\\n        r = n\\n\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            if isBadVersion(mid):\\n                if isBadVersion(mid -1) == False:\\n                    return mid\\n                else:\\n                    r = mid-1\\n            else:\\n               l = mid + 1 \\n            \\n        return 0\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        if n==1 and isBadVersion(n):\\n            return 1\\n        l = 1\\n        r = n\\n\\n        while l <= r:\\n            mid = l + (r-l) // 2\\n            if isBadVersion(mid):\\n                if isBadVersion(mid -1) == False:\\n                    return mid\\n                else:\\n                    r = mid-1\\n            else:\\n               l = mid + 1 \\n            \\n        return 0\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2515933,
                "title": "python-simple-solution-faster-than-98-50",
                "content": "Simple python solution using binary search algorithm. Faster that 98.50% online solutions.\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\t```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2016733,
                "title": "javascript-o-logn-understandable-solution",
                "content": "```\\nvar solution = function(isBadVersion) {\\n  \\n    return function(n) {\\n        let left = 0;\\n        let right = n;\\n        let mid = 0;\\n        while(right-left > 1){\\n            mid = Math.floor((right + left)/2);\\n            if(isBadVersion(mid)){\\n                right = mid;\\n            }else left = mid;\\n        }\\n        return right\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar solution = function(isBadVersion) {\\n  \\n    return function(n) {\\n        let left = 0;\\n        let right = n;\\n        let mid = 0;\\n        while(right-left > 1){\\n            mid = Math.floor((right + left)/2);\\n            if(isBadVersion(mid)){\\n                right = mid;\\n            }else left = mid;\\n        }\\n        return right\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1631094,
                "title": "278-first-bad-version-java-a-clean-and-simple-solution-with-explanation",
                "content": "```java\\npublic int firstBadVersion(int n) {\\n    // The basic idea can be illustrated below:\\n\\t// n = 6, firstBadVersion = 5\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t// |     |        |\\n\\t// l     m        r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |  |\\n\\t//          l  m  r\\n\\t// isBadVersion(m) = true, move left\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |\\n\\t//          l  r\\n\\t//          m\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//             |\\n\\t//             r\\n\\t//             l\\n\\t//             m\\n\\t// return l\\n\\n\\t// Q: why do we need l = m + 1?\\n\\t// A: because l = m will end up to an infinite loop, for example:\\n\\t// n = 6, firstBadVersion = 5\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t// |     |        |\\n\\t// l     m        r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//       |  |     |\\n\\t//       l  m     r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |  |\\n\\t//          l  m  r\\n\\t// isBadVersion(m) = true, move left\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |\\n\\t//          l  r\\n\\t//          m\\n\\t// isBadVersion(m) = false, move right\\n\\t// at this point, if set l = m, then l will remain its current index and lead to an infinite loop.\\n\\n\\tif (isBadVersion(1)) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tint l = 1;\\n\\tint r = n;\\n\\n\\twhile (l < r) {\\n\\t\\tint m = l + (r - l) / 2;\\n\\t\\tif (isBadVersion(m)) {\\n\\t\\t\\t// move left\\n\\t\\t\\tr = m;\\n\\t\\t} else {\\n\\t\\t\\t// move right\\n\\t\\t\\tl = m + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn l;\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```java\\npublic int firstBadVersion(int n) {\\n    // The basic idea can be illustrated below:\\n\\t// n = 6, firstBadVersion = 5\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t// |     |        |\\n\\t// l     m        r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |  |\\n\\t//          l  m  r\\n\\t// isBadVersion(m) = true, move left\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |\\n\\t//          l  r\\n\\t//          m\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//             |\\n\\t//             r\\n\\t//             l\\n\\t//             m\\n\\t// return l\\n\\n\\t// Q: why do we need l = m + 1?\\n\\t// A: because l = m will end up to an infinite loop, for example:\\n\\t// n = 6, firstBadVersion = 5\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t// |     |        |\\n\\t// l     m        r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//       |  |     |\\n\\t//       l  m     r\\n\\t// isBadVersion(m) = false, move right\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |  |\\n\\t//          l  m  r\\n\\t// isBadVersion(m) = true, move left\\n\\n\\t// 1, 2, 3, 4, 5, 6\\n\\t//          |  |\\n\\t//          l  r\\n\\t//          m\\n\\t// isBadVersion(m) = false, move right\\n\\t// at this point, if set l = m, then l will remain its current index and lead to an infinite loop.\\n\\n\\tif (isBadVersion(1)) {\\n\\t\\treturn 1;\\n\\t}\\n\\n\\tint l = 1;\\n\\tint r = n;\\n\\n\\twhile (l < r) {\\n\\t\\tint m = l + (r - l) / 2;\\n\\t\\tif (isBadVersion(m)) {\\n\\t\\t\\t// move left\\n\\t\\t\\tr = m;\\n\\t\\t} else {\\n\\t\\t\\t// move right\\n\\t\\t\\tl = m + 1;\\n\\t\\t}\\n\\t}\\n\\n\\treturn l;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1615549,
                "title": "not-sure-what-this-is-asking-click-here-also-solution-for-js",
                "content": "This challenge confused me for the longest time in part beause I simply could not understand what the heck it was asking for.\\nWhen you run your code, there are two inputs. The first is the current version of the broken software (This is what is passed into your function as \\'n\\'.) The second number is the first broken version. i.e. The answer that you\\'re supposed to return. However, before you get too excited, it\\'s not accessible to you in the code. Wamp wamp.\\n\\nSo YOUR job is to start taking numbers between 1 and n (inclusive) and passing them into isBadVersion() one at a time. This will return a 1 or 0 (true/false) until you find the earliest broken version number. \\n\\nI found it helped to get a piece of paper and make a number line to work through it a couple times (Also to print the current left, mid, and right points in the loop so you could see what the heck was going on).\\n\\n```    \\n    return function(n) {\\n\\n        let left = 0\\n        let right = n\\n        let mid = n;\\n        while(left != (right-1)){\\n            mid = Math.floor((left + right)/2)\\n            if(isBadVersion(mid) == 0) {\\n                left = mid\\n            }\\n            else{\\n                right = mid\\n            }\\n        }\\n        return right\\n    };",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "This challenge confused me for the longest time in part beause I simply could not understand what the heck it was asking for.\\nWhen you run your code, there are two inputs. The first is the current version of the broken software (This is what is passed into your function as \\'n\\'.) The second number is the first broken version. i.e. The answer that you\\'re supposed to return. However, before you get too excited, it\\'s not accessible to you in the code. Wamp wamp.\\n\\nSo YOUR job is to start taking numbers between 1 and n (inclusive) and passing them into isBadVersion() one at a time. This will return a 1 or 0 (true/false) until you find the earliest broken version number. \\n\\nI found it helped to get a piece of paper and make a number line to work through it a couple times (Also to print the current left, mid, and right points in the loop so you could see what the heck was going on).\\n\\n```    \\n    return function(n) {\\n\\n        let left = 0\\n        let right = n\\n        let mid = n;\\n        while(left != (right-1)){\\n            mid = Math.floor((left + right)/2)\\n            if(isBadVersion(mid) == 0) {\\n                left = mid\\n            }\\n            else{\\n                right = mid\\n            }\\n        }\\n        return right\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 1514905,
                "title": "javascript-99-clean-binary-search",
                "content": "```\\nconst solution = isBadVersion => \\n  (n, l = 1, r = n) => {\\n    while (l <= r) {\\n      const mid = Math.floor((l + r) / 2);\\n      if (!isBadVersion(mid)) l = mid + 1;\\n      else r = mid - 1;\\n    }\\n    return l\\n  };\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst solution = isBadVersion => \\n  (n, l = 1, r = n) => {\\n    while (l <= r) {\\n      const mid = Math.floor((l + r) / 2);\\n      if (!isBadVersion(mid)) l = mid + 1;\\n      else r = mid - 1;\\n    }\\n    return l\\n  };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 913553,
                "title": "easy-solution",
                "content": "# if (FIND==USEFUL)\\n#  {\\n#  \\tcout<<UPVOTE;\\n#  }\\n#  else\\n#  {\\n#  \\tcout<<DOWNVOTE\\uD83D\\uDE22;\\n# }\\n\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        \\n        int l=1;\\n        int h=n;\\n        \\n        while(l<=h)\\n        {\\n            int m=l + (h-l)/2;\\n            if(isBadVersion(m)==true)\\n            {\\n                h=m-1;;\\n            }\\n            else\\n            {\\n                l=m+1;\\n            }\\n        }\\n        return l;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        \\n        int l=1;\\n        int h=n;\\n        \\n        while(l<=h)\\n        {\\n            int m=l + (h-l)/2;\\n            if(isBadVersion(m)==true)\\n            {\\n                h=m-1;;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 344266,
                "title": "python3-first-bad-version-binary-search",
                "content": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return a bool\\n# def isBadVersion(version):\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        l,r = 0, n\\n        while l <=r:\\n            m = (l+r)//2\\n\\t\\t\\t# we find the target:\\n            if isBadVersion(m-1) == False and isBadVersion(m)== True:\\n                return m\\n\\t\\t\\t# we didn\\'t find the target, we eleminate the half that the target cannot lie\\n            else:\\n                if isBadVersion(m) == False:\\n                    l = m +1\\n                else:\\n                    r = m -1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return a bool\\n# def isBadVersion(version):\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        l,r = 0, n\\n        while l <=r:\\n            m = (l+r)//2\\n\\t\\t\\t# we find the target:\\n            if isBadVersion(m-1) == False and isBadVersion(m)== True:\\n                return m\\n\\t\\t\\t# we didn\\'t find the target, we eleminate the half that the target cannot lie\\n            else:\\n                if isBadVersion(m) == False:\\n                    l = m +1\\n                else:\\n                    r = m -1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71298,
                "title": "python-easy-to-understand-solution",
                "content": "```\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        start, end = 1, n\\n        while start < end:\\n            mid = start + (end - start) / 2\\n            if isBadVersion(mid):\\n                # if mid is bad, any version newer than mid is bad.\\n                end = mid\\n            else:\\n                # if mid is good, any version older than mid + 1 is good \\n                start = mid + 1\\n        return start\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        start, end = 1, n\\n        while start < end:\\n            mid = start + (end - start) / 2\\n            if isBadVersion(mid):\\n                # if mid is bad, any version newer than mid is bad.\\n                end = mid\\n            else:\\n                # if mid is good, any version older than mid + 1 is good \\n                start = mid + 1\\n        return start\\n```",
                "codeTag": "Java"
            },
            {
                "id": 71430,
                "title": "c-o-logn-0-ms-solution",
                "content": "Basically the problem is a variant of **upper_bound()** / **lower_bound()** problem.\\n<BR>So we can follow the standard implementation to solve it.\\n\\n    int firstBadVersion(int n) {\\n        int lo = 1, hi = n, mid;\\n        while (lo < hi) {\\n            mid = lo + ((hi - lo) >> 1);\\n            isBadVersion(mid) ? (hi = mid) : (lo = mid + 1);\\n        }\\n        return hi;\\n    }",
                "solutionTags": [],
                "code": "Basically the problem is a variant of **upper_bound()** / **lower_bound()** problem.\\n<BR>So we can follow the standard implementation to solve it.\\n\\n    int firstBadVersion(int n) {\\n        int lo = 1, hi = n, mid;\\n        while (lo < hi) {\\n            mid = lo + ((hi - lo) >> 1);\\n            isBadVersion(mid) ? (hi = mid) : (lo = mid + 1);\\n        }\\n        return hi;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71426,
                "title": "java-binary-search-with-recursive-implement",
                "content": "/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n\\n    public int firstBadVersion(int n) {\\n        \\n        if(n==0) {\\n            return 0;\\n        }\\n    \\n       return helper(n,1,n);\\n    }\\n    \\n    \\n    public int helper(int n, int start, int end) {\\n        \\n        if(start>=end) {\\n            return start;\\n        }\\n        int middle = start+(end-start)/2;\\n        \\n        if(isBadVersion(middle)) {\\n            return helper(n,start,middle);\\n        } else {\\n            return helper(n,middle+1,end);\\n            \\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution extends VersionControl {\\n\\n    public int firstBadVersion(int n) {\\n        \\n        if(n==0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3864389,
                "title": "leetcode-first-bad-version-efficient-binary-search-solution-in-c",
                "content": "# Intuition\\nThe problem can be solved using binary search, an efficient algorithm to find an element in a sorted array. In this case, we have a range of versions from 1 to n, and we need to find the first bad version. The versions are sorted in ascending order, and we want to minimize the number of checks (API calls) to determine whether a version is bad or not.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nThe binary search algorithm has a time complexity of O(log n), which is very efficient compared to a linear search that would have O(n) time complexity.\\n\\n- Space complexity:\\nThe space complexity of this approach is O(1), as we only use a constant amount of extra space for the pointers low and high.\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        if(n==1)\\n        return n;\\n\\n        int low=1,high=n;\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(isBadVersion(mid))\\n            high=mid;\\n            else\\n            low=mid+1;\\n\\n        }\\n        return low;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        if(n==1)\\n        return n;\\n\\n        int low=1,high=n;\\n        while(low<high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(isBadVersion(mid))\\n            high=mid;\\n            else\\n            low=mid+1;\\n\\n        }\\n        return low;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446112,
                "title": "binary-search-beats-98-56-with-explanation-and-proof",
                "content": "# Approach\\n- We will initialize two pointers left and right to 0, n respectively. \\n\\n- We will perfrom binary Search in order to find first bad version. \\n\\n- First we will check that if `isBadVersion(mid)` is True or not. If its True then version before mid will also be bad so we will set right pointer to mid and will search in left half.\\n\\n- If `isBadVersion(mid)` is not True then we will set left pointer to `mid+1` and will search in right half. Search will continue till left < right and at the end we will return left `l`\\n\\n- This Solution has Time Complexity of `O(log n)` as we are using binary search and Space Complexity of `O(1)` as we are using constant memory space. \\n\\n# Code\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 0, n \\n        while l < r:\\n            mid = (l+r) // 2\\n            if isBadVersion(mid): r = mid\\n            else: l = mid+1\\n        return l\\n```\\n# Proof \\n\\n![Screenshot 2023-04-23 at 10.40.21 AM.png](https://assets.leetcode.com/users/images/930fe845-57cf-4f15-a9ef-27817fc8b354_1682226687.00638.png)\\n",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 0, n \\n        while l < r:\\n            mid = (l+r) // 2\\n            if isBadVersion(mid): r = mid\\n            else: l = mid+1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375529,
                "title": "100-runtime-66-25-memory-beats-with-explanation-using-binary-search",
                "content": "# Intuition\\nThis code implements a binary search algorithm to find the first \"bad\" version out of \"n\" versions given as an input. Here, \"bad\" implies a version that is to be avoided. \\n\\n# Approach\\nThe code starts with initializing the search space by keeping the left pointer as zero and the right pointer as n. Then, the code continuously partitions the search space into halves by calculating the midpoint and checks for bad versions. If a bad version is encountered, the code moves the right pointer to the midpoint and records this result as a candidate for the first bad version. On the other hand, if a good version is encountered, the code moves the left pointer to the midpoint+1 and records the maximum good version possible so far. The code repeats this process until the left and right pointers meet. Finally, the code checks if the maximum good version found so far is the second last version (good version) or the last version (bad version) and returns the corresponding result.\\n\\n\\n\\n# Complexity\\n- Time complexity O(log n):\\nThe time complexity of this algorithm is O(log n) as it uses binary search to find the first bad version, resulting in logarithmic time complexity.\\n\\n- Space complexity O(1):\\nThe space complexity of this algorithm is O(1) as it only uses constant space variables regardless of the size of input n.\\n\\n\\n\\n# Code\\n```\\n/**\\n * The knows API is defined in the parent class VersionControl.\\n *     func isBadVersion(_ version: Int) -> Bool{}\\n */\\n\\nclass Solution : VersionControl {\\n    func firstBadVersion(_ n: Int) -> Int {\\n       // Initialize left, right pointers and result variable.\\n        var left: Int = 0\\n        var right: Int = n\\n        var result: Int = 1\\n        // Initialize maxGoodVersion as 0.\\n        var maxGoodVersion = 0\\n        // While the left pointer is less than the right pointer.\\n        while left < right {\\n          // Find the midpoint of the current search space.\\n            var mid = (left + right)/2\\n            // Check if the current version is bad.\\n            if isBadVersion(mid){\\n                // If the current version is bad, move the right pointer to the midpoint, \\n                // record this value for future use and check if the previous version is the maximum good version.\\n                right = mid \\n                result = mid\\n                if result == maxGoodVersion + 1{\\n                    return result\\n                }\\n            }else{\\n                // If the current version is good, move the left pointer to the midpoint+1, \\n                // record the maximum good version so far, and repeat the process.\\n                maxGoodVersion = mid\\n                left = mid + 1\\n            }\\n        }\\n        // If the maximum good version found so far is the second last version, it is the answer.\\n        if maxGoodVersion == n - 1{\\n            return n\\n        }\\n        // Otherwise, return the candidate for the first bad version.\\n        return result\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search",
                    "Interactive"
                ],
                "code": "```\\n/**\\n * The knows API is defined in the parent class VersionControl.\\n *     func isBadVersion(_ version: Int) -> Bool{}\\n */\\n\\nclass Solution : VersionControl {\\n    func firstBadVersion(_ n: Int) -> Int {\\n       // Initialize left, right pointers and result variable.\\n        var left: Int = 0\\n        var right: Int = n\\n        var result: Int = 1\\n        // Initialize maxGoodVersion as 0.\\n        var maxGoodVersion = 0\\n        // While the left pointer is less than the right pointer.\\n        while left < right {\\n          // Find the midpoint of the current search space.\\n            var mid = (left + right)/2\\n            // Check if the current version is bad.\\n            if isBadVersion(mid){\\n                // If the current version is bad, move the right pointer to the midpoint, \\n                // record this value for future use and check if the previous version is the maximum good version.\\n                right = mid \\n                result = mid\\n                if result == maxGoodVersion + 1{\\n                    return result\\n                }\\n            }else{\\n                // If the current version is good, move the left pointer to the midpoint+1, \\n                // record the maximum good version so far, and repeat the process.\\n                maxGoodVersion = mid\\n                left = mid + 1\\n            }\\n        }\\n        // If the maximum good version found so far is the second last version, it is the answer.\\n        if maxGoodVersion == n - 1{\\n            return n\\n        }\\n        // Otherwise, return the candidate for the first bad version.\\n        return result\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051362,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Binary Search\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long l = 1, r = n;\\n        while(l <= r) {\\n            long long mid = (l + r) / 2;\\n            if(isBadVersion(mid)) r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long long l = 1, r = n;\\n        while(l <= r) {\\n            long long mid = (l + r) / 2;\\n            if(isBadVersion(mid)) r = mid - 1;\\n            else l = mid + 1;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2980298,
                "title": "cpp-python-binary-search-3ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- This problem is a version of binary search much like findind the first occurrence of element in sorted array containing duplicate elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Applying binary search, if a bad version is found we check if the number on the left ( mid-1 ) is also a bad version or not.\\n- If the number on the left is not a bad version then we can simply return the current number as it is the first bad version.\\n- If the number on the left is a bad version then we can set `r = mid-1` and continue with binary search.\\n- If current number is not a bad version then we can set `l = mid+1`.\\n\\n# Complexity\\n- Time complexity: **O(log n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\nCPP / C++\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n\\n        while( l<=r ) {\\n            int mid = l + (r-l)/2;\\n            if( isBadVersion(mid) ) {\\n                if( isBadVersion(mid) != isBadVersion(mid-1) ) return mid;\\n                else r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n---\\nPYTHON\\n```class Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l,r = 1, n\\n        while l<=r :\\n            mid = l + (r-l)//2\\n            if isBadVersion( mid ):\\n                if isBadVersion( mid )!=isBadVersion( mid-1 ) :\\n                    return mid\\n                else :\\n                    r = mid-1\\n            elif not isBadVersion( mid ):\\n                l = mid+1\\n        return 0\\n```",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n\\n        while( l<=r ) {\\n            int mid = l + (r-l)/2;\\n            if( isBadVersion(mid) ) {\\n                if( isBadVersion(mid) != isBadVersion(mid-1) ) return mid;\\n                else r = mid-1;\\n            }\\n            else l = mid+1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```class Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l,r = 1, n\\n        while l<=r :\\n            mid = l + (r-l)//2\\n            if isBadVersion( mid ):\\n                if isBadVersion( mid )!=isBadVersion( mid-1 ) :\\n                    return mid\\n                else :\\n                    r = mid-1\\n            elif not isBadVersion( mid ):\\n                l = mid+1\\n        return 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808776,
                "title": "binary-search-easy-java-code",
                "content": "# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start=1,end=n;\\n        \\n        while(start<end){\\n            int mid=start+ (end-start)/2;\\n            \\n            if(isBadVersion(mid)==true){\\n                end=mid;\\n                \\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start=1,end=n;\\n        \\n        while(start<end){\\n            int mid=start+ (end-start)/2;\\n            \\n            if(isBadVersion(mid)==true){\\n                end=mid;\\n                \\n            }else{\\n                start=mid+1;\\n            }\\n        }\\n        return start;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2666426,
                "title": "100-acceptance-optimal-approach-binary-search",
                "content": "![image](https://assets.leetcode.com/users/images/4c4ede0d-bda4-4bae-bde7-927ed2e07953_1665010789.3143034.png)\\n![image](https://assets.leetcode.com/users/images/62297faa-b6d3-42f4-b5ec-aea152030069_1665010808.5824919.gif)\\n\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        if(n == 1) if(isBadVersion(n)) return n;\\n        int i = 1, j = n;\\n        int ans;\\n        long int mid;\\n        while(i<=j){\\n            mid = i + (j-i)/2;\\n            if(isBadVersion(mid)){\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            if(isBadVersion(mid) == false) i = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        if(n == 1) if(isBadVersion(n)) return n;\\n        int i = 1, j = n;\\n        int ans;\\n        long int mid;\\n        while(i<=j){\\n            mid = i + (j-i)/2;\\n            if(isBadVersion(mid)){\\n                ans = mid;\\n                j = mid-1;\\n            }\\n            if(isBadVersion(mid) == false) i = mid+1;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2453936,
                "title": "c-0ms-most-efficient-solution",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n\\t\\t// Considering low as 1\\n\\t\\t// And high as n\\n        int low = 1;\\n        int high = n;\\n\\t\\t// Continuing in the loop until we found a answer\\n        while(true){\\n            int mid = low + (high - low)/2;\\n\\t\\t\\t// Checking the base conditin i.e, whether the first and the last values are bad or not\\n\\t\\t\\t// if so they are bad then it is understandable that we reached all the way through starting and ending\\n\\t\\t\\t// points so obviously they would be bad\\n            if((mid==n or mid==1) and isBadVersion(mid)==true) return mid;\\n\\t\\t\\t// checking for the current value is false and the next one is true, so the bad ones start from mid+1\\n            else if((isBadVersion(mid) == false) and (isBadVersion(mid+1) == true)) return mid+1;\\n\\t\\t\\t// checking if the mid value is false so as far we haven\\'t encountered any false value so we can start from \\n\\t\\t\\t// that position\\n            else if(isBadVersion(mid) == false) low = mid+1;\\n\\t\\t\\t// If we encountered true then the true value starts from some way before so we need to go back\\n            else high = mid-1;\\n        }\\n    }\\n};\\n\\n```\\n![image](https://assets.leetcode.com/users/images/64cdebab-4ac8-4998-ae98-62674d44841e_1661006300.890129.png)\\n\\n**upvote if you understood and if it helped you**\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n\\t\\t// Considering low as 1\\n\\t\\t// And high as n\\n        int low = 1;\\n        int high = n;\\n\\t\\t// Continuing in the loop until we found a answer\\n        while(true){\\n            int mid = low + (high - low)/2;\\n\\t\\t\\t// Checking the base conditin i.e, whether the first and the last values are bad or not\\n\\t\\t\\t// if so they are bad then it is understandable that we reached all the way through starting and ending\\n\\t\\t\\t// points so obviously they would be bad\\n            if((mid==n or mid==1) and isBadVersion(mid)==true) return mid;\\n\\t\\t\\t// checking for the current value is false and the next one is true, so the bad ones start from mid+1\\n            else if((isBadVersion(mid) == false) and (isBadVersion(mid+1) == true)) return mid+1;\\n\\t\\t\\t// checking if the mid value is false so as far we haven\\'t encountered any false value so we can start from \\n\\t\\t\\t// that position\\n            else if(isBadVersion(mid) == false) low = mid+1;\\n\\t\\t\\t// If we encountered true then the true value starts from some way before so we need to go back\\n            else high = mid-1;\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2428905,
                "title": "c-python-java-best-optimized-approach-using-binary-search",
                "content": "#### C++\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for First Bad Version.\\nMemory Usage: 6 MB, less than 22.67% of C++ online submissions for First Bad Version.\\n\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s<e) {\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                e = mid;\\n            }\\n            else {\\n                s = mid + 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\nTime Complexity - O(logN)\\nSpace Complexity - O(1)\\n#### Java\\nRuntime: 20 ms, faster than 65.20% of Java online submissions for First Bad Version.\\nMemory Usage: 41.2 MB, less than 26.56% of Java online submissions for First Bad Version.\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s<e) {\\n            int mid = s+(e-s)/2;\\n            if(isBadVersion(mid)) {\\n                e = mid;\\n            }\\n            \\n            else {\\n                s = mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\\nTime Complexity - O(logN)\\nSpace Complexity - O(1)\\n\\n#### Python\\nRuntime: 56 ms, faster than 23.61% of Python3 online submissions for First Bad Version.\\nMemory Usage: 13.9 MB, less than 61.83% of Python3 online submissions for First Bad Version.\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        s = 1\\n        e = n\\n        while(s<e):\\n            mid = s+(e-s)//2\\n            if(isBadVersion(mid)):\\n                e = mid\\n                \\n            else:\\n                s = mid+1\\n        return s\\n```\\nTime Complexity - O(logN)\\nSpace Complexity - O(1)\\n\\n##### I hope that you\\'ve found this useful. If you like the solution and find it understandable, then do upvote it & Share it with others.\\n##### It only motivates me to write more such posts, If you found any error, any suggestions then do comment for any query\\n##### Thanks alot ! Cheers to your coding",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "Binary Search"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s<e) {\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                e = mid;\\n            }\\n            else {\\n                s = mid + 1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int s = 1;\\n        int e = n;\\n        while(s<e) {\\n            int mid = s+(e-s)/2;\\n            if(isBadVersion(mid)) {\\n                e = mid;\\n            }\\n            \\n            else {\\n                s = mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        s = 1\\n        e = n\\n        while(s<e):\\n            mid = s+(e-s)//2\\n            if(isBadVersion(mid)):\\n                e = mid\\n                \\n            else:\\n                s = mid+1\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2414671,
                "title": "c-solution",
                "content": "```\\npublic class Solution : VersionControl {\\n    public int FirstBadVersion(int n) {\\n            int bad = 0;\\n            int low = 1;\\n            int high = n;\\n            while (low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                if (IsBadVersion(mid))\\n                {\\n                    bad = mid;\\n                    high = mid - 1;\\n                }\\n                else\\n                    low = mid + 1;\\n            }\\n            return bad;\\n    }\\n}",
                "solutionTags": [
                    "C#",
                    "Binary Tree"
                ],
                "code": "class Solution : VersionControl {\\n    public int FirstBadVersion(int n) {\\n            int bad = 0;\\n            int low = 1;\\n            int high = n;\\n            while (low <= high)\\n            {\\n                int mid = low + (high - low) / 2;\\n                if (IsBadVersion(mid))\\n                {\\n                    bad = mid;\\n                    high = mid - 1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2397117,
                "title": "31-ms-faster-than-92-46-of-python3",
                "content": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        beg = 1\\n        end = n\\n        while beg <= end:\\n            mid = (beg+end)//2\\n            if isBadVersion(mid) == True:\\n                end = mid-1\\n            else:\\n                beg = mid+1\\n        return beg\\n        \\n```\\n\\nupvote if you find this helps :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        beg = 1\\n        end = n\\n        while beg <= end:\\n            mid = (beg+end)//2\\n            if isBadVersion(mid) == True:\\n                end = mid-1\\n            else:\\n                beg = mid+1\\n        return beg\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330703,
                "title": "now-now-onwards-i-will-never-use-beg-end-2-again",
                "content": "using (beg + end)/2 instead of mid= beg+(end-beg)/2  can lead to overflows(beg + end > 2147483647) as was the case this time, or change all the int variable to the long variables \\n\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        \\n        \\n        int beg= 1, end= n, mid, ans=-1;\\n        \\n        while( beg<= end){\\n            mid= (beg+(end-beg)/2);\\n            \\n            if( isBadVersion(mid)==true){\\n                end= mid-1;\\n                ans= mid;\\n            }\\n            else{\\n                beg=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        \\n        \\n        int beg= 1, end= n, mid, ans=-1;\\n        \\n        while( beg<= end){\\n            mid= (beg+(end-beg)/2);\\n            \\n            if( isBadVersion(mid)==true){\\n                end= mid-1;\\n                ans= mid;\\n            }\\n            else{\\n                beg=mid+1;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319817,
                "title": "c-solution",
                "content": "```\\npublic class Solution : VersionControl {\\n    public int FirstBadVersion(int n) {\\n        int i = 1,\\n            j = n;\\n        \\n        while (i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            \\n            if (IsBadVersion(mid))\\n            {\\n                j = mid - 1;\\n            }\\n            else\\n            {\\n                i = mid + 1;\\n            }\\n        }\\n        \\n        return j + 1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution : VersionControl {\\n    public int FirstBadVersion(int n) {\\n        int i = 1,\\n            j = n;\\n        \\n        while (i <= j)\\n        {\\n            int mid = i + (j - i) / 2;\\n            \\n            if (IsBadVersion(mid))\\n            {\\n                j = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2021988,
                "title": "javascript-binary-search-solution-with-short-comment-99-21-faster",
                "content": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let start = 1;\\n        let end = n;\\n        let mid = 0;\\n        \\n        while(start <= end) {\\n            mid = Math.floor((start + end) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                if(isBadVersion(mid - 1)) end = mid - 1;  // if mid bad is not *first* bad version, set end point to mid - 1\\n                else return mid;  // if mid is first bad version\\n            }\\n            else start = mid + 1; // if mid is not bad version, set start point to mid + 1\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let start = 1;\\n        let end = n;\\n        let mid = 0;\\n        \\n        while(start <= end) {\\n            mid = Math.floor((start + end) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                if(isBadVersion(mid - 1)) end = mid - 1;  // if mid bad is not *first* bad version, set end point to mid - 1\\n                else return mid;  // if mid is first bad version\\n            }\\n            else start = mid + 1; // if mid is not bad version, set start point to mid + 1\\n        }\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1928828,
                "title": "php-simple-and-fast-solution-without-built-in-functions",
                "content": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      public function isBadVersion($version){} */\\n\\nclass Solution extends VersionControl {\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function firstBadVersion($n) {\\n        $left = 1;\\n        $right = $n;\\n        $current = false;\\n        while($left != $right){\\n            $current = (int)(($left + $right) / 2);\\n      if ($this->isBadVersion($current)) {\\n                $right = $current;\\n            } else {\\n                $left = $current + 1;\\n            }\\n        }\\n        return $right;\\n      \\n    }\\n}\\n```\\nPlease upvote if you like the solution and feel free to ask for more information if you need-",
                "solutionTags": [
                    "PHP"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      public function isBadVersion($version){} */\\n\\nclass Solution extends VersionControl {\\n    /**\\n     * @param Integer $n\\n     * @return Integer\\n     */\\n    function firstBadVersion($n) {\\n        $left = 1;\\n        $right = $n;\\n        $current = false;\\n        while($left != $right){\\n            $current = (int)(($left + $right) / 2);\\n      if ($this->isBadVersion($current)) {\\n                $right = $current;\\n            } else {\\n                $left = $current + 1;\\n            }\\n        }\\n        return $right;\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1869908,
                "title": "java-easy-and-intuitive-solution-with-explanation-binary-search",
                "content": "**Code**\\n```java\\npublic int firstBadVersion(int n) {\\n\\tint s = 1, e = n;\\n\\tint firstBad = Integer.MAX_VALUE;\\n\\twhile(s <= e) {\\n\\t\\tint mid = s + (e-s)/2;\\n\\t\\tif(!isBadVersion(mid)) {\\n\\t\\t\\ts = mid+1;\\n\\t\\t} else {\\n\\t\\t\\tfirstBad = Math.min(firstBad, mid);\\n\\t\\t\\te = mid-1;\\n\\t\\t}\\n\\t}\\n\\treturn firstBad;\\n}\\n```\\n\\n**Explanation**\\n1. The logic is to simply use binary search inorder to make as less calls to avaiable API as possible, another important constraint given to us is that the nums are in ascending order.\\n2. Two conditions occur:-\\n\\t1. If `mid` is not a bad version than that means no number lesser than mid will be bad, so move start index to mid+1.\\n\\t2. else if mid is bad version than move backward to find first bad version.\\n\\n![image](https://assets.leetcode.com/users/images/78e5328a-703c-46c7-a700-03dd301bfe81_1647858429.4432962.png)\\n\\nHope it helps\\nThanks\\nDo upvote",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```java\\npublic int firstBadVersion(int n) {\\n\\tint s = 1, e = n;\\n\\tint firstBad = Integer.MAX_VALUE;\\n\\twhile(s <= e) {\\n\\t\\tint mid = s + (e-s)/2;\\n\\t\\tif(!isBadVersion(mid)) {\\n\\t\\t\\ts = mid+1;\\n\\t\\t} else {\\n\\t\\t\\tfirstBad = Math.min(firstBad, mid);\\n\\t\\t\\te = mid-1;\\n\\t\\t}\\n\\t}\\n\\treturn firstBad;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1778578,
                "title": "go-benchmarking-and-profiling-different-versions",
                "content": "I was curious to see how small changes moved the constant factors. I benchmarked 4 similar variations of my own solution and one other Go solution chosen at random from the discussions:\\n\\n```\\nRunning tool: /home/jchase/sdk/go1.17.6/bin/go test -benchmem -run=^$ -coverprofile=/tmp/vscode-golEPwFj/go-code-cover -bench . badversion\\n\\ngoos: linux\\ngoarch: amd64\\npkg: badversion\\ncpu: AMD Ryzen 5 PRO 3500U w/ Radeon Vega Mobile Gfx\\nBenchmarkV1-8               \\t83998635\\t        14.15 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV2-8               \\t111287302\\t         9.916 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV3-8               \\t119297382\\t        10.10 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV4-8               \\t113270150\\t        11.38 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkDiscuss1756768-8   \\t78179970\\t        14.65 ns/op\\t       0 B/op\\t       0 allocs/op\\nPASS\\ncoverage: 100.0% of statements\\nok  \\tbadversion\\t9.007s\\n```\\n\\n```go\\npackage main\\n\\nfunc isBadVersion(version int) bool {\\n\\treturn version >= 50\\n}\\n\\nfunc firstBadVersion(n int) int {\\n\\tstart := 0\\n\\tend := n\\n\\n\\tfor mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tend = mid\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn start\\n}\\n\\nfunc firstBadVersionV2(n int) int {\\n\\tmaybeBad := 1\\n\\n\\tfor mid := (n + maybeBad) / 2; maybeBad < n; mid = (n + maybeBad) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tn = mid\\n\\t\\t} else {\\n\\t\\t\\tmaybeBad = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc firstBadVersionV3(n int) int {\\n\\tmaybeBad := 1\\n\\n\\tfor maybeBad < n {\\n\\t\\tif isBadVersion((n + maybeBad) / 2) {\\n\\t\\t\\tn = (n + maybeBad) / 2\\n\\t\\t} else {\\n\\t\\t\\tmaybeBad = (n+maybeBad)/2 + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc firstBadVersionV4(n int) int {\\n\\tstart := 1\\n\\tend := n\\n\\n\\tfor mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tend = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn start\\n}\\n\\nfunc firstBadVersionDiscuss1756768(n int) int {\\n\\tleft, right := 1, n\\n\\tvar mid int\\n\\n\\tfor right >= left {\\n\\t\\tmid = left + (right-left)/2\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn left\\n}\\n```\\n\\n```\\njchase@laptop:~/Dropbox/src/go/leetcode/278-first-bad-version_easy$ go test -bench=. -benchmem -memprofile memprofile.out -cpuprofile profile.out\\ngoos: linux\\ngoarch: amd64\\npkg: badversion\\ncpu: AMD Ryzen 5 PRO 3500U w/ Radeon Vega Mobile Gfx\\nBenchmarkV1-8                   149749778                8.078 ns/op           0 B/op          0 allocs/op\\nBenchmarkV2-8                   131324102                8.963 ns/op           0 B/op          0 allocs/op\\nBenchmarkV3-8                   151681826                8.575 ns/op           0 B/op          0 allocs/op\\nBenchmarkV4-8                   112265661               10.74 ns/op            0 B/op          0 allocs/op\\nBenchmarkDiscuss1756768-8       93514813                12.76 ns/op            0 B/op          0 allocs/op\\nPASS\\nok      badversion      9.431s\\njchase@laptop:~/Dropbox/src/go/leetcode/278-first-bad-version_easy$ go tool pprof profile.out\\nFile: badversion.test\\nType: cpu\\nTime: Feb 17, 2022 at 10:42am (EST)\\nDuration: 9.42s, Total samples = 9.33s (99.01%)\\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\\n(pprof) list firstBadVersion\\nTotal: 9.33s\\nROUTINE ======================== badversion.firstBadVersion in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.75s      1.75s (flat, cum) 18.76% of Total\\n         .          .      6:\\n         .          .      7:func firstBadVersion(n int) int {\\n         .          .      8:   start := 0\\n         .          .      9:   end := n\\n         .          .     10:\\n     1.37s      1.37s     11:   for mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n     380ms      380ms     12:           if isBadVersion(mid) {\\n         .          .     13:                   end = mid\\n         .          .     14:           } else {\\n         .          .     15:                   start = mid + 1\\n         .          .     16:           }\\n         .          .     17:   }\\nROUTINE ======================== badversion.firstBadVersionDiscuss1756768 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.71s      2.06s (flat, cum) 22.08% of Total\\n         .          .     64:\\n         .          .     65:func firstBadVersionDiscuss1756768(n int) int {\\n         .          .     66:   left, right := 1, n\\n         .          .     67:   var mid int\\n         .          .     68:\\n     360ms      360ms     69:   for right >= left {\\n     760ms      760ms     70:           mid = left + (right-left)/2\\n     490ms      840ms     71:           if isBadVersion(mid) {\\n     100ms      100ms     72:                   right = mid - 1\\n         .          .     73:           } else {\\n         .          .     74:                   left = mid + 1\\n         .          .     75:           }\\n         .          .     76:   }\\n         .          .     77:   return left\\nROUTINE ======================== badversion.firstBadVersionV2 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.76s      1.76s (flat, cum) 18.86% of Total\\n         .          .     20:}\\n         .          .     21:\\n         .          .     22:func firstBadVersionV2(n int) int {\\n         .          .     23:   maybeBad := 1\\n         .          .     24:\\n     1.17s      1.17s     25:   for mid := (n + maybeBad) / 2; maybeBad < n; mid = (n + maybeBad) / 2 {\\n     550ms      550ms     26:           if isBadVersion(mid) {\\n         .          .     27:                   n = mid\\n         .          .     28:           } else {\\n      40ms       40ms     29:                   maybeBad = mid + 1\\n         .          .     30:           }\\n         .          .     31:   }\\n         .          .     32:\\n         .          .     33:   return n\\n         .          .     34:}\\nROUTINE ======================== badversion.firstBadVersionV3 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.75s      1.83s (flat, cum) 19.61% of Total\\n         .          .     34:}\\n         .          .     35:\\n         .          .     36:func firstBadVersionV3(n int) int {\\n         .          .     37:   maybeBad := 1\\n         .          .     38:\\n     330ms      330ms     39:   for maybeBad < n {\\n     1.42s      1.50s     40:           if isBadVersion((n + maybeBad) / 2) {\\n         .          .     41:                   n = (n + maybeBad) / 2\\n         .          .     42:           } else {\\n         .          .     43:                   maybeBad = (n+maybeBad)/2 + 1\\n         .          .     44:           }\\n         .          .     45:   }\\nROUTINE ======================== badversion.firstBadVersionV4 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.83s      1.83s (flat, cum) 19.61% of Total\\n         .          .     49:\\n         .          .     50:func firstBadVersionV4(n int) int {\\n         .          .     51:   start := 1\\n         .          .     52:   end := n\\n         .          .     53:\\n     1.28s      1.28s     54:   for mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n     460ms      460ms     55:           if isBadVersion(mid) {\\n      80ms       80ms     56:                   end = mid - 1\\n         .          .     57:           } else {\\n      10ms       10ms     58:                   start = mid + 1\\n         .          .     59:           }\\n         .          .     60:   }\\n         .          .     61:\\n         .          .     62:   return start\\n         .          .     63:}\\n(pprof)\\n```\\n\\n```go\\npackage main\\n\\nimport \"testing\"\\n\\nvar Result int\\n\\nfunc BenchmarkV1(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersion(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV2(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV2(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV3(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV3(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV4(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV4(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkDiscuss1756768(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionDiscuss1756768(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc Test_firstBadVersion(t *testing.T) {\\n\\ttype args struct {\\n\\t\\tn int\\n\\t}\\n\\ttests := []struct {\\n\\t\\tname string\\n\\t\\targs args\\n\\t\\twant int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname: \"example 1\",\\n\\t\\t\\twant: 50,\\n\\t\\t\\targs: args{\\n\\t\\t\\t\\tn: 100,\\n\\t\\t\\t},\\n\\t\\t},\\n\\t}\\n\\tfor _, tt := range tests {\\n\\t\\tt.Run(tt.name, func(t *testing.T) {\\n\\t\\t\\tif got := firstBadVersion(tt.args.n); got != tt.want {\\n\\t\\t\\t\\tt.Errorf(\"firstBadVersion() = %v, want %v\", got, tt.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nRunning tool: /home/jchase/sdk/go1.17.6/bin/go test -benchmem -run=^$ -coverprofile=/tmp/vscode-golEPwFj/go-code-cover -bench . badversion\\n\\ngoos: linux\\ngoarch: amd64\\npkg: badversion\\ncpu: AMD Ryzen 5 PRO 3500U w/ Radeon Vega Mobile Gfx\\nBenchmarkV1-8               \\t83998635\\t        14.15 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV2-8               \\t111287302\\t         9.916 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV3-8               \\t119297382\\t        10.10 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkV4-8               \\t113270150\\t        11.38 ns/op\\t       0 B/op\\t       0 allocs/op\\nBenchmarkDiscuss1756768-8   \\t78179970\\t        14.65 ns/op\\t       0 B/op\\t       0 allocs/op\\nPASS\\ncoverage: 100.0% of statements\\nok  \\tbadversion\\t9.007s\\n```\n```go\\npackage main\\n\\nfunc isBadVersion(version int) bool {\\n\\treturn version >= 50\\n}\\n\\nfunc firstBadVersion(n int) int {\\n\\tstart := 0\\n\\tend := n\\n\\n\\tfor mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tend = mid\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn start\\n}\\n\\nfunc firstBadVersionV2(n int) int {\\n\\tmaybeBad := 1\\n\\n\\tfor mid := (n + maybeBad) / 2; maybeBad < n; mid = (n + maybeBad) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tn = mid\\n\\t\\t} else {\\n\\t\\t\\tmaybeBad = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc firstBadVersionV3(n int) int {\\n\\tmaybeBad := 1\\n\\n\\tfor maybeBad < n {\\n\\t\\tif isBadVersion((n + maybeBad) / 2) {\\n\\t\\t\\tn = (n + maybeBad) / 2\\n\\t\\t} else {\\n\\t\\t\\tmaybeBad = (n+maybeBad)/2 + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn n\\n}\\n\\nfunc firstBadVersionV4(n int) int {\\n\\tstart := 1\\n\\tend := n\\n\\n\\tfor mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tend = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn start\\n}\\n\\nfunc firstBadVersionDiscuss1756768(n int) int {\\n\\tleft, right := 1, n\\n\\tvar mid int\\n\\n\\tfor right >= left {\\n\\t\\tmid = left + (right-left)/2\\n\\t\\tif isBadVersion(mid) {\\n\\t\\t\\tright = mid - 1\\n\\t\\t} else {\\n\\t\\t\\tleft = mid + 1\\n\\t\\t}\\n\\t}\\n\\treturn left\\n}\\n```\n```\\njchase@laptop:~/Dropbox/src/go/leetcode/278-first-bad-version_easy$ go test -bench=. -benchmem -memprofile memprofile.out -cpuprofile profile.out\\ngoos: linux\\ngoarch: amd64\\npkg: badversion\\ncpu: AMD Ryzen 5 PRO 3500U w/ Radeon Vega Mobile Gfx\\nBenchmarkV1-8                   149749778                8.078 ns/op           0 B/op          0 allocs/op\\nBenchmarkV2-8                   131324102                8.963 ns/op           0 B/op          0 allocs/op\\nBenchmarkV3-8                   151681826                8.575 ns/op           0 B/op          0 allocs/op\\nBenchmarkV4-8                   112265661               10.74 ns/op            0 B/op          0 allocs/op\\nBenchmarkDiscuss1756768-8       93514813                12.76 ns/op            0 B/op          0 allocs/op\\nPASS\\nok      badversion      9.431s\\njchase@laptop:~/Dropbox/src/go/leetcode/278-first-bad-version_easy$ go tool pprof profile.out\\nFile: badversion.test\\nType: cpu\\nTime: Feb 17, 2022 at 10:42am (EST)\\nDuration: 9.42s, Total samples = 9.33s (99.01%)\\nEntering interactive mode (type \"help\" for commands, \"o\" for options)\\n(pprof) list firstBadVersion\\nTotal: 9.33s\\nROUTINE ======================== badversion.firstBadVersion in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.75s      1.75s (flat, cum) 18.76% of Total\\n         .          .      6:\\n         .          .      7:func firstBadVersion(n int) int {\\n         .          .      8:   start := 0\\n         .          .      9:   end := n\\n         .          .     10:\\n     1.37s      1.37s     11:   for mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n     380ms      380ms     12:           if isBadVersion(mid) {\\n         .          .     13:                   end = mid\\n         .          .     14:           } else {\\n         .          .     15:                   start = mid + 1\\n         .          .     16:           }\\n         .          .     17:   }\\nROUTINE ======================== badversion.firstBadVersionDiscuss1756768 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.71s      2.06s (flat, cum) 22.08% of Total\\n         .          .     64:\\n         .          .     65:func firstBadVersionDiscuss1756768(n int) int {\\n         .          .     66:   left, right := 1, n\\n         .          .     67:   var mid int\\n         .          .     68:\\n     360ms      360ms     69:   for right >= left {\\n     760ms      760ms     70:           mid = left + (right-left)/2\\n     490ms      840ms     71:           if isBadVersion(mid) {\\n     100ms      100ms     72:                   right = mid - 1\\n         .          .     73:           } else {\\n         .          .     74:                   left = mid + 1\\n         .          .     75:           }\\n         .          .     76:   }\\n         .          .     77:   return left\\nROUTINE ======================== badversion.firstBadVersionV2 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.76s      1.76s (flat, cum) 18.86% of Total\\n         .          .     20:}\\n         .          .     21:\\n         .          .     22:func firstBadVersionV2(n int) int {\\n         .          .     23:   maybeBad := 1\\n         .          .     24:\\n     1.17s      1.17s     25:   for mid := (n + maybeBad) / 2; maybeBad < n; mid = (n + maybeBad) / 2 {\\n     550ms      550ms     26:           if isBadVersion(mid) {\\n         .          .     27:                   n = mid\\n         .          .     28:           } else {\\n      40ms       40ms     29:                   maybeBad = mid + 1\\n         .          .     30:           }\\n         .          .     31:   }\\n         .          .     32:\\n         .          .     33:   return n\\n         .          .     34:}\\nROUTINE ======================== badversion.firstBadVersionV3 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.75s      1.83s (flat, cum) 19.61% of Total\\n         .          .     34:}\\n         .          .     35:\\n         .          .     36:func firstBadVersionV3(n int) int {\\n         .          .     37:   maybeBad := 1\\n         .          .     38:\\n     330ms      330ms     39:   for maybeBad < n {\\n     1.42s      1.50s     40:           if isBadVersion((n + maybeBad) / 2) {\\n         .          .     41:                   n = (n + maybeBad) / 2\\n         .          .     42:           } else {\\n         .          .     43:                   maybeBad = (n+maybeBad)/2 + 1\\n         .          .     44:           }\\n         .          .     45:   }\\nROUTINE ======================== badversion.firstBadVersionV4 in /home/jchase/Dropbox/src/go/leetcode/278-first-bad-version_easy/main.go\\n     1.83s      1.83s (flat, cum) 19.61% of Total\\n         .          .     49:\\n         .          .     50:func firstBadVersionV4(n int) int {\\n         .          .     51:   start := 1\\n         .          .     52:   end := n\\n         .          .     53:\\n     1.28s      1.28s     54:   for mid := (end + start) / 2; start < end; mid = (end + start) / 2 {\\n     460ms      460ms     55:           if isBadVersion(mid) {\\n      80ms       80ms     56:                   end = mid - 1\\n         .          .     57:           } else {\\n      10ms       10ms     58:                   start = mid + 1\\n         .          .     59:           }\\n         .          .     60:   }\\n         .          .     61:\\n         .          .     62:   return start\\n         .          .     63:}\\n(pprof)\\n```\n```go\\npackage main\\n\\nimport \"testing\"\\n\\nvar Result int\\n\\nfunc BenchmarkV1(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersion(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV2(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV2(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV3(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV3(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkV4(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionV4(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc BenchmarkDiscuss1756768(b *testing.B) {\\n\\tvar r int\\n\\tfor i := 0; i < b.N; i++ {\\n\\t\\tr = firstBadVersionDiscuss1756768(1000)\\n\\t}\\n\\n\\tResult = r\\n}\\n\\nfunc Test_firstBadVersion(t *testing.T) {\\n\\ttype args struct {\\n\\t\\tn int\\n\\t}\\n\\ttests := []struct {\\n\\t\\tname string\\n\\t\\targs args\\n\\t\\twant int\\n\\t}{\\n\\t\\t{\\n\\t\\t\\tname: \"example 1\",\\n\\t\\t\\twant: 50,\\n\\t\\t\\targs: args{\\n\\t\\t\\t\\tn: 100,\\n\\t\\t\\t},\\n\\t\\t},\\n\\t}\\n\\tfor _, tt := range tests {\\n\\t\\tt.Run(tt.name, func(t *testing.T) {\\n\\t\\t\\tif got := firstBadVersion(tt.args.n); got != tt.want {\\n\\t\\t\\t\\tt.Errorf(\"firstBadVersion() = %v, want %v\", got, tt.want)\\n\\t\\t\\t}\\n\\t\\t})\\n\\t}\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1553233,
                "title": "ruby-94-faster-clean-and-simple",
                "content": "```\\ndef first_bad_version(n)\\n    left, right = 1, n\\n    \\n    until left == right do \\n      middle = left + ((right - left)/2) \\n      is_bad_version(middle) ? right = middle : left = middle + 1\\n    end\\n\\t\\n    left\\nend\\n```\\n\\nI know a lot of people dislike Ruby\\'s `until` and `unless` but I find them both to be very helpful and readable. In this case, using `until` the left and right pointers are the same was more readable and explicit to me than `while` the left pointer is less than the right pointer.",
                "solutionTags": [
                    "Ruby",
                    "Binary Tree"
                ],
                "code": "```\\ndef first_bad_version(n)\\n    left, right = 1, n\\n    \\n    until left == right do \\n      middle = left + ((right - left)/2) \\n      is_bad_version(middle) ? right = middle : left = middle + 1\\n    end\\n\\t\\n    left\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1550763,
                "title": "simple-java-solution-better-than-your-code",
                "content": "public class Solution extends VersionControl {\\n\\n\\n    public int firstBadVersion(int n) {\\n        int lo=1;\\n        int hi=n;\\n        int mid=lo+(hi-lo)/2;\\n        while(lo<hi){\\n            if(isBadVersion(mid)==true){\\n                if(mid!=0 && isBadVersion(mid-1)==false){\\n                    return mid;\\n                }\\n                hi=mid-1;\\n            }\\n            else if(isBadVersion(mid)==false){\\n                \\n               lo=mid+1; \\n            }\\n            \\n             mid=lo+(hi-lo)/2;\\n        }\\n        return mid;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution extends VersionControl {\\n\\n\\n    public int firstBadVersion(int n) {\\n        int lo=1;\\n        int hi=n;\\n        int mid=lo+(hi-lo)/2;\\n        while(lo<hi){\\n            if(isBadVersion(mid)==true){\\n                if(mid!=0 && isBadVersion(mid-1)==false){\\n                    return mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1539053,
                "title": "javascript-o-logn-simple-solution",
                "content": "```    \\nreturn function(n) {\\n\\tlet l = 1,\\n\\t\\tr = n,\\n\\t\\tm;\\n\\n\\twhile (l < r) {\\n\\t\\tm = ~~((l+r)/2);\\n\\t\\tif (isBadVersion(m)) r = m;\\n\\t\\telse l = m + 1;\\n\\t}\\n\\n\\treturn l;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```    \\nreturn function(n) {\\n\\tlet l = 1,\\n\\t\\tr = n,\\n\\t\\tm;\\n\\n\\twhile (l < r) {\\n\\t\\tm = ~~((l+r)/2);\\n\\t\\tif (isBadVersion(m)) r = m;\\n\\t\\telse l = m + 1;\\n\\t}\\n\\n\\treturn l;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1419848,
                "title": "easy-java-solution-using-binary-search",
                "content": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1;\\n        int end = n;\\n\\n        while (start <= end){\\n            int mid = start + (end-start) / 2;\\n            boolean ans = isBadVersion(mid);\\n            if(ans == false){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid -1;\\n            }\\n            \\n        }return start;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1;\\n        int end = n;\\n\\n        while (start <= end){\\n            int mid = start + (end-start) / 2;\\n            boolean ans = isBadVersion(mid);\\n            if(ans == false){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid -1;\\n            }\\n            \\n        }return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 919971,
                "title": "kotlin-o-logn-time-and-o-1-space",
                "content": "\\n    override fun firstBadVersion(n: Int) : Int {\\n        // [a, b)\\n        var l: Long = 1\\n        var r: Long = n.toLong() + 1\\n        \\n\\t\\t// lower_boundry()\\n        while (l < r) {\\n            val m = l + (r - l) / 2\\n\\n            if (isBadVersion(m.toInt()))\\n                r = m\\n            else\\n                l = m + 1\\n        }\\n\\n        return l.toInt()\\n\\t}\\n",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "\\n    override fun firstBadVersion(n: Int) : Int {\\n        // [a, b)\\n        var l: Long = 1\\n        var r: Long = n.toLong() + 1\\n        \\n\\t\\t// lower_boundry()\\n        while (l < r) {\\n            val m = l + (r - l) / 2\\n\\n            if (isBadVersion(m.toInt()))\\n                r = m\\n            else\\n                l = m + 1\\n        }\\n\\n        return l.toInt()\\n\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 617226,
                "title": "o-logn-simple-c-solution-100-faster",
                "content": "```\\nint firstBadVersion(int n) {\\n        int min=1,max=n;\\n        while(min<=max){\\n            int mid = min + (max-min)/2;\\n            if(isBadVersion(mid)){\\n                max=mid-1;\\n            }\\n            else{\\n                min=mid+1;\\n            }\\n        }\\n        return min;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint firstBadVersion(int n) {\\n        int min=1,max=n;\\n        while(min<=max){\\n            int mid = min + (max-min)/2;\\n            if(isBadVersion(mid)){\\n                max=mid-1;\\n            }\\n            else{\\n                min=mid+1;\\n            }\\n        }\\n        return min;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 606468,
                "title": "golang-o-logn-0-ms-solution",
                "content": "Golang solution with implementing **binary search** to find first bad version.\\n```\\nfunc firstBadVersion(n int) int {\\n\\tstart, end := 1, n\\n\\tfirstBadVersion := n\\n\\n\\tfor start < end {\\n\\t\\tmid := (start + end) / 2\\n\\t\\tresult := isBadVersion(mid)\\n\\n\\t\\tif result {\\n\\t\\t\\tend = mid\\n\\t\\t\\tfirstBadVersion = mid\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn firstBadVersion\\n}",
                "solutionTags": [
                    "Go",
                    "Binary Tree"
                ],
                "code": "Golang solution with implementing **binary search** to find first bad version.\\n```\\nfunc firstBadVersion(n int) int {\\n\\tstart, end := 1, n\\n\\tfirstBadVersion := n\\n\\n\\tfor start < end {\\n\\t\\tmid := (start + end) / 2\\n\\t\\tresult := isBadVersion(mid)\\n\\n\\t\\tif result {\\n\\t\\t\\tend = mid\\n\\t\\t\\tfirstBadVersion = mid\\n\\t\\t} else {\\n\\t\\t\\tstart = mid + 1\\n\\t\\t}\\n\\t}\\n\\n\\treturn firstBadVersion\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 564117,
                "title": "swift-version",
                "content": "```\\nfunc firstBadVersion(_ n: Int) -> Int {\\n        var left = 1\\n        var right = n\\n        var mid = 0\\n        while left + 1 < right {\\n            mid = left + (right - mid) / 2\\n            if isBadVersion(mid) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        if isBadVersion(left) {\\n            return left\\n        }\\n        return right\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nfunc firstBadVersion(_ n: Int) -> Int {\\n        var left = 1\\n        var right = n\\n        var mid = 0\\n        while left + 1 < right {\\n            mid = left + (right - mid) / 2\\n            if isBadVersion(mid) {\\n                right = mid\\n            } else {\\n                left = mid + 1\\n            }\\n        }\\n        if isBadVersion(left) {\\n            return left\\n        }\\n        return right\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 532447,
                "title": "unorthodox-yet-elegant-simple-binary-search-implementation-varying-step-sizes-is-all-you-need",
                "content": "Straightforward linear search solution like\\n```c++\\nint firstBadVersion(int n) {\\n    int version = n;\\n    while (version > 1 && isBadVersion(version - 1)) {\\n        version -= 1;\\n    }\\n    return version;\\n}\\n```\\n\\nturns into an efficient binary search with just a simple twist:\\n\\n```c++\\nint firstBadVersion(int n) {\\n    int version = n;\\n    for (int step = n; step >= 1; step /= 2) {\\n        while (version - step >= 1 && isBadVersion(version - step)) {\\n            version -= step;\\n        }\\n    }\\n    return version;\\n}\\n```\\n\\nNo need to maintain `left`, `right` variables and reason about happens to them on corner cases! Varying step sizes is all you need.",
                "solutionTags": [],
                "code": "```c++\\nint firstBadVersion(int n) {\\n    int version = n;\\n    while (version > 1 && isBadVersion(version - 1)) {\\n        version -= 1;\\n    }\\n    return version;\\n}\\n```\n```c++\\nint firstBadVersion(int n) {\\n    int version = n;\\n    for (int step = n; step >= 1; step /= 2) {\\n        while (version - step >= 1 && isBadVersion(version - step)) {\\n            version -= step;\\n        }\\n    }\\n    return version;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497251,
                "title": "python-linear-iterative-recursive-and-binary-search",
                "content": "\\n\\n```\\ndef firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n\\n        \\n        \\'\\'\\'\\n        Recursive solution\\n        \\'\\'\\'\\n         if n == 1:\\n             return 1\\n         suspect = n-1\\n         if isBadVersion(suspect):\\n             return suspect\\n         return self.firstBadVersion(suspect)\\n        \\n        \\'\\'\\'\\n        linear -- O(n)\\n        \\'\\'\\'\\n         for i in range(n):\\n             if isBadVersion(i):\\n                 return i\\n         return n\\n        \\n        \\'\\'\\'\\n        binary search -- O(logn)\\n        \\'\\'\\'\\n        if n == 1:\\n            return 1\\n\\n        l, r = 0, n\\n        while l <= r:\\n            mid = (l+r)//2\\n            if isBadVersion(mid):\\n                version = mid  # --- update the most recent bad version so far\\n                r = mid-1\\n            else:\\n                l = mid+1\\n        return version\\n```",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\ndef firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n\\n        \\n        \\'\\'\\'\\n        Recursive solution\\n        \\'\\'\\'\\n         if n == 1:\\n             return 1\\n         suspect = n-1\\n         if isBadVersion(suspect):\\n             return suspect\\n         return self.firstBadVersion(suspect)\\n        \\n        \\'\\'\\'\\n        linear -- O(n)\\n        \\'\\'\\'\\n         for i in range(n):\\n             if isBadVersion(i):\\n                 return i\\n         return n\\n        \\n        \\'\\'\\'\\n        binary search -- O(logn)\\n        \\'\\'\\'\\n        if n == 1:\\n            return 1\\n\\n        l, r = 0, n\\n        while l <= r:\\n            mid = (l+r)//2\\n            if isBadVersion(mid):\\n                version = mid  # --- update the most recent bad version so far\\n                r = mid-1\\n            else:\\n                l = mid+1\\n        return version\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 279900,
                "title": "increase-speed-by-50-through-a-simple-change",
                "content": "calculation of mid #1: ```mid = start + ((end - start)/2);```\\ncalculation of mid #2: ```mid = start + ((end - start)>>1);```\\n\\nSpeed increased by almost 50% for calculation 2 because I eliminated the divide operation.",
                "solutionTags": [],
                "code": "```mid = start + ((end - start)/2);```\n```mid = start + ((end - start)>>1);```",
                "codeTag": "Unknown"
            },
            {
                "id": 71404,
                "title": "solution-with-using-low-high-2-and-not-low-high-low-2",
                "content": "     int firstBadVersion(int n) {\\n        long start=1,end=n;\\n        int res=-1;\\n        while(start<=end){\\n            long mid = (start+end)/2;\\n            if(isBadVersion(mid)){\\n                res=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "     int firstBadVersion(int n) {\\n        long start=1,end=n;\\n        int res=-1;\\n        while(start<=end){\\n            long mid = (start+end)/2;\\n            if(isBadVersion(mid)){\\n                res=mid;\\n                end=mid-1;\\n            }\\n            else\\n                start=mid+1;\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 71429,
                "title": "share-my-java-solution-which-is-easy-to-understand",
                "content": "    public class Solution extends VersionControl {\\n        public int firstBadVersion(int n) {\\n            int lo = 1, hi = n;\\n            int last = 0;\\n            while(lo <= hi){\\n                int mid = lo + (hi - lo)/2;\\n                if(isBadVersion(mid)){\\n                    hi = mid - 1;\\n                    last = mid;\\n                }else{\\n                    lo = mid + 1;\\n                }\\n            }\\n            return last;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution extends VersionControl {\\n        public int firstBadVersion(int n) {\\n            int lo = 1, hi = n;\\n            int last = 0;\\n            while(lo <= hi){\\n                int mid = lo + (hi - lo)/2;\\n                if(isBadVersion(mid)){\\n                    hi = mid - 1;\\n                    last = mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 71420,
                "title": "my-0ms-c-solution-with-o-logn-time-and-o-1-space",
                "content": "    class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int from,to,mid;\\n            from=1;to=n;\\n            while(from!=to)\\n            {\\n                mid=((long long)from+to)/2;\\n                if(isBadVersion(mid)==true)\\n                {\\n                    to=mid;\\n                }\\n                else\\n                {\\n                    from=mid+1;\\n                }\\n            }\\n            return from;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int firstBadVersion(int n) {\\n            int from,to,mid;\\n            from=1;to=n;\\n            while(from!=to)\\n            {\\n                mid=((long long)from+to)/2;\\n                if(isBadVersion(mid)==true)\\n                {\\n                    to=mid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3876062,
                "title": "binary-search-beginner-easy-to-understand-c-0ms-faster-than-100",
                "content": "# Intuition\\n\\n# Approach\\nusing exponential search and binary search.\\nyou should be familiar with BS and ES.\\n* first we find the range of bad solution using exponential search .\\n* we pass range to bs and we are going to found upper bound And upper bound is our required solution\\n* we are taking long i because when we multiply i*2 for big number it will cross 2^31-1 for if condition .\\n* ES --> BS.\\n\\n# Complexity\\n- Time complexity:\\nTC <= O(logn).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n  \\n  int bs(int n,int s,int e){\\n      int ans=e;  \\n     while(s<=e){\\n            int m=s+(e-s)/2;\\n         if(isBadVersion(m)==true){\\n             ans=m;\\n             e=m-1;\\n         }\\n         else {\\n             s=m+1;\\n         }\\n     }      \\n         return ans;\\n  }\\n  int exp_s(int n){\\n      if(isBadVersion(1)==true){\\n          return 1;\\n      }\\n      long i=1;\\n      while(i<n&&isBadVersion(i)==false){\\n          if(i*2>INT_MAX){\\n              i=n;\\n              break;\\n          }\\n            i*=2;\\n      }\\n      int min;\\n      if(i>n){\\n          min=n;\\n      }\\n      else{\\n          min=i;\\n      }\\n      return bs(n,i/2,min);\\n  }\\n    int firstBadVersion(int n) {\\n\\n      int ans=exp_s(n);\\n      return ans;\\n    }\\n};\\n```\\n# If you like the solution then please **upvote** me it gives me encouragement to do more...........\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n  \\n  int bs(int n,int s,int e){\\n      int ans=e;  \\n     while(s<=e){\\n            int m=s+(e-s)/2;\\n         if(isBadVersion(m)==true){\\n             ans=m;\\n             e=m-1;\\n         }\\n         else {\\n             s=m+1;\\n         }\\n     }      \\n         return ans;\\n  }\\n  int exp_s(int n){\\n      if(isBadVersion(1)==true){\\n          return 1;\\n      }\\n      long i=1;\\n      while(i<n&&isBadVersion(i)==false){\\n          if(i*2>INT_MAX){\\n              i=n;\\n              break;\\n          }\\n            i*=2;\\n      }\\n      int min;\\n      if(i>n){\\n          min=n;\\n      }\\n      else{\\n          min=i;\\n      }\\n      return bs(n,i/2,min);\\n  }\\n    int firstBadVersion(int n) {\\n\\n      int ans=exp_s(n);\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3740256,
                "title": "easy-c-solution-simple-binary-search-approach-beats-100-in-both",
                "content": "# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start = 1, end = n, mid = start+(end-start)/2, ans;\\n        while(start<=end)\\n        {\\n            if(isBadVersion(mid))\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n            mid = start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start = 1, end = n, mid = start+(end-start)/2, ans;\\n        while(start<=end)\\n        {\\n            if(isBadVersion(mid))\\n                ans = mid, end = mid-1;\\n            else\\n                start = mid+1;\\n            mid = start+(end-start)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544358,
                "title": "easy-to-understand-binary-search-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nO(n) too slow for big data (do not go for linear method)\\ninstead go with binary searching method to reduce api calling\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nmodify and implement  binary search model to find the bad version which is \\nright to the good version (basically find only good,bad pair)\\n# Complexity\\n- Time complexity:O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        if n==1:\\n            return n if isBadVersion(n) else 0 \\n        left,right=0,n\\n        while left<right:\\n            mid=(right+left)//2\\n            if isBadVersion(mid):\\n                if isBadVersion(mid-1):\\n                    right=mid-1\\n                else:\\n                    return mid    \\n            else:\\n                if isBadVersion(mid+1):\\n                    return mid+1\\n                else:\\n                    left=mid+1     \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        if n==1:\\n            return n if isBadVersion(n) else 0 \\n        left,right=0,n\\n        while left<right:\\n            mid=(right+left)//2\\n            if isBadVersion(mid):\\n                if isBadVersion(mid-1):\\n                    right=mid-1\\n                else:\\n                    return mid    \\n            else:\\n                if isBadVersion(mid+1):\\n                    return mid+1\\n                else:\\n                    left=mid+1     \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3513654,
                "title": "building-intuition-from-simple-binary-search-made-with",
                "content": "\\nThis question is a part of a Binary Search Roadmap that provides a comprehensive understanding of the topic. With this roadmap, you will be able to solve any question that comes your way. The roadmap consists of around 30 modules, each representing a concept. Each module is broken down into simpler components before building up to more complex concepts. If you find this solution helpful, please consider checking out the full roadmap on my blog, [ConstantTime](https://constanttime.io/) Thanks!.It is made with \\u2764\\uFE0F\\n\\n\\n\\n### Prerequsites : [Binary Search(Vanilla) ](https://constanttime.io/binary-search/binary-search-vanilla)\\n\\n### Laying the ground work using a simpler question. Find the First True in a Sorted Boolean Array \\n\\n### Question\\n\\nAn array bools is given, divided into two halves, the left half consists of all False values and the right with all True. Find the index of the first True Element. If there is no True value in the array return -1.\\n\\n`bools = [F,F,F,T,T,T]` \\n\\n`result = 3`\\n\\n![sec 1.png](https://assets.leetcode.com/users/images/2f25fe02-d98b-4e10-bbaf-d9e48ff25ef8_1683833042.0055177.png)\\n\\n\\n### Intuition\\n\\n1. Can we reduce the search space in an array with sorted false and true values?\\n2. During a binary search, we narrow down the search space by dividing it in half with each iteration. This is accomplished by removing either the entire right or left side of the search space, based on the location of the midpoint and its relationship with what we are looking for. How can that be applied to a sorted boolean array?\\n3. False values are positioned at the start (left side) of the array, followed by true values. As soon as we encounter a false value, we can safely discard all values to its left and focus only on the remaining true values to its right.\\n    \\n    ![sec 2.png](https://assets.leetcode.com/users/images/d4f4c7bb-7aa8-444f-95ba-ec29899ad262_1683833085.4226837.png)\\n    \\n4. At True Value, we have identified a potential value that can be stored, but we are unsure if it is the first True value. If the element we are on is not the first and all values to its right are True, then the first True value must be on the left side of it. Therefore, we can discard all values to the right. By iterating from right to left, we constantly update and obtain the most current and leftmost potential True value.\\n    \\n    \\n    ![sec 3.png](https://assets.leetcode.com/users/images/29ce7cb8-a83a-4b4a-8030-d6490e9e296b_1683833074.7744706.png)\\n    \\n\\n### Implementation\\n\\nUsing the base template used in [Binary Search(Vanilla) ](https://constanttime.io/binary-search/binary-search-vanilla) \\n\\n1. Left: lowest possible index, right: highest possible index\\n2. Using a while loop, based on the value we are on. If true, store the possible value and chop the range from the right side. If false, chop the range from the left side. Will return the possible value if found, else will return the default -1 as the possible value.\\n\\n### Keeping with the Vanilla Tradition Code\\n\\n```python\\nclass Solution:\\n\\n    def firstTrue(self, bools):\\n\\n        (left, right) = (0, len(bools) - 1)\\n        possibleValue = -1\\n\\n        while left <= right:\\n\\n            mid = left + (right - left) // 2\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# True\\n            if bools[mid]: \\n                possibleValue = mid\\n                right = mid - 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# False\\n            else:\\n                left = mid + 1\\n\\n        return possibleValue\\n```\\n\\n### [SandBox PythonTutor (Visualized)](https://pythontutor.com/visualize.html#code=class%20Solution%3A%0A%0A%20%20%20%20def%20firstTrue%28self,%20bools%29%3A%0A%0A%20%20%20%20%20%20%20%20%28left,%20right%29%20%3D%20%280,%20len%28bools%29%20-%201%29%0A%20%20%20%20%20%20%20%20possibleValue%20%3D%20-1%0A%0A%20%20%20%20%20%20%20%20while%20left%20%3C%3D%20right%3A%0A%0A%20%20%20%20%20%20%20%20%20%20%20%20mid%20%3D%20left%20%2B%20%28right%20-%20left%29%20//%202%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20True%0A%20%20%20%20%20%20%20%20%20%20%20%20if%20bools%5Bmid%5D%3A%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20possibleValue%20%3D%20mid%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20right%20%3D%20mid%20-%201%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20False%0A%20%20%20%20%20%20%20%20%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20left%20%3D%20mid%20%2B%201%0A%0A%20%20%20%20%20%20%20%20return%20possibleValue%0A%0A%0Aa1%20%3D%20%5BFalse,%20False,%20False,True%5D%0A%0A%23comment%20out%20to%20run%20these%20cases%0A%23____________________________________%0A%23%20a2%20%3D%20%5BTrue%5D%0A%23%20a3%20%3D%20%5BFalse,%20False,%20False,%20False,%20False,%20False,%20False,%20False,%20True%5D%20%20%20%20%20%20%20%20%0A%20%20%20%20%20%20%20%20%0AS%3D%20Solution%28%29%0AS.firstTrue%28a1%29%0A%23comment%20out%20to%20run%20these%20cases%0A%23____________________________________%0A%23%20S.firstTrue%28a2%29%0A%23%20S.firstTrue%28a3%29&cumulative=false&curInstr=0&heapPrimitives=nevernest&mode=display&origin=opt-frontend.js&py=3&rawInputLstJSON=%5B%5D&textReferences=false)\\n\\n![image.png](https://assets.leetcode.com/users/images/642769c5-5ba7-47ba-9dd8-9320006af2d8_1683833274.0109713.png)\\n\\n### Complexities\\n\\nTime Complexity:\\xA0`O(log(n))`\\n\\nSpace Complexity:\\xA0`O(1)`\\n\\n[Understanding Time Complexity of OLog(N): Math + Intuition](https://constanttime.io/binary-search/understanding-time-complexity-of-ologn-math-intuition) \\n\\n\\n### [****Find the First True in a Sorted Boolean Array (Optional Alternate Approach)****](https://constanttime.io/binary-search/find-the-first-true-in-a-sorted-boolean-array-optional-alternate-approach)\\n\\n### Building to this Question\\n\\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have\\xA0`n`\\xA0versions\\xA0`[1, 2, ..., n]`\\xA0and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API\\xA0`bool isBadVersion(version)`\\xA0which returns whether\\xA0`version`\\xA0is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\n### [Leetcode](https://leetcode.com/problems/first-bad-version/)\\n\\n### Implementation\\n\\n1. Question mascarading as [****Find the First True in a Sorted Boolean Array**** ](https://constanttime.io/binary-search/find-the-first-true-in-a-sorted-boolean-array)\\n2. Instead of a True value in an array it returns that from an API.\\n\\n### Regular Approach\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        \\n        left, right = 0,n\\n        possibleValue = -1\\n        \\n        \\n        while left <= right:\\n            \\n            mid = left + (right-left)//2\\n            PotentialTrue = isBadVersion(mid)\\n\\n\\t\\n            if PotentialTrue:\\n                possibleValue = mid\\n                right = mid -1\\n            \\n            else:\\n                left = mid + 1\\n                \\n        return possibleValue\\n```\\n\\n### Alternate Approach (Optional)\\n\\n```python\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        \\n        left, right = 0,n\\n      \\n        while left < right:\\n            \\n            mid = left + (right-left)//2\\n            PotentialTrue = isBadVersion(mid)\\n\\t\\n            if PotentialTrue:\\n                right = mid\\n            \\n            else:\\n                left = mid + 1\\n                \\n        return right if isBadVersion(right) == True else -1\\n```\\n\\n\\n### Follow-up\\nHow will you go about solving for the last true value, like the array below?\\n\\n`bools = [T,T,T,F,F,F]`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n\\n    def firstTrue(self, bools):\\n\\n        (left, right) = (0, len(bools) - 1)\\n        possibleValue = -1\\n\\n        while left <= right:\\n\\n            mid = left + (right - left) // 2\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# True\\n            if bools[mid]: \\n                possibleValue = mid\\n                right = mid - 1\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# False\\n            else:\\n                left = mid + 1\\n\\n        return possibleValue\\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        \\n        left, right = 0,n\\n        possibleValue = -1\\n        \\n        \\n        while left <= right:\\n            \\n            mid = left + (right-left)//2\\n            PotentialTrue = isBadVersion(mid)\\n\\n\\t\\n            if PotentialTrue:\\n                possibleValue = mid\\n                right = mid -1\\n            \\n            else:\\n                left = mid + 1\\n                \\n        return possibleValue\\n```\n```python\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        \\n        left, right = 0,n\\n      \\n        while left < right:\\n            \\n            mid = left + (right-left)//2\\n            PotentialTrue = isBadVersion(mid)\\n\\t\\n            if PotentialTrue:\\n                right = mid\\n            \\n            else:\\n                left = mid + 1\\n                \\n        return right if isBadVersion(right) == True else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455012,
                "title": "beats-97-easy-java-solution-using-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=0,h=n,ans=n;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(isBadVersion(mid))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=0,h=n,ans=n;\\n        while(l<=h)\\n        {\\n            int mid=l+(h-l)/2;\\n            if(isBadVersion(mid))\\n            {\\n                ans=mid;\\n                h=mid-1;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345447,
                "title": "easy-with-amazing-logic-using-binary-search",
                "content": "# \\uD83D\\uDD25Solution using Python and JavaScripit Both\\n\\n# Python\\n```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return a bool\\n# def isBadVersion(version):\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left=1\\n        right=n\\n        mid=(right+left)/2\\n        while left<right:\\n            mid=(right+left)/2\\n            if isBadVersion(mid): right=mid\\n            else: left=mid+1\\n        return left\\n\\n# please upvote me, it would encourage me alot. Thank you!\\n```\\n\\n# JavaScript \\n\\n```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let left=1;\\n        let right=n;\\n        let mid=Math.floor((right+left)/2);\\n        while(left<right){\\n            mid=Math.floor((right+left)/2);\\n            if(isBadVersion(mid)){\\n                right=mid;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    };\\n};\\n\\n# please upvote me, it would encourage me alot. Thank you!\\n```\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# @param version, an integer\\n# @return a bool\\n# def isBadVersion(version):\\n\\nclass Solution(object):\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left=1\\n        right=n\\n        mid=(right+left)/2\\n        while left<right:\\n            mid=(right+left)/2\\n            if isBadVersion(mid): right=mid\\n            else: left=mid+1\\n        return left\\n\\n# please upvote me, it would encourage me alot. Thank you!\\n```\n```\\n/**\\n * Definition for isBadVersion()\\n * \\n * @param {integer} version number\\n * @return {boolean} whether the version is bad\\n * isBadVersion = function(version) {\\n *     ...\\n * };\\n */\\n\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        let left=1;\\n        let right=n;\\n        let mid=Math.floor((right+left)/2);\\n        while(left<right){\\n            mid=Math.floor((right+left)/2);\\n            if(isBadVersion(mid)){\\n                right=mid;\\n            }else{\\n                left=mid+1;\\n            }\\n        }\\n        return left;\\n    };\\n};\\n\\n# please upvote me, it would encourage me alot. Thank you!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3230406,
                "title": "ts-o-log-n-binary-search-algorithm-intuitive-solution-described",
                "content": "# Intuition\\nSince the versions are sorted in \\n\\n# Approach\\nBinary search is a search algorithm that finds the index of a target value in a sorted array.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * The knows API is defined in the parent class Relation.\\n * isBadVersion(version: number): boolean {\\n *     ...\\n * };\\n */\\n\\nvar solution = function(isBadVersion: (version: number) => boolean ) {\\n\\n    return function(n: number): number {\\n        let start = 0; // define start\\n        let end = n; // define end for binary search\\n        let lastBadVersion = 1; // We take the first bad version as 1\\n\\n        while (start <= end) {\\n            let mid = Math.floor((start + end) / 2);\\n             // Defining pivot, \\n             // so we are starting from the middle\\n             // of the versions provided\\n\\n            if (isBadVersion(mid)) { // Checking if our pivot is bad\\n                end = mid - 1; \\n                // getting rid of the versions\\n                // after our pivot version\\n                lastBadVersion = mid;\\n                // assigining the pivot as last bad version\\n            } else { \\n                // if pivot was not bad,\\n                start = mid + 1; \\n                // getting rid of\\n                // versions before pivot\\n            }\\n        }\\n\\n        return lastBadVersion;\\n    };\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Binary Search"
                ],
                "code": "```\\n/**\\n * The knows API is defined in the parent class Relation.\\n * isBadVersion(version: number): boolean {\\n *     ...\\n * };\\n */\\n\\nvar solution = function(isBadVersion: (version: number) => boolean ) {\\n\\n    return function(n: number): number {\\n        let start = 0; // define start\\n        let end = n; // define end for binary search\\n        let lastBadVersion = 1; // We take the first bad version as 1\\n\\n        while (start <= end) {\\n            let mid = Math.floor((start + end) / 2);\\n             // Defining pivot, \\n             // so we are starting from the middle\\n             // of the versions provided\\n\\n            if (isBadVersion(mid)) { // Checking if our pivot is bad\\n                end = mid - 1; \\n                // getting rid of the versions\\n                // after our pivot version\\n                lastBadVersion = mid;\\n                // assigining the pivot as last bad version\\n            } else { \\n                // if pivot was not bad,\\n                start = mid + 1; \\n                // getting rid of\\n                // versions before pivot\\n            }\\n        }\\n\\n        return lastBadVersion;\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078237,
                "title": "c-solution-o-log-n-binary-search",
                "content": "# Intuition\\nBinary Search\\n\\n# Approach\\nBinary Search\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long st=1;\\n        long et=n;\\n        long mid=(st+et)/2;\\n        while(st<=et)\\n        {\\n            mid=(st+et)/2;\\n            if(isBadVersion(mid)==true && isBadVersion(mid-1)==false)\\n                return mid;\\n            if(isBadVersion(mid)==true)\\n                et=mid-1;\\n            else\\n                st=mid+1;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        long st=1;\\n        long et=n;\\n        long mid=(st+et)/2;\\n        while(st<=et)\\n        {\\n            mid=(st+et)/2;\\n            if(isBadVersion(mid)==true && isBadVersion(mid-1)==false)\\n                return mid;\\n            if(isBadVersion(mid)==true)\\n                et=mid-1;\\n            else\\n                st=mid+1;\\n        }\\n        return mid;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053906,
                "title": "better-than-100-0ms-used-binary-search-easy-to-understand",
                "content": "\\n\\n# Approach--> Binary Search\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Code\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=0,e=n;\\n        \\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isBadVersion(mid)==true and isBadVersion(mid-1)!=true)\\n                return mid;\\n            else if(isBadVersion(mid)!=true){\\n                s=mid+1;\\n                }\\n            else if(isBadVersion(mid)){\\n                e=mid-1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=0,e=n;\\n        \\n        while(s<=e){\\n            int mid = s+(e-s)/2;\\n            if(isBadVersion(mid)==true and isBadVersion(mid-1)!=true)\\n                return mid;\\n            else if(isBadVersion(mid)!=true){\\n                s=mid+1;\\n                }\\n            else if(isBadVersion(mid)){\\n                e=mid-1;\\n            }\\n        }\\n        return 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3024113,
                "title": "very-easy-solution-java-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=1;\\n        int h=n;\\n\\n        while(l<=h){\\n            int mid=(l+(h-l)/2);\\n        \\n            if(isBadVersion(mid)==false){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l=1;\\n        int h=n;\\n\\n        while(l<=h){\\n            int mid=(l+(h-l)/2);\\n        \\n            if(isBadVersion(mid)==false){\\n                l=mid+1;\\n            }\\n            else{\\n                h=mid-1;\\n            }\\n        }\\n        return l;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2860726,
                "title": "python-binary-search-beats-92",
                "content": "# :: IF YOU LIKE THE SOLUTION PLEASE UP-VOTE ::\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> We can exploit the fact that our search space is linearly increasing so we can use Binary-Search. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. --> \\n- We find our solution using Binary Search\\n- store that as answer\\n- discard the right half of search space\\n- try to find if there are answers to the left\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        start = 1\\n        end = n\\n        ans = n\\n        while start < end:\\n            mid = (start + end) // 2\\n\\n            if isBadVersion(mid):\\n                end = mid\\n                ans = mid\\n            else:\\n                start = mid + 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        start = 1\\n        end = n\\n        ans = n\\n        while start < end:\\n            mid = (start + end) // 2\\n\\n            if isBadVersion(mid):\\n                end = mid\\n                ans = mid\\n            else:\\n                start = mid + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843329,
                "title": "simple-and-easy-kotlin-solution",
                "content": "```\\nclass Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var start = 1\\n        var end = n\\n        var result = -1\\n        \\n        while(start <= end) {\\n            var medium = start + (end - start) / 2\\n            var isBad = isBadVersion(medium)\\n            if (isBad) {\\n                result = medium\\n                end = medium - 1\\n            } else {\\n                start = medium + 1\\n            }\\n        }\\n        return result\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var start = 1\\n        var end = n\\n        var result = -1\\n        \\n        while(start <= end) {\\n            var medium = start + (end - start) / 2\\n            var isBad = isBadVersion(medium)\\n            if (isBad) {\\n                result = medium\\n                end = medium - 1\\n            } else {\\n                start = medium + 1\\n            }\\n        }\\n        return result\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2830258,
                "title": "cpp-easy-to-understand-simple-and-clean",
                "content": "```class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n         int s=1;\\n        int end=n;\\n        int ans=0;\\n               int  mid=s+(end-s)/2;\\n        while(s<=end)\\n        {\\n         bool flag=isBadVersion(mid);\\n            if(flag==false)\\n            {\\n                s=mid+1;\\n            }\\n            if(flag==true)\\n            {\\n                end=mid-1;\\n                ans=mid;\\n            }\\n            mid=s+(end-s)/2;\\n        }\\n        return ans;\\n    }\\n };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n         int s=1;\\n        int end=n;\\n        int ans=0;\\n               int  mid=s+(end-s)/2;\\n        while(s<=end)\\n        {\\n         bool flag=isBadVersion(mid);\\n            if(flag==false)\\n            {\\n                s=mid+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2695278,
                "title": "easy-c-solution-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int l = 0, r = n;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            if(isBadVersion(mid)){\\n                if(mid - 1 >= 0 and !isBadVersion(mid - 1)) return mid;\\n                else r = mid - 1;\\n            }\\n            else l = mid + 1;\\n        }\\n        return 0;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int l = 0, r = n;\\n        while(l <= r){\\n            int mid = l + (r - l) / 2;\\n            if(isBadVersion(mid)){\\n                if(mid - 1 >= 0 and !isBadVersion(mid - 1)) return mid;\\n                else r = mid - 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2609871,
                "title": "java-cpp-python-simple-clean-code",
                "content": "# Basically you have to find the first ocurrence of bad version out of many. This is a slight change from normal finding the Target value.\\n# As we encounter the bad one we\\'ll store that index and will shift the search space to left \\n# May be stored index was the first occurence and we moved to the left that\\'s the reason why we\\'re keeping that index.\\n```\\nint firstBadVersion(int n) {\\n        int left = 0;\\n        int right = n;\\n        int ans = 0;\\n        while(left<=right){\\n            \\n            int mid = left + (right-left)/2;\\n            if(isBadVersion(mid)){\\n                ans = mid;\\n                right = mid-1;\\n            }\\n            else left = mid+1;   \\n        }\\n        return ans;\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Binary Tree"
                ],
                "code": "```\\nint firstBadVersion(int n) {\\n        int left = 0;\\n        int right = n;\\n        int ans = 0;\\n        while(left<=right){\\n            \\n            int mid = left + (right-left)/2;\\n            if(isBadVersion(mid)){\\n                ans = mid;\\n                right = mid-1;\\n            }\\n            else left = mid+1;   \\n        }\\n        return ans;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515446,
                "title": "java-easy-to-understand-o-logn",
                "content": "## Java | Binary Search | O(logn)\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        if(n==1) return 1;\\n        int l = 1;\\n        int r = n;\\n        while(l<=r){\\n            int m = l+(r-l)/2;\\n            if(isBadVersion(m)){\\n                r = m - 1;\\n            }else{\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        if(n==1) return 1;\\n        int l = 1;\\n        int r = n;\\n        while(l<=r){\\n            int m = l+(r-l)/2;\\n            if(isBadVersion(m)){\\n                r = m - 1;\\n            }else{\\n                l = m + 1;\\n            }\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2508726,
                "title": "first-bad-version-solution-using-binary-search-with-100-efficiency-and-runtime",
                "content": "The problem asks for the **first occurrence** of the bad version, that is the **lower bound** of the bad version.\\n**Approach -\\n1. We will search whether the mid is bad or good.\\n2. If the mid version is bad, we will further check if it is the first bad version.\\n3. If it is the first bad version we will simply return the mid.\\n4. If it is not the first bad version we can simply call for (r=mid-1), i.e; the lower or first half.\\n5. If the mid version is good then it is clear that, all versions before it will also be good and we will search for the bad version in the upper or greater half, i.e; l = mid + 1.****\\n \\n ****This is simple implementation of finding first occurrence of an element in a sorted array. \\n\\n\\n**CODE:**\\n```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution\\n{\\n    public:\\n        int firstBadVersion(int n)\\n        {\\n            int l = 1, r = n;\\n            while (l <= r)\\n            {\\n                int mid = l + (r - l) / 2;\\n                if (isBadVersion(mid))\\n                {\\n                    if (mid != 1 and isBadVersion(mid - 1))\\n                    {\\n                        r = mid - 1;\\n                    }\\n                    else\\n                    {\\n                        return mid;\\n                    }\\n                }\\n                else\\n                {\\n                    l = mid + 1;\\n                }\\n            }\\n            return r;\\n        }\\n};\\n```\\n\\n**Hope it helps :)          \\nTHANK YOU ! **\\n  **^^^^^^^^^^**",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution\\n{\\n    public:\\n        int firstBadVersion(int n)\\n        {\\n            int l = 1, r = n;\\n            while (l <= r)\\n            {\\n                int mid = l + (r - l) / 2;\\n                if (isBadVersion(mid))\\n                {\\n                    if (mid != 1 and isBadVersion(mid - 1))\\n                    {\\n                        r = mid - 1;\\n                    }\\n                    else\\n                    {\\n                        return mid;\\n                    }\\n                }\\n                else\\n                {\\n                    l = mid + 1;\\n                }\\n            }\\n            return r;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478814,
                "title": "c-0ms-100-faster-easy-binary-search-solution",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        \\n        int start = 1;\\n        int end = n;\\n        int bad = n;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(isBadVersion(mid))\\n            {\\n                bad  = mid;\\n                end = mid-1;\\n            }\\n            else \\n                start = mid+1;\\n        }\\n        \\n        return bad;\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/953ed303-3fda-495f-8edc-6ea6d6953329_1661436373.3437002.png)\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        \\n        int start = 1;\\n        int end = n;\\n        int bad = n;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start)/2;\\n            \\n            if(isBadVersion(mid))\\n            {\\n                bad  = mid;\\n                end = mid-1;\\n            }\\n            else \\n                start = mid+1;\\n        }\\n        \\n        return bad;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454981,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-100-faster-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q278. First Bad Version***\\nYou are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have `n` versions `[1, 2, ..., n]` and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API` bool isBadVersion(version)` which returns whether `version` is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        i,j = 1,n\\n        while (i < j):\\n            pivot = (i+j) // 2\\n            if (isBadVersion(pivot)):\\n                j = pivot       \\n            else:\\n                i = pivot + 1   \\n        return i\\n```\\n**Runtime:**  49 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1, end = n;\\n        while (start < end) {\\n        int mid = start + (end-start) / 2;\\n        if (!isBadVersion(mid)) start = mid + 1;\\n        else end = mid;            \\n    }        \\n    return start;\\n    }\\n}\\n```\\n**Runtime:**  20ms\\t\\n**Memory Usage:**  40.4 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start = 1, end = n;\\n        while (start < end) {\\n        int mid = start + (end-start) / 2;\\n        if (!isBadVersion(mid)) start = mid + 1;\\n        else end = mid;            \\n    }        \\n    return start;\\n    }\\n};\\n```\\n**Runtime:** 0 ms\\t\\t\\n**Memory Usage:**  5.9 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        i,j = 1,n\\n        while (i < j):\\n            pivot = (i+j) // 2\\n            if (isBadVersion(pivot)):\\n                j = pivot       \\n            else:\\n                i = pivot + 1   \\n        return i\\n```\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start = 1, end = n;\\n        while (start < end) {\\n        int mid = start + (end-start) / 2;\\n        if (!isBadVersion(mid)) start = mid + 1;\\n        else end = mid;            \\n    }        \\n    return start;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int start = 1, end = n;\\n        while (start < end) {\\n        int mid = start + (end-start) / 2;\\n        if (!isBadVersion(mid)) start = mid + 1;\\n        else end = mid;            \\n    }        \\n    return start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425443,
                "title": "first-bad-version-java-solution-binary-search",
                "content": "```\\npublic int firstBadVersion(int n) {\\n        int start=1;\\n        int end=n;\\n       \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(isBadVersion(mid))\\n            {\\n                if(isBadVersion(mid-1)==false)\\n                {\\n                    return mid;\\n                }\\n                end=mid;\\n            }else{\\n                \\n                if(isBadVersion(mid+1)==true)\\n                {\\n                    return mid+1;\\n                }\\n                start=mid;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int firstBadVersion(int n) {\\n        int start=1;\\n        int end=n;\\n       \\n        while(start<=end)\\n        {\\n            int mid=start+(end-start)/2;\\n            \\n            if(isBadVersion(mid))\\n            {\\n                if(isBadVersion(mid-1)==false)\\n                {\\n                    return mid;\\n                }\\n                end=mid;\\n            }else{\\n                \\n                if(isBadVersion(mid+1)==true)\\n                {\\n                    return mid+1;\\n                }\\n                start=mid;\\n            }\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2375787,
                "title": "isbadversion-fast-simple-easy-c",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       int start=1,end=n,mid;\\n        while(start<end){\\n            mid=start+(end-start)/2;\\n            if(!isBadVersion(mid))\\n                start=mid+1;\\n            else\\n                end=mid;\\n            \\n        }return start;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n       int start=1,end=n,mid;\\n        while(start<end){\\n            mid=start+(end-start)/2;\\n            if(!isBadVersion(mid))\\n                start=mid+1;\\n            else\\n                end=mid;\\n            \\n        }return start;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336626,
                "title": "javascript-2-solutions-easy-understand",
                "content": "```\\n//First Solution -  Runtime is fast since O(logn)\\n\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n\\t\\tlet last = n, first = Math.floor((2+last)/2);\\n        if(isBadVersion(n) && !isBadVersion(n-1)) return n;\\n        while(!(isBadVersion(first) && !isBadVersion(first-1))) {\\n            if(isBadVersion(first)) {\\n                last = first;\\n                first = 1;\\n            }\\n            first = Math.floor((first+last)/2);\\n        }\\n        return first;\\n    };\\n};\\n\\n//Second solution -  Runtime is slow since it\\'s O(n)\\n\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let first = 1, last = n;\\n        while(first <= last) {\\n            if(isBadVersion(first)) return first;\\n            first++;\\n        }\\n    };\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n//First Solution -  Runtime is fast since O(logn)\\n\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n\\t\\tlet last = n, first = Math.floor((2+last)/2);\\n        if(isBadVersion(n) && !isBadVersion(n-1)) return n;\\n        while(!(isBadVersion(first) && !isBadVersion(first-1))) {\\n            if(isBadVersion(first)) {\\n                last = first;\\n                first = 1;\\n            }\\n            first = Math.floor((first+last)/2);\\n        }\\n        return first;\\n    };\\n};\\n\\n//Second solution -  Runtime is slow since it\\'s O(n)\\n\\nvar solution = function(isBadVersion) {\\n    return function(n) {\\n        let first = 1, last = n;\\n        while(first <= last) {\\n            if(isBadVersion(first)) return first;\\n            first++;\\n        }\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2330900,
                "title": "javascript-2-solutions-brute-force-binary-search",
                "content": "**Solution 1: Brute Force Solution ~ 10205 ms**\\n\\n```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n\\nvar solution = function(isBadVersion) {\\n\\n    return function(n) {\\n        for (let i = 1; i <= n; i++) {\\n            if(isBadVersion(i))\\n                return i;\\n        }\\n        \\n        return -1;\\n    };\\n};\\n```\\n\\n**Solution 2: Binary Search ~ 73 ms**\\n\\n```\\n// Time complexity: O(log n)\\n// Space complexity: O(1)\\n\\nvar solution = function(isBadVersion) {\\n\\n    return function(n) {\\n        let index = -1;\\n        let low = 1, high = n;\\n        \\n        while(low <= high) {\\n            const mid = low + parseInt((high - low) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                index = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return index;\\n    };\\n};\\n```\\n\\n***Please upvote if you find this post useful. Happy Coding!***",
                "solutionTags": [],
                "code": "```\\n// Time complexity: O(n)\\n// Space complexity: O(1)\\n\\nvar solution = function(isBadVersion) {\\n\\n    return function(n) {\\n        for (let i = 1; i <= n; i++) {\\n            if(isBadVersion(i))\\n                return i;\\n        }\\n        \\n        return -1;\\n    };\\n};\\n```\n```\\n// Time complexity: O(log n)\\n// Space complexity: O(1)\\n\\nvar solution = function(isBadVersion) {\\n\\n    return function(n) {\\n        let index = -1;\\n        let low = 1, high = n;\\n        \\n        while(low <= high) {\\n            const mid = low + parseInt((high - low) / 2);\\n            \\n            if(isBadVersion(mid)) {\\n                index = mid;\\n                high = mid - 1;\\n            }\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return index;\\n    };\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2273392,
                "title": "c-runtime-0-ms-faster-than-100-00",
                "content": "\\n```\\nApproach: If mid is bad then it means first bad is on the left part of array including mid.\\n\\t\\t\\t\\tif Mid is not bad then the first bad must be on the right part of array.\\n```\\nWith this approach we can apply our simple binary search.\\n**Here we are assuming 1 to n numbers as array, just for understanding.**\\n\\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 1, e = n;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                e = mid -1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nApproach: If mid is bad then it means first bad is on the left part of array including mid.\\n\\t\\t\\t\\tif Mid is not bad then the first bad must be on the right part of array.\\n```\n```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s = 1, e = n;\\n        while(s<=e){\\n            int mid = s + (e-s)/2;\\n            if(isBadVersion(mid)){\\n                e = mid -1;\\n            }\\n            else{\\n                s = mid+1;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238708,
                "title": "python-binary-search-runtime-beats-98-87",
                "content": "### Solution\\nInitially, we assign left pointer to the beginning of the array, and the right to the end. Then, we assign variable mid to the middle of the array. Afterwards, we check if mid is Bad:\\n* If so, we move the right pointer to the (mid - 1) position and change the index we need to the mid \\n\\t\\n\\tFor instance, we have TTTFFFF, where mid is F, so now we check the sub-array TTT to find the earliest bad version and assign bad index to the value of mid\\n* If mid is not Bad, we move left pointer to the (mid+1)\\n\\n\\tFor example, we have TTTTFFF, where mid is T; thus, we check the sub-array FFF to find the initial bad version.\\n\\n```class Solution:\\n    def firstBadVersion(self, n: int) -> int:   \\n        left, right, idx = 0, n, n//2\\n        while left <= right:\\n            mid = (left+right)//2\\n            \\n            if isBadVersion(mid) == True:\\n                right = mid - 1\\n                idx = mid\\n            else:\\n                left = mid + 1\\n       \\n        return idx\\n\\n\\t",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "### Solution\\nInitially, we assign left pointer to the beginning of the array, and the right to the end. Then, we assign variable mid to the middle of the array. Afterwards, we check if mid is Bad:\\n* If so, we move the right pointer to the (mid - 1) position and change the index we need to the mid \\n\\t\\n\\tFor instance, we have TTTFFFF, where mid is F, so now we check the sub-array TTT to find the earliest bad version and assign bad index to the value of mid\\n* If mid is not Bad, we move left pointer to the (mid+1)\\n\\n\\tFor example, we have TTTTFFF, where mid is T; thus, we check the sub-array FFF to find the initial bad version.\\n\\n```class Solution:\\n    def firstBadVersion(self, n: int) -> int:   \\n        left, right, idx = 0, n, n//2\\n        while left <= right:\\n            mid = (left+right)//2\\n            \\n            if isBadVersion(mid) == True:\\n                right = mid - 1\\n                idx = mid\\n            else:\\n                left = mid + 1\\n       \\n        return idx\\n\\n\\t",
                "codeTag": "Java"
            },
            {
                "id": 2200722,
                "title": "278-java-python-solution-learn-binary-search-more",
                "content": "Prefered Java ver : (case 2)\\n```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int mid = l + (r-l)/2;\\n            if (isBadVersion(mid)) {\\n                // if mid is a bad version, it could possibly be the first bad ver\\n                // so the right bound of search range becomes mid\\n                r = mid;\\n            } else {\\n                // if mid is a good version, then we can just define the \\n                // left bound of search range as mid+1, since we want a bad version\\n                // and mid is obvious not what we want\\n                l = mid+1;\\n            }\\n        }\\n        // when out of loop, l == r, so we can return either l or r\\n        return l;\\n    }\\n}\\n```\\n\\nJava ver: (case 1)\\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n, mid = 0;\\n        while (l<=r){\\n            // do not use this: mid = (l+r)/2; it causes int overflow\\n            mid = l + (r-l)/2;\\n            if (!isBadVersion(mid)) l = mid+1;\\n            else r = mid-1;\\n        }\\n        return l;\\n    }\\n}\\n```\\n----\\n## Case 1\\nThoughts:\\nWe have the same idea of binary search, but with differnt loop condition, there would be slightly different but meaningful modification.\\n\\nIn this case, when we go out from the loop, we have index r on the left of index l, which means r+1=l.\\n\\nNow the whole list is devided into 2 parts. nums[0...r] nums[l...n-1]. One part is all good, the other is all bad. So we should return index l.\\n\\t\\nConsider situation that before we go out of loop, if index m is bad, then we move r = m-1\\n\\t\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l <= r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return l\\n```\\n-------\\n### Case 2\\nIn this case, when out of loop, we have l=r, and the whole list is also diveded into two parts, with index l (equally index r) to be the pivot point. Before to figure out what to return, let\\'s think about how to update our search space:\\n\\nIf index m is bad version, we will keep the right search range r=m. Why not r=m-1? Because current index could possibly be the first bad version, which is what we want. So we include m itself in the right search range.\\nIf index m is good version, then we can directly move the left range as l = m+1, cause we will not miss the first bad version by doing this.\\nIn the last iteration of while loop, if that m index is bad version, we keep r=m, if it is good, we make l = m+1, and now l=r, we jump out the loop. So l or r must be the first bad version. \\nIn this case, return l or return r are both ok.\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l < r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m\\n            else:\\n                l = m+1\\n        return r\\n\\t\\t# return l is also ok\\n```\\n-----\\n### Case 3\\nIn this solution, when out of loop, we have l + 1 = r, the list can be devided into nums[0...l] nums[r...n-1]\\nif index m is bad version, we make right search range shrink, but we have to include m itself in the range.\\nIf index m is good version, we also make left range shrink, included m itself. \\nIn the end, nums[0...l] will all be good, nums[r..n-1] all bad, so r is the index to return.\\nWait....what if the length of nums is 2 or even 1? If the length is 2, then l=0, r=1, we don\\'t even enter the loop, so we can\\'t start searching, which will not give us the correct anwser.\\nWhat if all versions are bad, then l and r cannot partition the list in a correct way. We will always have l=0, r=1, and if we return r like we said above, it would be the right answer, index l = 0 is the first bad version.\\n\\nSo here comes the special trick for this method only: we return either l or right depending on the condition we need. In this problem, we want first bad verision, so we check index l first, if it is bad, we return it. If index l is not bad, then index r must be the first bad version, so we return r instead.\\n\\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l+1 < r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m\\n            else:\\n                l = m\\n        if isBadVersion(l):\\n            return l\\n        else:\\n            return r\\n```",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\n/* The isBadVersion API is defined in the parent class VersionControl.\\n      boolean isBadVersion(int version); */\\n\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n;\\n        while (l < r) {\\n            int mid = l + (r-l)/2;\\n            if (isBadVersion(mid)) {\\n                // if mid is a bad version, it could possibly be the first bad ver\\n                // so the right bound of search range becomes mid\\n                r = mid;\\n            } else {\\n                // if mid is a good version, then we can just define the \\n                // left bound of search range as mid+1, since we want a bad version\\n                // and mid is obvious not what we want\\n                l = mid+1;\\n            }\\n        }\\n        // when out of loop, l == r, so we can return either l or r\\n        return l;\\n    }\\n}\\n```\n```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int l = 1, r = n, mid = 0;\\n        while (l<=r){\\n            // do not use this: mid = (l+r)/2; it causes int overflow\\n            mid = l + (r-l)/2;\\n            if (!isBadVersion(mid)) l = mid+1;\\n            else r = mid-1;\\n        }\\n        return l;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l <= r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m - 1\\n            else:\\n                l = m + 1\\n        return l\\n```\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l < r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m\\n            else:\\n                l = m+1\\n        return r\\n\\t\\t# return l is also ok\\n```\n```\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l, r = 1, n\\n        while l+1 < r:\\n            m = (l+r)//2\\n            if isBadVersion(m):\\n                r = m\\n            else:\\n                l = m\\n        if isBadVersion(l):\\n            return l\\n        else:\\n            return r\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2151932,
                "title": "simple-python-binary-search-solution",
                "content": "```class Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l=1\\n        h=n\\n        while(l<=h):\\n            m=(l+h)//2\\n            if(isBadVersion(m)):\\n                h=m-1\\n            else:\\n                l=m+1\\n        return l",
                "solutionTags": [
                    "Python",
                    "Binary Tree"
                ],
                "code": "```class Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        l=1\\n        h=n\\n        while(l<=h):\\n            m=(l+h)//2\\n            if(isBadVersion(m)):\\n                h=m-1\\n            else:\\n                l=m+1\\n        return l",
                "codeTag": "Java"
            },
            {
                "id": 2135817,
                "title": "python3-binary-search-solution-faster-than-87-41-easily-explained",
                "content": "# Python3 Binary Search Solution.\\n**Runtime: 31 ms, faster than 87.41%\\nMemory Usage: 13.8 MB, less than 60.20%**\\n```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n\\t# We use left = 0, right = n and and check if the mid = (left + right) // 2 is bad that means\\n    # first bad is at left-er side so updating right = mid but if the mid is not bad that means\\n    # the first bad is at right-er side so we update our left = mid + 1; mid + 1 because we\\'ve\\n    # already seen the mid now we want to start from the next that\\'s why +1. And eventually\\n    # while loop exhausts and we find our first bad version at left pointer.\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\n# The isBadVersion API is already defined for you.\\n# def isBadVersion(version: int) -> bool:\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n\\t# We use left = 0, right = n and and check if the mid = (left + right) // 2 is bad that means\\n    # first bad is at left-er side so updating right = mid but if the mid is not bad that means\\n    # the first bad is at right-er side so we update our left = mid + 1; mid + 1 because we\\'ve\\n    # already seen the mid now we want to start from the next that\\'s why +1. And eventually\\n    # while loop exhausts and we find our first bad version at left pointer.\\n        left, right = 1, n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2109813,
                "title": "c-simple-binary-search-solution-explanation",
                "content": "# How I think and implement it?\\n(1) Set the range of L, R should be `1,n`\\n(2) write done the condition of matched case. In this problem, we have the condition\\n`isBadVersion(M)  && (M-1<1 || !isBadVersion(M-1))`\\n(3) When tha matched case is not happened, we need to decide search right-side or left-side.\\nSo , when the logic condition `isBadVersion(M)`  is true, then go to the left-side. \\nOtherwise, go to the right-side.\\n\\nSo we have th following code\\n```C++\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int L=1,R=n;\\n        while(L<=R) {\\n            int M = L+(R-L)/2;\\n            if(isBadVersion(M)  && (M-1<1 || !isBadVersion(M-1)) ) {\\n                return M;\\n            }\\n            if(isBadVersion(M)) \\n                R=M-1;\\n            else \\n                L=M+1;\\n        }\\n        return -1; //The code will not be wrong becuase so there\\'s no such case happened\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```C++\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int L=1,R=n;\\n        while(L<=R) {\\n            int M = L+(R-L)/2;\\n            if(isBadVersion(M)  && (M-1<1 || !isBadVersion(M-1)) ) {\\n                return M;\\n            }\\n            if(isBadVersion(M)) \\n                R=M-1;\\n            else \\n                L=M+1;\\n        }\\n        return -1; //The code will not be wrong becuase so there\\'s no such case happened\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1969275,
                "title": "easy-to-understand-java",
                "content": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start =0, end = n-1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(isBadVersion(mid)){\\n                end = mid-1;\\n            } else\\n                start = mid+1;\\n        }\\n        return start;\\n    }\\n}\\n```\\nIf you have any **doubts**, feel **free to ask**...\\nIf you understand the **concept**. Don\\'t Forget to **upvote**\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic class Solution extends VersionControl {\\n    public int firstBadVersion(int n) {\\n        int start =0, end = n-1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(isBadVersion(mid)){\\n                end = mid-1;\\n            } else\\n                start = mid+1;\\n        }\\n        return start;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1957600,
                "title": "c-binary-search",
                "content": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int first=1;\\n        int last=n;\\n        int output=0;\\n        while(first<=last){\\n            int mid=first+(last-first)/2;\\n         if(isBadVersion(mid)){\\n             output=mid; // we found the bad version but its not the first one so we will keep on reducing the last ele...\\n             last=mid-1;\\n         }else{\\n            first=mid+1;\\n    }}\\n            return output;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int first=1;\\n        int last=n;\\n        int output=0;\\n        while(first<=last){\\n            int mid=first+(last-first)/2;\\n         if(isBadVersion(mid)){\\n             output=mid; // we found the bad version but its not the first one so we will keep on reducing the last ele...\\n             last=mid-1;\\n         }else{\\n            first=mid+1;\\n    }}\\n            return output;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939030,
                "title": "rust-binary-search-and-notes-on-overflows",
                "content": "```\\nimpl Solution {\\n    pub fn first_bad_version(&self, n: i32) -> i32 {\\n        let mut low = 1i32;\\n        let mut high = n;\\n        let mut mid = low + (high - low)/2;\\n        \\n        while low <= high {\\n            if self.isBadVersion(mid) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n            mid = low + (high - low)/2;\\n        }\\n        high + 1\\n    }\\n}\\n```\\n\\nNote how ```mid``` is computed:```mid = low + (high - low)/2;```\\nThis is mathematically equivalent to ```mid = (low + high)/2;```\\nHowever, the latter will cause overflow on one of the test cases ([2126753390, 1702766719]) since we\\'re dealing with ```i32``` types.",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn first_bad_version(&self, n: i32) -> i32 {\\n        let mut low = 1i32;\\n        let mut high = n;\\n        let mut mid = low + (high - low)/2;\\n        \\n        while low <= high {\\n            if self.isBadVersion(mid) {\\n                high = mid - 1;\\n            } else {\\n                low = mid + 1;\\n            }\\n            mid = low + (high - low)/2;\\n        }\\n        high + 1\\n    }\\n}\\n```\n```mid```\n```mid = low + (high - low)/2;```\n```mid = (low + high)/2;```\n```i32```",
                "codeTag": "Unknown"
            },
            {
                "id": 1916083,
                "title": "python",
                "content": "\\n    def firstBadVersion(self, n):\\n        left, right = 1, n\\n        \\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            \\n            if isBadVersion(mid):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n                \\n        return left",
                "solutionTags": [],
                "code": "\\n    def firstBadVersion(self, n):\\n        left, right = 1, n\\n        \\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            \\n            if isBadVersion(mid):\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n                \\n        return left",
                "codeTag": "Python3"
            },
            {
                "id": 1884753,
                "title": "first-bad-version-100-solutions",
                "content": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=0; \\n        int e=n;\\n        int ans=0;\\n        int mid=s+(e-s)/2;\\n        while(s<=e){\\n            if(isBadVersion(mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nclass Solution {\\npublic:\\n    int firstBadVersion(int n) {\\n        int s=0; \\n        int e=n;\\n        int ans=0;\\n        int mid=s+(e-s)/2;\\n        while(s<=e){\\n            if(isBadVersion(mid)){\\n                ans=mid;\\n                e=mid-1;\\n            }\\n            else {\\n                s=mid+1;\\n            }\\n            mid=s+(e-s)/2;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567767,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1570560,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1696954,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1564807,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1680905,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1566378,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1567940,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1569858,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1576911,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1568584,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1567767,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1570560,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1696954,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1564807,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1680905,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1566378,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1567940,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1569858,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1576911,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1568584,
                "content": [
                    {
                        "username": "Baby_TRex",
                        "content": "Am I the only one who felt problem description and input is messy?"
                    },
                    {
                        "username": "iamtanishq",
                        "content": "I was asked this in an interview few seconds ago, I couldn\\'t understand it even then :(("
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "// The API isBadVersion is defined for you.\\n// bool isBadVersion(int version);\\n\\nint firstBadVersion(int n) {\\n    int count=0;\\n    int defected=0;\\n    for(int i=n;1>=1;i--){\\n        count=0;\\n        if(isBadVersion(i)){\\n            count+=1;\\n        }\\n        \\n        else{\\n            if(count==0){\\n defected=i+1;\\n            break;\\n            }\\n           \\n        }\\n    }\\n    return defected;\\n    \\n}\\nbro its very easy code hope u will understand"
                    },
                    {
                        "username": "kolupayev",
                        "content": "The thing here is- you need to write solution with one var = n(amount of versions). And as it stated - you don\\'t know the bad version and you need to find it with your solution.\\n\\nThe second \"variable\" should not really appear in your code, think about it as a known bad version to test your solution.\\n\\nYou can pass the second var of bad version in new test case, so it will be passed to isBadVersion() function somewhere in background of leetcode infra."
                    },
                    {
                        "username": "patlo",
                        "content": "I\\'m just curious why, in JS, we\\'re using closure when it looks to me like we don\\'t need to. I brought the problem into my chrome console, converted `var solution` to `function firstBadVersion(n)` and eliminated `return function(n)` and my solution worked just the same."
                    },
                    {
                        "username": "vivek1313",
                        "content": "Same"
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "I didn\\'t get the problem, can anyone tell and describe the problem : /"
                    },
                    {
                        "username": "harshkapsha",
                        "content": "describe the class and variables USING Python its easy\\n class Solution:\\n    def firstBadVersion(self, n):\\n        \"\"\"\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        left,right = 0,n\\n        while left < right:\\n            mid = (left + right) // 2\\n            if isBadVersion(mid):\\n                right = mid\\n            else:\\n                left = mid + 1\\n        return left"
                    },
                    {
                        "username": "scapegoat079",
                        "content": "so given n=5 --> \"1 2 3 4 5\"\\nand bug 3 (the second input)\\nthe 3 and following versions 4 and 5 are all \"bad\"\\n\\nwith as few isBadVersion() checks, Find the first bad version in the list.\\nso the main thing you\\'re looking for is \"is the previous version good and the current version bad\"\\n\\nUnravel this however you can, as efficiently as possible!"
                    },
                    {
                        "username": "Hazytea",
                        "content": "\"You are a product manager and currently leading a team to develop a new product.\"\\n\\nAssumes product managers can lead."
                    },
                    {
                        "username": "Ungureanu_Ovidiu",
                        "content": "Bruh\\n"
                    },
                    {
                        "username": "close27",
                        "content": "LOL"
                    },
                    {
                        "username": "aaronwei",
                        "content": "Is there any difference between \" ( low + high ) / 2 \"  and  \" low + ( high - low ) / 2 \"?\\n\\nWhen I use the first one, it told me \"time limit exceed\" but if I use the second one, it worked!"
                    },
                    {
                        "username": "Jatinkumar25",
                        "content": "first one is going to be out of range of the  Integer  that\\'s  why time limit exceed occurred"
                    },
                    {
                        "username": "don9594",
                        "content": "[@DebjyotiShit](/DebjyotiShit) yup exactly. consider this: in c++, highest signed int value is  2147483647 (this can vary with architecture but can be considered fine for this example). say you have int x = 2147483640 and int y = 2147483644. so now if you try to find the average using (x+y)/2, notice that the addition of the two values will exceed the highest value that can be stored in an int. hence the error. but following (x + (y-x)/2), that does not happen."
                    },
                    {
                        "username": "kashishbhatia789",
                        "content": "[@raisunlakra18](/raisunlakra18) check if the API is used correctly.  Or try initializing a variable to store the value."
                    },
                    {
                        "username": "Aetherus",
                        "content": "Depends on what language you are using. Integers in some languages like C and Java can overflow, but in others like Ruby and Elixir will never overflow, not even if it causes out of memory.\n\nSuppose `low = 0x7FFFFFFD` and `high = 0x7FFFFFFF`. `low + high = 0xFFFFFFFC` and it overflows in C and Java and returns `-4`, so `(low + high) / 2` return `-2`. But `high - low` produces `2`. `low + (high - low) / 2` returns `0x7FFFFFFE` which is still a positive number.\n\nIf you don't want to handle overflow, try use a bigger integer type, like `long` in Java or `long long` in C, or use an unsigned integer type, like `u32` in Rust."
                    },
                    {
                        "username": "thatikondamanish",
                        "content": "yes, they both are not same because when you use the first one where lets consider low has 10^9 time limit and high has 10^9 time limit adding them both makes it 10^18 which exceeds the time limit due to the constraints where it would be mentioned as 10^9.\\nbut where as considering the second case we would be first considering the operation in brackets due to its high priority so high has 10^9 and low has 10^9 now as its subtraction and then the denominator 2 gets multiplied with low(10^9) which makes it 2*10^9 and it is smaller than 10^18 so the second case would be working and remember this every time when your doing binary search."
                    },
                    {
                        "username": "Ddas_2707",
                        "content": "no bro both are same\\nhave a practice of using the second one\\nsince when we consider large numbers second expression donot create any problem.\\nsuppose take a large no. of start and end ,adding both large number will be difficult for a compiler to compile so using the second expression donot create large expressions and TLE is not shown."
                    },
                    {
                        "username": "DebjyotiShit",
                        "content": "Yes,  I also face same problem . \\nWhy it\\'s give you time limit exceed because\\n( low + high ) / 2 .When we are take a long value \\nIn this time what happened integer overloading \\nFor that reason it\\'s give us time limit exceed .  "
                    },
                    {
                        "username": "raisunlakra18",
                        "content": "I am getting TLE in both"
                    },
                    {
                        "username": "Nishant5454",
                        "content": "No Both Gives the same value..but second one is more effecient when we consider of a long long value"
                    },
                    {
                        "username": "rohityadav04",
                        "content": "it is due to the outflow of integer in the first case \\n"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented."
                    },
                    {
                        "username": "Flemoid",
                        "content": "[@thenileshmishra](/thenileshmishra) Actually when you do (low + high), suppose one of the values of \\'low\\' and \\'high\\' is INT_MAX, so when it is added to other, the value goes out of the range of integer i.e. goes beyond INT_MAX, that\\'s why we do low + (high-low)/2 that solves this problem because (high-low)/2 will make the value so lower in number that when it will be added to \\'low\\', it will not go beyond INT_MAX. That\\'s the reason."
                    },
                    {
                        "username": "hetpatelcse",
                        "content": "got to learn something new, thanks to your comment. now i will also use the second one everytime i code such type. thanks to replies \\uD83D\\uDE4F"
                    },
                    {
                        "username": "subratomukherjee222",
                        "content": "[@thenileshmishra](/thenileshmishra)  I have dry run over n=15 if we take mid=(high-low)/2 then it will loop through 3 4 5 infinitely thats why we add low+high-low/2 so it can move further in search area."
                    },
                    {
                        "username": "mishraanurag8446",
                        "content": "it will exceed the int limit in any programming language at certain point of time like we have int limit in java 2^-31 to 2^31-1 suppose you got the array of length 2^31-1 exactly now if we as low and high for some point it will exceed the int limit, \\nHope you got it \\uD83D\\uDE05, Thanks "
                    },
                    {
                        "username": "thenileshmishra",
                        "content": "[@gurudatta1455](/gurudatta1455)  how i didn\\'t get it\\n"
                    },
                    {
                        "username": "AhmedIbrahimHassan",
                        "content": "overflow "
                    },
                    {
                        "username": "Zesta",
                        "content": "there is basically no mathematical difference since if you take two as the LCD then the two expressions are mathematically equal."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\uD83D\\uDCA8 Simple Binary Search O(logN) \\uD83D\\uDE28\\nhttps://leetcode.com/problems/first-bad-version/solutions/2267231/simple-binary-search-o-logn/"
                    },
                    {
                        "username": "guruDAtTA_02",
                        "content": "Yes. It avoids  the integer overflow condition"
                    },
                    {
                        "username": "Glasseater90",
                        "content": "The issue is that Integer.MAX_VALUE, in java for example, is smaller than let\\'s say 2.12 billion + 1.06 billion. So you end up looping into negatives then looping forever. There should be no actual performance difference between \"low + (high - low) / 2\" and \"(low + high) / 2\" IF you can guarantee that n will never be > Integer.MAX_VALUE / 2"
                    },
                    {
                        "username": "vvek475",
                        "content": "because sometimes the sum might exceed maximum number size so dividing it will take too long and sometimes exceeds the maximum size so we reduce the size by dividing the difference"
                    },
                    {
                        "username": "Iluxmas",
                        "content": "Not the first time I notice description on leetcode is total trash =("
                    },
                    {
                        "username": "smith911",
                        "content": "Why do the sample cases show two inputs\\n\\n    Input: n = 5, bad = 4\\nbut the function \\n\\n    public int firstBadVersion(int n) { \\nhas only one input.\\nWhat am I supposed to do with the second input ?"
                    },
                    {
                        "username": "ChevalChivalry",
                        "content": "the second input is not for your function, it just tells you which the first bad version is. not a input in this way, just a reference to helps u check your answer."
                    },
                    {
                        "username": "csuu1927",
                        "content": "It\\'s to tell the test runner which version is the expected answer. It has nothing to do with implementation. Try adding a test and it should start to make sense."
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    },
                    {
                        "username": "SergeyTachenov",
                        "content": "This problem has a very real-life practical description. So it sounds like you are allowed to make practical assumptions. I am usually very careful about possible integer overflows, so when I was coding binary search I thought, \"Can it overflow?\", and then I thought \"No, we can't have that many versions in a real life scenario, so better use a simpler expression than the usual overflow-conscious one.\" And\\u2014voila!\\u2014it overflowed!\\n\\nBut really, 2126753390 versions? Even if you're making a new version every second, you still need *67 years* to produce that many. And even if you really do, it's a bad idea to use `int` to store version numbers in such case.\\n\\nP. S. As mentioned in the comments, there is a way to get both overflow-protected and concise expression for positive integers: `(left + right) >>> 1`. That's exactly what `Arrays.binarySearch` uses. So that makes this one test case for this problem very useful education-wise."
                    },
                    {
                        "username": "ExactZero",
                        "content": "Yes, it\\'s absolutely fucking retarded. Just a non-sensical example to force us to use binary search."
                    },
                    {
                        "username": "narender_dhull",
                        "content": "Hey Guys, I tried to solve the first problem in c# but it gives error \"Line 10: Char 13: error CS0103: The name \\'isBadVersion\\' does not exist in the current context (in Solution.cs)\" I think isBadVersion method should be there and i don\\'t have to write it. we can use c# right? Anyone solved in C#?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "First letter is uppercase: IsBadVersion."
                    },
                    {
                        "username": "zmmaja",
                        "content": " bool IsBadVersion(int version)"
                    },
                    {
                        "username": "sri_sushma",
                        "content": "For the example test case given, n = 5, means there are 5 versions and bad = 4, is not it obvious 4 is the first bad version.\\n\\nlets say there are 9 versions, that means from version 1 to version 9 (inclusive), say if bad version is 8, i would just return 8, as I already know from input bad version is 8.\\n\\nAlso it says n =5 and bad = 4, in the test case we see 5 followed by 4, but in the badversion function only 5, that is n is taken. how is the bad version taken into account?\\n\\n*I might probably the only one not understanding the question.*\\n\\nCan someone please explain me the question bit further. Thank you !\\n"
                    },
                    {
                        "username": "myselfsuryansh2001",
                        "content": "how they can say first bad version is 4, it may by any no between 1 to 5"
                    },
                    {
                        "username": "kartikey_wariyal",
                        "content": "me too not able to get whats its asking"
                    },
                    {
                        "username": "tanmayaaeron142014",
                        "content": "Can somebody tell what does second number in input represents?"
                    },
                    {
                        "username": "import_karan",
                        "content": "We have to return the value, equal to \"bad\", by just using \"n\" and helper function \"boolean isBadVersion(int version)\""
                    }
                ]
            },
            {
                "id": 1567241,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1779455,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1567765,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1568733,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1575357,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1570423,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1568721,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1791334,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1742580,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1694996,
                "content": [
                    {
                        "username": "DyXrLxSTAOadoD",
                        "content": "Could someone explain why m=s+e time exceeds but m=s+(e-s)/2 won't?"
                    },
                    {
                        "username": "konain7",
                        "content": "The expression mid = l + (h-l)/2 is faster than mid = (l + h)/2 in some cases because it can be optimized by the compiler to avoid overflow errors.\\n\\nIn computer arithmetic, adding two large numbers can result in an overflow error if the result exceeds the maximum representable number for the data type used. This can lead to unexpected results or program crashes. On the other hand, subtracting two numbers and then dividing the result by 2 is less prone to overflow errors because the intermediate result is smaller.\\n\\nFor this reason, the expression mid = l + (h-l)/2 can be considered faster than mid = (l + h)/2 in cases where overflow errors are a concern. This is especially true for low-level languages, such as C and Assembly, where arithmetic is performed on the binary level and overflow errors can have serious consequences.\\n\\nHowever, in many cases, the difference in performance between the two expressions is negligible, and the choice between them may depend on factors such as readability, personal preference, or the specific requirements of the algorithm being implemented.\\n"
                    },
                    {
                        "username": "santoshkumar15841",
                        "content": "m = s + e this is also right but if you use large value then this formula does not work it means that there will be overflow . hence we use m = s +(e-s)/2 it is use for both large and small value there will be no overflow.\\n"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "[@shuklaabhay181](/shuklaabhay181) I don\\'t think so this is exact reason. Its because of integer can store data in 4 bytes and addition operation might give you result that do not fit into 4 bytes. \\nSo we use s  + (e - s)/2; just to get rid of situation where integer overflow happens. \\n "
                    },
                    {
                        "username": "kunal-leetcode",
                        "content": "because if you do it manually in a notebook u will find the m result to be correct and we use this as if there are large input of s and e then for them if we use m = s + e /2 here first s and e will be added which will surely exceed the limit of int that\\'s why we use s + e-s/2 so that int limit should not be exceeded."
                    },
                    {
                        "username": "shuklaabhay181",
                        "content": "becoz /2 is for odd and even cases "
                    },
                    {
                        "username": "bnl29",
                        "content": "the fact this problem has not been revised and is still used in their algo study plans is insane lol"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "CodeQuiver",
                        "content": "Given the story problem here, where we\\'re looking through commits for the first instance of bad code, isn\\'t linear search from the end most likely to be faster given the shape of the data set?\\n\\nIn real life I\\'d expect that there are thousands of commits in a codebase, but a bug that was found recently probably was added relatively recently, so it makes the most sense to just search from the end. Given this, is binary search still real-world better, or only mathematically/ worst-case better here? Does anyone have another search method that weights the top end but is faster than linear search that they got to pass?"
                    },
                    {
                        "username": "yadav_deepakk",
                        "content": "what you are saying is correct for smaller array size. So you can write a code snippet handle separately for smaller array size and for bigger array size you must go for binary search. "
                    },
                    {
                        "username": "Yash_Mittal",
                        "content": "How can I know about the previous version, as I don\\'t know about the API things."
                    },
                    {
                        "username": "anupamkumar",
                        "content": "The example suggests that there are two inputs `n` and `bad`. Please, fix that. It\\'s going to throw people off."
                    },
                    {
                        "username": "hemantsoni480",
                        "content": "![image](https://assets.leetcode.com/users/images/b876416c-cdb5-4d27-b2f2-ca42dad5f53d_1643536198.820668.png)\\n"
                    },
                    {
                        "username": "rs7623",
                        "content": "[@mwalle](/mwalle)  it\\'s O(n), use Binary search for O(LogN)\\n"
                    },
                    {
                        "username": "mwalle",
                        "content": "this calls the isBadVersion API way too much."
                    },
                    {
                        "username": "noahdecker77",
                        "content": "getting time exceeds on the 11 test case. have no idea where its hanging. does anyone have an idea? "
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "overflow maybe can try binary search"
                    },
                    {
                        "username": "glebersh",
                        "content": "whats with this description......"
                    },
                    {
                        "username": "hauntarl",
                        "content": "Alternate Binary Search Algorithm:\n```\n    def firstBadVersion(self, n: int) -> int:\n        k = 0\n        while n > 0:\n            while not isBadVersion(n + k):\n                k += n\n            n //= 2\n        return k + 1\n```"
                    },
                    {
                        "username": "weisinger",
                        "content": "This is great.  I really like how small and clean it is."
                    }
                ]
            },
            {
                "id": 1569053,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1576233,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1576804,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1576648,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1576327,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1575215,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1574727,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1573357,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1571520,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1571521,
                "content": [
                    {
                        "username": "Harrywithcode",
                        "content": "If the first time I check version 1 and I find version 1 is good version, it means version 2 is obviously the bad version, why the solutions post here all return twice instead of once? If my program first time check version 1, it will return once.\\nDoes the test case has bug or am I misunderstand?"
                    },
                    {
                        "username": "Shiva_Rajan_K",
                        "content": "int i=0;\\nwhile(!isBadVersion(i))\\n            i++;\\nreturn i;"
                    },
                    {
                        "username": "HridayAg0102",
                        "content": "Can\\'t get the usage of `bad` variable in input. could anyone please explain?"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\\n\\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\\n\\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\\n\\nhttps://www.nileshblog.tech/2022/04/21/leet-code-first-bad-version-solution/"
                    },
                    {
                        "username": "rohitvishwakarma1819",
                        "content": "For finding mid between two numbers low `l` and high `h`, there are two ways :\\n\\n1. `mid = (l+h)/2`\\n2. `mid = l+(h-l)/2 => or => h-(h-l)/2`\\n\\nway 2 is more beneficial because it prevents variable from precision overflow"
                    },
                    {
                        "username": "pulkit83",
                        "content": "If your submission is timing out even after using binary search make sure that you are not doing\\n\\nint i = (start+end)/2;     \\n\\ninstead of \\n\\nint i = start+(end-start)/2;      \\n\\nBecause start + end can overflow."
                    },
                    {
                        "username": "adbenson",
                        "content": "**It can take a minute to understand that this is a binary search** and that the task is to show, in code how to find the value of one less than the value you are given. e.g. if given 10 return 9, if given 876 return 875, etc.\\n**It was in how the question is presented that wasn\\'t clear at first.** Previously, I took a data set, sorted it, then did a search to find if the value is in the data set i.e. if given a random set of values (words or numbers), detemine if the target value is in that set. What if the value was a large character alpha numeric value?\\nThe getting the target value itself is not a mystery, how you get there is the task.\\nSince the discussion, talking through the problem, is half of how you are evaluated, it seemed worth mentioning. The other part of the discussion is then to demonstrated the difference between iteration and recursion with respect to O(?), which process and why."
                    },
                    {
                        "username": "thula",
                        "content": "In the *explore* section for binary search, this problem is handled under template II: \\nhttps://leetcode.com/explore/learn/card/binary-search/126/template-ii/937/\\nthis template is characterised by the fact that the search condition needs to access a right neighbor of the middle element. \\nThe while loop uses `while start < end` and right is inremented to `right = mid` instead of `right = mid-1` in template I. This works perfectly, but here the search condition does not even need to access right neighbors. \\n\\nWhy?"
                    },
                    {
                        "username": "pathak007",
                        "content": "I am not sure why i am getting this error. Has the function be removed??\\n\\n\\nRuntime Error Message:Line 16: NameError: global name 'isBadVersion' is not defined\\nLast executed input:1 version\\n1 is the first bad version."
                    },
                    {
                        "username": "dingli",
                        "content": "hi anyone use C# has the same issue?"
                    }
                ]
            },
            {
                "id": 1569856,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 1569449,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 1571519,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2073213,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2063610,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2044421,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2035858,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2034330,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2033025,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2027396,
                "content": [
                    {
                        "username": "geek_",
                        "content": "Check out this \\n\\nhttps://thefellowprogrammer.blogspot.com/2020/05/first-bad-version.html\\n\\n"
                    },
                    {
                        "username": "constablensw",
                        "content": "Thank you! Now I understand what they are asking!"
                    },
                    {
                        "username": "cisforcojo",
                        "content": "Does anyone have insight into how the memory consumption is calculated? It appears as those variable name length affects memory consumption but it really shouldn\\'t.\\n\\nHere you can see my memory consumption drop from 8.3MB to 8MB simply by renaming all my variables to single letters (which is horrible for readability).\\n![image](https://assets.leetcode.com/users/cisforcojo/image_1552535099.png)\\n\\nI tested this when I noticed my memory consumption jumped from 8.1 -> 8.3MB when I used slightly longer but more descriptive variable names.\\n\\nThanks!\\n"
                    },
                    {
                        "username": "tekkamanblade0",
                        "content": "The key point for the question is not binary search but this statement \"mid = start + (end - start) / 2\", if you don't use it or long type to store your temporary values, your answer will not be accepted!"
                    },
                    {
                        "username": "Anuragcpp",
                        "content": "My algorithms is working fine in the given test cases but when I\\'m trying to submit it\\'s showing \"Time Limit Exceed\", How to solve this problem.\\n\\n"
                    },
                    {
                        "username": "paraswaghela777",
                        "content": "Just ignore the 2nd Input (i.e bad=4,1) just ignore it and think only that way you only have  N sized array and u have to search for 1st occurance of TARGET and current element is target or not will be decided by Calling Bool function"
                    },
                    {
                        "username": "the_timmer",
                        "content": "Despite the window dressing, this is just a version of, \"I am thinking of a number between 1 and 100.  I will tell you high or low after each guess.  Try to get the correct answer in as few answers as possible.\"  If the number is between 1 and 100, the first guess should always be 50 so you can eliminate half of the choices right off the bat when you get told high or low.  If you are told high, your second guess should be 25, but if you are told low, your second guess should be 75.  You need to eliminate half of the possibilities with every guess.  That\\'s the only way to deal with a high range such as 2126753390."
                    },
                    {
                        "username": "legendofbeans",
                        "content": "This question when passed to isBadVersion() returns true"
                    },
                    {
                        "username": "abhinav__19",
                        "content": "Those who are thinking about how to solve this problem and only one value is given , notice the commented part in the editor (what is written there) .\\nThe commented part says everything that you should check every number from 1 to n and if its a bad version then return it.\\nThe checking can be done by passing the i-th value to the function  \" isBadVersion(int version)\" .\\n\\nUsing linear search will end up giving you TLE, so don`t use it.\\n\\nYou should be using Binary search because the numbers are starting from 1 to n and it is in increasing order which means that it is sorted already, just apply the logic of binary search and check every mid value and return the first occurrence of the bad version.\\n\\nFor reference-> you can look up to the code\\n\\n\\nint l=1,h=n;\\n\\n        if(n==1)\\n            return 1;\\n\\n        \\n        while(l<h){\\n            int mid=l+(h-l)/2;\\n\\n            if(isBadVersion(mid)){\\n                \\n                h=mid;\\n            }\\n            else\\n                l=mid+1;\\n        }\\n"
                    },
                    {
                        "username": "Aetherus",
                        "content": "You really shouldn\\'t post your solution here. You should post it in the Solutions tab."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Second input \"bad\" helps the isBadVersion( ) to set the first bad version (output)\n\nfor example if n = 9 and bad = 5\nthen the isBadVersion( ) return result as [0,0,0,0,1,1,1,1,1] \n\nfor example if n = 7 and bad = 2\nthen the isBadVersion( ) return result as [0,1,1,1,1,1,1] "
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "The description of the problem is utter trash, can\\'t understand a thing. Am I the only one?"
                    },
                    {
                        "username": "jitesh_raghav",
                        "content": "what is blud waffling about?"
                    }
                ]
            },
            {
                "id": 2018854,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 2011885,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 2007884,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 2006656,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 2005791,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1989693,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1973557,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1943972,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1930649,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1920014,
                "content": [
                    {
                        "username": "lokesh7887",
                        "content": "can anybody tell what is the predefined API \\n"
                    },
                    {
                        "username": "ishaanvi_reet",
                        "content": "2 of my test cases passed, third was uanble to pass"
                    },
                    {
                        "username": "goesbyabhi",
                        "content": "Bruh what is that explanation? \\n`call isBadVersion(3)`\\n`call isBadVersion(5)`\\n`call isBadVersion(4)`\\n\\nHow the heck did we jump to 5 and then come back to 4? "
                    },
                    {
                        "username": "Aetherus",
                        "content": "Actually that\\'s a hint of solving this problem"
                    },
                    {
                        "username": "Edlyn_P",
                        "content": "I honestly don\\'t understand this question at all lol "
                    },
                    {
                        "username": "Skaezr73",
                        "content": "Problem descriptions  gone bonkers!! :)"
                    },
                    {
                        "username": "metryingmybest",
                        "content": "uh...how can I see the parent class VersionControl?"
                    },
                    {
                        "username": "1rant",
                        "content": "Needs more clarification"
                    },
                    {
                        "username": "Aadil42",
                        "content": "WTF! What is the bad argument is there for?"
                    },
                    {
                        "username": "pa-one55",
                        "content": "there is already a function (i.e. the API ) defined for this code(problem) and returns true or false, but is not given for us to see, so\\nbasically we are calling the API function - isBadVersion() for all numbers less than equal to n till it returns false\\nand then we will return n+1 since that will be the first bad one.\\n\\n `// The API isBadVersion is defined for you.`\\n `// bool isBadVersion(int version);`\\n `class Solution {`\\n`public:`\\n`    int firstBadVersion(int n) {`\\n`        while( isBadVersion(n) ){`\\n`            n--;`\\n`        }`\\n`        return n+1;`\\n`    }`\\n`};`\\n"
                    },
                    {
                        "username": "bodhisatta1999",
                        "content": "What did the question even want me to do?\\nDidn\\'t get it? Stupid qn"
                    }
                ]
            },
            {
                "id": 1902683,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1898201,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1886485,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1884953,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1883324,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1870898,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1870544,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1867983,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1865839,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1863345,
                "content": [
                    {
                        "username": "amanj0318",
                        "content": "During  Dry Run, how can we test the no is bad or not as result is coming from external api."
                    },
                    {
                        "username": "abdou_b",
                        "content": "Can someone please help me understand why is this: \nint mid = (high - low)/2 + low;\nbetter than just using regular : \nmid = (high + low)/2 ?\n\nI got this one, it's a solution to avoid overflow.\n\n\none other this that confused me was: \ni had to check if ( !IsBadVersion(n))\nbecause if (IsBadVersion(n)) does not work ? \n\ni'm using C# "
                    },
                    {
                        "username": "Greenleaph",
                        "content": "The reason why int mid = (high - low)/2 + low is \"better\" than int mid = (high + low)/2 is because it avoids integer overflow.\\n\\nIf the sum of high and low exceed the max value that can be represented by the data type, then it will result in an integer overflow which can lead to incorrect results.\\n\\nint mid = (high - low)/2 + low avoids this because we are calculating the difference of high and low first and then dividing it by 2. Thus, reducing the chance of integer overflow. \\n\\nI suggest you read more about integer overflow online to get a firm grasp of this concept and why it\\'s especially important in languages like C or C++."
                    },
                    {
                        "username": "Nine_hoots",
                        "content": "It\\'s just a modified binary search."
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yep"
                    },
                    {
                        "username": "nick3000",
                        "content": "Leetcode is playing fun little game here. It\\'s called\\nGuess the remaining problem statement !"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "simply came with tought this is binary search surely"
                    },
                    {
                        "username": "Harris-0716",
                        "content": "This question can be simplified as 000011111 when is the first time the 1 appears."
                    },
                    {
                        "username": "tarbaev",
                        "content": "We can interpret this task as search the position of first occurrence 1 (true), in given array: for \"Example 1\" array is [0, 0, 0, 1, 1], so the answer is 4"
                    },
                    {
                        "username": "mo1ok",
                        "content": "Anyone having issues with JS interpreter running out of memory, even doing it with a bisection algo? I am.\n\nEdit: Don't use any fancy array methods, like Array.from. For some reason that was busting the heap. When I used a vanilla for loop it worked!"
                    },
                    {
                        "username": "geraltofr23",
                        "content": "This is probably the most confusing problem description ever."
                    },
                    {
                        "username": "ka09934147002",
                        "content": "The description provided here is incomplete. "
                    },
                    {
                        "username": "Alireza_Nikpay",
                        "content": "Why I get different result from `submit` and `run`?!!!\\n\\ninput: 1926205968\\nexpected: 1167880583\\n\\nin the `run` I get expected output, but I\\'ll get `Time Limit Exceeded` in `submit` section."
                    }
                ]
            },
            {
                "id": 1863313,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1862819,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1861451,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1856829,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1854891,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1851742,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1842932,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1833737,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1832438,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1826503,
                "content": [
                    {
                        "username": "m1ma087",
                        "content": "REALLY take care of overflow errors, when adding two large numbers!"
                    },
                    {
                        "username": "dikshanpatil97",
                        "content": "Use binary search for effective solution. TC - O(log n)"
                    },
                    {
                        "username": "Arctanaar",
                        "content": "Why is this problem\\'s related topics include \\'interactive\\'?"
                    },
                    {
                        "username": "Msey",
                        "content": "in c# IsBadVersion function is written in uppercase but there\\'s no mention about in ugly description"
                    },
                    {
                        "username": "souvik_2000",
                        "content": "the input bad has no use, just ignore it..."
                    },
                    {
                        "username": "imtiaz_py",
                        "content": "I understood the problem and have successfully implemented the solution. However, I couldn\\'t understand how the bad version is inputted while the system runs the solution. We know that \\'n\\' is given as the total number of versions, ranging from version 1 to version n. But how is the system taking the first bad version as input? Can somebody clarify this for me?"
                    },
                    {
                        "username": "subasmohanty256",
                        "content": "I have solved this question by using binary search , it showed me the time taken to execute this is 16 ms after submitting the solution . As i am new to leetcode can someone tell me is it something wrong with my code or due to the function calling it is taking such long time ."
                    },
                    {
                        "username": "mishanin",
                        "content": "The first stupid mistake I make I thought there is one bad version...\nBut there are all bad versions on the right if current bad and there all good on the left if current good.\nAlso the search is going until we have 'bad' with 'good' on the next left"
                    },
                    {
                        "username": "surendra-1390",
                        "content": "Can Anyone explain the question?"
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "The question states that after a certain point (given as bad) all the numbers beyond that are bad. Our task is to find the first bad number. The BAD given in the question is not accessible. We can find the number we find is bad or not using the isBadVersion(number) function. It will be true if the number is bad else false.\\n\\nBy this way you can find the answer.\\nHope you understood."
                    },
                    {
                        "username": "xiaoxiaoma137",
                        "content": "false and true part is very confusing..."
                    },
                    {
                        "username": "Anandprabhu333",
                        "content": "beyond a point (given as bad in question) all numbers are bad. isBadVersion(version) will return true if the number is bad else false."
                    }
                ]
            },
            {
                "id": 1815492,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1809429,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1809332,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1809300,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1808438,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1807697,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1806473,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1804667,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1801168,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1801123,
                "content": [
                    {
                        "username": "Alex230103",
                        "content": "my code gives me a MemoryError in the test case 11 in this cycle:\\n`for i in reversed(range(0, n)):\\n    if isBadVersion(i) == False: return i + 1`\\nI honestly don\\'t know what I should change in order to fix this error"
                    },
                    {
                        "username": "voronokKita",
                        "content": "This is easy to solve by generating an array from a number, but a strict time limit blocks this way.\\nTo divide a number into equal parts with an offset (like an array) and get the middle, you need to google the formula."
                    },
                    {
                        "username": "guptashubham-sg11",
                        "content": "Basically, this problem asks to find the first occurrence of true in a Boolean sorted array."
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "bisect module can help inspire. But be mindful that this problem is asking for the lowest version a method returns True\\n\\n```\\n    lo, hi = 1, n\\n    while lo < hi:\\n        mid = (lo+hi)//2\\n        if bool: hi = mid\\n        else: lo = mid+1\\n    return lo\\n```"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "yeah it\\'s binary search"
                    },
                    {
                        "username": "user4876s",
                        "content": "there is problem in the question.....the description shows 2 inputs and function shows only one input"
                    },
                    {
                        "username": "pjpjmama",
                        "content": "Did anyone see the description that included the answer like me?"
                    },
                    {
                        "username": "S_SAYUJ",
                        "content": "why is there a mismatch in the number of inputs given in the example and in the real program , should we fill it"
                    },
                    {
                        "username": "kakon114",
                        "content": "Why the problem description and input output explanation are not enough descriptive??"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "Related topics should have `Divide and conquer`\n`tip`"
                    },
                    {
                        "username": "thykingu",
                        "content": "I don't know why, but it seems to be a bug in leetcode. I tried my code in a local machine with the same test and it worked, I also put some printf in my leetcode editor (I have the free version so I can't use a debug) and the result I print is what I expected, but even if the do/while statement I used reaches a false value, it doesn't exit the loop!\nIt gives me \"time limit exceeded\".\n\n `exit = (!((bad_1 == 0) && (bad == 1)));`\n `printf(\"hight: %d; low %d; exit %d \\n\", hight, low, exit);`\n `}while(!((bad_1 == 0) && (bad == 1)));`\n\n^ This is the code I use to check with print; the \"while\" is the termination of do/while statement.\n\nret: 2; bad_1 0; bad 0 \nhight: 5; low 2; exit 1 \n\nret: 3; bad_1 0; bad 0 \nhight: 5; low 3; exit 1 \n\nret: 4; bad_1 0; bad 1 \nhight: 4; low 3; exit 0 \n\nret: 0; bad_1 0; bad 0 \nhight: 1; low 0; exit 1 \n\n^ This is the output I obtain. exit is 0, and exit is the same as the out condition in the while, but the loop seems to continue!\n\nAny suggestion?"
                    }
                ]
            },
            {
                "id": 1789465,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1784401,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1777815,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1776548,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1775407,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1770915,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1770231,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1763584,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1760316,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1760241,
                "content": [
                    {
                        "username": "siddharthmishra436",
                        "content": "public class Solution extends VersionControl {\\n    \\n    public int firstBadVersion(int n) {\\n        int low = 1;\\n        int high = n;\\n        while(low < high){\\n            int mid = low + (high - low)/2;\\n            if(isBadVersion(mid) == true)\\n                high = mid;\\n            else if(isBadVersion(mid) == false)\\n                low = mid + 1; \\n            \\n        }\\n    //    for(int i = 0 ; i <= n ; i++){\\n    //        if(isBadVersion(i) == true)\\n    //             return i;\\n    //        }\\n         return low;\\n       }\\n      \\n    }"
                    },
                    {
                        "username": "plafko",
                        "content": "The keyword here is:\\n\\n\"which causes all the following ones to be bad.\"\\n\\nI dismissed the idea of binary search because I did not read that thoroughly thinking, therefore thinking the following API calls could go back to being good versions.\\n\\nI mean, why would the fallacies of version X be carried over to each subsequent version of the API? That kind of defeats the purpose of versions..\\n\\nAnyway, now you\\'re all set! Good luck. "
                    },
                    {
                        "username": "stryker9000",
                        "content": "Trash problem"
                    },
                    {
                        "username": "prakhar-singh",
                        "content": "Can we apply linear search also?"
                    },
                    {
                        "username": "Ashish_4k",
                        "content": "tle I guess "
                    },
                    {
                        "username": "rasheed1397",
                        "content": "This problem is so poorly defined. I was good up until the example. The 2nd input leaves me baffled, I don\\'t know if it represents the number of bad versions or an arbitrarily selected bad version out of possible other bad versions."
                    },
                    {
                        "username": "hardikbth",
                        "content": "[leetcode](https://leetcode.com) what kind of number is bad between 1 to n.\\nlike 1....5 ->ans 4, can not understand question discription"
                    },
                    {
                        "username": "OneVsAll",
                        "content": "can someone explain why while(l <= r) works but while(l < r) doesn't work?"
                    },
                    {
                        "username": "Felipe_Serna",
                        "content": "Leetcode: The description is wrong. It should be \"IsBadVersion\". First letter is uppercase. Correct that please."
                    },
                    {
                        "username": "exe-0535",
                        "content": "I like it how \n `if(!IsBadVersion(mid))` condition passes through, but \n `if(IsBadVersion(mid))` doesn't "
                    },
                    {
                        "username": "justacatburyme",
                        "content": "you would expect the binary search to be 0 indexed but the question input is 1 indexed. i was stuck on this for so long"
                    }
                ]
            },
            {
                "id": 1757920,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1748249,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1745076,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1737472,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1735619,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1734813,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1734714,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1733570,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1730439,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1729005,
                "content": [
                    {
                        "username": "JeromeLi",
                        "content": "(low + (high - low)) / 2; \\n\\nI used the expression above to prevent overflow, it doesn\\'t work unless I do \\n\\nlow + (high - low) / 2; \\n\\nWhat\\'s the difference?"
                    },
                    {
                        "username": "prathamgohil751",
                        "content": "This rating system seems to be quite inaccurate. First my code showed 3 ms runtime and then the same code showed 0ms bringing me upto 100%"
                    },
                    {
                        "username": "Vithesh",
                        "content": "we will get output if we use long instead of int and then while returning we can simply type cast it back to int .This will avoid integer overflow or  time limit exceeded error.  The problem in using int will increase your execution time and your solution will  be in bottom 10 percent. \\nhere overflow happens while you are calculating mid. \\nSo use different formula which is logically similar to (low+high)/2\\nie low+(high-low)/2;"
                    },
                    {
                        "username": "Taterr",
                        "content": "the description for this problem is confusing"
                    },
                    {
                        "username": "chprvaibhav",
                        "content": "can xor operation of present and previous state define the output if xor-ed value turn out to be true then the answer is the present state else answer is 1 , can anyone tell me why my logic is wrong"
                    },
                    {
                        "username": "DavalC",
                        "content": "The space complexity of this solution is O(1), since we are only using a few variables to store the left and right pointers.\\n\\nThe time complexity is O(log n), since the number of iterations is directly proportional to the logarithm of the input number. This is because we are continuously splitting the range of versions in half until the left and right pointers meet.\\n\\nTherefore, this solution is already efficient in terms of both space and time complexity. It is not possible to improve the space complexity, but it is possible to further optimize the time complexity by using a more advanced algorithm or data structure. However, the improvement in time complexity would likely be minimal, as the binary search algorithm is already an efficient solution for this problem."
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "\\u0644\\u0644\\u0639\\u0631\\u0628\\n\\u0641\\u064A\\u0647 \\u0627\\u0646\\u0628\\u0648\\u062A \\u0648\\u0627\\u062D\\u062F \\u0628\\u0633 ..\\u0627\\u0644\\u062A\\u0627\\u0646\\u064A \\u062F\\u0627\\u0647 \\u0645\\u062C\\u0631\\u062F \\u0634\\u0631\\u062D \\u0628\\u064A\\u0648\\u0636\\u062D\\u0644\\u0643 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0633\\u064A\\u0626\\u0629 \\u0645\\u0646 1 \\u0644\\u062D\\u062F \\u0627\\u0644\\u0627\\u0646\\u0628\\u0648\\u062A\\n\\u062A\\u062E\\u064A\\u0644 \\u0627\\u0646\\u0646\\u0627 \\u0645\\u0639\\u0627\\u0646\\u0627 \\u0645\\u062C\\u0645\\u0648\\u0639\\u0629 \\u0627\\u0631\\u0642\\u0627\\u0645 \\u0645\\u0631\\u062A\\u0628\\u0629 \\u0648\\u0645\\u0643\\u0631\\u0631\\u0629 \\u0639\\u0627\\u062F\\u064A \\u0648\\u0645\\u062D\\u062A\\u0627\\u062C\\u064A\\u0646 \\u0646\\u062C\\u064A\\u0628 \\u0627\\u0648\\u0644 \\u0646\\u0633\\u062E\\u0629 \\u0645\\u0646 \\u0631\\u0642\\u0645 \\u0645\\u0639\\u064A\\u0646\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th one."
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "sherodtaylor",
                        "content": "Idk if i understand the question because for the golang option there is only one input but for the javascript version it returns a function that takes a bad version\\n\\n```go\\n/** \\n * Forward declaration of isBadVersion API.\\n * @param   version   your guess about first bad version\\n * @return \\t \\t      true if current version is bad \\n *\\t\\t\\t          false if current version is good\\n * func isBadVersion(version int) bool;\\n */\\n\\nfunc firstBadVersion(n int) int {\\n    \\n}\\n```\\n\\n```javascript\\n/**\\n * @param {function} isBadVersion()\\n * @return {function}\\n */\\nvar solution = function(isBadVersion) {\\n    /**\\n     * @param {integer} n Total versions\\n     * @return {integer} The first bad version\\n     */\\n    return function(n) {\\n        \\n    };\\n```"
                    },
                    {
                        "username": "markaleksanyan",
                        "content": "Can anyone explain, or give a hint on why this code, even though I use binary search algorithm, exceeds the time limit for big inputs?\\n\\npublic class Solution extends VersionControl {\\n\\n    public int versionSearch(int n, int left)\\n    {\\n        \\n        int mid=(left+n)/2;\\n        if(left>n) return 1;\\n        if(!isBadVersion(mid))\\n        {\\n            return versionSearch(n, mid+1);\\n        }\\n        else if(isBadVersion(mid)&&!isBadVersion(mid-1))\\n        {\\n            return mid;\\n        }else\\n        {\\n            return versionSearch(mid-1,left);\\n        }\\n    }\\n    public int firstBadVersion(int n) {\\n        return versionSearch(n, 1);\\n    }\\n}"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "use \\nmid=left+(n-left)/2  instead of  mid=(left+n)/2"
                    }
                ]
            },
            {
                "id": 1727436,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1726608,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1726167,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1725108,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1724918,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1723797,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1723186,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1707342,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1687710,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            },
            {
                "id": 1681326,
                "content": [
                    {
                        "username": "mridulsaggi",
                        "content": "why are we given the second input? and why are we doing binary search?"
                    },
                    {
                        "username": "abdulrhmanm557",
                        "content": "it\\'s not a second one , it\\'s only to understand the problem\\n(1,4,5,7,7,7,9,11)\\nit\\'s like we are search to find the first 7 in this sorted array\\n(g,g,g,b,b)\\nfirst bad is the 4th\\n"
                    },
                    {
                        "username": "nithinu2810",
                        "content": "I think i got little descriptive solution for the statement given. The task is to find when the project get bad version... yeah we think correct that need to search 1 to n. But due to larger value of inputs we takes more time so we move to binary search to search where failure starts."
                    },
                    {
                        "username": "biltuandal",
                        "content": "Python code. Easy to understand\\n\\nclass Solution:\\n    def firstBadVersion(self, n: int) -> int:\\n        low = 1\\n        high = n\\n        while True:\\n            if isBadVersion((low+high)/2) == True:\\n                high = ((low+high)/2)\\n            else:\\n                low = ceil((low+high)/2)\\n            if high == low:\\n                break\\n        #print(high)\\n        return low"
                    },
                    {
                        "username": "craftyshark",
                        "content": "whoever decided that the function should be isBadVersion instead of isGoodVersion ur moms a hoe. "
                    },
                    {
                        "username": "founderjames",
                        "content": "The debugger does not seem to be working for me, I am not sure why??"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/278_first_bad_version.cpp"
                    },
                    {
                        "username": "harrysrangal",
                        "content": "Can somebody please explain me the difference between `left + (right - left) / 2` and `(left + right) / 2` The second one is giving the Time Limit Exceeded and first one is working fine, when both of them results the same value. What\\'s the logic behind this?"
                    },
                    {
                        "username": "Egermeisterrr",
                        "content": "Guys, please tell me what\\'s wrong with my solution, I think it\\'s quite good and I found similar codes in the solutions, but I catch Time Limit Exceeded on the test n = 2126753390, first bad version = 1702766719.\\n\\n`class Solution: VersionControl() {\\n    override fun firstBadVersion(n: Int) : Int {\\n        var low = 1\\n        var high = n\\n        while (low < high) {\\n            val current = low + (high - low) / 2\\n            if (isBadVersion(current)) {\\n                high = current\\n            } else\\n                low = current\\n        }\\n        return low\\n\\t}\\n}`\\n\\nThank you so much"
                    },
                    {
                        "username": "rammi44",
                        "content": "Solution is\\n\\n public int FirstBadVersion(int n) {\\n        var isBadVersion=false;\\n        do\\n        {\\n            isBadVersion=IsBadVersion(n);\\n            Console.WriteLine($\"is badversion for {n}, {isBadVersion}\");\\n            if(isBadVersion)\\n                n=n-1;\\n        }\\n        while(isBadVersion && n>0);\\n\\n        n=n+1;\\n        Console.WriteLine($\"Value of n is {n}\");\\n        return n;\\n    }"
                    },
                    {
                        "username": "rvishal3107",
                        "content": "THOUGHT PROCESS\n\nBinary Search\n- We test the mid version is bad or not\n- If it's bad, we move right pointer to mid, else we move left pointer to mid + 1\n- Notice we should not use (lo <= hi) in the while condition, since it will stuck indefinitely\n- Time complexity O(logn)\n- Space complexity O(1)\n\nreferance :\nhttps://just4once.gitbooks.io/leetcode-notes/content/leetcode/binary-search/278-first-bad-version.html"
                    }
                ]
            }
        ]
    }
]